;
(function () {
  var _templateObject, _templateObject2;
  var _excluded2 = ["page"],
    _excluded3 = ["page", "matches"],
    _excluded4 = ["onClick", "discover", "prefetch", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition", "unstable_defaultShouldRevalidate"],
    _excluded5 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"],
    _excluded6 = ["discover", "fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition", "unstable_defaultShouldRevalidate"],
    _excluded7 = ["__cssMap", "__cssVars", "__breakpoints"],
    _excluded8 = ["transitionEnd", "transition"],
    _excluded9 = ["attrX", "attrY", "attrScale", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"],
    _excluded0 = ["transitionEnd", "transition"],
    _excluded1 = ["autoplay", "delay", "type", "repeat", "repeatDelay", "repeatType"],
    _excluded10 = ["onComplete", "onUpdate", "motionValue", "element"],
    _excluded11 = ["motionValue", "onUpdate", "onComplete", "element"],
    _excluded12 = ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from", "elapsed"],
    _excluded13 = ["transition", "transitionEnd"],
    _excluded14 = ["transition", "transitionEnd"],
    _excluded15 = ["root"],
    _excluded16 = ["willChange"],
    _excluded17 = ["theme", "css", "__css", "sx"],
    _excluded18 = ["baseStyle"],
    _excluded19 = ["children"],
    _excluded20 = ["styleConfig"],
    _excluded21 = ["as", "viewBox", "color", "focusable", "children", "className", "__css"],
    _excluded22 = ["label", "thickness", "speed", "emptyColor", "className"],
    _excluded23 = ["status", "addRole"],
    _excluded24 = ["children", "isDisabled", "__css"],
    _excluded25 = ["containerRef"],
    _excluded26 = ["children", "theme", "toastOptions"],
    _excluded27 = ["name", "getInitials"],
    _excluded28 = ["src", "srcSet", "name", "showBorder", "borderRadius", "onError", "onLoad", "getInitials", "icon", "iconLabel", "loading", "children", "borderColor", "ignoreFallback", "crossOrigin", "referrerPolicy"],
    _excluded29 = ["className"],
    _excluded30 = ["children", "spacing", "separator", "className", "listProps"],
    _excluded31 = ["isCurrentPage", "as", "className", "href"],
    _excluded32 = ["spacing"],
    _excluded33 = ["isCurrentPage", "separator", "isLastChild", "spacing", "children", "className"],
    _excluded34 = ["children", "className"],
    _excluded35 = ["label", "placement", "spacing", "children", "className", "__css"],
    _excluded36 = ["isDisabled", "isLoading", "isActive", "children", "leftIcon", "rightIcon", "loadingText", "iconSpacing", "type", "spinner", "spinnerPlacement", "className", "as", "shouldWrapChildren"],
    _excluded37 = ["icon", "children", "isRound", "aria-label"],
    _excluded38 = ["className", "children", "direction", "justify", "align"],
    _excluded39 = ["className"],
    _excluded40 = ["axis"],
    _excluded41 = ["id", "isRequired", "isInvalid", "isDisabled", "isReadOnly"],
    _excluded42 = ["getRootProps", "htmlProps"],
    _excluded43 = ["isDisabled", "isInvalid", "isReadOnly", "isRequired"],
    _excluded44 = ["id", "disabled", "readOnly", "required", "isRequired", "isInvalid", "isReadOnly", "isDisabled", "onFocus", "onBlur"],
    _excluded45 = ["className", "centerContent"],
    _excluded46 = ["borderLeftWidth", "borderBottomWidth", "borderTopWidth", "borderRightWidth", "borderWidth", "borderStyle", "borderColor"],
    _excluded47 = ["className", "orientation", "__css"],
    _excluded48 = ["direction", "align", "justify", "wrap", "basis", "grow", "shrink"],
    _excluded49 = ["className", "children", "requiredIndicator", "optionalIndicator"],
    _excluded50 = ["templateAreas", "gap", "rowGap", "columnGap", "column", "row", "autoFlow", "autoRows", "templateRows", "autoColumns", "templateColumns"],
    _excluded51 = ["columns", "spacingX", "spacingY", "spacing", "minChildWidth"],
    _excluded52 = ["htmlSize"],
    _excluded53 = ["children", "className"],
    _excluded54 = ["placement"],
    _excluded55 = ["className"],
    _excluded56 = ["className"],
    _excluded57 = ["className", "isExternal"],
    _excluded58 = ["size", "shadowColor", "bg", "style"],
    _excluded59 = ["ref", "isDisabled", "isFocusable", "clickOnEnter", "clickOnSpace", "onMouseDown", "onMouseUp", "onClick", "onKeyDown", "onKeyUp", "tabIndex", "onMouseOver", "onMouseLeave"],
    _excluded60 = ["className"],
    _excluded61 = ["onClick", "className"],
    _excluded62 = ["className"],
    _excluded63 = ["unmountOnExit", "in", "className", "transition", "transitionEnd", "delay", "animatePresenceProps"],
    _excluded64 = ["className", "transition", "motionProps"],
    _excluded65 = ["isOpen", "onClose", "placement", "children"],
    _excluded66 = ["direction", "style", "unmountOnExit", "in", "className", "transition", "transitionEnd", "delay", "motionProps", "animatePresenceProps"],
    _excluded67 = ["className", "children", "motionProps", "containerProps"],
    _excluded68 = ["children", "placeholder", "className"],
    _excluded69 = ["rootProps", "placeholder", "icon", "color", "height", "h", "minH", "minHeight", "iconColor", "iconSize"],
    _excluded70 = ["children"],
    _excluded71 = ["isInline", "direction", "align", "justify", "spacing", "wrap", "children", "divider", "className", "shouldWrapChildren"],
    _excluded72 = ["className", "children"],
    _excluded73 = ["defaultIndex", "onChange", "index", "isManual", "isLazy", "lazyBehavior", "orientation", "direction"],
    _excluded74 = ["isDisabled", "isFocusable"],
    _excluded75 = ["children"],
    _excluded76 = ["children", "className"],
    _excluded77 = ["htmlProps", "descendants"],
    _excluded78 = ["isFitted"],
    _excluded79 = ["className", "rows"],
    _excluded80 = ["openDelay", "closeDelay", "closeOnClick", "closeOnMouseDown", "closeOnScroll", "closeOnPointerDown", "closeOnEsc", "onOpen", "onClose", "placement", "id", "isOpen", "defaultIsOpen", "arrowSize", "arrowShadowColor", "arrowPadding", "modifiers", "isDisabled", "gutter", "offset", "direction"],
    _excluded81 = ["children", "label", "shouldWrapChildren", "aria-label", "hasArrow", "bg", "portalProps", "background", "backgroundColor", "bgColor", "motionProps", "animatePresenceProps"],
    _excluded82 = ["className"],
    _excluded83 = ["className", "align", "decoration", "casing"];
  function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
  function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
  function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
  function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
  function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf2(Wrapper, t); }, _wrapNativeSuper(t); }
  function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf2(p, r.prototype), p; }
  function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function _objectWithoutProperties2(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose2(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
  function _objectWithoutPropertiesLoose2(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
  function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
  function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof2(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
  function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
  function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf2(t, e); }
  function _setPrototypeOf2(t, e) { return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf2(t, e); }
  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey2(o.key), o); } }
  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
  function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _defineProperty2(e, r, t) { return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey2(t) { var i = _toPrimitive2(t, "string"); return "symbol" == _typeof2(i) ? i : i + ""; }
  function _toPrimitive2(t, r) { if ("object" != _typeof2(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof2(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _typeof2(o) { "@babel/helpers - typeof"; return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof2(o); }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  System.register([], function (exports, module) {
    'use strict';

    return {
      execute: function execute() {
        var _defineStyle13, _defineStyle14, _inputTheme$baseStyle, _inputTheme$variants$, _inputTheme$variants4, _defineStyle17, _inputTheme$baseStyle2, _inputTheme$sizes2, _inputTheme$sizes3, _inputTheme$sizes4, _inputTheme$sizes5, _inputTheme$sizes6, _inputTheme$sizes7, _inputTheme$sizes8, _inputTheme$sizes9, _defineStyle24, _inputTheme$baseStyle3, _inputTheme$variants$5, _inputTheme$variants8, _inputTheme$sizes$xs$, _inputTheme$sizes0, _inputTheme$sizes$sm$, _inputTheme$sizes1, _inputTheme$sizes$md$, _inputTheme$sizes10, _inputTheme$sizes$lg$, _inputTheme$sizes11, _defineStyle25, _FocusLockCombination;
        function _mergeNamespaces(n, m) {
          var _loop2 = function _loop2() {
            var e = m[i];
            if (typeof e !== 'string' && !Array.isArray(e)) {
              var _loop3 = function _loop3(_k2) {
                if (_k2 !== 'default' && !(_k2 in n)) {
                  var _d2 = Object.getOwnPropertyDescriptor(e, _k2);
                  if (_d2) {
                    Object.defineProperty(n, _k2, _d2.get ? _d2 : {
                      enumerable: true,
                      get: function get() {
                        return e[_k2];
                      }
                    });
                  }
                }
              };
              for (var _k2 in e) {
                _loop3(_k2);
              }
            }
          };
          for (var i = 0; i < m.length; i++) {
            _loop2();
          }
          return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: 'Module'
          }));
        }
        exports({
          $: arrayToObjectNotation,
          D: FiExternalLink,
          F: FiFileText,
          G: keyframes$1,
          M: ModalFocusScope,
          O: FiAward,
          P: FiTrendingUp,
          Q: useImage,
          U: omit,
          X: useEnvironment,
          Y: useTheme,
          Z: isObject,
          a: getValidChildren,
          a0: useStyleConfig,
          a1: useToken,
          a2: cssVar$1,
          a3: FiClock,
          a5: FiRefreshCw,
          c: createContext,
          f: forwardRef,
          g: getDefaultExportFromCjs,
          i: defineStyle,
          k: useColorModeValue,
          o: omitThemingProps,
          u: useMultiStyleConfig
        });
        false && function polyfill() {
          var relList = document.createElement("link").relList;
          if (relList && relList.supports && relList.supports("modulepreload")) {
            return;
          }
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(function (mutations) {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== "childList") {
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _node = _step3.value;
                    if (_node.tagName === "LINK" && _node.rel === "modulepreload") processPreload(_node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            var fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";else fetchOpts.credentials = "same-origin";
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();
        var scriptRel = 'modulepreload';
        var assetsURL = function assetsURL(dep) {
          return "/international-law-reference/" + dep;
        };
        var seen = {};
        var __vitePreload = function preload(baseModule, deps, importerUrl) {
          var promise = Promise.resolve();
          if (false && deps && deps.length > 0) {
            document.getElementsByTagName("link");
            var cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
            var cspNonce = (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.getAttribute("nonce"));
            promise = Promise.allSettled(deps.map(function (dep) {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              var isCss = dep.endsWith(".css");
              var cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector("link[href=\"".concat(dep, "\"]").concat(cssSelector))) {
                return;
              }
              var link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise(function (res, rej) {
                  link.addEventListener("load", res);
                  link.addEventListener("error", function () {
                    return rej(new Error("Unable to preload CSS for ".concat(dep)));
                  });
                });
              }
            }));
          }
          function handlePreloadError(err) {
            var e = new Event("vite:preloadError", {
              cancelable: true
            });
            e.payload = err;
            window.dispatchEvent(e);
            if (!e.defaultPrevented) {
              throw err;
            }
          }
          return promise.then(function (res) {
            var _iterator4 = _createForOfIteratorHelper(res || []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var item = _step4.value;
                if (item.status !== "rejected") continue;
                handlePreloadError(item.reason);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            return baseModule().catch(handlePreloadError);
          });
        };
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        var jsxRuntime = {
          exports: {}
        };
        var reactJsxRuntime_production_min = {};
        var react = {
          exports: {}
        };
        var react_production_min = {};

        /**
         * @license React
         * react.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var l$2 = Symbol.for("react.element"),
          n$2 = Symbol.for("react.portal"),
          p$3 = Symbol.for("react.fragment"),
          q$2 = Symbol.for("react.strict_mode"),
          r$2 = Symbol.for("react.profiler"),
          t$2 = Symbol.for("react.provider"),
          u = Symbol.for("react.context"),
          v$2 = Symbol.for("react.forward_ref"),
          w$1 = Symbol.for("react.suspense"),
          x$1 = Symbol.for("react.memo"),
          y$1 = Symbol.for("react.lazy"),
          z$2 = Symbol.iterator;
        function A$2(a) {
          if (null === a || "object" !== _typeof2(a)) return null;
          a = z$2 && a[z$2] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var B$1 = {
            isMounted: function isMounted() {
              return false;
            },
            enqueueForceUpdate: function enqueueForceUpdate() {},
            enqueueReplaceState: function enqueueReplaceState() {},
            enqueueSetState: function enqueueSetState() {}
          },
          C$1 = Object.assign,
          D$1 = {};
        function E$1(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$1;
          this.updater = e || B$1;
        }
        E$1.prototype.isReactComponent = {};
        E$1.prototype.setState = function (a, b) {
          if ("object" !== _typeof2(a) && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          this.updater.enqueueSetState(this, a, b, "setState");
        };
        E$1.prototype.forceUpdate = function (a) {
          this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        };
        function F() {}
        F.prototype = E$1.prototype;
        function G$1(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$1;
          this.updater = e || B$1;
        }
        var H$1 = G$1.prototype = new F();
        H$1.constructor = G$1;
        C$1(H$1, E$1.prototype);
        H$1.isPureReactComponent = true;
        var I$1 = Array.isArray,
          J = Object.prototype.hasOwnProperty,
          K$1 = {
            current: null
          },
          L$1 = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
        function M$1(a, b, e) {
          var d,
            c = {},
            k = null,
            h = null;
          if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
          var g = arguments.length - 2;
          if (1 === g) c.children = e;else if (1 < g) {
            for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
            c.children = f;
          }
          if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
          return {
            $$typeof: l$2,
            type: a,
            key: k,
            ref: h,
            props: c,
            _owner: K$1.current
          };
        }
        function N$1(a, b) {
          return {
            $$typeof: l$2,
            type: a.type,
            key: b,
            ref: a.ref,
            props: a.props,
            _owner: a._owner
          };
        }
        function O$1(a) {
          return "object" === _typeof2(a) && null !== a && a.$$typeof === l$2;
        }
        function escape$2(a) {
          var b = {
            "=": "=0",
            ":": "=2"
          };
          return "$" + a.replace(/[=:]/g, function (a) {
            return b[a];
          });
        }
        var P$1 = /\/+/g;
        function Q$1(a, b) {
          return "object" === _typeof2(a) && null !== a && null != a.key ? escape$2("" + a.key) : b.toString(36);
        }
        function R$1(a, b, e, d, c) {
          var k = _typeof2(a);
          if ("undefined" === k || "boolean" === k) a = null;
          var h = false;
          if (null === a) h = true;else switch (k) {
            case "string":
            case "number":
              h = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case l$2:
                case n$2:
                  h = true;
              }
          }
          if (h) return h = a, c = c(h), a = "" === d ? "." + Q$1(h, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function (a) {
            return a;
          })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
          h = 0;
          d = "" === d ? "." : d + ":";
          if (I$1(a)) for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = d + Q$1(k, g);
            h += R$1(k, b, e, f, c);
          } else if (f = A$2(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q$1(k, g++), h += R$1(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
          return h;
        }
        function S$1(a, b, e) {
          if (null == a) return a;
          var d = [],
            c = 0;
          R$1(a, d, "", "", function (a) {
            return b.call(e, a, c++);
          });
          return d;
        }
        function T$1(a) {
          if (-1 === a._status) {
            var b = a._result;
            b = b();
            b.then(function (b) {
              if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
            }, function (b) {
              if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
            });
            -1 === a._status && (a._status = 0, a._result = b);
          }
          if (1 === a._status) return a._result.default;
          throw a._result;
        }
        var U$1 = {
            current: null
          },
          V$1 = {
            transition: null
          },
          W$1 = {
            ReactCurrentDispatcher: U$1,
            ReactCurrentBatchConfig: V$1,
            ReactCurrentOwner: K$1
          };
        function X$1() {
          throw Error("act(...) is not supported in production builds of React.");
        }
        react_production_min.Children = {
          map: S$1,
          forEach: function forEach(a, b, e) {
            S$1(a, function () {
              b.apply(this, arguments);
            }, e);
          },
          count: function count(a) {
            var b = 0;
            S$1(a, function () {
              b++;
            });
            return b;
          },
          toArray: function toArray(a) {
            return S$1(a, function (a) {
              return a;
            }) || [];
          },
          only: function only(a) {
            if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
            return a;
          }
        };
        react_production_min.Component = E$1;
        react_production_min.Fragment = p$3;
        react_production_min.Profiler = r$2;
        react_production_min.PureComponent = G$1;
        react_production_min.StrictMode = q$2;
        react_production_min.Suspense = w$1;
        react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
        react_production_min.act = X$1;
        react_production_min.cloneElement = function (a, b, e) {
          if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
          var d = C$1({}, a.props),
            c = a.key,
            k = a.ref,
            h = a._owner;
          if (null != b) {
            void 0 !== b.ref && (k = b.ref, h = K$1.current);
            void 0 !== b.key && (c = "" + b.key);
            if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
            for (f in b) J.call(b, f) && !L$1.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
          }
          var f = arguments.length - 2;
          if (1 === f) d.children = e;else if (1 < f) {
            g = Array(f);
            for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
            d.children = g;
          }
          return {
            $$typeof: l$2,
            type: a.type,
            key: c,
            ref: k,
            props: d,
            _owner: h
          };
        };
        react_production_min.createContext = function (a) {
          a = {
            $$typeof: u,
            _currentValue: a,
            _currentValue2: a,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          a.Provider = {
            $$typeof: t$2,
            _context: a
          };
          return a.Consumer = a;
        };
        react_production_min.createElement = M$1;
        react_production_min.createFactory = function (a) {
          var b = M$1.bind(null, a);
          b.type = a;
          return b;
        };
        react_production_min.createRef = function () {
          return {
            current: null
          };
        };
        react_production_min.forwardRef = function (a) {
          return {
            $$typeof: v$2,
            render: a
          };
        };
        react_production_min.isValidElement = O$1;
        react_production_min.lazy = function (a) {
          return {
            $$typeof: y$1,
            _payload: {
              _status: -1,
              _result: a
            },
            _init: T$1
          };
        };
        react_production_min.memo = function (a, b) {
          return {
            $$typeof: x$1,
            type: a,
            compare: void 0 === b ? null : b
          };
        };
        react_production_min.startTransition = function (a) {
          var b = V$1.transition;
          V$1.transition = {};
          try {
            a();
          } finally {
            V$1.transition = b;
          }
        };
        react_production_min.unstable_act = X$1;
        react_production_min.useCallback = function (a, b) {
          return U$1.current.useCallback(a, b);
        };
        react_production_min.useContext = function (a) {
          return U$1.current.useContext(a);
        };
        react_production_min.useDebugValue = function () {};
        react_production_min.useDeferredValue = function (a) {
          return U$1.current.useDeferredValue(a);
        };
        react_production_min.useEffect = function (a, b) {
          return U$1.current.useEffect(a, b);
        };
        react_production_min.useId = function () {
          return U$1.current.useId();
        };
        react_production_min.useImperativeHandle = function (a, b, e) {
          return U$1.current.useImperativeHandle(a, b, e);
        };
        react_production_min.useInsertionEffect = function (a, b) {
          return U$1.current.useInsertionEffect(a, b);
        };
        react_production_min.useLayoutEffect = function (a, b) {
          return U$1.current.useLayoutEffect(a, b);
        };
        react_production_min.useMemo = function (a, b) {
          return U$1.current.useMemo(a, b);
        };
        react_production_min.useReducer = function (a, b, e) {
          return U$1.current.useReducer(a, b, e);
        };
        react_production_min.useRef = function (a) {
          return U$1.current.useRef(a);
        };
        react_production_min.useState = function (a) {
          return U$1.current.useState(a);
        };
        react_production_min.useSyncExternalStore = function (a, b, e) {
          return U$1.current.useSyncExternalStore(a, b, e);
        };
        react_production_min.useTransition = function () {
          return U$1.current.useTransition();
        };
        react_production_min.version = "18.3.1";
        {
          react.exports = react_production_min;
        }
        var reactExports = exports("r", react.exports);
        var React = exports("R", /*@__PURE__*/getDefaultExportFromCjs(reactExports));
        var React$1 = /*#__PURE__*/_mergeNamespaces({
          __proto__: null,
          default: React
        }, [reactExports]);

        /**
         * @license React
         * react-jsx-runtime.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var f$1 = reactExports,
          k$1 = Symbol.for("react.element"),
          l$1 = Symbol.for("react.fragment"),
          m$2 = Object.prototype.hasOwnProperty,
          n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
          p$2 = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
        function q$1(c, a, g) {
          var b,
            d = {},
            e = null,
            h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m$2.call(a, b) && !p$2.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return {
            $$typeof: k$1,
            type: c,
            key: e,
            ref: h,
            props: d,
            _owner: n$1.current
          };
        }
        reactJsxRuntime_production_min.Fragment = l$1;
        reactJsxRuntime_production_min.jsx = q$1;
        reactJsxRuntime_production_min.jsxs = q$1;
        {
          jsxRuntime.exports = reactJsxRuntime_production_min;
        }
        var jsxRuntimeExports = exports("j", jsxRuntime.exports);
        var client = {};
        var reactDom = {
          exports: {}
        };
        var reactDom_production_min = {};
        var scheduler = {
          exports: {}
        };
        var scheduler_production_min = {};

        /**
         * @license React
         * scheduler.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        (function (exports$1) {
          function f(a, b) {
            var c = a.length;
            a.push(b);
            a: for (; 0 < c;) {
              var d = c - 1 >>> 1,
                e = a[d];
              if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
            }
          }
          function h(a) {
            return 0 === a.length ? null : a[0];
          }
          function k(a) {
            if (0 === a.length) return null;
            var b = a[0],
              c = a.pop();
            if (c !== b) {
              a[0] = c;
              a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
                var m = 2 * (d + 1) - 1,
                  C = a[m],
                  n = m + 1,
                  x = a[n];
                if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
              }
            }
            return b;
          }
          function g(a, b) {
            var c = a.sortIndex - b.sortIndex;
            return 0 !== c ? c : a.id - b.id;
          }
          if ("object" === (typeof performance === "undefined" ? "undefined" : _typeof2(performance)) && "function" === typeof performance.now) {
            var l = performance;
            exports$1.unstable_now = function () {
              return l.now();
            };
          } else {
            var p = Date,
              q = p.now();
            exports$1.unstable_now = function () {
              return p.now() - q;
            };
          }
          var r = [],
            t = [],
            u = 1,
            v = null,
            y = 3,
            z = false,
            A = false,
            B = false,
            D = "function" === typeof setTimeout ? setTimeout : null,
            E = "function" === typeof clearTimeout ? clearTimeout : null,
            F = "undefined" !== typeof setImmediate ? setImmediate : null;
          "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
          function G(a) {
            for (var b = h(t); null !== b;) {
              if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
              b = h(t);
            }
          }
          function H(a) {
            B = false;
            G(a);
            if (!A) if (null !== h(r)) A = true, I(J);else {
              var b = h(t);
              null !== b && K(H, b.startTime - a);
            }
          }
          function J(a, b) {
            A = false;
            B && (B = false, E(L), L = -1);
            z = true;
            var c = y;
            try {
              G(b);
              for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
                var d = v.callback;
                if ("function" === typeof d) {
                  v.callback = null;
                  y = v.priorityLevel;
                  var e = d(v.expirationTime <= b);
                  b = exports$1.unstable_now();
                  "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                  G(b);
                } else k(r);
                v = h(r);
              }
              if (null !== v) var w = !0;else {
                var m = h(t);
                null !== m && K(H, m.startTime - b);
                w = !1;
              }
              return w;
            } finally {
              v = null, y = c, z = false;
            }
          }
          var N = false,
            O = null,
            L = -1,
            P = 5,
            Q = -1;
          function M() {
            return exports$1.unstable_now() - Q < P ? false : true;
          }
          function R() {
            if (null !== O) {
              var a = exports$1.unstable_now();
              Q = a;
              var b = true;
              try {
                b = O(!0, a);
              } finally {
                b ? S() : (N = false, O = null);
              }
            } else N = false;
          }
          var S;
          if ("function" === typeof F) S = function S() {
            F(R);
          };else if ("undefined" !== typeof MessageChannel) {
            var T = new MessageChannel(),
              U = T.port2;
            T.port1.onmessage = R;
            S = function S() {
              U.postMessage(null);
            };
          } else S = function S() {
            D(R, 0);
          };
          function I(a) {
            O = a;
            N || (N = true, S());
          }
          function K(a, b) {
            L = D(function () {
              a(exports$1.unstable_now());
            }, b);
          }
          exports$1.unstable_IdlePriority = 5;
          exports$1.unstable_ImmediatePriority = 1;
          exports$1.unstable_LowPriority = 4;
          exports$1.unstable_NormalPriority = 3;
          exports$1.unstable_Profiling = null;
          exports$1.unstable_UserBlockingPriority = 2;
          exports$1.unstable_cancelCallback = function (a) {
            a.callback = null;
          };
          exports$1.unstable_continueExecution = function () {
            A || z || (A = true, I(J));
          };
          exports$1.unstable_forceFrameRate = function (a) {
            0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
          };
          exports$1.unstable_getCurrentPriorityLevel = function () {
            return y;
          };
          exports$1.unstable_getFirstCallbackNode = function () {
            return h(r);
          };
          exports$1.unstable_next = function (a) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var b = 3;
                break;
              default:
                b = y;
            }
            var c = y;
            y = b;
            try {
              return a();
            } finally {
              y = c;
            }
          };
          exports$1.unstable_pauseExecution = function () {};
          exports$1.unstable_requestPaint = function () {};
          exports$1.unstable_runWithPriority = function (a, b) {
            switch (a) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                a = 3;
            }
            var c = y;
            y = a;
            try {
              return b();
            } finally {
              y = c;
            }
          };
          exports$1.unstable_scheduleCallback = function (a, b, c) {
            var d = exports$1.unstable_now();
            "object" === _typeof2(c) && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
            switch (a) {
              case 1:
                var e = -1;
                break;
              case 2:
                e = 250;
                break;
              case 5:
                e = 1073741823;
                break;
              case 4:
                e = 1E4;
                break;
              default:
                e = 5E3;
            }
            e = c + e;
            a = {
              id: u++,
              callback: b,
              priorityLevel: a,
              startTime: c,
              expirationTime: e,
              sortIndex: -1
            };
            c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
            return a;
          };
          exports$1.unstable_shouldYield = M;
          exports$1.unstable_wrapCallback = function (a) {
            var b = y;
            return function () {
              var c = y;
              y = b;
              try {
                return a.apply(this, arguments);
              } finally {
                y = c;
              }
            };
          };
        })(scheduler_production_min);
        {
          scheduler.exports = scheduler_production_min;
        }
        var schedulerExports = scheduler.exports;

        /**
         * @license React
         * react-dom.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var aa = reactExports,
          ca = schedulerExports;
        function p$1(a) {
          for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
          return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var da = new Set(),
          ea = {};
        function fa(a, b) {
          ha(a, b);
          ha(a + "Capture", b);
        }
        function ha(a, b) {
          ea[a] = b;
          for (a = 0; a < b.length; a++) da.add(b[a]);
        }
        var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
          ja = Object.prototype.hasOwnProperty,
          ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
          la = {},
          ma = {};
        function oa(a) {
          if (ja.call(ma, a)) return true;
          if (ja.call(la, a)) return false;
          if (ka.test(a)) return ma[a] = true;
          la[a] = true;
          return false;
        }
        function pa(a, b, c, d) {
          if (null !== c && 0 === c.type) return false;
          switch (_typeof2(b)) {
            case "function":
            case "symbol":
              return true;
            case "boolean":
              if (d) return false;
              if (null !== c) return !c.acceptsBooleans;
              a = a.toLowerCase().slice(0, 5);
              return "data-" !== a && "aria-" !== a;
            default:
              return false;
          }
        }
        function qa(a, b, c, d) {
          if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
          if (d) return false;
          if (null !== c) switch (c.type) {
            case 3:
              return !b;
            case 4:
              return false === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
          return false;
        }
        function v$1(a, b, c, d, e, f, g) {
          this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
          this.attributeName = d;
          this.attributeNamespace = e;
          this.mustUseProperty = c;
          this.propertyName = a;
          this.type = b;
          this.sanitizeURL = f;
          this.removeEmptyString = g;
        }
        var z$1 = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
          z$1[a] = new v$1(a, 0, false, a, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
          var b = a[0];
          z$1[b] = new v$1(b, 1, false, a[1], null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
          z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
          z$1[a] = new v$1(a, 2, false, a, null, false, false);
        });
        "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
          z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
        });
        ["checked", "multiple", "muted", "selected"].forEach(function (a) {
          z$1[a] = new v$1(a, 3, true, a, null, false, false);
        });
        ["capture", "download"].forEach(function (a) {
          z$1[a] = new v$1(a, 4, false, a, null, false, false);
        });
        ["cols", "rows", "size", "span"].forEach(function (a) {
          z$1[a] = new v$1(a, 6, false, a, null, false, false);
        });
        ["rowSpan", "start"].forEach(function (a) {
          z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
        });
        var ra = /[\-:]([a-z])/g;
        function sa(a) {
          return a[1].toUpperCase();
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$1[b] = new v$1(b, 1, false, a, null, false, false);
        });
        "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$1[b] = new v$1(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
        });
        ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
          var b = a.replace(ra, sa);
          z$1[b] = new v$1(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function (a) {
          z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
        });
        z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function (a) {
          z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
        });
        function ta(a, b, c, d) {
          var e = z$1.hasOwnProperty(b) ? z$1[b] : null;
          if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
        }
        var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          va = Symbol.for("react.element"),
          wa = Symbol.for("react.portal"),
          ya = Symbol.for("react.fragment"),
          za = Symbol.for("react.strict_mode"),
          Aa = Symbol.for("react.profiler"),
          Ba = Symbol.for("react.provider"),
          Ca = Symbol.for("react.context"),
          Da = Symbol.for("react.forward_ref"),
          Ea = Symbol.for("react.suspense"),
          Fa = Symbol.for("react.suspense_list"),
          Ga = Symbol.for("react.memo"),
          Ha = Symbol.for("react.lazy");
        var Ia = Symbol.for("react.offscreen");
        var Ja = Symbol.iterator;
        function Ka(a) {
          if (null === a || "object" !== _typeof2(a)) return null;
          a = Ja && a[Ja] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var A$1 = Object.assign,
          La;
        function Ma(a) {
          if (void 0 === La) try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            La = b && b[1] || "";
          }
          return "\n" + La + a;
        }
        var Na = false;
        function Oa(a, b) {
          if (!a || Na) return "";
          Na = true;
          var c = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (b) {
              if (b = function b() {
                throw Error();
              }, Object.defineProperty(b.prototype, "props", {
                set: function set() {
                  throw Error();
                }
              }), "object" === (typeof Reflect === "undefined" ? "undefined" : _typeof2(Reflect)) && Reflect.construct) {
                try {
                  Reflect.construct(b, []);
                } catch (l) {
                  var d = l;
                }
                Reflect.construct(a, [], b);
              } else {
                try {
                  b.call();
                } catch (l) {
                  d = l;
                }
                a.call(b.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (l) {
                d = l;
              }
              a();
            }
          } catch (l) {
            if (l && d && "string" === typeof l.stack) {
              for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
              for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  } while (1 <= g && 0 <= h);
                }
                break;
              }
            }
          } finally {
            Na = false, Error.prepareStackTrace = c;
          }
          return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
        }
        function Pa(a) {
          switch (a.tag) {
            case 5:
              return Ma(a.type);
            case 16:
              return Ma("Lazy");
            case 13:
              return Ma("Suspense");
            case 19:
              return Ma("SuspenseList");
            case 0:
            case 2:
            case 15:
              return a = Oa(a.type, false), a;
            case 11:
              return a = Oa(a.type.render, false), a;
            case 1:
              return a = Oa(a.type, true), a;
            default:
              return "";
          }
        }
        function Qa(a) {
          if (null == a) return null;
          if ("function" === typeof a) return a.displayName || a.name || null;
          if ("string" === typeof a) return a;
          switch (a) {
            case ya:
              return "Fragment";
            case wa:
              return "Portal";
            case Aa:
              return "Profiler";
            case za:
              return "StrictMode";
            case Ea:
              return "Suspense";
            case Fa:
              return "SuspenseList";
          }
          if ("object" === _typeof2(a)) switch (a.$$typeof) {
            case Ca:
              return (a.displayName || "Context") + ".Consumer";
            case Ba:
              return (a._context.displayName || "Context") + ".Provider";
            case Da:
              var b = a.render;
              a = a.displayName;
              a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
              return a;
            case Ga:
              return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
            case Ha:
              b = a._payload;
              a = a._init;
              try {
                return Qa(a(b));
              } catch (c) {}
          }
          return null;
        }
        function Ra(a) {
          var b = a.type;
          switch (a.tag) {
            case 24:
              return "Cache";
            case 9:
              return (b.displayName || "Context") + ".Consumer";
            case 10:
              return (b._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 5:
              return b;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return Qa(b);
            case 8:
              return b === za ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if ("function" === typeof b) return b.displayName || b.name || null;
              if ("string" === typeof b) return b;
          }
          return null;
        }
        function Sa(a) {
          switch (_typeof2(a)) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return a;
            case "object":
              return a;
            default:
              return "";
          }
        }
        function Ta(a) {
          var b = a.type;
          return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
        }
        function Ua(a) {
          var b = Ta(a) ? "checked" : "value",
            c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
            d = "" + a[b];
          if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
            var e = c.get,
              f = c.set;
            Object.defineProperty(a, b, {
              configurable: true,
              get: function get() {
                return e.call(this);
              },
              set: function set(a) {
                d = "" + a;
                f.call(this, a);
              }
            });
            Object.defineProperty(a, b, {
              enumerable: c.enumerable
            });
            return {
              getValue: function getValue() {
                return d;
              },
              setValue: function setValue(a) {
                d = "" + a;
              },
              stopTracking: function stopTracking() {
                a._valueTracker = null;
                delete a[b];
              }
            };
          }
        }
        function Va(a) {
          a._valueTracker || (a._valueTracker = Ua(a));
        }
        function Wa(a) {
          if (!a) return false;
          var b = a._valueTracker;
          if (!b) return true;
          var c = b.getValue();
          var d = "";
          a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
          a = d;
          return a !== c ? (b.setValue(a), true) : false;
        }
        function Xa(a) {
          a = a || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof a) return null;
          try {
            return a.activeElement || a.body;
          } catch (b) {
            return a.body;
          }
        }
        function Ya(a, b) {
          var c = b.checked;
          return A$1({}, b, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != c ? c : a._wrapperState.initialChecked
          });
        }
        function Za(a, b) {
          var c = null == b.defaultValue ? "" : b.defaultValue,
            d = null != b.checked ? b.checked : b.defaultChecked;
          c = Sa(null != b.value ? b.value : c);
          a._wrapperState = {
            initialChecked: d,
            initialValue: c,
            controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
          };
        }
        function ab(a, b) {
          b = b.checked;
          null != b && ta(a, "checked", b, false);
        }
        function bb(a, b) {
          ab(a, b);
          var c = Sa(b.value),
            d = b.type;
          if (null != c) {
            if ("number" === d) {
              if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
            } else a.value !== "" + c && (a.value = "" + c);
          } else if ("submit" === d || "reset" === d) {
            a.removeAttribute("value");
            return;
          }
          b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
          null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
        }
        function db(a, b, c) {
          if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
            var d = b.type;
            if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
            b = "" + a._wrapperState.initialValue;
            c || b === a.value || (a.value = b);
            a.defaultValue = b;
          }
          c = a.name;
          "" !== c && (a.name = "");
          a.defaultChecked = !!a._wrapperState.initialChecked;
          "" !== c && (a.name = c);
        }
        function cb(a, b, c) {
          if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
        }
        var eb = Array.isArray;
        function fb(a, b, c, d) {
          a = a.options;
          if (b) {
            b = {};
            for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
            for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
          } else {
            c = "" + Sa(c);
            b = null;
            for (e = 0; e < a.length; e++) {
              if (a[e].value === c) {
                a[e].selected = true;
                d && (a[e].defaultSelected = true);
                return;
              }
              null !== b || a[e].disabled || (b = a[e]);
            }
            null !== b && (b.selected = true);
          }
        }
        function gb(a, b) {
          if (null != b.dangerouslySetInnerHTML) throw Error(p$1(91));
          return A$1({}, b, {
            value: void 0,
            defaultValue: void 0,
            children: "" + a._wrapperState.initialValue
          });
        }
        function hb(a, b) {
          var c = b.value;
          if (null == c) {
            c = b.children;
            b = b.defaultValue;
            if (null != c) {
              if (null != b) throw Error(p$1(92));
              if (eb(c)) {
                if (1 < c.length) throw Error(p$1(93));
                c = c[0];
              }
              b = c;
            }
            null == b && (b = "");
            c = b;
          }
          a._wrapperState = {
            initialValue: Sa(c)
          };
        }
        function ib(a, b) {
          var c = Sa(b.value),
            d = Sa(b.defaultValue);
          null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
          null != d && (a.defaultValue = "" + d);
        }
        function jb(a) {
          var b = a.textContent;
          b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
        }
        function kb(a) {
          switch (a) {
            case "svg":
              return "http://www.w3.org/2000/svg";
            case "math":
              return "http://www.w3.org/1998/Math/MathML";
            default:
              return "http://www.w3.org/1999/xhtml";
          }
        }
        function lb(a, b) {
          return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
        }
        var mb,
          nb = function (a) {
            return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
              MSApp.execUnsafeLocalFunction(function () {
                return a(b, c, d, e);
              });
            } : a;
          }(function (a, b) {
            if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
              mb = mb || document.createElement("div");
              mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
              for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
              for (; b.firstChild;) a.appendChild(b.firstChild);
            }
          });
        function ob(a, b) {
          if (b) {
            var c = a.firstChild;
            if (c && c === a.lastChild && 3 === c.nodeType) {
              c.nodeValue = b;
              return;
            }
          }
          a.textContent = b;
        }
        var pb = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          },
          qb = ["Webkit", "ms", "Moz", "O"];
        Object.keys(pb).forEach(function (a) {
          qb.forEach(function (b) {
            b = b + a.charAt(0).toUpperCase() + a.substring(1);
            pb[b] = pb[a];
          });
        });
        function rb(a, b, c) {
          return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
        }
        function sb(a, b) {
          a = a.style;
          for (var c in b) if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"),
              e = rb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
          }
        }
        var tb = A$1({
          menuitem: true
        }, {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        });
        function ub(a, b) {
          if (b) {
            if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p$1(137, a));
            if (null != b.dangerouslySetInnerHTML) {
              if (null != b.children) throw Error(p$1(60));
              if ("object" !== _typeof2(b.dangerouslySetInnerHTML) || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p$1(61));
            }
            if (null != b.style && "object" !== _typeof2(b.style)) throw Error(p$1(62));
          }
        }
        function vb(a, b) {
          if (-1 === a.indexOf("-")) return "string" === typeof b.is;
          switch (a) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var wb = null;
        function xb(a) {
          a = a.target || a.srcElement || window;
          a.correspondingUseElement && (a = a.correspondingUseElement);
          return 3 === a.nodeType ? a.parentNode : a;
        }
        var yb = null,
          zb = null,
          Ab = null;
        function Bb(a) {
          if (a = Cb(a)) {
            if ("function" !== typeof yb) throw Error(p$1(280));
            var b = a.stateNode;
            b && (b = Db(b), yb(a.stateNode, a.type, b));
          }
        }
        function Eb(a) {
          zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
        }
        function Fb() {
          if (zb) {
            var a = zb,
              b = Ab;
            Ab = zb = null;
            Bb(a);
            if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
          }
        }
        function Gb(a, b) {
          return a(b);
        }
        function Hb() {}
        var Ib = false;
        function Jb(a, b, c) {
          if (Ib) return a(b, c);
          Ib = true;
          try {
            return Gb(a, b, c);
          } finally {
            if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
          }
        }
        function Kb(a, b) {
          var c = a.stateNode;
          if (null === c) return null;
          var d = Db(c);
          if (null === d) return null;
          c = d[b];
          a: switch (b) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
              a = !d;
              break a;
            default:
              a = false;
          }
          if (a) return null;
          if (c && "function" !== typeof c) throw Error(p$1(231, b, _typeof2(c)));
          return c;
        }
        var Lb = false;
        if (ia) try {
          var Mb = {};
          Object.defineProperty(Mb, "passive", {
            get: function get() {
              Lb = !0;
            }
          });
          window.addEventListener("test", Mb, Mb);
          window.removeEventListener("test", Mb, Mb);
        } catch (a) {
          Lb = false;
        }
        function Nb(a, b, c, d, e, f, g, h, k) {
          var l = Array.prototype.slice.call(arguments, 3);
          try {
            b.apply(c, l);
          } catch (m) {
            this.onError(m);
          }
        }
        var Ob = false,
          Pb = null,
          Qb = false,
          Rb = null,
          Sb = {
            onError: function onError(a) {
              Ob = true;
              Pb = a;
            }
          };
        function Tb(a, b, c, d, e, f, g, h, k) {
          Ob = false;
          Pb = null;
          Nb.apply(Sb, arguments);
        }
        function Ub(a, b, c, d, e, f, g, h, k) {
          Tb.apply(this, arguments);
          if (Ob) {
            if (Ob) {
              var l = Pb;
              Ob = false;
              Pb = null;
            } else throw Error(p$1(198));
            Qb || (Qb = true, Rb = l);
          }
        }
        function Vb(a) {
          var b = a,
            c = a;
          if (a.alternate) for (; b.return;) b = b.return;else {
            a = b;
            do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
          }
          return 3 === b.tag ? c : null;
        }
        function Wb(a) {
          if (13 === a.tag) {
            var b = a.memoizedState;
            null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
            if (null !== b) return b.dehydrated;
          }
          return null;
        }
        function Xb(a) {
          if (Vb(a) !== a) throw Error(p$1(188));
        }
        function Yb(a) {
          var b = a.alternate;
          if (!b) {
            b = Vb(a);
            if (null === b) throw Error(p$1(188));
            return b !== a ? null : a;
          }
          for (var c = a, d = b;;) {
            var e = c.return;
            if (null === e) break;
            var f = e.alternate;
            if (null === f) {
              d = e.return;
              if (null !== d) {
                c = d;
                continue;
              }
              break;
            }
            if (e.child === f.child) {
              for (f = e.child; f;) {
                if (f === c) return Xb(e), a;
                if (f === d) return Xb(e), b;
                f = f.sibling;
              }
              throw Error(p$1(188));
            }
            if (c.return !== d.return) c = e, d = f;else {
              for (var g = false, h = e.child; h;) {
                if (h === c) {
                  g = true;
                  c = e;
                  d = f;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = e;
                  c = f;
                  break;
                }
                h = h.sibling;
              }
              if (!g) {
                for (h = f.child; h;) {
                  if (h === c) {
                    g = true;
                    c = f;
                    d = e;
                    break;
                  }
                  if (h === d) {
                    g = true;
                    d = f;
                    c = e;
                    break;
                  }
                  h = h.sibling;
                }
                if (!g) throw Error(p$1(189));
              }
            }
            if (c.alternate !== d) throw Error(p$1(190));
          }
          if (3 !== c.tag) throw Error(p$1(188));
          return c.stateNode.current === c ? a : b;
        }
        function Zb(a) {
          a = Yb(a);
          return null !== a ? $b(a) : null;
        }
        function $b(a) {
          if (5 === a.tag || 6 === a.tag) return a;
          for (a = a.child; null !== a;) {
            var b = $b(a);
            if (null !== b) return b;
            a = a.sibling;
          }
          return null;
        }
        var ac = ca.unstable_scheduleCallback,
          bc = ca.unstable_cancelCallback,
          cc = ca.unstable_shouldYield,
          dc = ca.unstable_requestPaint,
          B = ca.unstable_now,
          ec = ca.unstable_getCurrentPriorityLevel,
          fc = ca.unstable_ImmediatePriority,
          gc = ca.unstable_UserBlockingPriority,
          hc = ca.unstable_NormalPriority,
          ic = ca.unstable_LowPriority,
          jc = ca.unstable_IdlePriority,
          kc = null,
          lc = null;
        function mc(a) {
          if (lc && "function" === typeof lc.onCommitFiberRoot) try {
            lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
          } catch (b) {}
        }
        var oc = Math.clz32 ? Math.clz32 : nc,
          pc = Math.log,
          qc = Math.LN2;
        function nc(a) {
          a >>>= 0;
          return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
        }
        var rc = 64,
          sc = 4194304;
        function tc(a) {
          switch (a & -a) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return a & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return a & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return a;
          }
        }
        function uc(a, b) {
          var c = a.pendingLanes;
          if (0 === c) return 0;
          var d = 0,
            e = a.suspendedLanes,
            f = a.pingedLanes,
            g = c & 268435455;
          if (0 !== g) {
            var h = g & ~e;
            0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
          } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
          if (0 === d) return 0;
          if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
          0 !== (d & 4) && (d |= c & 16);
          b = a.entangledLanes;
          if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
          return d;
        }
        function vc(a, b) {
          switch (a) {
            case 1:
            case 2:
            case 4:
              return b + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return b + 5E3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function wc(a, b) {
          for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
            var g = 31 - oc(f),
              h = 1 << g,
              k = e[g];
            if (-1 === k) {
              if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
            } else k <= b && (a.expiredLanes |= h);
            f &= ~h;
          }
        }
        function xc(a) {
          a = a.pendingLanes & -1073741825;
          return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
        }
        function yc() {
          var a = rc;
          rc <<= 1;
          0 === (rc & 4194240) && (rc = 64);
          return a;
        }
        function zc(a) {
          for (var b = [], c = 0; 31 > c; c++) b.push(a);
          return b;
        }
        function Ac(a, b, c) {
          a.pendingLanes |= b;
          536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
          a = a.eventTimes;
          b = 31 - oc(b);
          a[b] = c;
        }
        function Bc(a, b) {
          var c = a.pendingLanes & ~b;
          a.pendingLanes = b;
          a.suspendedLanes = 0;
          a.pingedLanes = 0;
          a.expiredLanes &= b;
          a.mutableReadLanes &= b;
          a.entangledLanes &= b;
          b = a.entanglements;
          var d = a.eventTimes;
          for (a = a.expirationTimes; 0 < c;) {
            var e = 31 - oc(c),
              f = 1 << e;
            b[e] = 0;
            d[e] = -1;
            a[e] = -1;
            c &= ~f;
          }
        }
        function Cc(a, b) {
          var c = a.entangledLanes |= b;
          for (a = a.entanglements; c;) {
            var d = 31 - oc(c),
              e = 1 << d;
            e & b | a[d] & b && (a[d] |= b);
            c &= ~e;
          }
        }
        var C = 0;
        function Dc(a) {
          a &= -a;
          return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
        }
        var Ec,
          Fc,
          Gc,
          Hc,
          Ic,
          Jc = false,
          Kc = [],
          Lc = null,
          Mc = null,
          Nc = null,
          Oc = new Map(),
          Pc = new Map(),
          Qc = [],
          Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
        function Sc(a, b) {
          switch (a) {
            case "focusin":
            case "focusout":
              Lc = null;
              break;
            case "dragenter":
            case "dragleave":
              Mc = null;
              break;
            case "mouseover":
            case "mouseout":
              Nc = null;
              break;
            case "pointerover":
            case "pointerout":
              Oc.delete(b.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              Pc.delete(b.pointerId);
          }
        }
        function Tc(a, b, c, d, e, f) {
          if (null === a || a.nativeEvent !== f) return a = {
            blockedOn: b,
            domEventName: c,
            eventSystemFlags: d,
            nativeEvent: f,
            targetContainers: [e]
          }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
          a.eventSystemFlags |= d;
          b = a.targetContainers;
          null !== e && -1 === b.indexOf(e) && b.push(e);
          return a;
        }
        function Uc(a, b, c, d, e) {
          switch (b) {
            case "focusin":
              return Lc = Tc(Lc, a, b, c, d, e), true;
            case "dragenter":
              return Mc = Tc(Mc, a, b, c, d, e), true;
            case "mouseover":
              return Nc = Tc(Nc, a, b, c, d, e), true;
            case "pointerover":
              var f = e.pointerId;
              Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
              return true;
            case "gotpointercapture":
              return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
          }
          return false;
        }
        function Vc(a) {
          var b = Wc(a.target);
          if (null !== b) {
            var c = Vb(b);
            if (null !== c) if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function () {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
          a.blockedOn = null;
        }
        function Xc(a) {
          if (null !== a.blockedOn) return false;
          for (var b = a.targetContainers; 0 < b.length;) {
            var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null === c) {
              c = a.nativeEvent;
              var d = new c.constructor(c.type, c);
              wb = d;
              c.target.dispatchEvent(d);
              wb = null;
            } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
            b.shift();
          }
          return true;
        }
        function Zc(a, b, c) {
          Xc(a) && c.delete(b);
        }
        function $c() {
          Jc = false;
          null !== Lc && Xc(Lc) && (Lc = null);
          null !== Mc && Xc(Mc) && (Mc = null);
          null !== Nc && Xc(Nc) && (Nc = null);
          Oc.forEach(Zc);
          Pc.forEach(Zc);
        }
        function ad(a, b) {
          a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
        }
        function bd(a) {
          function b(b) {
            return ad(b, a);
          }
          if (0 < Kc.length) {
            ad(Kc[0], a);
            for (var c = 1; c < Kc.length; c++) {
              var d = Kc[c];
              d.blockedOn === a && (d.blockedOn = null);
            }
          }
          null !== Lc && ad(Lc, a);
          null !== Mc && ad(Mc, a);
          null !== Nc && ad(Nc, a);
          Oc.forEach(b);
          Pc.forEach(b);
          for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
          for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
        }
        var cd = ua.ReactCurrentBatchConfig,
          dd = true;
        function ed(a, b, c, d) {
          var e = C,
            f = cd.transition;
          cd.transition = null;
          try {
            C = 1, fd(a, b, c, d);
          } finally {
            C = e, cd.transition = f;
          }
        }
        function gd(a, b, c, d) {
          var e = C,
            f = cd.transition;
          cd.transition = null;
          try {
            C = 4, fd(a, b, c, d);
          } finally {
            C = e, cd.transition = f;
          }
        }
        function fd(a, b, c, d) {
          if (dd) {
            var e = Yc(a, b, c, d);
            if (null === e) hd(a, b, d, id$2, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
              for (; null !== e;) {
                var f = Cb(e);
                null !== f && Ec(f);
                f = Yc(a, b, c, d);
                null === f && hd(a, b, d, id$2, c);
                if (f === e) break;
                e = f;
              }
              null !== e && d.stopPropagation();
            } else hd(a, b, d, null, c);
          }
        }
        var id$2 = null;
        function Yc(a, b, c, d) {
          id$2 = null;
          a = xb(d);
          a = Wc(a);
          if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
            a = Wb(b);
            if (null !== a) return a;
            a = null;
          } else if (3 === c) {
            if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
            a = null;
          } else b !== a && (a = null);
          id$2 = a;
          return null;
        }
        function jd(a) {
          switch (a) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 4;
            case "message":
              switch (ec()) {
                case fc:
                  return 1;
                case gc:
                  return 4;
                case hc:
                case ic:
                  return 16;
                case jc:
                  return 536870912;
                default:
                  return 16;
              }
            default:
              return 16;
          }
        }
        var kd = null,
          ld = null,
          md = null;
        function nd() {
          if (md) return md;
          var a,
            b = ld,
            c = b.length,
            d,
            e = "value" in kd ? kd.value : kd.textContent,
            f = e.length;
          for (a = 0; a < c && b[a] === e[a]; a++);
          var g = c - a;
          for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
          return md = e.slice(a, 1 < d ? 1 - d : void 0);
        }
        function od(a) {
          var b = a.keyCode;
          "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
          10 === a && (a = 13);
          return 32 <= a || 13 === a ? a : 0;
        }
        function pd() {
          return true;
        }
        function qd() {
          return false;
        }
        function rd(a) {
          function b(b, d, e, f, g) {
            this._reactName = b;
            this._targetInst = e;
            this.type = d;
            this.nativeEvent = f;
            this.target = g;
            this.currentTarget = null;
            for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
            this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
            this.isPropagationStopped = qd;
            return this;
          }
          A$1(b.prototype, {
            preventDefault: function preventDefault() {
              this.defaultPrevented = true;
              var a = this.nativeEvent;
              a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = false), this.isDefaultPrevented = pd);
            },
            stopPropagation: function stopPropagation() {
              var a = this.nativeEvent;
              a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = true), this.isPropagationStopped = pd);
            },
            persist: function persist() {},
            isPersistent: pd
          });
          return b;
        }
        var sd = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function timeStamp(a) {
              return a.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          },
          td = rd(sd),
          ud = A$1({}, sd, {
            view: 0,
            detail: 0
          }),
          vd = rd(ud),
          wd,
          xd,
          yd,
          Ad = A$1({}, ud, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: zd,
            button: 0,
            buttons: 0,
            relatedTarget: function relatedTarget(a) {
              return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
            },
            movementX: function movementX(a) {
              if ("movementX" in a) return a.movementX;
              a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
              return wd;
            },
            movementY: function movementY(a) {
              return "movementY" in a ? a.movementY : xd;
            }
          }),
          Bd = rd(Ad),
          Cd = A$1({}, Ad, {
            dataTransfer: 0
          }),
          Dd = rd(Cd),
          Ed = A$1({}, ud, {
            relatedTarget: 0
          }),
          Fd = rd(Ed),
          Gd = A$1({}, sd, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Hd = rd(Gd),
          Id = A$1({}, sd, {
            clipboardData: function clipboardData(a) {
              return "clipboardData" in a ? a.clipboardData : window.clipboardData;
            }
          }),
          Jd = rd(Id),
          Kd = A$1({}, sd, {
            data: 0
          }),
          Ld = rd(Kd),
          Md = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          },
          Nd = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
          },
          Od = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
        function Pd(a) {
          var b = this.nativeEvent;
          return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
        }
        function zd() {
          return Pd;
        }
        var Qd = A$1({}, ud, {
            key: function key(a) {
              if (a.key) {
                var b = Md[a.key] || a.key;
                if ("Unidentified" !== b) return b;
              }
              return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: zd,
            charCode: function charCode(a) {
              return "keypress" === a.type ? od(a) : 0;
            },
            keyCode: function keyCode(a) {
              return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            },
            which: function which(a) {
              return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            }
          }),
          Rd = rd(Qd),
          Sd = A$1({}, Ad, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          }),
          Td = rd(Sd),
          Ud = A$1({}, ud, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: zd
          }),
          Vd = rd(Ud),
          Wd = A$1({}, sd, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Xd = rd(Wd),
          Yd = A$1({}, Ad, {
            deltaX: function deltaX(a) {
              return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
            },
            deltaY: function deltaY(a) {
              return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          }),
          Zd = rd(Yd),
          $d = [9, 13, 27, 32],
          ae = ia && "CompositionEvent" in window,
          be = null;
        ia && "documentMode" in document && (be = document.documentMode);
        var ce = ia && "TextEvent" in window && !be,
          de = ia && (!ae || be && 8 < be && 11 >= be),
          ee = String.fromCharCode(32),
          fe = false;
        function ge(a, b) {
          switch (a) {
            case "keyup":
              return -1 !== $d.indexOf(b.keyCode);
            case "keydown":
              return 229 !== b.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function he(a) {
          a = a.detail;
          return "object" === _typeof2(a) && "data" in a ? a.data : null;
        }
        var ie = false;
        function je(a, b) {
          switch (a) {
            case "compositionend":
              return he(b);
            case "keypress":
              if (32 !== b.which) return null;
              fe = true;
              return ee;
            case "textInput":
              return a = b.data, a === ee && fe ? null : a;
            default:
              return null;
          }
        }
        function ke(a, b) {
          if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
          switch (a) {
            case "paste":
              return null;
            case "keypress":
              if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                if (b.char && 1 < b.char.length) return b.char;
                if (b.which) return String.fromCharCode(b.which);
              }
              return null;
            case "compositionend":
              return de && "ko" !== b.locale ? null : b.data;
            default:
              return null;
          }
        }
        var le = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function me(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
        }
        function ne(a, b, c, d) {
          Eb(d);
          b = oe(b, "onChange");
          0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
            event: c,
            listeners: b
          }));
        }
        var pe = null,
          qe = null;
        function re(a) {
          se(a, 0);
        }
        function te(a) {
          var b = ue(a);
          if (Wa(b)) return a;
        }
        function ve(a, b) {
          if ("change" === a) return b;
        }
        var we = false;
        if (ia) {
          var xe;
          if (ia) {
            var ye = "oninput" in document;
            if (!ye) {
              var ze = document.createElement("div");
              ze.setAttribute("oninput", "return;");
              ye = "function" === typeof ze.oninput;
            }
            xe = ye;
          } else xe = false;
          we = xe && (!document.documentMode || 9 < document.documentMode);
        }
        function Ae() {
          pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
        }
        function Be(a) {
          if ("value" === a.propertyName && te(qe)) {
            var b = [];
            ne(b, qe, a, xb(a));
            Jb(re, b);
          }
        }
        function Ce(a, b, c) {
          "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
        }
        function De(a) {
          if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
        }
        function Ee(a, b) {
          if ("click" === a) return te(b);
        }
        function Fe(a, b) {
          if ("input" === a || "change" === a) return te(b);
        }
        function Ge(a, b) {
          return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var He = "function" === typeof Object.is ? Object.is : Ge;
        function Ie(a, b) {
          if (He(a, b)) return true;
          if ("object" !== _typeof2(a) || null === a || "object" !== _typeof2(b) || null === b) return false;
          var c = Object.keys(a),
            d = Object.keys(b);
          if (c.length !== d.length) return false;
          for (d = 0; d < c.length; d++) {
            var e = c[d];
            if (!ja.call(b, e) || !He(a[e], b[e])) return false;
          }
          return true;
        }
        function Je(a) {
          for (; a && a.firstChild;) a = a.firstChild;
          return a;
        }
        function Ke(a, b) {
          var c = Je(a);
          a = 0;
          for (var d; c;) {
            if (3 === c.nodeType) {
              d = a + c.textContent.length;
              if (a <= b && d >= b) return {
                node: c,
                offset: b - a
              };
              a = d;
            }
            a: {
              for (; c;) {
                if (c.nextSibling) {
                  c = c.nextSibling;
                  break a;
                }
                c = c.parentNode;
              }
              c = void 0;
            }
            c = Je(c);
          }
        }
        function Le(a, b) {
          return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
        }
        function Me() {
          for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
            try {
              var c = "string" === typeof b.contentWindow.location.href;
            } catch (d) {
              c = false;
            }
            if (c) a = b.contentWindow;else break;
            b = Xa(a.document);
          }
          return b;
        }
        function Ne(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
        }
        function Oe(a) {
          var b = Me(),
            c = a.focusedElem,
            d = a.selectionRange;
          if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
            if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length,
                f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(c, d);
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
            b = [];
            for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
              element: a,
              left: a.scrollLeft,
              top: a.scrollTop
            });
            "function" === typeof c.focus && c.focus();
            for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
          }
        }
        var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
          Qe = null,
          Re = null,
          Se = null,
          Te = false;
        function Ue(a, b, c) {
          var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
          Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
            start: d.selectionStart,
            end: d.selectionEnd
          } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
            anchorNode: d.anchorNode,
            anchorOffset: d.anchorOffset,
            focusNode: d.focusNode,
            focusOffset: d.focusOffset
          }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
            event: b,
            listeners: d
          }), b.target = Qe)));
        }
        function Ve(a, b) {
          var c = {};
          c[a.toLowerCase()] = b.toLowerCase();
          c["Webkit" + a] = "webkit" + b;
          c["Moz" + a] = "moz" + b;
          return c;
        }
        var We = {
            animationend: Ve("Animation", "AnimationEnd"),
            animationiteration: Ve("Animation", "AnimationIteration"),
            animationstart: Ve("Animation", "AnimationStart"),
            transitionend: Ve("Transition", "TransitionEnd")
          },
          Xe = {},
          Ye = {};
        ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
        function Ze(a) {
          if (Xe[a]) return Xe[a];
          if (!We[a]) return a;
          var b = We[a],
            c;
          for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
          return a;
        }
        var $e = Ze("animationend"),
          af = Ze("animationiteration"),
          bf = Ze("animationstart"),
          cf = Ze("transitionend"),
          df = new Map(),
          ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        function ff(a, b) {
          df.set(a, b);
          fa(b, [a]);
        }
        for (var gf = 0; gf < ef.length; gf++) {
          var hf = ef[gf],
            jf = hf.toLowerCase(),
            kf = hf[0].toUpperCase() + hf.slice(1);
          ff(jf, "on" + kf);
        }
        ff($e, "onAnimationEnd");
        ff(af, "onAnimationIteration");
        ff(bf, "onAnimationStart");
        ff("dblclick", "onDoubleClick");
        ff("focusin", "onFocus");
        ff("focusout", "onBlur");
        ff(cf, "onTransitionEnd");
        ha("onMouseEnter", ["mouseout", "mouseover"]);
        ha("onMouseLeave", ["mouseout", "mouseover"]);
        ha("onPointerEnter", ["pointerout", "pointerover"]);
        ha("onPointerLeave", ["pointerout", "pointerover"]);
        fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
        fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
        fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
          mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
        function nf(a, b, c) {
          var d = a.type || "unknown-event";
          a.currentTarget = c;
          Ub(d, b, void 0, a);
          a.currentTarget = null;
        }
        function se(a, b) {
          b = 0 !== (b & 4);
          for (var c = 0; c < a.length; c++) {
            var d = a[c],
              e = d.event;
            d = d.listeners;
            a: {
              var f = void 0;
              if (b) for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g],
                  k = h.instance,
                  l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              } else for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              }
            }
          }
          if (Qb) throw a = Rb, Qb = false, Rb = null, a;
        }
        function D(a, b) {
          var c = b[of];
          void 0 === c && (c = b[of] = new Set());
          var d = a + "__bubble";
          c.has(d) || (pf(b, a, 2, false), c.add(d));
        }
        function qf(a, b, c) {
          var d = 0;
          b && (d |= 4);
          pf(c, a, d, b);
        }
        var rf = "_reactListening" + Math.random().toString(36).slice(2);
        function sf(a) {
          if (!a[rf]) {
            a[rf] = true;
            da.forEach(function (b) {
              "selectionchange" !== b && (mf.has(b) || qf(b, false, a), qf(b, true, a));
            });
            var b = 9 === a.nodeType ? a : a.ownerDocument;
            null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
          }
        }
        function pf(a, b, c, d) {
          switch (jd(b)) {
            case 1:
              var e = ed;
              break;
            case 4:
              e = gd;
              break;
            default:
              e = fd;
          }
          c = e.bind(null, b, c, a);
          e = void 0;
          !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
          d ? void 0 !== e ? a.addEventListener(b, c, {
            capture: true,
            passive: e
          }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, {
            passive: e
          }) : a.addEventListener(b, c, false);
        }
        function hd(a, b, c, d, e) {
          var f = d;
          if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
            if (null === d) return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || 8 === h.nodeType && h.parentNode === e) break;
              if (4 === g) for (g = d.return; null !== g;) {
                var k = g.tag;
                if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                g = g.return;
              }
              for (; null !== h;) {
                g = Wc(h);
                if (null === g) return;
                k = g.tag;
                if (5 === k || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
          Jb(function () {
            var d = f,
              e = xb(c),
              g = [];
            a: {
              var h = df.get(a);
              if (void 0 !== h) {
                var k = td,
                  n = a;
                switch (a) {
                  case "keypress":
                    if (0 === od(c)) break a;
                  case "keydown":
                  case "keyup":
                    k = Rd;
                    break;
                  case "focusin":
                    n = "focus";
                    k = Fd;
                    break;
                  case "focusout":
                    n = "blur";
                    k = Fd;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    k = Fd;
                    break;
                  case "click":
                    if (2 === c.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    k = Bd;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    k = Dd;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    k = Vd;
                    break;
                  case $e:
                  case af:
                  case bf:
                    k = Hd;
                    break;
                  case cf:
                    k = Xd;
                    break;
                  case "scroll":
                    k = vd;
                    break;
                  case "wheel":
                    k = Zd;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    k = Jd;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    k = Td;
                }
                var t = 0 !== (b & 4),
                  J = !t && "scroll" === a,
                  x = t ? null !== h ? h + "Capture" : null : h;
                t = [];
                for (var w = d, u; null !== w;) {
                  u = w;
                  var F = u.stateNode;
                  5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                  if (J) break;
                  w = w.return;
                }
                0 < t.length && (h = new k(h, n, null, c, e), g.push({
                  event: h,
                  listeners: t
                }));
              }
            }
            if (0 === (b & 7)) {
              a: {
                h = "mouseover" === a || "pointerover" === a;
                k = "mouseout" === a || "pointerout" === a;
                if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
                if (k || h) {
                  h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
                  if (k) {
                    if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                  } else k = null, n = d;
                  if (k !== n) {
                    t = Bd;
                    F = "onMouseLeave";
                    x = "onMouseEnter";
                    w = "mouse";
                    if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                    J = null == k ? h : ue(k);
                    u = null == n ? h : ue(n);
                    h = new t(F, w + "leave", k, c, e);
                    h.target = J;
                    h.relatedTarget = u;
                    F = null;
                    Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
                    J = F;
                    if (k && n) b: {
                      t = k;
                      x = n;
                      w = 0;
                      for (u = t; u; u = vf(u)) w++;
                      u = 0;
                      for (F = x; F; F = vf(F)) u++;
                      for (; 0 < w - u;) t = vf(t), w--;
                      for (; 0 < u - w;) x = vf(x), u--;
                      for (; w--;) {
                        if (t === x || null !== x && t === x.alternate) break b;
                        t = vf(t);
                        x = vf(x);
                      }
                      t = null;
                    } else t = null;
                    null !== k && wf(g, h, k, t, false);
                    null !== n && null !== J && wf(g, J, n, t, true);
                  }
                }
              }
              a: {
                h = d ? ue(d) : window;
                k = h.nodeName && h.nodeName.toLowerCase();
                if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
                  if (we) na = Fe;else {
                    na = De;
                    var xa = Ce;
                  }
                } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
                if (na && (na = na(a, d))) {
                  ne(g, na, c, e);
                  break a;
                }
                xa && xa(a, h, d);
                "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
              }
              xa = d ? ue(d) : window;
              switch (a) {
                case "focusin":
                  if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
                  break;
                case "focusout":
                  Se = Re = Qe = null;
                  break;
                case "mousedown":
                  Te = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  Te = false;
                  Ue(g, c, e);
                  break;
                case "selectionchange":
                  if (Pe) break;
                case "keydown":
                case "keyup":
                  Ue(g, c, e);
              }
              var $a;
              if (ae) b: {
                switch (a) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
              ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
                event: ba,
                listeners: xa
              }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
              if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
                event: e,
                listeners: d
              }), e.data = $a);
            }
            se(g, b);
          });
        }
        function tf(a, b, c) {
          return {
            instance: a,
            listener: b,
            currentTarget: c
          };
        }
        function oe(a, b) {
          for (var c = b + "Capture", d = []; null !== a;) {
            var e = a,
              f = e.stateNode;
            5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
            a = a.return;
          }
          return d;
        }
        function vf(a) {
          if (null === a) return null;
          do a = a.return; while (a && 5 !== a.tag);
          return a ? a : null;
        }
        function wf(a, b, c, d, e) {
          for (var f = b._reactName, g = []; null !== c && c !== d;) {
            var h = c,
              k = h.alternate,
              l = h.stateNode;
            if (null !== k && k === d) break;
            5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
            c = c.return;
          }
          0 !== g.length && a.push({
            event: b,
            listeners: g
          });
        }
        var xf = /\r\n?/g,
          yf = /\u0000|\uFFFD/g;
        function zf(a) {
          return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
        }
        function Af(a, b, c) {
          b = zf(b);
          if (zf(a) !== b && c) throw Error(p$1(425));
        }
        function Bf() {}
        var Cf = null,
          Df = null;
        function Ef(a, b) {
          return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof2(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
        }
        var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
          Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
          Hf = "function" === typeof Promise ? Promise : void 0,
          Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
            return Hf.resolve(null).then(a).catch(If);
          } : Ff;
        function If(a) {
          setTimeout(function () {
            throw a;
          });
        }
        function Kf(a, b) {
          var c = b,
            d = 0;
          do {
            var e = c.nextSibling;
            a.removeChild(c);
            if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
              if (0 === d) {
                a.removeChild(e);
                bd(b);
                return;
              }
              d--;
            } else "$" !== c && "$?" !== c && "$!" !== c || d++;
            c = e;
          } while (c);
          bd(b);
        }
        function Lf(a) {
          for (; null != a; a = a.nextSibling) {
            var b = a.nodeType;
            if (1 === b || 3 === b) break;
            if (8 === b) {
              b = a.data;
              if ("$" === b || "$!" === b || "$?" === b) break;
              if ("/$" === b) return null;
            }
          }
          return a;
        }
        function Mf(a) {
          a = a.previousSibling;
          for (var b = 0; a;) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("$" === c || "$!" === c || "$?" === c) {
                if (0 === b) return a;
                b--;
              } else "/$" === c && b++;
            }
            a = a.previousSibling;
          }
          return null;
        }
        var Nf = Math.random().toString(36).slice(2),
          Of = "__reactFiber$" + Nf,
          Pf = "__reactProps$" + Nf,
          uf = "__reactContainer$" + Nf,
          of = "__reactEvents$" + Nf,
          Qf = "__reactListeners$" + Nf,
          Rf = "__reactHandles$" + Nf;
        function Wc(a) {
          var b = a[Of];
          if (b) return b;
          for (var c = a.parentNode; c;) {
            if (b = c[uf] || c[Of]) {
              c = b.alternate;
              if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
                if (c = a[Of]) return c;
                a = Mf(a);
              }
              return b;
            }
            a = c;
            c = a.parentNode;
          }
          return null;
        }
        function Cb(a) {
          a = a[Of] || a[uf];
          return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
        }
        function ue(a) {
          if (5 === a.tag || 6 === a.tag) return a.stateNode;
          throw Error(p$1(33));
        }
        function Db(a) {
          return a[Pf] || null;
        }
        var Sf = [],
          Tf = -1;
        function Uf(a) {
          return {
            current: a
          };
        }
        function E(a) {
          0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
        }
        function G(a, b) {
          Tf++;
          Sf[Tf] = a.current;
          a.current = b;
        }
        var Vf = {},
          H = Uf(Vf),
          Wf = Uf(false),
          Xf = Vf;
        function Yf(a, b) {
          var c = a.type.contextTypes;
          if (!c) return Vf;
          var d = a.stateNode;
          if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
          var e = {},
            f;
          for (f in c) e[f] = b[f];
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
          return e;
        }
        function Zf(a) {
          a = a.childContextTypes;
          return null !== a && void 0 !== a;
        }
        function $f() {
          E(Wf);
          E(H);
        }
        function ag(a, b, c) {
          if (H.current !== Vf) throw Error(p$1(168));
          G(H, b);
          G(Wf, c);
        }
        function bg(a, b, c) {
          var d = a.stateNode;
          b = b.childContextTypes;
          if ("function" !== typeof d.getChildContext) return c;
          d = d.getChildContext();
          for (var e in d) if (!(e in b)) throw Error(p$1(108, Ra(a) || "Unknown", e));
          return A$1({}, c, d);
        }
        function cg(a) {
          a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
          Xf = H.current;
          G(H, a);
          G(Wf, Wf.current);
          return true;
        }
        function dg(a, b, c) {
          var d = a.stateNode;
          if (!d) throw Error(p$1(169));
          c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
          G(Wf, c);
        }
        var eg = null,
          fg = false,
          gg = false;
        function hg(a) {
          null === eg ? eg = [a] : eg.push(a);
        }
        function ig(a) {
          fg = true;
          hg(a);
        }
        function jg() {
          if (!gg && null !== eg) {
            gg = true;
            var a = 0,
              b = C;
            try {
              var c = eg;
              for (C = 1; a < c.length; a++) {
                var d = c[a];
                do d = d(!0); while (null !== d);
              }
              eg = null;
              fg = !1;
            } catch (e) {
              throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
            } finally {
              C = b, gg = false;
            }
          }
          return null;
        }
        var kg = [],
          lg = 0,
          mg = null,
          ng = 0,
          og = [],
          pg = 0,
          qg = null,
          rg = 1,
          sg = "";
        function tg(a, b) {
          kg[lg++] = ng;
          kg[lg++] = mg;
          mg = a;
          ng = b;
        }
        function ug(a, b, c) {
          og[pg++] = rg;
          og[pg++] = sg;
          og[pg++] = qg;
          qg = a;
          var d = rg;
          a = sg;
          var e = 32 - oc(d) - 1;
          d &= ~(1 << e);
          c += 1;
          var f = 32 - oc(b) + e;
          if (30 < f) {
            var g = e - e % 5;
            f = (d & (1 << g) - 1).toString(32);
            d >>= g;
            e -= g;
            rg = 1 << 32 - oc(b) + e | c << e | d;
            sg = f + a;
          } else rg = 1 << f | c << e | d, sg = a;
        }
        function vg(a) {
          null !== a.return && (tg(a, 1), ug(a, 1, 0));
        }
        function wg(a) {
          for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
          for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
        }
        var xg = null,
          yg = null,
          I = false,
          zg = null;
        function Ag(a, b) {
          var c = Bg(5, null, null, 0);
          c.elementType = "DELETED";
          c.stateNode = b;
          c.return = a;
          b = a.deletions;
          null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
        }
        function Cg(a, b) {
          switch (a.tag) {
            case 5:
              var c = a.type;
              b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
              return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
            case 6:
              return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
            case 13:
              return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
                id: rg,
                overflow: sg
              } : null, a.memoizedState = {
                dehydrated: b,
                treeContext: c,
                retryLane: 1073741824
              }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
            default:
              return false;
          }
        }
        function Dg(a) {
          return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
        }
        function Eg(a) {
          if (I) {
            var b = yg;
            if (b) {
              var c = b;
              if (!Cg(a, b)) {
                if (Dg(a)) throw Error(p$1(418));
                b = Lf(c.nextSibling);
                var d = xg;
                b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
              }
            } else {
              if (Dg(a)) throw Error(p$1(418));
              a.flags = a.flags & -4097 | 2;
              I = false;
              xg = a;
            }
          }
        }
        function Fg(a) {
          for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
          xg = a;
        }
        function Gg(a) {
          if (a !== xg) return false;
          if (!I) return Fg(a), I = true, false;
          var b;
          (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
          if (b && (b = yg)) {
            if (Dg(a)) throw Hg(), Error(p$1(418));
            for (; b;) Ag(a, b), b = Lf(b.nextSibling);
          }
          Fg(a);
          if (13 === a.tag) {
            a = a.memoizedState;
            a = null !== a ? a.dehydrated : null;
            if (!a) throw Error(p$1(317));
            a: {
              a = a.nextSibling;
              for (b = 0; a;) {
                if (8 === a.nodeType) {
                  var c = a.data;
                  if ("/$" === c) {
                    if (0 === b) {
                      yg = Lf(a.nextSibling);
                      break a;
                    }
                    b--;
                  } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                }
                a = a.nextSibling;
              }
              yg = null;
            }
          } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
          return true;
        }
        function Hg() {
          for (var a = yg; a;) a = Lf(a.nextSibling);
        }
        function Ig() {
          yg = xg = null;
          I = false;
        }
        function Jg(a) {
          null === zg ? zg = [a] : zg.push(a);
        }
        var Kg = ua.ReactCurrentBatchConfig;
        function Lg(a, b, c) {
          a = c.ref;
          if (null !== a && "function" !== typeof a && "object" !== _typeof2(a)) {
            if (c._owner) {
              c = c._owner;
              if (c) {
                if (1 !== c.tag) throw Error(p$1(309));
                var d = c.stateNode;
              }
              if (!d) throw Error(p$1(147, a));
              var e = d,
                f = "" + a;
              if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
              b = function b(a) {
                var b = e.refs;
                null === a ? delete b[f] : b[f] = a;
              };
              b._stringRef = f;
              return b;
            }
            if ("string" !== typeof a) throw Error(p$1(284));
            if (!c._owner) throw Error(p$1(290, a));
          }
          return a;
        }
        function Mg(a, b) {
          a = Object.prototype.toString.call(b);
          throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
        }
        function Ng(a) {
          var b = a._init;
          return b(a._payload);
        }
        function Og(a) {
          function b(b, c) {
            if (a) {
              var d = b.deletions;
              null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
            }
          }
          function c(c, d) {
            if (!a) return null;
            for (; null !== d;) b(c, d), d = d.sibling;
            return null;
          }
          function d(a, b) {
            for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
            return a;
          }
          function e(a, b) {
            a = Pg(a, b);
            a.index = 0;
            a.sibling = null;
            return a;
          }
          function f(b, c, d) {
            b.index = d;
            if (!a) return b.flags |= 1048576, c;
            d = b.alternate;
            if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
            b.flags |= 2;
            return c;
          }
          function g(b) {
            a && null === b.alternate && (b.flags |= 2);
            return b;
          }
          function h(a, b, c, d) {
            if (null === b || 6 !== b.tag) return b = Qg(c, a.mode, d), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function k(a, b, c, d) {
            var f = c.type;
            if (f === ya) return m(a, b, c.props.children, d, c.key);
            if (null !== b && (b.elementType === f || "object" === _typeof2(f) && null !== f && f.$$typeof === Ha && Ng(f) === b.type)) return d = e(b, c.props), d.ref = Lg(a, b, c), d.return = a, d;
            d = Rg(c.type, c.key, c.props, null, a.mode, d);
            d.ref = Lg(a, b, c);
            d.return = a;
            return d;
          }
          function l(a, b, c, d) {
            if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Sg(c, a.mode, d), b.return = a, b;
            b = e(b, c.children || []);
            b.return = a;
            return b;
          }
          function m(a, b, c, d, f) {
            if (null === b || 7 !== b.tag) return b = Tg(c, a.mode, d, f), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function q(a, b, c) {
            if ("string" === typeof b && "" !== b || "number" === typeof b) return b = Qg("" + b, a.mode, c), b.return = a, b;
            if ("object" === _typeof2(b) && null !== b) {
              switch (b.$$typeof) {
                case va:
                  return c = Rg(b.type, b.key, b.props, null, a.mode, c), c.ref = Lg(a, null, b), c.return = a, c;
                case wa:
                  return b = Sg(b, a.mode, c), b.return = a, b;
                case Ha:
                  var d = b._init;
                  return q(a, d(b._payload), c);
              }
              if (eb(b) || Ka(b)) return b = Tg(b, a.mode, c, null), b.return = a, b;
              Mg(a, b);
            }
            return null;
          }
          function r(a, b, c, d) {
            var e = null !== b ? b.key : null;
            if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
            if ("object" === _typeof2(c) && null !== c) {
              switch (c.$$typeof) {
                case va:
                  return c.key === e ? k(a, b, c, d) : null;
                case wa:
                  return c.key === e ? l(a, b, c, d) : null;
                case Ha:
                  return e = c._init, r(a, b, e(c._payload), d);
              }
              if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
              Mg(a, c);
            }
            return null;
          }
          function y(a, b, c, d, e) {
            if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
            if ("object" === _typeof2(d) && null !== d) {
              switch (d.$$typeof) {
                case va:
                  return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
                case wa:
                  return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
                case Ha:
                  var f = d._init;
                  return y(a, b, c, f(d._payload), e);
              }
              if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
              Mg(b, d);
            }
            return null;
          }
          function n(e, g, h, k) {
            for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
              u.index > w ? (x = u, u = null) : x = u.sibling;
              var n = r(e, u, h[w], k);
              if (null === n) {
                null === u && (u = x);
                break;
              }
              a && u && null === n.alternate && b(e, u);
              g = f(n, g, w);
              null === m ? l = n : m.sibling = n;
              m = n;
              u = x;
            }
            if (w === h.length) return c(e, u), I && tg(e, w), l;
            if (null === u) {
              for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
              I && tg(e, w);
              return l;
            }
            for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
            a && u.forEach(function (a) {
              return b(e, a);
            });
            I && tg(e, w);
            return l;
          }
          function t(e, g, h, k) {
            var l = Ka(h);
            if ("function" !== typeof l) throw Error(p$1(150));
            h = l.call(h);
            if (null == h) throw Error(p$1(151));
            for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
              m.index > w ? (x = m, m = null) : x = m.sibling;
              var t = r(e, m, n.value, k);
              if (null === t) {
                null === m && (m = x);
                break;
              }
              a && m && null === t.alternate && b(e, m);
              g = f(t, g, w);
              null === u ? l = t : u.sibling = t;
              u = t;
              m = x;
            }
            if (n.done) return c(e, m), I && tg(e, w), l;
            if (null === m) {
              for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
              I && tg(e, w);
              return l;
            }
            for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
            a && m.forEach(function (a) {
              return b(e, a);
            });
            I && tg(e, w);
            return l;
          }
          function J(a, d, f, h) {
            "object" === _typeof2(f) && null !== f && f.type === ya && null === f.key && (f = f.props.children);
            if ("object" === _typeof2(f) && null !== f) {
              switch (f.$$typeof) {
                case va:
                  a: {
                    for (var k = f.key, l = d; null !== l;) {
                      if (l.key === k) {
                        k = f.type;
                        if (k === ya) {
                          if (7 === l.tag) {
                            c(a, l.sibling);
                            d = e(l, f.props.children);
                            d.return = a;
                            a = d;
                            break a;
                          }
                        } else if (l.elementType === k || "object" === _typeof2(k) && null !== k && k.$$typeof === Ha && Ng(k) === l.type) {
                          c(a, l.sibling);
                          d = e(l, f.props);
                          d.ref = Lg(a, l, f);
                          d.return = a;
                          a = d;
                          break a;
                        }
                        c(a, l);
                        break;
                      } else b(a, l);
                      l = l.sibling;
                    }
                    f.type === ya ? (d = Tg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Rg(f.type, f.key, f.props, null, a.mode, h), h.ref = Lg(a, d, f), h.return = a, a = h);
                  }
                  return g(a);
                case wa:
                  a: {
                    for (l = f.key; null !== d;) {
                      if (d.key === l) {
                        if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                          c(a, d.sibling);
                          d = e(d, f.children || []);
                          d.return = a;
                          a = d;
                          break a;
                        } else {
                          c(a, d);
                          break;
                        }
                      } else b(a, d);
                      d = d.sibling;
                    }
                    d = Sg(f, a.mode, h);
                    d.return = a;
                    a = d;
                  }
                  return g(a);
                case Ha:
                  return l = f._init, J(a, d, l(f._payload), h);
              }
              if (eb(f)) return n(a, d, f, h);
              if (Ka(f)) return t(a, d, f, h);
              Mg(a, f);
            }
            return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Qg(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
          }
          return J;
        }
        var Ug = Og(true),
          Vg = Og(false),
          Wg = Uf(null),
          Xg = null,
          Yg = null,
          Zg = null;
        function $g() {
          Zg = Yg = Xg = null;
        }
        function ah(a) {
          var b = Wg.current;
          E(Wg);
          a._currentValue = b;
        }
        function bh(a, b, c) {
          for (; null !== a;) {
            var d = a.alternate;
            (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
            if (a === c) break;
            a = a.return;
          }
        }
        function ch(a, b) {
          Xg = a;
          Zg = Yg = null;
          a = a.dependencies;
          null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
        }
        function eh(a) {
          var b = a._currentValue;
          if (Zg !== a) if (a = {
            context: a,
            memoizedValue: b,
            next: null
          }, null === Yg) {
            if (null === Xg) throw Error(p$1(308));
            Yg = a;
            Xg.dependencies = {
              lanes: 0,
              firstContext: a
            };
          } else Yg = Yg.next = a;
          return b;
        }
        var fh = null;
        function gh(a) {
          null === fh ? fh = [a] : fh.push(a);
        }
        function hh(a, b, c, d) {
          var e = b.interleaved;
          null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
          b.interleaved = c;
          return ih(a, d);
        }
        function ih(a, b) {
          a.lanes |= b;
          var c = a.alternate;
          null !== c && (c.lanes |= b);
          c = a;
          for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
          return 3 === c.tag ? c.stateNode : null;
        }
        var jh = false;
        function kh(a) {
          a.updateQueue = {
            baseState: a.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: 0
            },
            effects: null
          };
        }
        function lh(a, b) {
          a = a.updateQueue;
          b.updateQueue === a && (b.updateQueue = {
            baseState: a.baseState,
            firstBaseUpdate: a.firstBaseUpdate,
            lastBaseUpdate: a.lastBaseUpdate,
            shared: a.shared,
            effects: a.effects
          });
        }
        function mh(a, b) {
          return {
            eventTime: a,
            lane: b,
            tag: 0,
            payload: null,
            callback: null,
            next: null
          };
        }
        function nh(a, b, c) {
          var d = a.updateQueue;
          if (null === d) return null;
          d = d.shared;
          if (0 !== (K & 2)) {
            var e = d.pending;
            null === e ? b.next = b : (b.next = e.next, e.next = b);
            d.pending = b;
            return ih(a, c);
          }
          e = d.interleaved;
          null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
          d.interleaved = b;
          return ih(a, c);
        }
        function oh(a, b, c) {
          b = b.updateQueue;
          if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        function ph(a, b) {
          var c = a.updateQueue,
            d = a.alternate;
          if (null !== d && (d = d.updateQueue, c === d)) {
            var e = null,
              f = null;
            c = c.firstBaseUpdate;
            if (null !== c) {
              do {
                var g = {
                  eventTime: c.eventTime,
                  lane: c.lane,
                  tag: c.tag,
                  payload: c.payload,
                  callback: c.callback,
                  next: null
                };
                null === f ? e = f = g : f = f.next = g;
                c = c.next;
              } while (null !== c);
              null === f ? e = f = b : f = f.next = b;
            } else e = f = b;
            c = {
              baseState: d.baseState,
              firstBaseUpdate: e,
              lastBaseUpdate: f,
              shared: d.shared,
              effects: d.effects
            };
            a.updateQueue = c;
            return;
          }
          a = c.lastBaseUpdate;
          null === a ? c.firstBaseUpdate = b : a.next = b;
          c.lastBaseUpdate = b;
        }
        function qh(a, b, c, d) {
          var e = a.updateQueue;
          jh = false;
          var f = e.firstBaseUpdate,
            g = e.lastBaseUpdate,
            h = e.shared.pending;
          if (null !== h) {
            e.shared.pending = null;
            var k = h,
              l = k.next;
            k.next = null;
            null === g ? f = l : g.next = l;
            g = k;
            var m = a.alternate;
            null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
          }
          if (null !== f) {
            var q = e.baseState;
            g = 0;
            m = l = k = null;
            h = f;
            do {
              var r = h.lane,
                y = h.eventTime;
              if ((d & r) === r) {
                null !== m && (m = m.next = {
                  eventTime: y,
                  lane: 0,
                  tag: h.tag,
                  payload: h.payload,
                  callback: h.callback,
                  next: null
                });
                a: {
                  var n = a,
                    t = h;
                  r = b;
                  y = c;
                  switch (t.tag) {
                    case 1:
                      n = t.payload;
                      if ("function" === typeof n) {
                        q = n.call(y, q, r);
                        break a;
                      }
                      q = n;
                      break a;
                    case 3:
                      n.flags = n.flags & -65537 | 128;
                    case 0:
                      n = t.payload;
                      r = "function" === typeof n ? n.call(y, q, r) : n;
                      if (null === r || void 0 === r) break a;
                      q = A$1({}, q, r);
                      break a;
                    case 2:
                      jh = true;
                  }
                }
                null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
              } else y = {
                eventTime: y,
                lane: r,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
              h = h.next;
              if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
            } while (1);
            null === m && (k = q);
            e.baseState = k;
            e.firstBaseUpdate = l;
            e.lastBaseUpdate = m;
            b = e.shared.interleaved;
            if (null !== b) {
              e = b;
              do g |= e.lane, e = e.next; while (e !== b);
            } else null === f && (e.shared.lanes = 0);
            rh |= g;
            a.lanes = g;
            a.memoizedState = q;
          }
        }
        function sh(a, b, c) {
          a = b.effects;
          b.effects = null;
          if (null !== a) for (b = 0; b < a.length; b++) {
            var d = a[b],
              e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e) throw Error(p$1(191, e));
              e.call(d);
            }
          }
        }
        var th = {},
          uh = Uf(th),
          vh$1 = Uf(th),
          wh = Uf(th);
        function xh(a) {
          if (a === th) throw Error(p$1(174));
          return a;
        }
        function yh(a, b) {
          G(wh, b);
          G(vh$1, a);
          G(uh, th);
          a = b.nodeType;
          switch (a) {
            case 9:
            case 11:
              b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
              break;
            default:
              a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
          }
          E(uh);
          G(uh, b);
        }
        function zh() {
          E(uh);
          E(vh$1);
          E(wh);
        }
        function Ah(a) {
          xh(wh.current);
          var b = xh(uh.current);
          var c = lb(b, a.type);
          b !== c && (G(vh$1, a), G(uh, c));
        }
        function Bh(a) {
          vh$1.current === a && (E(uh), E(vh$1));
        }
        var L = Uf(0);
        function Ch(a) {
          for (var b = a; null !== b;) {
            if (13 === b.tag) {
              var c = b.memoizedState;
              if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
            } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
              if (0 !== (b.flags & 128)) return b;
            } else if (null !== b.child) {
              b.child.return = b;
              b = b.child;
              continue;
            }
            if (b === a) break;
            for (; null === b.sibling;) {
              if (null === b.return || b.return === a) return null;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
          return null;
        }
        var Dh = [];
        function Eh() {
          for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
          Dh.length = 0;
        }
        var Fh = ua.ReactCurrentDispatcher,
          Gh = ua.ReactCurrentBatchConfig,
          Hh = 0,
          M = null,
          N = null,
          O = null,
          Ih = false,
          Jh = false,
          Kh = 0,
          Lh = 0;
        function P() {
          throw Error(p$1(321));
        }
        function Mh(a, b) {
          if (null === b) return false;
          for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
          return true;
        }
        function Nh(a, b, c, d, e, f) {
          Hh = f;
          M = b;
          b.memoizedState = null;
          b.updateQueue = null;
          b.lanes = 0;
          Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
          a = c(d, e);
          if (Jh) {
            f = 0;
            do {
              Jh = false;
              Kh = 0;
              if (25 <= f) throw Error(p$1(301));
              f += 1;
              O = N = null;
              b.updateQueue = null;
              Fh.current = Qh;
              a = c(d, e);
            } while (Jh);
          }
          Fh.current = Rh;
          b = null !== N && null !== N.next;
          Hh = 0;
          O = N = M = null;
          Ih = false;
          if (b) throw Error(p$1(300));
          return a;
        }
        function Sh() {
          var a = 0 !== Kh;
          Kh = 0;
          return a;
        }
        function Th() {
          var a = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === O ? M.memoizedState = O = a : O = O.next = a;
          return O;
        }
        function Uh() {
          if (null === N) {
            var a = M.alternate;
            a = null !== a ? a.memoizedState : null;
          } else a = N.next;
          var b = null === O ? M.memoizedState : O.next;
          if (null !== b) O = b, N = a;else {
            if (null === a) throw Error(p$1(310));
            N = a;
            a = {
              memoizedState: N.memoizedState,
              baseState: N.baseState,
              baseQueue: N.baseQueue,
              queue: N.queue,
              next: null
            };
            null === O ? M.memoizedState = O = a : O = O.next = a;
          }
          return O;
        }
        function Vh(a, b) {
          return "function" === typeof b ? b(a) : b;
        }
        function Wh(a) {
          var b = Uh(),
            c = b.queue;
          if (null === c) throw Error(p$1(311));
          c.lastRenderedReducer = a;
          var d = N,
            e = d.baseQueue,
            f = c.pending;
          if (null !== f) {
            if (null !== e) {
              var g = e.next;
              e.next = f.next;
              f.next = g;
            }
            d.baseQueue = e = f;
            c.pending = null;
          }
          if (null !== e) {
            f = e.next;
            d = d.baseState;
            var h = g = null,
              k = null,
              l = f;
            do {
              var m = l.lane;
              if ((Hh & m) === m) null !== k && (k = k.next = {
                lane: 0,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
                var q = {
                  lane: m,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
                };
                null === k ? (h = k = q, g = d) : k = k.next = q;
                M.lanes |= m;
                rh |= m;
              }
              l = l.next;
            } while (null !== l && l !== f);
            null === k ? g = d : k.next = h;
            He(d, b.memoizedState) || (dh = true);
            b.memoizedState = d;
            b.baseState = g;
            b.baseQueue = k;
            c.lastRenderedState = d;
          }
          a = c.interleaved;
          if (null !== a) {
            e = a;
            do f = e.lane, M.lanes |= f, rh |= f, e = e.next; while (e !== a);
          } else null === e && (c.lanes = 0);
          return [b.memoizedState, c.dispatch];
        }
        function Xh(a) {
          var b = Uh(),
            c = b.queue;
          if (null === c) throw Error(p$1(311));
          c.lastRenderedReducer = a;
          var d = c.dispatch,
            e = c.pending,
            f = b.memoizedState;
          if (null !== e) {
            c.pending = null;
            var g = e = e.next;
            do f = a(f, g.action), g = g.next; while (g !== e);
            He(f, b.memoizedState) || (dh = true);
            b.memoizedState = f;
            null === b.baseQueue && (b.baseState = f);
            c.lastRenderedState = f;
          }
          return [f, d];
        }
        function Yh() {}
        function Zh(a, b) {
          var c = M,
            d = Uh(),
            e = b(),
            f = !He(d.memoizedState, e);
          f && (d.memoizedState = e, dh = true);
          d = d.queue;
          $h(ai.bind(null, c, d, a), [a]);
          if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
            c.flags |= 2048;
            bi(9, ci.bind(null, c, d, e, b), void 0, null);
            if (null === Q) throw Error(p$1(349));
            0 !== (Hh & 30) || di(c, b, e);
          }
          return e;
        }
        function di(a, b, c) {
          a.flags |= 16384;
          a = {
            getSnapshot: b,
            value: c
          };
          b = M.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
        }
        function ci(a, b, c, d) {
          b.value = c;
          b.getSnapshot = d;
          ei(b) && fi(a);
        }
        function ai(a, b, c) {
          return c(function () {
            ei(b) && fi(a);
          });
        }
        function ei(a) {
          var b = a.getSnapshot;
          a = a.value;
          try {
            var c = b();
            return !He(a, c);
          } catch (d) {
            return true;
          }
        }
        function fi(a) {
          var b = ih(a, 1);
          null !== b && gi(b, a, 1, -1);
        }
        function hi(a) {
          var b = Th();
          "function" === typeof a && (a = a());
          b.memoizedState = b.baseState = a;
          a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Vh,
            lastRenderedState: a
          };
          b.queue = a;
          a = a.dispatch = ii.bind(null, M, a);
          return [b.memoizedState, a];
        }
        function bi(a, b, c, d) {
          a = {
            tag: a,
            create: b,
            destroy: c,
            deps: d,
            next: null
          };
          b = M.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
          return a;
        }
        function ji() {
          return Uh().memoizedState;
        }
        function ki(a, b, c, d) {
          var e = Th();
          M.flags |= a;
          e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
        }
        function li(a, b, c, d) {
          var e = Uh();
          d = void 0 === d ? null : d;
          var f = void 0;
          if (null !== N) {
            var g = N.memoizedState;
            f = g.destroy;
            if (null !== d && Mh(d, g.deps)) {
              e.memoizedState = bi(b, c, f, d);
              return;
            }
          }
          M.flags |= a;
          e.memoizedState = bi(1 | b, c, f, d);
        }
        function mi(a, b) {
          return ki(8390656, 8, a, b);
        }
        function $h(a, b) {
          return li(2048, 8, a, b);
        }
        function ni(a, b) {
          return li(4, 2, a, b);
        }
        function oi(a, b) {
          return li(4, 4, a, b);
        }
        function pi(a, b) {
          if ("function" === typeof b) return a = a(), b(a), function () {
            b(null);
          };
          if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
            b.current = null;
          };
        }
        function qi(a, b, c) {
          c = null !== c && void 0 !== c ? c.concat([a]) : null;
          return li(4, 4, pi.bind(null, b, a), c);
        }
        function ri() {}
        function si(a, b) {
          var c = Uh();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Mh(b, d[1])) return d[0];
          c.memoizedState = [a, b];
          return a;
        }
        function ti(a, b) {
          var c = Uh();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Mh(b, d[1])) return d[0];
          a = a();
          c.memoizedState = [a, b];
          return a;
        }
        function ui(a, b, c) {
          if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
          He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
          return b;
        }
        function vi(a, b) {
          var c = C;
          C = 0 !== c && 4 > c ? c : 4;
          a(true);
          var d = Gh.transition;
          Gh.transition = {};
          try {
            a(!1), b();
          } finally {
            C = c, Gh.transition = d;
          }
        }
        function wi() {
          return Uh().memoizedState;
        }
        function xi(a, b, c) {
          var d = yi(a);
          c = {
            lane: d,
            action: c,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (zi(a)) Ai(b, c);else if (c = hh(a, b, c, d), null !== c) {
            var e = R();
            gi(c, a, d, e);
            Bi(c, b, d);
          }
        }
        function ii(a, b, c) {
          var d = yi(a),
            e = {
              lane: d,
              action: c,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
          if (zi(a)) Ai(b, e);else {
            var f = a.alternate;
            if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
              var g = b.lastRenderedState,
                h = f(g, c);
              e.hasEagerState = !0;
              e.eagerState = h;
              if (He(h, g)) {
                var k = b.interleaved;
                null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
                b.interleaved = e;
                return;
              }
            } catch (l) {} finally {}
            c = hh(a, b, e, d);
            null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
          }
        }
        function zi(a) {
          var b = a.alternate;
          return a === M || null !== b && b === M;
        }
        function Ai(a, b) {
          Jh = Ih = true;
          var c = a.pending;
          null === c ? b.next = b : (b.next = c.next, c.next = b);
          a.pending = b;
        }
        function Bi(a, b, c) {
          if (0 !== (c & 4194240)) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        var Rh = {
            readContext: eh,
            useCallback: P,
            useContext: P,
            useEffect: P,
            useImperativeHandle: P,
            useInsertionEffect: P,
            useLayoutEffect: P,
            useMemo: P,
            useReducer: P,
            useRef: P,
            useState: P,
            useDebugValue: P,
            useDeferredValue: P,
            useTransition: P,
            useMutableSource: P,
            useSyncExternalStore: P,
            useId: P,
            unstable_isNewReconciler: false
          },
          Oh = {
            readContext: eh,
            useCallback: function useCallback(a, b) {
              Th().memoizedState = [a, void 0 === b ? null : b];
              return a;
            },
            useContext: eh,
            useEffect: mi,
            useImperativeHandle: function useImperativeHandle(a, b, c) {
              c = null !== c && void 0 !== c ? c.concat([a]) : null;
              return ki(4194308, 4, pi.bind(null, b, a), c);
            },
            useLayoutEffect: function useLayoutEffect(a, b) {
              return ki(4194308, 4, a, b);
            },
            useInsertionEffect: function useInsertionEffect(a, b) {
              return ki(4, 2, a, b);
            },
            useMemo: function useMemo(a, b) {
              var c = Th();
              b = void 0 === b ? null : b;
              a = a();
              c.memoizedState = [a, b];
              return a;
            },
            useReducer: function useReducer(a, b, c) {
              var d = Th();
              b = void 0 !== c ? c(b) : b;
              d.memoizedState = d.baseState = b;
              a = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: a,
                lastRenderedState: b
              };
              d.queue = a;
              a = a.dispatch = xi.bind(null, M, a);
              return [d.memoizedState, a];
            },
            useRef: function useRef(a) {
              var b = Th();
              a = {
                current: a
              };
              return b.memoizedState = a;
            },
            useState: hi,
            useDebugValue: ri,
            useDeferredValue: function useDeferredValue(a) {
              return Th().memoizedState = a;
            },
            useTransition: function useTransition() {
              var a = hi(false),
                b = a[0];
              a = vi.bind(null, a[1]);
              Th().memoizedState = a;
              return [b, a];
            },
            useMutableSource: function useMutableSource() {},
            useSyncExternalStore: function useSyncExternalStore(a, b, c) {
              var d = M,
                e = Th();
              if (I) {
                if (void 0 === c) throw Error(p$1(407));
                c = c();
              } else {
                c = b();
                if (null === Q) throw Error(p$1(349));
                0 !== (Hh & 30) || di(d, b, c);
              }
              e.memoizedState = c;
              var f = {
                value: c,
                getSnapshot: b
              };
              e.queue = f;
              mi(ai.bind(null, d, f, a), [a]);
              d.flags |= 2048;
              bi(9, ci.bind(null, d, f, c, b), void 0, null);
              return c;
            },
            useId: function useId() {
              var a = Th(),
                b = Q.identifierPrefix;
              if (I) {
                var c = sg;
                var d = rg;
                c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
                b = ":" + b + "R" + c;
                c = Kh++;
                0 < c && (b += "H" + c.toString(32));
                b += ":";
              } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
              return a.memoizedState = b;
            },
            unstable_isNewReconciler: false
          },
          Ph = {
            readContext: eh,
            useCallback: si,
            useContext: eh,
            useEffect: $h,
            useImperativeHandle: qi,
            useInsertionEffect: ni,
            useLayoutEffect: oi,
            useMemo: ti,
            useReducer: Wh,
            useRef: ji,
            useState: function useState() {
              return Wh(Vh);
            },
            useDebugValue: ri,
            useDeferredValue: function useDeferredValue(a) {
              var b = Uh();
              return ui(b, N.memoizedState, a);
            },
            useTransition: function useTransition() {
              var a = Wh(Vh)[0],
                b = Uh().memoizedState;
              return [a, b];
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: wi,
            unstable_isNewReconciler: false
          },
          Qh = {
            readContext: eh,
            useCallback: si,
            useContext: eh,
            useEffect: $h,
            useImperativeHandle: qi,
            useInsertionEffect: ni,
            useLayoutEffect: oi,
            useMemo: ti,
            useReducer: Xh,
            useRef: ji,
            useState: function useState() {
              return Xh(Vh);
            },
            useDebugValue: ri,
            useDeferredValue: function useDeferredValue(a) {
              var b = Uh();
              return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
            },
            useTransition: function useTransition() {
              var a = Xh(Vh)[0],
                b = Uh().memoizedState;
              return [a, b];
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: wi,
            unstable_isNewReconciler: false
          };
        function Ci(a, b) {
          if (a && a.defaultProps) {
            b = A$1({}, b);
            a = a.defaultProps;
            for (var c in a) void 0 === b[c] && (b[c] = a[c]);
            return b;
          }
          return b;
        }
        function Di(a, b, c, d) {
          b = a.memoizedState;
          c = c(d, b);
          c = null === c || void 0 === c ? b : A$1({}, b, c);
          a.memoizedState = c;
          0 === a.lanes && (a.updateQueue.baseState = c);
        }
        var Ei = {
          isMounted: function isMounted(a) {
            return (a = a._reactInternals) ? Vb(a) === a : false;
          },
          enqueueSetState: function enqueueSetState(a, b, c) {
            a = a._reactInternals;
            var d = R(),
              e = yi(a),
              f = mh(d, e);
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = nh(a, f, e);
            null !== b && (gi(b, a, e, d), oh(b, a, e));
          },
          enqueueReplaceState: function enqueueReplaceState(a, b, c) {
            a = a._reactInternals;
            var d = R(),
              e = yi(a),
              f = mh(d, e);
            f.tag = 1;
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = nh(a, f, e);
            null !== b && (gi(b, a, e, d), oh(b, a, e));
          },
          enqueueForceUpdate: function enqueueForceUpdate(a, b) {
            a = a._reactInternals;
            var c = R(),
              d = yi(a),
              e = mh(c, d);
            e.tag = 2;
            void 0 !== b && null !== b && (e.callback = b);
            b = nh(a, e, d);
            null !== b && (gi(b, a, d, c), oh(b, a, d));
          }
        };
        function Fi(a, b, c, d, e, f, g) {
          a = a.stateNode;
          return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
        }
        function Gi(a, b, c) {
          var d = false,
            e = Vf;
          var f = b.contextType;
          "object" === _typeof2(f) && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
          b = new b(c, f);
          a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
          b.updater = Ei;
          a.stateNode = b;
          b._reactInternals = a;
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
          return b;
        }
        function Hi(a, b, c, d) {
          a = b.state;
          "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
          "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
          b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
        }
        function Ii(a, b, c, d) {
          var e = a.stateNode;
          e.props = c;
          e.state = a.memoizedState;
          e.refs = {};
          kh(a);
          var f = b.contextType;
          "object" === _typeof2(f) && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
          e.state = a.memoizedState;
          f = b.getDerivedStateFromProps;
          "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
          "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
          "function" === typeof e.componentDidMount && (a.flags |= 4194308);
        }
        function Ji(a, b) {
          try {
            var c = "",
              d = b;
            do c += Pa(d), d = d.return; while (d);
            var e = c;
          } catch (f) {
            e = "\nError generating stack: " + f.message + "\n" + f.stack;
          }
          return {
            value: a,
            source: b,
            stack: e,
            digest: null
          };
        }
        function Ki(a, b, c) {
          return {
            value: a,
            source: null,
            stack: null != c ? c : null,
            digest: null != b ? b : null
          };
        }
        function Li(a, b) {
          try {
            console.error(b.value);
          } catch (c) {
            setTimeout(function () {
              throw c;
            });
          }
        }
        var Mi = "function" === typeof WeakMap ? WeakMap : Map;
        function Ni(a, b, c) {
          c = mh(-1, c);
          c.tag = 3;
          c.payload = {
            element: null
          };
          var d = b.value;
          c.callback = function () {
            Oi || (Oi = true, Pi = d);
            Li(a, b);
          };
          return c;
        }
        function Qi(a, b, c) {
          c = mh(-1, c);
          c.tag = 3;
          var d = a.type.getDerivedStateFromError;
          if ("function" === typeof d) {
            var e = b.value;
            c.payload = function () {
              return d(e);
            };
            c.callback = function () {
              Li(a, b);
            };
          }
          var f = a.stateNode;
          null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
            Li(a, b);
            "function" !== typeof d && (null === Ri ? Ri = new Set([this]) : Ri.add(this));
            var c = b.stack;
            this.componentDidCatch(b.value, {
              componentStack: null !== c ? c : ""
            });
          });
          return c;
        }
        function Si(a, b, c) {
          var d = a.pingCache;
          if (null === d) {
            d = a.pingCache = new Mi();
            var e = new Set();
            d.set(b, e);
          } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
          e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
        }
        function Ui(a) {
          do {
            var b;
            if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
            if (b) return a;
            a = a.return;
          } while (null !== a);
          return null;
        }
        function Vi(a, b, c, d, e) {
          if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
          a.flags |= 65536;
          a.lanes = e;
          return a;
        }
        var Wi = ua.ReactCurrentOwner,
          dh = false;
        function Xi(a, b, c, d) {
          b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
        }
        function Yi(a, b, c, d, e) {
          c = c.render;
          var f = b.ref;
          ch(b, e);
          d = Nh(a, b, c, d, f, e);
          c = Sh();
          if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
          I && c && vg(b);
          b.flags |= 1;
          Xi(a, b, d, e);
          return b.child;
        }
        function $i(a, b, c, d, e) {
          if (null === a) {
            var f = c.type;
            if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
            a = Rg(c.type, null, d, b, b.mode, e);
            a.ref = b.ref;
            a.return = b;
            return b.child = a;
          }
          f = a.child;
          if (0 === (a.lanes & e)) {
            var g = f.memoizedProps;
            c = c.compare;
            c = null !== c ? c : Ie;
            if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
          }
          b.flags |= 1;
          a = Pg(f, d);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        function bj(a, b, c, d, e) {
          if (null !== a) {
            var f = a.memoizedProps;
            if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);else return b.lanes = a.lanes, Zi(a, b, e);
          }
          return cj(a, b, c, d, e);
        }
        function dj(a, b, c) {
          var d = b.pendingProps,
            e = d.children,
            f = null !== a ? a.memoizedState : null;
          if ("hidden" === d.mode) {
            if (0 === (b.mode & 1)) b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
            }, G(ej, fj), fj |= c;else {
              if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
                baseLanes: a,
                cachePool: null,
                transitions: null
              }, b.updateQueue = null, G(ej, fj), fj |= a, null;
              b.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
              };
              d = null !== f ? f.baseLanes : c;
              G(ej, fj);
              fj |= d;
            }
          } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
          Xi(a, b, e, c);
          return b.child;
        }
        function gj(a, b) {
          var c = b.ref;
          if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
        }
        function cj(a, b, c, d, e) {
          var f = Zf(c) ? Xf : H.current;
          f = Yf(b, f);
          ch(b, e);
          c = Nh(a, b, c, d, f, e);
          d = Sh();
          if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
          I && d && vg(b);
          b.flags |= 1;
          Xi(a, b, c, e);
          return b.child;
        }
        function hj(a, b, c, d, e) {
          if (Zf(c)) {
            var f = true;
            cg(b);
          } else f = false;
          ch(b, e);
          if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;else if (null === a) {
            var g = b.stateNode,
              h = b.memoizedProps;
            g.props = h;
            var k = g.context,
              l = c.contextType;
            "object" === _typeof2(l) && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
            var m = c.getDerivedStateFromProps,
              q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
            q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
            jh = false;
            var r = b.memoizedState;
            g.state = r;
            qh(b, d, g, e);
            k = b.memoizedState;
            h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
          } else {
            g = b.stateNode;
            lh(a, b);
            h = b.memoizedProps;
            l = b.type === b.elementType ? h : Ci(b.type, h);
            g.props = l;
            q = b.pendingProps;
            r = g.context;
            k = c.contextType;
            "object" === _typeof2(k) && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
            var y = c.getDerivedStateFromProps;
            (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
            jh = false;
            r = b.memoizedState;
            g.state = r;
            qh(b, d, g, e);
            var n = b.memoizedState;
            h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
          }
          return jj(a, b, c, d, f, e);
        }
        function jj(a, b, c, d, e, f) {
          gj(a, b);
          var g = 0 !== (b.flags & 128);
          if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
          d = b.stateNode;
          Wi.current = b;
          var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
          b.flags |= 1;
          null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
          b.memoizedState = d.state;
          e && dg(b, c, true);
          return b.child;
        }
        function kj(a) {
          var b = a.stateNode;
          b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
          yh(a, b.containerInfo);
        }
        function lj(a, b, c, d, e) {
          Ig();
          Jg(e);
          b.flags |= 256;
          Xi(a, b, c, d);
          return b.child;
        }
        var mj = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0
        };
        function nj(a) {
          return {
            baseLanes: a,
            cachePool: null,
            transitions: null
          };
        }
        function oj(a, b, c) {
          var d = b.pendingProps,
            e = L.current,
            f = false,
            g = 0 !== (b.flags & 128),
            h;
          (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
          if (h) f = true, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
          G(L, e & 1);
          if (null === a) {
            Eg(b);
            a = b.memoizedState;
            if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
            g = d.children;
            a = d.fallback;
            return f ? (d = b.mode, f = b.child, g = {
              mode: "hidden",
              children: g
            }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
          }
          e = a.memoizedState;
          if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
          if (f) {
            f = d.fallback;
            g = b.mode;
            e = a.child;
            h = e.sibling;
            var k = {
              mode: "hidden",
              children: d.children
            };
            0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
            null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
            f.return = b;
            d.return = b;
            d.sibling = f;
            b.child = d;
            d = f;
            f = b.child;
            g = a.child.memoizedState;
            g = null === g ? nj(c) : {
              baseLanes: g.baseLanes | c,
              cachePool: null,
              transitions: g.transitions
            };
            f.memoizedState = g;
            f.childLanes = a.childLanes & ~c;
            b.memoizedState = mj;
            return d;
          }
          f = a.child;
          a = f.sibling;
          d = Pg(f, {
            mode: "visible",
            children: d.children
          });
          0 === (b.mode & 1) && (d.lanes = c);
          d.return = b;
          d.sibling = null;
          null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
          b.child = d;
          b.memoizedState = null;
          return d;
        }
        function qj(a, b) {
          b = pj({
            mode: "visible",
            children: b
          }, a.mode, 0, null);
          b.return = a;
          return a.child = b;
        }
        function sj(a, b, c, d) {
          null !== d && Jg(d);
          Ug(b, a.child, null, c);
          a = qj(b, b.pendingProps.children);
          a.flags |= 2;
          b.memoizedState = null;
          return a;
        }
        function rj(a, b, c, d, e, f, g) {
          if (c) {
            if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p$1(422))), sj(a, b, g, d);
            if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
            f = d.fallback;
            e = b.mode;
            d = pj({
              mode: "visible",
              children: d.children
            }, e, 0, null);
            f = Tg(f, e, g, null);
            f.flags |= 2;
            d.return = b;
            f.return = b;
            d.sibling = f;
            b.child = d;
            0 !== (b.mode & 1) && Ug(b, a.child, null, g);
            b.child.memoizedState = nj(g);
            b.memoizedState = mj;
            return f;
          }
          if (0 === (b.mode & 1)) return sj(a, b, g, null);
          if ("$!" === e.data) {
            d = e.nextSibling && e.nextSibling.dataset;
            if (d) var h = d.dgst;
            d = h;
            f = Error(p$1(419));
            d = Ki(f, d, void 0);
            return sj(a, b, g, d);
          }
          h = 0 !== (g & a.childLanes);
          if (dh || h) {
            d = Q;
            if (null !== d) {
              switch (g & -g) {
                case 4:
                  e = 2;
                  break;
                case 16:
                  e = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  e = 32;
                  break;
                case 536870912:
                  e = 268435456;
                  break;
                default:
                  e = 0;
              }
              e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
              0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
            }
            tj();
            d = Ki(Error(p$1(421)));
            return sj(a, b, g, d);
          }
          if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
          a = f.treeContext;
          yg = Lf(e.nextSibling);
          xg = b;
          I = true;
          zg = null;
          null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
          b = qj(b, d.children);
          b.flags |= 4096;
          return b;
        }
        function vj(a, b, c) {
          a.lanes |= b;
          var d = a.alternate;
          null !== d && (d.lanes |= b);
          bh(a.return, b, c);
        }
        function wj(a, b, c, d, e) {
          var f = a.memoizedState;
          null === f ? a.memoizedState = {
            isBackwards: b,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: c,
            tailMode: e
          } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
        }
        function xj(a, b, c) {
          var d = b.pendingProps,
            e = d.revealOrder,
            f = d.tail;
          Xi(a, b, d.children, c);
          d = L.current;
          if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
            if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
              if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);else if (19 === a.tag) vj(a, c, b);else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b) break a;
              for (; null === a.sibling;) {
                if (null === a.return || a.return === b) break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
            d &= 1;
          }
          G(L, d);
          if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c;) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
              c = e;
              null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
              wj(b, false, e, c, f);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e;) {
                a = e.alternate;
                if (null !== a && null === Ch(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              wj(b, true, c, null, f);
              break;
            case "together":
              wj(b, false, null, null, void 0);
              break;
            default:
              b.memoizedState = null;
          }
          return b.child;
        }
        function ij(a, b) {
          0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        }
        function Zi(a, b, c) {
          null !== a && (b.dependencies = a.dependencies);
          rh |= b.lanes;
          if (0 === (c & b.childLanes)) return null;
          if (null !== a && b.child !== a.child) throw Error(p$1(153));
          if (null !== b.child) {
            a = b.child;
            c = Pg(a, a.pendingProps);
            b.child = c;
            for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
            c.sibling = null;
          }
          return b.child;
        }
        function yj(a, b, c) {
          switch (b.tag) {
            case 3:
              kj(b);
              Ig();
              break;
            case 5:
              Ah(b);
              break;
            case 1:
              Zf(b.type) && cg(b);
              break;
            case 4:
              yh(b, b.stateNode.containerInfo);
              break;
            case 10:
              var d = b.type._context,
                e = b.memoizedProps.value;
              G(Wg, d._currentValue);
              d._currentValue = e;
              break;
            case 13:
              d = b.memoizedState;
              if (null !== d) {
                if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
                if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
                G(L, L.current & 1);
                a = Zi(a, b, c);
                return null !== a ? a.sibling : null;
              }
              G(L, L.current & 1);
              break;
            case 19:
              d = 0 !== (c & b.childLanes);
              if (0 !== (a.flags & 128)) {
                if (d) return xj(a, b, c);
                b.flags |= 128;
              }
              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
              G(L, L.current);
              if (d) break;else return null;
            case 22:
            case 23:
              return b.lanes = 0, dj(a, b, c);
          }
          return Zi(a, b, c);
        }
        var zj, Aj, Bj, Cj;
        zj = function zj(a, b) {
          for (var c = b.child; null !== c;) {
            if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
              c.child.return = c;
              c = c.child;
              continue;
            }
            if (c === b) break;
            for (; null === c.sibling;) {
              if (null === c.return || c.return === b) return;
              c = c.return;
            }
            c.sibling.return = c.return;
            c = c.sibling;
          }
        };
        Aj = function Aj() {};
        Bj = function Bj(a, b, c, d) {
          var e = a.memoizedProps;
          if (e !== d) {
            a = b.stateNode;
            xh(uh.current);
            var f = null;
            switch (c) {
              case "input":
                e = Ya(a, e);
                d = Ya(a, d);
                f = [];
                break;
              case "select":
                e = A$1({}, e, {
                  value: void 0
                });
                d = A$1({}, d, {
                  value: void 0
                });
                f = [];
                break;
              case "textarea":
                e = gb(a, e);
                d = gb(a, d);
                f = [];
                break;
              default:
                "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
            }
            ub(c, d);
            var g;
            c = null;
            for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
              var h = e[l];
              for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
            for (l in d) {
              var k = d[l];
              h = null != e ? e[l] : void 0;
              if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
                if (h) {
                  for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                  for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                } else c || (f || (f = []), f.push(l, c)), c = k;
              } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
            }
            c && (f = f || []).push("style", c);
            var l = f;
            if (b.updateQueue = l) b.flags |= 4;
          }
        };
        Cj = function Cj(a, b, c, d) {
          c !== d && (b.flags |= 4);
        };
        function Dj(a, b) {
          if (!I) switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
              null === c ? a.tail = null : c.sibling = null;
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
              null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
          }
        }
        function S(a) {
          var b = null !== a.alternate && a.alternate.child === a.child,
            c = 0,
            d = 0;
          if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
          a.subtreeFlags |= d;
          a.childLanes = c;
          return b;
        }
        function Ej(a, b, c) {
          var d = b.pendingProps;
          wg(b);
          switch (b.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return S(b), null;
            case 1:
              return Zf(b.type) && $f(), S(b), null;
            case 3:
              d = b.stateNode;
              zh();
              E(Wf);
              E(H);
              Eh();
              d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
              if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
              Aj(a, b);
              S(b);
              return null;
            case 5:
              Bh(b);
              var e = xh(wh.current);
              c = b.type;
              if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
                if (!d) {
                  if (null === b.stateNode) throw Error(p$1(166));
                  S(b);
                  return null;
                }
                a = xh(uh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.type;
                  var f = b.memoizedProps;
                  d[Of] = b;
                  d[Pf] = f;
                  a = 0 !== (b.mode & 1);
                  switch (c) {
                    case "dialog":
                      D("cancel", d);
                      D("close", d);
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", d);
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], d);
                      break;
                    case "source":
                      D("error", d);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D("error", d);
                      D("load", d);
                      break;
                    case "details":
                      D("toggle", d);
                      break;
                    case "input":
                      Za(d, f);
                      D("invalid", d);
                      break;
                    case "select":
                      d._wrapperState = {
                        wasMultiple: !!f.multiple
                      };
                      D("invalid", d);
                      break;
                    case "textarea":
                      hb(d, f), D("invalid", d);
                  }
                  ub(c, f);
                  e = null;
                  for (var g in f) if (f.hasOwnProperty(g)) {
                    var h = f[g];
                    "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                  }
                  switch (c) {
                    case "input":
                      Va(d);
                      db(d, f, true);
                      break;
                    case "textarea":
                      Va(d);
                      jb(d);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" === typeof f.onClick && (d.onclick = Bf);
                  }
                  d = e;
                  b.updateQueue = d;
                  null !== d && (b.flags |= 4);
                } else {
                  g = 9 === e.nodeType ? e : e.ownerDocument;
                  "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                  "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
                    is: d.is
                  }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                  a[Of] = b;
                  a[Pf] = d;
                  zj(a, b, false, false);
                  b.stateNode = a;
                  a: {
                    g = vb(c, d);
                    switch (c) {
                      case "dialog":
                        D("cancel", a);
                        D("close", a);
                        e = d;
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        D("load", a);
                        e = d;
                        break;
                      case "video":
                      case "audio":
                        for (e = 0; e < lf.length; e++) D(lf[e], a);
                        e = d;
                        break;
                      case "source":
                        D("error", a);
                        e = d;
                        break;
                      case "img":
                      case "image":
                      case "link":
                        D("error", a);
                        D("load", a);
                        e = d;
                        break;
                      case "details":
                        D("toggle", a);
                        e = d;
                        break;
                      case "input":
                        Za(a, d);
                        e = Ya(a, d);
                        D("invalid", a);
                        break;
                      case "option":
                        e = d;
                        break;
                      case "select":
                        a._wrapperState = {
                          wasMultiple: !!d.multiple
                        };
                        e = A$1({}, d, {
                          value: void 0
                        });
                        D("invalid", a);
                        break;
                      case "textarea":
                        hb(a, d);
                        e = gb(a, d);
                        D("invalid", a);
                        break;
                      default:
                        e = d;
                    }
                    ub(c, e);
                    h = e;
                    for (f in h) if (h.hasOwnProperty(f)) {
                      var k = h[f];
                      "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                    }
                    switch (c) {
                      case "input":
                        Va(a);
                        db(a, d, false);
                        break;
                      case "textarea":
                        Va(a);
                        jb(a);
                        break;
                      case "option":
                        null != d.value && a.setAttribute("value", "" + Sa(d.value));
                        break;
                      case "select":
                        a.multiple = !!d.multiple;
                        f = d.value;
                        null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                        break;
                      default:
                        "function" === typeof e.onClick && (a.onclick = Bf);
                    }
                    switch (c) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        d = !!d.autoFocus;
                        break a;
                      case "img":
                        d = true;
                        break a;
                      default:
                        d = false;
                    }
                  }
                  d && (b.flags |= 4);
                }
                null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
              }
              S(b);
              return null;
            case 6:
              if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);else {
                if ("string" !== typeof d && null === b.stateNode) throw Error(p$1(166));
                c = xh(wh.current);
                xh(uh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.memoizedProps;
                  d[Of] = b;
                  if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                  f && (b.flags |= 4);
                } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
              }
              S(b);
              return null;
            case 13:
              E(L);
              d = b.memoizedState;
              if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                  if (null === a) {
                    if (!f) throw Error(p$1(318));
                    f = b.memoizedState;
                    f = null !== f ? f.dehydrated : null;
                    if (!f) throw Error(p$1(317));
                    f[Of] = b;
                  } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                  S(b);
                  f = false;
                } else null !== zg && (Fj(zg), zg = null), f = true;
                if (!f) return b.flags & 65536 ? b : null;
              }
              if (0 !== (b.flags & 128)) return b.lanes = c, b;
              d = null !== d;
              d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
              null !== b.updateQueue && (b.flags |= 4);
              S(b);
              return null;
            case 4:
              return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
            case 10:
              return ah(b.type._context), S(b), null;
            case 17:
              return Zf(b.type) && $f(), S(b), null;
            case 19:
              E(L);
              f = b.memoizedState;
              if (null === f) return S(b), null;
              d = 0 !== (b.flags & 128);
              g = f.rendering;
              if (null === g) {
                if (d) Dj(f, false);else {
                  if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
                    g = Ch(a);
                    if (null !== g) {
                      b.flags |= 128;
                      Dj(f, false);
                      d = g.updateQueue;
                      null !== d && (b.updateQueue = d, b.flags |= 4);
                      b.subtreeFlags = 0;
                      d = c;
                      for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                        lanes: a.lanes,
                        firstContext: a.firstContext
                      }), c = c.sibling;
                      G(L, L.current & 1 | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                  null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
                }
              } else {
                if (!d) if (a = Ch(g), null !== a) {
                  if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
                } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
                f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
              }
              if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
              S(b);
              return null;
            case 22:
            case 23:
              return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(p$1(156, b.tag));
        }
        function Ij(a, b) {
          wg(b);
          switch (b.tag) {
            case 1:
              return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 3:
              return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
            case 5:
              return Bh(b), null;
            case 13:
              E(L);
              a = b.memoizedState;
              if (null !== a && null !== a.dehydrated) {
                if (null === b.alternate) throw Error(p$1(340));
                Ig();
              }
              a = b.flags;
              return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 19:
              return E(L), null;
            case 4:
              return zh(), null;
            case 10:
              return ah(b.type._context), null;
            case 22:
            case 23:
              return Hj(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Jj = false,
          U = false,
          Kj = "function" === typeof WeakSet ? WeakSet : Set,
          V = null;
        function Lj(a, b) {
          var c = a.ref;
          if (null !== c) if ("function" === typeof c) try {
            c(null);
          } catch (d) {
            W(a, b, d);
          } else c.current = null;
        }
        function Mj(a, b, c) {
          try {
            c();
          } catch (d) {
            W(a, b, d);
          }
        }
        var Nj = false;
        function Oj(a, b) {
          Cf = dd;
          a = Me();
          if (Ne(a)) {
            if ("selectionStart" in a) var c = {
              start: a.selectionStart,
              end: a.selectionEnd
            };else a: {
              c = (c = a.ownerDocument) && c.defaultView || window;
              var d = c.getSelection && c.getSelection();
              if (d && 0 !== d.rangeCount) {
                c = d.anchorNode;
                var e = d.anchorOffset,
                  f = d.focusNode;
                d = d.focusOffset;
                try {
                  c.nodeType, f.nodeType;
                } catch (F) {
                  c = null;
                  break a;
                }
                var g = 0,
                  h = -1,
                  k = -1,
                  l = 0,
                  m = 0,
                  q = a,
                  r = null;
                b: for (;;) {
                  for (var y;;) {
                    q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                    q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                    3 === q.nodeType && (g += q.nodeValue.length);
                    if (null === (y = q.firstChild)) break;
                    r = q;
                    q = y;
                  }
                  for (;;) {
                    if (q === a) break b;
                    r === c && ++l === e && (h = g);
                    r === f && ++m === d && (k = g);
                    if (null !== (y = q.nextSibling)) break;
                    q = r;
                    r = q.parentNode;
                  }
                  q = y;
                }
                c = -1 === h || -1 === k ? null : {
                  start: h,
                  end: k
                };
              } else c = null;
            }
            c = c || {
              start: 0,
              end: 0
            };
          } else c = null;
          Df = {
            focusedElem: a,
            selectionRange: c
          };
          dd = false;
          for (V = b; null !== V;) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
            b = V;
            try {
              var n = b.alternate;
              if (0 !== (b.flags & 1024)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (null !== n) {
                    var t = n.memoizedProps,
                      J = n.memoizedState,
                      x = b.stateNode,
                      w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                    x.__reactInternalSnapshotBeforeUpdate = w;
                  }
                  break;
                case 3:
                  var u = b.stateNode.containerInfo;
                  1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(p$1(163));
              }
            } catch (F) {
              W(b, b.return, F);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V = a;
              break;
            }
            V = b.return;
          }
          n = Nj;
          Nj = false;
          return n;
        }
        function Pj(a, b, c) {
          var d = b.updateQueue;
          d = null !== d ? d.lastEffect : null;
          if (null !== d) {
            var e = d = d.next;
            do {
              if ((e.tag & a) === a) {
                var f = e.destroy;
                e.destroy = void 0;
                void 0 !== f && Mj(b, c, f);
              }
              e = e.next;
            } while (e !== d);
          }
        }
        function Qj(a, b) {
          b = b.updateQueue;
          b = null !== b ? b.lastEffect : null;
          if (null !== b) {
            var c = b = b.next;
            do {
              if ((c.tag & a) === a) {
                var d = c.create;
                c.destroy = d();
              }
              c = c.next;
            } while (c !== b);
          }
        }
        function Rj(a) {
          var b = a.ref;
          if (null !== b) {
            var c = a.stateNode;
            switch (a.tag) {
              case 5:
                a = c;
                break;
              default:
                a = c;
            }
            "function" === typeof b ? b(a) : b.current = a;
          }
        }
        function Sj(a) {
          var b = a.alternate;
          null !== b && (a.alternate = null, Sj(b));
          a.child = null;
          a.deletions = null;
          a.sibling = null;
          5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
          a.stateNode = null;
          a.return = null;
          a.dependencies = null;
          a.memoizedProps = null;
          a.memoizedState = null;
          a.pendingProps = null;
          a.stateNode = null;
          a.updateQueue = null;
        }
        function Tj(a) {
          return 5 === a.tag || 3 === a.tag || 4 === a.tag;
        }
        function Uj(a) {
          a: for (;;) {
            for (; null === a.sibling;) {
              if (null === a.return || Tj(a.return)) return null;
              a = a.return;
            }
            a.sibling.return = a.return;
            for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
              if (a.flags & 2) continue a;
              if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
            }
            if (!(a.flags & 2)) return a.stateNode;
          }
        }
        function Vj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a;) Vj(a, b, c), a = a.sibling;
        }
        function Wj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
        }
        var X = null,
          Xj = false;
        function Yj(a, b, c) {
          for (c = c.child; null !== c;) Zj(a, b, c), c = c.sibling;
        }
        function Zj(a, b, c) {
          if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
            lc.onCommitFiberUnmount(kc, c);
          } catch (h) {}
          switch (c.tag) {
            case 5:
              U || Lj(c, b);
            case 6:
              var d = X,
                e = Xj;
              X = null;
              Yj(a, b, c);
              X = d;
              Xj = e;
              null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
              break;
            case 18:
              null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
              break;
            case 4:
              d = X;
              e = Xj;
              X = c.stateNode.containerInfo;
              Xj = true;
              Yj(a, b, c);
              X = d;
              Xj = e;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                e = d = d.next;
                do {
                  var f = e,
                    g = f.destroy;
                  f = f.tag;
                  void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                  e = e.next;
                } while (e !== d);
              }
              Yj(a, b, c);
              break;
            case 1:
              if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
              } catch (h) {
                W(c, b, h);
              }
              Yj(a, b, c);
              break;
            case 21:
              Yj(a, b, c);
              break;
            case 22:
              c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
              break;
            default:
              Yj(a, b, c);
          }
        }
        function ak(a) {
          var b = a.updateQueue;
          if (null !== b) {
            a.updateQueue = null;
            var c = a.stateNode;
            null === c && (c = a.stateNode = new Kj());
            b.forEach(function (b) {
              var d = bk.bind(null, a, b);
              c.has(b) || (c.add(b), b.then(d, d));
            });
          }
        }
        function ck(a, b) {
          var c = b.deletions;
          if (null !== c) for (var d = 0; d < c.length; d++) {
            var e = c[d];
            try {
              var f = a,
                g = b,
                h = g;
              a: for (; null !== h;) {
                switch (h.tag) {
                  case 5:
                    X = h.stateNode;
                    Xj = !1;
                    break a;
                  case 3:
                    X = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                  case 4:
                    X = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                }
                h = h.return;
              }
              if (null === X) throw Error(p$1(160));
              Zj(f, g, e);
              X = null;
              Xj = !1;
              var k = e.alternate;
              null !== k && (k.return = null);
              e.return = null;
            } catch (l) {
              W(e, b, l);
            }
          }
          if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) dk(b, a), b = b.sibling;
        }
        function dk(a, b) {
          var c = a.alternate,
            d = a.flags;
          switch (a.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              ck(b, a);
              ek(a);
              if (d & 4) {
                try {
                  Pj(3, a, a.return), Qj(3, a);
                } catch (t) {
                  W(a, a.return, t);
                }
                try {
                  Pj(5, a, a.return);
                } catch (t) {
                  W(a, a.return, t);
                }
              }
              break;
            case 1:
              ck(b, a);
              ek(a);
              d & 512 && null !== c && Lj(c, c.return);
              break;
            case 5:
              ck(b, a);
              ek(a);
              d & 512 && null !== c && Lj(c, c.return);
              if (a.flags & 32) {
                var e = a.stateNode;
                try {
                  ob(e, "");
                } catch (t) {
                  W(a, a.return, t);
                }
              }
              if (d & 4 && (e = a.stateNode, null != e)) {
                var f = a.memoizedProps,
                  g = null !== c ? c.memoizedProps : f,
                  h = a.type,
                  k = a.updateQueue;
                a.updateQueue = null;
                if (null !== k) try {
                  "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                  vb(h, g);
                  var l = vb(h, f);
                  for (g = 0; g < k.length; g += 2) {
                    var m = k[g],
                      q = k[g + 1];
                    "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                  }
                  switch (h) {
                    case "input":
                      bb(e, f);
                      break;
                    case "textarea":
                      ib(e, f);
                      break;
                    case "select":
                      var r = e._wrapperState.wasMultiple;
                      e._wrapperState.wasMultiple = !!f.multiple;
                      var y = f.value;
                      null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                  }
                  e[Pf] = f;
                } catch (t) {
                  W(a, a.return, t);
                }
              }
              break;
            case 6:
              ck(b, a);
              ek(a);
              if (d & 4) {
                if (null === a.stateNode) throw Error(p$1(162));
                e = a.stateNode;
                f = a.memoizedProps;
                try {
                  e.nodeValue = f;
                } catch (t) {
                  W(a, a.return, t);
                }
              }
              break;
            case 3:
              ck(b, a);
              ek(a);
              if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
                bd(b.containerInfo);
              } catch (t) {
                W(a, a.return, t);
              }
              break;
            case 4:
              ck(b, a);
              ek(a);
              break;
            case 13:
              ck(b, a);
              ek(a);
              e = a.child;
              e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
              d & 4 && ak(a);
              break;
            case 22:
              m = null !== c && null !== c.memoizedState;
              a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
              ek(a);
              if (d & 8192) {
                l = null !== a.memoizedState;
                if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
                  for (q = V = m; null !== V;) {
                    r = V;
                    y = r.child;
                    switch (r.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Pj(4, r, r.return);
                        break;
                      case 1:
                        Lj(r, r.return);
                        var n = r.stateNode;
                        if ("function" === typeof n.componentWillUnmount) {
                          d = r;
                          c = r.return;
                          try {
                            b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                          } catch (t) {
                            W(d, c, t);
                          }
                        }
                        break;
                      case 5:
                        Lj(r, r.return);
                        break;
                      case 22:
                        if (null !== r.memoizedState) {
                          gk(q);
                          continue;
                        }
                    }
                    null !== y ? (y.return = r, V = y) : gk(q);
                  }
                  m = m.sibling;
                }
                a: for (m = null, q = a;;) {
                  if (5 === q.tag) {
                    if (null === m) {
                      m = q;
                      try {
                        e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                      } catch (t) {
                        W(a, a.return, t);
                      }
                    }
                  } else if (6 === q.tag) {
                    if (null === m) try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                    q.child.return = q;
                    q = q.child;
                    continue;
                  }
                  if (q === a) break a;
                  for (; null === q.sibling;) {
                    if (null === q.return || q.return === a) break a;
                    m === q && (m = null);
                    q = q.return;
                  }
                  m === q && (m = null);
                  q.sibling.return = q.return;
                  q = q.sibling;
                }
              }
              break;
            case 19:
              ck(b, a);
              ek(a);
              d & 4 && ak(a);
              break;
            case 21:
              break;
            default:
              ck(b, a), ek(a);
          }
        }
        function ek(a) {
          var b = a.flags;
          if (b & 2) {
            try {
              a: {
                for (var c = a.return; null !== c;) {
                  if (Tj(c)) {
                    var d = c;
                    break a;
                  }
                  c = c.return;
                }
                throw Error(p$1(160));
              }
              switch (d.tag) {
                case 5:
                  var e = d.stateNode;
                  d.flags & 32 && (ob(e, ""), d.flags &= -33);
                  var f = Uj(a);
                  Wj(a, f, e);
                  break;
                case 3:
                case 4:
                  var g = d.stateNode.containerInfo,
                    h = Uj(a);
                  Vj(a, h, g);
                  break;
                default:
                  throw Error(p$1(161));
              }
            } catch (k) {
              W(a, a.return, k);
            }
            a.flags &= -3;
          }
          b & 4096 && (a.flags &= -4097);
        }
        function hk(a, b, c) {
          V = a;
          ik(a);
        }
        function ik(a, b, c) {
          for (var d = 0 !== (a.mode & 1); null !== V;) {
            var e = V,
              f = e.child;
            if (22 === e.tag && d) {
              var g = null !== e.memoizedState || Jj;
              if (!g) {
                var h = e.alternate,
                  k = null !== h && null !== h.memoizedState || U;
                h = Jj;
                var l = U;
                Jj = g;
                if ((U = k) && !l) for (V = e; null !== V;) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
                for (; null !== f;) V = f, ik(f), f = f.sibling;
                V = e;
                Jj = h;
                U = l;
              }
              kk(a);
            } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
          }
        }
        function kk(a) {
          for (; null !== V;) {
            var b = V;
            if (0 !== (b.flags & 8772)) {
              var c = b.alternate;
              try {
                if (0 !== (b.flags & 8772)) switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U || Qj(5, b);
                    break;
                  case 1:
                    var d = b.stateNode;
                    if (b.flags & 4 && !U) if (null === c) d.componentDidMount();else {
                      var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                    var f = b.updateQueue;
                    null !== f && sh(b, f, d);
                    break;
                  case 3:
                    var g = b.updateQueue;
                    if (null !== g) {
                      c = null;
                      if (null !== b.child) switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                      sh(b, g, c);
                    }
                    break;
                  case 5:
                    var h = b.stateNode;
                    if (null === c && b.flags & 4) {
                      c = h;
                      var k = b.memoizedProps;
                      switch (b.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k.autoFocus && c.focus();
                          break;
                        case "img":
                          k.src && (c.src = k.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (null === b.memoizedState) {
                      var l = b.alternate;
                      if (null !== l) {
                        var m = l.memoizedState;
                        if (null !== m) {
                          var q = m.dehydrated;
                          null !== q && bd(q);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p$1(163));
                }
                U || b.flags & 512 && Rj(b);
              } catch (r) {
                W(b, b.return, r);
              }
            }
            if (b === a) {
              V = null;
              break;
            }
            c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V = c;
              break;
            }
            V = b.return;
          }
        }
        function gk(a) {
          for (; null !== V;) {
            var b = V;
            if (b === a) {
              V = null;
              break;
            }
            var c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V = c;
              break;
            }
            V = b.return;
          }
        }
        function jk(a) {
          for (; null !== V;) {
            var b = V;
            try {
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  var c = b.return;
                  try {
                    Qj(4, b);
                  } catch (k) {
                    W(b, c, k);
                  }
                  break;
                case 1:
                  var d = b.stateNode;
                  if ("function" === typeof d.componentDidMount) {
                    var e = b.return;
                    try {
                      d.componentDidMount();
                    } catch (k) {
                      W(b, e, k);
                    }
                  }
                  var f = b.return;
                  try {
                    Rj(b);
                  } catch (k) {
                    W(b, f, k);
                  }
                  break;
                case 5:
                  var g = b.return;
                  try {
                    Rj(b);
                  } catch (k) {
                    W(b, g, k);
                  }
              }
            } catch (k) {
              W(b, b.return, k);
            }
            if (b === a) {
              V = null;
              break;
            }
            var h = b.sibling;
            if (null !== h) {
              h.return = b.return;
              V = h;
              break;
            }
            V = b.return;
          }
        }
        var lk = Math.ceil,
          mk = ua.ReactCurrentDispatcher,
          nk = ua.ReactCurrentOwner,
          ok = ua.ReactCurrentBatchConfig,
          K = 0,
          Q = null,
          Y = null,
          Z = 0,
          fj = 0,
          ej = Uf(0),
          T = 0,
          pk = null,
          rh = 0,
          qk = 0,
          rk = 0,
          sk = null,
          tk = null,
          fk = 0,
          Gj = Infinity,
          uk = null,
          Oi = false,
          Pi = null,
          Ri = null,
          vk = false,
          wk = null,
          xk = 0,
          yk = 0,
          zk = null,
          Ak = -1,
          Bk = 0;
        function R() {
          return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
        }
        function yi(a) {
          if (0 === (a.mode & 1)) return 1;
          if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
          if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
          a = C;
          if (0 !== a) return a;
          a = window.event;
          a = void 0 === a ? 16 : jd(a.type);
          return a;
        }
        function gi(a, b, c, d) {
          if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
          Ac(a, c, d);
          if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
        }
        function Dk(a, b) {
          var c = a.callbackNode;
          wc(a, b);
          var d = uc(a, a === Q ? Z : 0);
          if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
            null != c && bc(c);
            if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function () {
              0 === (K & 6) && jg();
            }), c = null;else {
              switch (Dc(d)) {
                case 1:
                  c = fc;
                  break;
                case 4:
                  c = gc;
                  break;
                case 16:
                  c = hc;
                  break;
                case 536870912:
                  c = jc;
                  break;
                default:
                  c = hc;
              }
              c = Fk(c, Gk.bind(null, a));
            }
            a.callbackPriority = b;
            a.callbackNode = c;
          }
        }
        function Gk(a, b) {
          Ak = -1;
          Bk = 0;
          if (0 !== (K & 6)) throw Error(p$1(327));
          var c = a.callbackNode;
          if (Hk() && a.callbackNode !== c) return null;
          var d = uc(a, a === Q ? Z : 0);
          if (0 === d) return null;
          if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);else {
            b = d;
            var e = K;
            K |= 2;
            var f = Jk();
            if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
            do try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            } while (1);
            $g();
            mk.current = f;
            K = e;
            null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
          }
          if (0 !== b) {
            2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
            if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            if (6 === b) Ck(a, d);else {
              e = a.current.alternate;
              if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
              a.finishedWork = e;
              a.finishedLanes = d;
              switch (b) {
                case 0:
                case 1:
                  throw Error(p$1(345));
                case 2:
                  Pk(a, tk, uk);
                  break;
                case 3:
                  Ck(a, d);
                  if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                    if (0 !== uc(a, 0)) break;
                    e = a.suspendedLanes;
                    if ((e & d) !== d) {
                      R();
                      a.pingedLanes |= a.suspendedLanes & e;
                      break;
                    }
                    a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                    break;
                  }
                  Pk(a, tk, uk);
                  break;
                case 4:
                  Ck(a, d);
                  if ((d & 4194240) === d) break;
                  b = a.eventTimes;
                  for (e = -1; 0 < d;) {
                    var g = 31 - oc(d);
                    f = 1 << g;
                    g = b[g];
                    g > e && (e = g);
                    d &= ~f;
                  }
                  d = e;
                  d = B() - d;
                  d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                  if (10 < d) {
                    a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                    break;
                  }
                  Pk(a, tk, uk);
                  break;
                case 5:
                  Pk(a, tk, uk);
                  break;
                default:
                  throw Error(p$1(329));
              }
            }
          }
          Dk(a, B());
          return a.callbackNode === c ? Gk.bind(null, a) : null;
        }
        function Nk(a, b) {
          var c = sk;
          a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
          a = Ik(a, b);
          2 !== a && (b = tk, tk = c, null !== b && Fj(b));
          return a;
        }
        function Fj(a) {
          null === tk ? tk = a : tk.push.apply(tk, a);
        }
        function Ok(a) {
          for (var b = a;;) {
            if (b.flags & 16384) {
              var c = b.updateQueue;
              if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
                var e = c[d],
                  f = e.getSnapshot;
                e = e.value;
                try {
                  if (!He(f(), e)) return !1;
                } catch (g) {
                  return false;
                }
              }
            }
            c = b.child;
            if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
              if (b === a) break;
              for (; null === b.sibling;) {
                if (null === b.return || b.return === a) return true;
                b = b.return;
              }
              b.sibling.return = b.return;
              b = b.sibling;
            }
          }
          return true;
        }
        function Ck(a, b) {
          b &= ~rk;
          b &= ~qk;
          a.suspendedLanes |= b;
          a.pingedLanes &= ~b;
          for (a = a.expirationTimes; 0 < b;) {
            var c = 31 - oc(b),
              d = 1 << c;
            a[c] = -1;
            b &= ~d;
          }
        }
        function Ek(a) {
          if (0 !== (K & 6)) throw Error(p$1(327));
          Hk();
          var b = uc(a, 0);
          if (0 === (b & 1)) return Dk(a, B()), null;
          var c = Ik(a, b);
          if (0 !== a.tag && 2 === c) {
            var d = xc(a);
            0 !== d && (b = d, c = Nk(a, d));
          }
          if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
          if (6 === c) throw Error(p$1(345));
          a.finishedWork = a.current.alternate;
          a.finishedLanes = b;
          Pk(a, tk, uk);
          Dk(a, B());
          return null;
        }
        function Qk(a, b) {
          var c = K;
          K |= 1;
          try {
            return a(b);
          } finally {
            K = c, 0 === K && (Gj = B() + 500, fg && jg());
          }
        }
        function Rk(a) {
          null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
          var b = K;
          K |= 1;
          var c = ok.transition,
            d = C;
          try {
            if (ok.transition = null, C = 1, a) return a();
          } finally {
            C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
          }
        }
        function Hj() {
          fj = ej.current;
          E(ej);
        }
        function Kk(a, b) {
          a.finishedWork = null;
          a.finishedLanes = 0;
          var c = a.timeoutHandle;
          -1 !== c && (a.timeoutHandle = -1, Gf(c));
          if (null !== Y) for (c = Y.return; null !== c;) {
            var d = c;
            wg(d);
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && $f();
                break;
              case 3:
                zh();
                E(Wf);
                E(H);
                Eh();
                break;
              case 5:
                Bh(d);
                break;
              case 4:
                zh();
                break;
              case 13:
                E(L);
                break;
              case 19:
                E(L);
                break;
              case 10:
                ah(d.type._context);
                break;
              case 22:
              case 23:
                Hj();
            }
            c = c.return;
          }
          Q = a;
          Y = a = Pg(a.current, null);
          Z = fj = b;
          T = 0;
          pk = null;
          rk = qk = rh = 0;
          tk = sk = null;
          if (null !== fh) {
            for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
              c.interleaved = null;
              var e = d.next,
                f = c.pending;
              if (null !== f) {
                var g = f.next;
                f.next = e;
                d.next = g;
              }
              c.pending = d;
            }
            fh = null;
          }
          return a;
        }
        function Mk(a, b) {
          do {
            var c = Y;
            try {
              $g();
              Fh.current = Rh;
              if (Ih) {
                for (var d = M.memoizedState; null !== d;) {
                  var e = d.queue;
                  null !== e && (e.pending = null);
                  d = d.next;
                }
                Ih = !1;
              }
              Hh = 0;
              O = N = M = null;
              Jh = !1;
              Kh = 0;
              nk.current = null;
              if (null === c || null === c.return) {
                T = 1;
                pk = b;
                Y = null;
                break;
              }
              a: {
                var f = a,
                  g = c.return,
                  h = c,
                  k = b;
                b = Z;
                h.flags |= 32768;
                if (null !== k && "object" === _typeof2(k) && "function" === typeof k.then) {
                  var l = k,
                    m = h,
                    q = m.tag;
                  if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                    var r = m.alternate;
                    r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                  }
                  var y = Ui(g);
                  if (null !== y) {
                    y.flags &= -257;
                    Vi(y, g, h, f, b);
                    y.mode & 1 && Si(f, l, b);
                    b = y;
                    k = l;
                    var n = b.updateQueue;
                    if (null === n) {
                      var t = new Set();
                      t.add(k);
                      b.updateQueue = t;
                    } else n.add(k);
                    break a;
                  } else {
                    if (0 === (b & 1)) {
                      Si(f, l, b);
                      tj();
                      break a;
                    }
                    k = Error(p$1(426));
                  }
                } else if (I && h.mode & 1) {
                  var J = Ui(g);
                  if (null !== J) {
                    0 === (J.flags & 65536) && (J.flags |= 256);
                    Vi(J, g, h, f, b);
                    Jg(Ji(k, h));
                    break a;
                  }
                }
                f = k = Ji(k, h);
                4 !== T && (T = 2);
                null === sk ? sk = [f] : sk.push(f);
                f = g;
                do {
                  switch (f.tag) {
                    case 3:
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var x = Ni(f, k, b);
                      ph(f, x);
                      break a;
                    case 1:
                      h = k;
                      var w = f.type,
                        u = f.stateNode;
                      if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                        f.flags |= 65536;
                        b &= -b;
                        f.lanes |= b;
                        var F = Qi(f, h, b);
                        ph(f, F);
                        break a;
                      }
                  }
                  f = f.return;
                } while (null !== f);
              }
              Sk(c);
            } catch (na) {
              b = na;
              Y === c && null !== c && (Y = c = c.return);
              continue;
            }
            break;
          } while (1);
        }
        function Jk() {
          var a = mk.current;
          mk.current = Rh;
          return null === a ? Rh : a;
        }
        function tj() {
          if (0 === T || 3 === T || 2 === T) T = 4;
          null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
        }
        function Ik(a, b) {
          var c = K;
          K |= 2;
          var d = Jk();
          if (Q !== a || Z !== b) uk = null, Kk(a, b);
          do try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          } while (1);
          $g();
          K = c;
          mk.current = d;
          if (null !== Y) throw Error(p$1(261));
          Q = null;
          Z = 0;
          return T;
        }
        function Tk() {
          for (; null !== Y;) Uk(Y);
        }
        function Lk() {
          for (; null !== Y && !cc();) Uk(Y);
        }
        function Uk(a) {
          var b = Vk(a.alternate, a, fj);
          a.memoizedProps = a.pendingProps;
          null === b ? Sk(a) : Y = b;
          nk.current = null;
        }
        function Sk(a) {
          var b = a;
          do {
            var c = b.alternate;
            a = b.return;
            if (0 === (b.flags & 32768)) {
              if (c = Ej(c, b, fj), null !== c) {
                Y = c;
                return;
              }
            } else {
              c = Ij(c, b);
              if (null !== c) {
                c.flags &= 32767;
                Y = c;
                return;
              }
              if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
                T = 6;
                Y = null;
                return;
              }
            }
            b = b.sibling;
            if (null !== b) {
              Y = b;
              return;
            }
            Y = b = a;
          } while (null !== b);
          0 === T && (T = 5);
        }
        function Pk(a, b, c) {
          var d = C,
            e = ok.transition;
          try {
            ok.transition = null, C = 1, Wk(a, b, c, d);
          } finally {
            ok.transition = e, C = d;
          }
          return null;
        }
        function Wk(a, b, c, d) {
          do Hk(); while (null !== wk);
          if (0 !== (K & 6)) throw Error(p$1(327));
          c = a.finishedWork;
          var e = a.finishedLanes;
          if (null === c) return null;
          a.finishedWork = null;
          a.finishedLanes = 0;
          if (c === a.current) throw Error(p$1(177));
          a.callbackNode = null;
          a.callbackPriority = 0;
          var f = c.lanes | c.childLanes;
          Bc(a, f);
          a === Q && (Y = Q = null, Z = 0);
          0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function () {
            Hk();
            return null;
          }));
          f = 0 !== (c.flags & 15990);
          if (0 !== (c.subtreeFlags & 15990) || f) {
            f = ok.transition;
            ok.transition = null;
            var g = C;
            C = 1;
            var h = K;
            K |= 4;
            nk.current = null;
            Oj(a, c);
            dk(c, a);
            Oe(Df);
            dd = !!Cf;
            Df = Cf = null;
            a.current = c;
            hk(c);
            dc();
            K = h;
            C = g;
            ok.transition = f;
          } else a.current = c;
          vk && (vk = false, wk = a, xk = e);
          f = a.pendingLanes;
          0 === f && (Ri = null);
          mc(c.stateNode);
          Dk(a, B());
          if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
            componentStack: e.stack,
            digest: e.digest
          });
          if (Oi) throw Oi = false, a = Pi, Pi = null, a;
          0 !== (xk & 1) && 0 !== a.tag && Hk();
          f = a.pendingLanes;
          0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
          jg();
          return null;
        }
        function Hk() {
          if (null !== wk) {
            var a = Dc(xk),
              b = ok.transition,
              c = C;
            try {
              ok.transition = null;
              C = 16 > a ? 16 : a;
              if (null === wk) var d = !1;else {
                a = wk;
                wk = null;
                xk = 0;
                if (0 !== (K & 6)) throw Error(p$1(331));
                var e = K;
                K |= 4;
                for (V = a.current; null !== V;) {
                  var f = V,
                    g = f.child;
                  if (0 !== (V.flags & 16)) {
                    var h = f.deletions;
                    if (null !== h) {
                      for (var k = 0; k < h.length; k++) {
                        var l = h[k];
                        for (V = l; null !== V;) {
                          var m = V;
                          switch (m.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Pj(8, m, f);
                          }
                          var q = m.child;
                          if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                            m = V;
                            var r = m.sibling,
                              y = m.return;
                            Sj(m);
                            if (m === l) {
                              V = null;
                              break;
                            }
                            if (null !== r) {
                              r.return = y;
                              V = r;
                              break;
                            }
                            V = y;
                          }
                        }
                      }
                      var n = f.alternate;
                      if (null !== n) {
                        var t = n.child;
                        if (null !== t) {
                          n.child = null;
                          do {
                            var J = t.sibling;
                            t.sibling = null;
                            t = J;
                          } while (null !== t);
                        }
                      }
                      V = f;
                    }
                  }
                  if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
                    f = V;
                    if (0 !== (f.flags & 2048)) switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(9, f, f.return);
                    }
                    var x = f.sibling;
                    if (null !== x) {
                      x.return = f.return;
                      V = x;
                      break b;
                    }
                    V = f.return;
                  }
                }
                var w = a.current;
                for (V = w; null !== V;) {
                  g = V;
                  var u = g.child;
                  if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
                    h = V;
                    if (0 !== (h.flags & 2048)) try {
                      switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, h);
                      }
                    } catch (na) {
                      W(h, h.return, na);
                    }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (null !== F) {
                      F.return = h.return;
                      V = F;
                      break b;
                    }
                    V = h.return;
                  }
                }
                K = e;
                jg();
                if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                  lc.onPostCommitFiberRoot(kc, a);
                } catch (na) {}
                d = !0;
              }
              return d;
            } finally {
              C = c, ok.transition = b;
            }
          }
          return false;
        }
        function Xk(a, b, c) {
          b = Ji(c, b);
          b = Ni(a, b, 1);
          a = nh(a, b, 1);
          b = R();
          null !== a && (Ac(a, 1, b), Dk(a, b));
        }
        function W(a, b, c) {
          if (3 === a.tag) Xk(a, a, c);else for (; null !== b;) {
            if (3 === b.tag) {
              Xk(b, a, c);
              break;
            } else if (1 === b.tag) {
              var d = b.stateNode;
              if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
                a = Ji(c, a);
                a = Qi(b, a, 1);
                b = nh(b, a, 1);
                a = R();
                null !== b && (Ac(b, 1, a), Dk(b, a));
                break;
              }
            }
            b = b.return;
          }
        }
        function Ti(a, b, c) {
          var d = a.pingCache;
          null !== d && d.delete(b);
          b = R();
          a.pingedLanes |= a.suspendedLanes & c;
          Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
          Dk(a, b);
        }
        function Yk(a, b) {
          0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
          var c = R();
          a = ih(a, b);
          null !== a && (Ac(a, b, c), Dk(a, c));
        }
        function uj(a) {
          var b = a.memoizedState,
            c = 0;
          null !== b && (c = b.retryLane);
          Yk(a, c);
        }
        function bk(a, b) {
          var c = 0;
          switch (a.tag) {
            case 13:
              var d = a.stateNode;
              var e = a.memoizedState;
              null !== e && (c = e.retryLane);
              break;
            case 19:
              d = a.stateNode;
              break;
            default:
              throw Error(p$1(314));
          }
          null !== d && d.delete(b);
          Yk(a, c);
        }
        var Vk;
        Vk = function Vk(a, b, c) {
          if (null !== a) {
            if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;else {
              if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
              dh = 0 !== (a.flags & 131072) ? true : false;
            }
          } else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
          b.lanes = 0;
          switch (b.tag) {
            case 2:
              var d = b.type;
              ij(a, b);
              a = b.pendingProps;
              var e = Yf(b, H.current);
              ch(b, c);
              e = Nh(null, b, d, a, e, c);
              var f = Sh();
              b.flags |= 1;
              "object" === _typeof2(e) && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
              return b;
            case 16:
              d = b.elementType;
              a: {
                ij(a, b);
                a = b.pendingProps;
                e = d._init;
                d = e(d._payload);
                b.type = d;
                e = b.tag = Zk(d);
                a = Ci(d, a);
                switch (e) {
                  case 0:
                    b = cj(null, b, d, a, c);
                    break a;
                  case 1:
                    b = hj(null, b, d, a, c);
                    break a;
                  case 11:
                    b = Yi(null, b, d, a, c);
                    break a;
                  case 14:
                    b = $i(null, b, d, Ci(d.type, a), c);
                    break a;
                }
                throw Error(p$1(306, d, ""));
              }
              return b;
            case 0:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
            case 1:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
            case 3:
              a: {
                kj(b);
                if (null === a) throw Error(p$1(387));
                d = b.pendingProps;
                f = b.memoizedState;
                e = f.element;
                lh(a, b);
                qh(b, d, null, c);
                var g = b.memoizedState;
                d = g.element;
                if (f.isDehydrated) {
                  if (f = {
                    element: d,
                    isDehydrated: false,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions
                  }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                    e = Ji(Error(p$1(423)), b);
                    b = lj(a, b, d, c, e);
                    break a;
                  } else if (d !== e) {
                    e = Ji(Error(p$1(424)), b);
                    b = lj(a, b, d, c, e);
                    break a;
                  } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
                } else {
                  Ig();
                  if (d === e) {
                    b = Zi(a, b, c);
                    break a;
                  }
                  Xi(a, b, d, c);
                }
                b = b.child;
              }
              return b;
            case 5:
              return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
            case 6:
              return null === a && Eg(b), null;
            case 13:
              return oj(a, b, c);
            case 4:
              return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
            case 11:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
            case 7:
              return Xi(a, b, b.pendingProps, c), b.child;
            case 8:
              return Xi(a, b, b.pendingProps.children, c), b.child;
            case 12:
              return Xi(a, b, b.pendingProps.children, c), b.child;
            case 10:
              a: {
                d = b.type._context;
                e = b.pendingProps;
                f = b.memoizedProps;
                g = e.value;
                G(Wg, d._currentValue);
                d._currentValue = g;
                if (null !== f) if (He(f.value, g)) {
                  if (f.children === e.children && !Wf.current) {
                    b = Zi(a, b, c);
                    break a;
                  }
                } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
                  var h = f.dependencies;
                  if (null !== h) {
                    g = f.child;
                    for (var k = h.firstContext; null !== k;) {
                      if (k.context === d) {
                        if (1 === f.tag) {
                          k = mh(-1, c & -c);
                          k.tag = 2;
                          var l = f.updateQueue;
                          if (null !== l) {
                            l = l.shared;
                            var m = l.pending;
                            null === m ? k.next = k : (k.next = m.next, m.next = k);
                            l.pending = k;
                          }
                        }
                        f.lanes |= c;
                        k = f.alternate;
                        null !== k && (k.lanes |= c);
                        bh(f.return, c, b);
                        h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
                    g = f.return;
                    if (null === g) throw Error(p$1(341));
                    g.lanes |= c;
                    h = g.alternate;
                    null !== h && (h.lanes |= c);
                    bh(g, c, b);
                    g = f.sibling;
                  } else g = f.child;
                  if (null !== g) g.return = f;else for (g = f; null !== g;) {
                    if (g === b) {
                      g = null;
                      break;
                    }
                    f = g.sibling;
                    if (null !== f) {
                      f.return = g.return;
                      g = f;
                      break;
                    }
                    g = g.return;
                  }
                  f = g;
                }
                Xi(a, b, e.children, c);
                b = b.child;
              }
              return b;
            case 9:
              return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
            case 14:
              return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
            case 15:
              return bj(a, b, b.type, b.pendingProps, c);
            case 17:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
            case 19:
              return xj(a, b, c);
            case 22:
              return dj(a, b, c);
          }
          throw Error(p$1(156, b.tag));
        };
        function Fk(a, b) {
          return ac(a, b);
        }
        function $k(a, b, c, d) {
          this.tag = a;
          this.key = c;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = b;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = d;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
        }
        function Bg(a, b, c, d) {
          return new $k(a, b, c, d);
        }
        function aj(a) {
          a = a.prototype;
          return !(!a || !a.isReactComponent);
        }
        function Zk(a) {
          if ("function" === typeof a) return aj(a) ? 1 : 0;
          if (void 0 !== a && null !== a) {
            a = a.$$typeof;
            if (a === Da) return 11;
            if (a === Ga) return 14;
          }
          return 2;
        }
        function Pg(a, b) {
          var c = a.alternate;
          null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
          c.flags = a.flags & 14680064;
          c.childLanes = a.childLanes;
          c.lanes = a.lanes;
          c.child = a.child;
          c.memoizedProps = a.memoizedProps;
          c.memoizedState = a.memoizedState;
          c.updateQueue = a.updateQueue;
          b = a.dependencies;
          c.dependencies = null === b ? null : {
            lanes: b.lanes,
            firstContext: b.firstContext
          };
          c.sibling = a.sibling;
          c.index = a.index;
          c.ref = a.ref;
          return c;
        }
        function Rg(a, b, c, d, e, f) {
          var g = 2;
          d = a;
          if ("function" === typeof a) aj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              g = 8;
              e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
            case Ia:
              return pj(c, e, f, b);
            default:
              if ("object" === _typeof2(a) && null !== a) switch (a.$$typeof) {
                case Ba:
                  g = 10;
                  break a;
                case Ca:
                  g = 9;
                  break a;
                case Da:
                  g = 11;
                  break a;
                case Ga:
                  g = 14;
                  break a;
                case Ha:
                  g = 16;
                  d = null;
                  break a;
              }
              throw Error(p$1(130, null == a ? a : _typeof2(a), ""));
          }
          b = Bg(g, c, b, e);
          b.elementType = a;
          b.type = d;
          b.lanes = f;
          return b;
        }
        function Tg(a, b, c, d) {
          a = Bg(7, a, d, b);
          a.lanes = c;
          return a;
        }
        function pj(a, b, c, d) {
          a = Bg(22, a, d, b);
          a.elementType = Ia;
          a.lanes = c;
          a.stateNode = {
            isHidden: false
          };
          return a;
        }
        function Qg(a, b, c) {
          a = Bg(6, a, null, b);
          a.lanes = c;
          return a;
        }
        function Sg(a, b, c) {
          b = Bg(4, null !== a.children ? a.children : [], a.key, b);
          b.lanes = c;
          b.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation
          };
          return b;
        }
        function al(a, b, c, d, e) {
          this.tag = b;
          this.containerInfo = a;
          this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = -1;
          this.callbackNode = this.pendingContext = this.context = null;
          this.callbackPriority = 0;
          this.eventTimes = zc(0);
          this.expirationTimes = zc(-1);
          this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = zc(0);
          this.identifierPrefix = d;
          this.onRecoverableError = e;
          this.mutableSourceEagerHydrationData = null;
        }
        function bl(a, b, c, d, e, f, g, h, k) {
          a = new al(a, b, c, h, k);
          1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
          f = Bg(3, null, null, b);
          a.current = f;
          f.stateNode = a;
          f.memoizedState = {
            element: d,
            isDehydrated: c,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          kh(f);
          return a;
        }
        function cl(a, b, c) {
          var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          return {
            $$typeof: wa,
            key: null == d ? null : "" + d,
            children: a,
            containerInfo: b,
            implementation: c
          };
        }
        function dl(a) {
          if (!a) return Vf;
          a = a._reactInternals;
          a: {
            if (Vb(a) !== a || 1 !== a.tag) throw Error(p$1(170));
            var b = a;
            do {
              switch (b.tag) {
                case 3:
                  b = b.stateNode.context;
                  break a;
                case 1:
                  if (Zf(b.type)) {
                    b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                    break a;
                  }
              }
              b = b.return;
            } while (null !== b);
            throw Error(p$1(171));
          }
          if (1 === a.tag) {
            var c = a.type;
            if (Zf(c)) return bg(a, c, b);
          }
          return b;
        }
        function el(a, b, c, d, e, f, g, h, k) {
          a = bl(c, d, true, a, e, f, g, h, k);
          a.context = dl(null);
          c = a.current;
          d = R();
          e = yi(c);
          f = mh(d, e);
          f.callback = void 0 !== b && null !== b ? b : null;
          nh(c, f, e);
          a.current.lanes = e;
          Ac(a, e, d);
          Dk(a, d);
          return a;
        }
        function fl(a, b, c, d) {
          var e = b.current,
            f = R(),
            g = yi(e);
          c = dl(c);
          null === b.context ? b.context = c : b.pendingContext = c;
          b = mh(f, g);
          b.payload = {
            element: a
          };
          d = void 0 === d ? null : d;
          null !== d && (b.callback = d);
          a = nh(e, b, g);
          null !== a && (gi(a, e, g, f), oh(a, e, g));
          return g;
        }
        function gl(a) {
          a = a.current;
          if (!a.child) return null;
          switch (a.child.tag) {
            case 5:
              return a.child.stateNode;
            default:
              return a.child.stateNode;
          }
        }
        function hl(a, b) {
          a = a.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            var c = a.retryLane;
            a.retryLane = 0 !== c && c < b ? c : b;
          }
        }
        function il(a, b) {
          hl(a, b);
          (a = a.alternate) && hl(a, b);
        }
        function jl() {
          return null;
        }
        var kl = "function" === typeof reportError ? reportError : function (a) {
          console.error(a);
        };
        function ll(a) {
          this._internalRoot = a;
        }
        ml.prototype.render = ll.prototype.render = function (a) {
          var b = this._internalRoot;
          if (null === b) throw Error(p$1(409));
          fl(a, b, null, null);
        };
        ml.prototype.unmount = ll.prototype.unmount = function () {
          var a = this._internalRoot;
          if (null !== a) {
            this._internalRoot = null;
            var b = a.containerInfo;
            Rk(function () {
              fl(null, a, null, null);
            });
            b[uf] = null;
          }
        };
        function ml(a) {
          this._internalRoot = a;
        }
        ml.prototype.unstable_scheduleHydration = function (a) {
          if (a) {
            var b = Hc();
            a = {
              blockedOn: null,
              target: a,
              priority: b
            };
            for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
            Qc.splice(c, 0, a);
            0 === c && Vc(a);
          }
        };
        function nl(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
        }
        function ol(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
        }
        function pl() {}
        function ql(a, b, c, d, e) {
          if (e) {
            if ("function" === typeof d) {
              var f = d;
              d = function d() {
                var a = gl(g);
                f.call(a);
              };
            }
            var g = el(b, d, a, 0, null, false, false, "", pl);
            a._reactRootContainer = g;
            a[uf] = g.current;
            sf(8 === a.nodeType ? a.parentNode : a);
            Rk();
            return g;
          }
          for (; e = a.lastChild;) a.removeChild(e);
          if ("function" === typeof d) {
            var h = d;
            d = function d() {
              var a = gl(k);
              h.call(a);
            };
          }
          var k = bl(a, 0, false, null, null, false, false, "", pl);
          a._reactRootContainer = k;
          a[uf] = k.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk(function () {
            fl(b, k, c, d);
          });
          return k;
        }
        function rl(a, b, c, d, e) {
          var f = c._reactRootContainer;
          if (f) {
            var g = f;
            if ("function" === typeof e) {
              var h = e;
              e = function e() {
                var a = gl(g);
                h.call(a);
              };
            }
            fl(b, g, a, e);
          } else g = ql(c, b, a, e, d);
          return gl(g);
        }
        Ec = function Ec(a) {
          switch (a.tag) {
            case 3:
              var b = a.stateNode;
              if (b.current.memoizedState.isDehydrated) {
                var c = tc(b.pendingLanes);
                0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
              }
              break;
            case 13:
              Rk(function () {
                var b = ih(a, 1);
                if (null !== b) {
                  var c = R();
                  gi(b, a, 1, c);
                }
              }), il(a, 1);
          }
        };
        Fc = function Fc(a) {
          if (13 === a.tag) {
            var b = ih(a, 134217728);
            if (null !== b) {
              var c = R();
              gi(b, a, 134217728, c);
            }
            il(a, 134217728);
          }
        };
        Gc = function Gc(a) {
          if (13 === a.tag) {
            var b = yi(a),
              c = ih(a, b);
            if (null !== c) {
              var d = R();
              gi(c, a, b, d);
            }
            il(a, b);
          }
        };
        Hc = function Hc() {
          return C;
        };
        Ic = function Ic(a, b) {
          var c = C;
          try {
            return C = a, b();
          } finally {
            C = c;
          }
        };
        yb = function yb(a, b, c) {
          switch (b) {
            case "input":
              bb(a, c);
              b = c.name;
              if ("radio" === c.type && null != b) {
                for (c = a; c.parentNode;) c = c.parentNode;
                c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                for (b = 0; b < c.length; b++) {
                  var d = c[b];
                  if (d !== a && d.form === a.form) {
                    var e = Db(d);
                    if (!e) throw Error(p$1(90));
                    Wa(d);
                    bb(d, e);
                  }
                }
              }
              break;
            case "textarea":
              ib(a, c);
              break;
            case "select":
              b = c.value, null != b && fb(a, !!c.multiple, b, false);
          }
        };
        Gb = Qk;
        Hb = Rk;
        var sl = {
            usingClientEntryPoint: false,
            Events: [Cb, ue, Db, Eb, Fb, Qk]
          },
          tl = {
            findFiberByHostInstance: Wc,
            bundleType: 0,
            version: "18.3.1",
            rendererPackageName: "react-dom"
          };
        var ul = {
          bundleType: tl.bundleType,
          version: tl.version,
          rendererPackageName: tl.rendererPackageName,
          rendererConfig: tl.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: ua.ReactCurrentDispatcher,
          findHostInstanceByFiber: function findHostInstanceByFiber(a) {
            a = Zb(a);
            return null === a ? null : a.stateNode;
          },
          findFiberByHostInstance: tl.findFiberByHostInstance || jl,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
        };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!vl.isDisabled && vl.supportsFiber) try {
            kc = vl.inject(ul), lc = vl;
          } catch (a) {}
        }
        reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
        reactDom_production_min.createPortal = function (a, b) {
          var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!nl(b)) throw Error(p$1(200));
          return cl(a, b, null, c);
        };
        reactDom_production_min.createRoot = function (a, b) {
          if (!nl(a)) throw Error(p$1(299));
          var c = false,
            d = "",
            e = kl;
          null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
          b = bl(a, 1, false, null, null, c, false, d, e);
          a[uf] = b.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          return new ll(b);
        };
        reactDom_production_min.findDOMNode = function (a) {
          if (null == a) return null;
          if (1 === a.nodeType) return a;
          var b = a._reactInternals;
          if (void 0 === b) {
            if ("function" === typeof a.render) throw Error(p$1(188));
            a = Object.keys(a).join(",");
            throw Error(p$1(268, a));
          }
          a = Zb(b);
          a = null === a ? null : a.stateNode;
          return a;
        };
        reactDom_production_min.flushSync = function (a) {
          return Rk(a);
        };
        reactDom_production_min.hydrate = function (a, b, c) {
          if (!ol(b)) throw Error(p$1(200));
          return rl(null, a, b, true, c);
        };
        reactDom_production_min.hydrateRoot = function (a, b, c) {
          if (!nl(a)) throw Error(p$1(405));
          var d = null != c && c.hydratedSources || null,
            e = false,
            f = "",
            g = kl;
          null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
          b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
          a[uf] = b.current;
          sf(a);
          if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
          return new ml(b);
        };
        reactDom_production_min.render = function (a, b, c) {
          if (!ol(b)) throw Error(p$1(200));
          return rl(null, a, b, false, c);
        };
        reactDom_production_min.unmountComponentAtNode = function (a) {
          if (!ol(a)) throw Error(p$1(40));
          return a._reactRootContainer ? (Rk(function () {
            rl(null, null, a, !1, function () {
              a._reactRootContainer = null;
              a[uf] = null;
            });
          }), true) : false;
        };
        reactDom_production_min.unstable_batchedUpdates = Qk;
        reactDom_production_min.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
          if (!ol(c)) throw Error(p$1(200));
          if (null == a || void 0 === a._reactInternals) throw Error(p$1(38));
          return rl(a, b, c, false, d);
        };
        reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
        function checkDCE() {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
            return;
          }
          try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
          } catch (err) {
            console.error(err);
          }
        }
        {
          checkDCE();
          reactDom.exports = reactDom_production_min;
        }
        var reactDomExports = reactDom.exports;
        var m$1 = reactDomExports;
        {
          client.createRoot = m$1.createRoot;
          client.hydrateRoot = m$1.hydrateRoot;
        }

        /**
         * react-router v7.12.0
         *
         * Copyright (c) Remix Software Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE.md file in the root directory of this source tree.
         *
         * @license MIT
         */
        var PopStateEventType = "popstate";
        function createHashHistory() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          function createHashLocation(window2, globalHistory) {
            var _parsePath = parsePath(window2.location.hash.substring(1)),
              _parsePath$pathname = _parsePath.pathname,
              pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname,
              _parsePath$search = _parsePath.search,
              search = _parsePath$search === void 0 ? "" : _parsePath$search,
              _parsePath$hash = _parsePath.hash,
              hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
            if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
              pathname = "/" + pathname;
            }
            return createLocation("", {
              pathname: pathname,
              search: search,
              hash: hash
            },
            // state defaults to `null` because `window.history.state` does
            globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
          }
          function createHashHref(window2, to) {
            var base = window2.document.querySelector("base");
            var href = "";
            if (base && base.getAttribute("href")) {
              var url = window2.location.href;
              var hashIndex = url.indexOf("#");
              href = hashIndex === -1 ? url : url.slice(0, hashIndex);
            }
            return href + "#" + (typeof to === "string" ? to : createPath(to));
          }
          function validateHashLocation(location, to) {
            warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(".concat(JSON.stringify(to), ")"));
          }
          return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
        }
        function invariant$1(value, message) {
          if (value === false || value === null || typeof value === "undefined") {
            throw new Error(message);
          }
        }
        function warning(cond, message) {
          if (!cond) {
            if (typeof console !== "undefined") console.warn(message);
            try {
              throw new Error(message);
            } catch (e) {}
          }
        }
        function createKey() {
          return Math.random().toString(36).substring(2, 10);
        }
        function getHistoryState(location, index) {
          return {
            usr: location.state,
            key: location.key,
            idx: index
          };
        }
        function createLocation(current, to) {
          var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var key = arguments.length > 3 ? arguments[3] : undefined;
          var location = _objectSpread3(_objectSpread3({
            pathname: typeof current === "string" ? current : current.pathname,
            search: "",
            hash: ""
          }, typeof to === "string" ? parsePath(to) : to), {}, {
            state: state,
            // TODO: This could be cleaned up.  push/replace should probably just take
            // full Locations now and avoid the need to run through this flow at all
            // But that's a pretty big refactor to the current test suite so going to
            // keep as is for the time being and just let any incoming keys take precedence
            key: to && to.key || key || createKey()
          });
          return location;
        }
        function createPath(_ref8) {
          var _ref8$pathname = _ref8.pathname,
            pathname = _ref8$pathname === void 0 ? "/" : _ref8$pathname,
            _ref8$search = _ref8.search,
            search = _ref8$search === void 0 ? "" : _ref8$search,
            _ref8$hash = _ref8.hash,
            hash = _ref8$hash === void 0 ? "" : _ref8$hash;
          if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
          if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
          return pathname;
        }
        function parsePath(path) {
          var parsedPath = {};
          if (path) {
            var hashIndex = path.indexOf("#");
            if (hashIndex >= 0) {
              parsedPath.hash = path.substring(hashIndex);
              path = path.substring(0, hashIndex);
            }
            var searchIndex = path.indexOf("?");
            if (searchIndex >= 0) {
              parsedPath.search = path.substring(searchIndex);
              path = path.substring(0, searchIndex);
            }
            if (path) {
              parsedPath.pathname = path;
            }
          }
          return parsedPath;
        }
        function getUrlBasedHistory(getLocation, createHref2, validateLocation) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var _options$window = options.window,
            window2 = _options$window === void 0 ? document.defaultView : _options$window,
            _options$v5Compat = options.v5Compat,
            v5Compat = _options$v5Compat === void 0 ? false : _options$v5Compat;
          var globalHistory = window2.history;
          var action = "POP";
          var listener = null;
          var index = getIndex();
          if (index == null) {
            index = 0;
            globalHistory.replaceState(_objectSpread3(_objectSpread3({}, globalHistory.state), {}, {
              idx: index
            }), "");
          }
          function getIndex() {
            var state = globalHistory.state || {
              idx: null
            };
            return state.idx;
          }
          function handlePop() {
            action = "POP";
            var nextIndex = getIndex();
            var delta = nextIndex == null ? null : nextIndex - index;
            index = nextIndex;
            if (listener) {
              listener({
                action: action,
                location: history.location,
                delta: delta
              });
            }
          }
          function push(to, state) {
            action = "PUSH";
            var location = createLocation(history.location, to, state);
            if (validateLocation) validateLocation(location, to);
            index = getIndex() + 1;
            var historyState = getHistoryState(location, index);
            var url = history.createHref(location);
            try {
              globalHistory.pushState(historyState, "", url);
            } catch (error) {
              if (error instanceof DOMException && error.name === "DataCloneError") {
                throw error;
              }
              window2.location.assign(url);
            }
            if (v5Compat && listener) {
              listener({
                action: action,
                location: history.location,
                delta: 1
              });
            }
          }
          function replace2(to, state) {
            action = "REPLACE";
            var location = createLocation(history.location, to, state);
            if (validateLocation) validateLocation(location, to);
            index = getIndex();
            var historyState = getHistoryState(location, index);
            var url = history.createHref(location);
            globalHistory.replaceState(historyState, "", url);
            if (v5Compat && listener) {
              listener({
                action: action,
                location: history.location,
                delta: 0
              });
            }
          }
          function createURL(to) {
            return createBrowserURLImpl(to);
          }
          var history = {
            get action() {
              return action;
            },
            get location() {
              return getLocation(window2, globalHistory);
            },
            listen: function listen(fn) {
              if (listener) {
                throw new Error("A history only accepts one active listener");
              }
              window2.addEventListener(PopStateEventType, handlePop);
              listener = fn;
              return function () {
                window2.removeEventListener(PopStateEventType, handlePop);
                listener = null;
              };
            },
            createHref: function createHref(to) {
              return createHref2(window2, to);
            },
            createURL: createURL,
            encodeLocation: function encodeLocation(to) {
              var url = createURL(to);
              return {
                pathname: url.pathname,
                search: url.search,
                hash: url.hash
              };
            },
            push: push,
            replace: replace2,
            go: function go(n) {
              return globalHistory.go(n);
            }
          };
          return history;
        }
        function createBrowserURLImpl(to) {
          var isAbsolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var base = "http://localhost";
          if (typeof window !== "undefined") {
            base = window.location.origin !== "null" ? window.location.origin : window.location.href;
          }
          invariant$1(base, "No window.location.(origin|href) available to create URL");
          var href = typeof to === "string" ? to : createPath(to);
          href = href.replace(/ $/, "%20");
          if (!isAbsolute && href.startsWith("//")) {
            href = base + href;
          }
          return new URL(href, base);
        }
        function matchRoutes(routes, locationArg) {
          var basename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "/";
          return matchRoutesImpl(routes, locationArg, basename, false);
        }
        function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
          var location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
          var pathname = stripBasename(location.pathname || "/", basename);
          if (pathname == null) {
            return null;
          }
          var branches = flattenRoutes(routes);
          rankRouteBranches(branches);
          var matches = null;
          for (var i = 0; matches == null && i < branches.length; ++i) {
            var decoded = decodePath(pathname);
            matches = matchRouteBranch(branches[i], decoded, allowPartial);
          }
          return matches;
        }
        function flattenRoutes(routes) {
          var branches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var parentsMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
          var _hasParentOptionalSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var flattenRoute = function flattenRoute(route, index) {
            var hasParentOptionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _hasParentOptionalSegments;
            var relativePath = arguments.length > 3 ? arguments[3] : undefined;
            var meta = {
              relativePath: relativePath === void 0 ? route.path || "" : relativePath,
              caseSensitive: route.caseSensitive === true,
              childrenIndex: index,
              route: route
            };
            if (meta.relativePath.startsWith("/")) {
              if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
                return;
              }
              invariant$1(meta.relativePath.startsWith(parentPath), "Absolute route path \"".concat(meta.relativePath, "\" nested under path \"").concat(parentPath, "\" is not valid. An absolute child route path must start with the combined path of all its parent routes."));
              meta.relativePath = meta.relativePath.slice(parentPath.length);
            }
            var path = joinPaths([parentPath, meta.relativePath]);
            var routesMeta = parentsMeta.concat(meta);
            if (route.children && route.children.length > 0) {
              invariant$1(
              // Our types know better, but runtime JS may not!
              // @ts-expect-error
              route.index !== true, "Index routes must not have child routes. Please remove all child routes from route path \"".concat(path, "\"."));
              flattenRoutes(route.children, branches, routesMeta, path, hasParentOptionalSegments);
            }
            if (route.path == null && !route.index) {
              return;
            }
            branches.push({
              path: path,
              score: computeScore(path, route.index),
              routesMeta: routesMeta
            });
          };
          routes.forEach(function (route, index) {
            var _route$path;
            if (route.path === "" || !((_route$path = route.path) !== null && _route$path !== void 0 && _route$path.includes("?"))) {
              flattenRoute(route, index);
            } else {
              var _iterator5 = _createForOfIteratorHelper(explodeOptionalSegments(route.path)),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var exploded = _step5.value;
                  flattenRoute(route, index, true, exploded);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            }
          });
          return branches;
        }
        function explodeOptionalSegments(path) {
          var segments = path.split("/");
          if (segments.length === 0) return [];
          var _segments = _toArray(segments),
            first = _segments[0],
            rest = _arrayLikeToArray(_segments).slice(1);
          var isOptional = first.endsWith("?");
          var required = first.replace(/\?$/, "");
          if (rest.length === 0) {
            return isOptional ? [required, ""] : [required];
          }
          var restExploded = explodeOptionalSegments(rest.join("/"));
          var result = [];
          result.push.apply(result, _toConsumableArray(restExploded.map(function (subpath) {
            return subpath === "" ? required : [required, subpath].join("/");
          })));
          if (isOptional) {
            result.push.apply(result, _toConsumableArray(restExploded));
          }
          return result.map(function (exploded) {
            return path.startsWith("/") && exploded === "" ? "/" : exploded;
          });
        }
        function rankRouteBranches(branches) {
          branches.sort(function (a, b) {
            return a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(function (meta) {
              return meta.childrenIndex;
            }), b.routesMeta.map(function (meta) {
              return meta.childrenIndex;
            }));
          });
        }
        var paramRe = /^:[\w-]+$/;
        var dynamicSegmentValue = 3;
        var indexRouteValue = 2;
        var emptySegmentValue = 1;
        var staticSegmentValue = 10;
        var splatPenalty = -2;
        var isSplat = function isSplat(s) {
          return s === "*";
        };
        function computeScore(path, index) {
          var segments = path.split("/");
          var initialScore = segments.length;
          if (segments.some(isSplat)) {
            initialScore += splatPenalty;
          }
          if (index) {
            initialScore += indexRouteValue;
          }
          return segments.filter(function (s) {
            return !isSplat(s);
          }).reduce(function (score, segment) {
            return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue);
          }, initialScore);
        }
        function compareIndexes(a, b) {
          var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {
            return n === b[i];
          });
          return siblings ?
          // If two routes are siblings, we should try to match the earlier sibling
          // first. This allows people to have fine-grained control over the matching
          // behavior by simply putting routes with identical paths in the order they
          // want them tried.
          a[a.length - 1] - b[b.length - 1] :
          // Otherwise, it doesn't really make sense to rank non-siblings by index,
          // so they sort equally.
          0;
        }
        function matchRouteBranch(branch, pathname) {
          var allowPartial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var routesMeta = branch.routesMeta;
          var matchedParams = {};
          var matchedPathname = "/";
          var matches = [];
          for (var i = 0; i < routesMeta.length; ++i) {
            var meta = routesMeta[i];
            var _end = i === routesMeta.length - 1;
            var remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
            var _match = matchPath({
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end: _end
            }, remainingPathname);
            var route = meta.route;
            if (!_match && _end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
              _match = matchPath({
                path: meta.relativePath,
                caseSensitive: meta.caseSensitive,
                end: false
              }, remainingPathname);
            }
            if (!_match) {
              return null;
            }
            Object.assign(matchedParams, _match.params);
            matches.push({
              // TODO: Can this as be avoided?
              params: matchedParams,
              pathname: joinPaths([matchedPathname, _match.pathname]),
              pathnameBase: normalizePathname(joinPaths([matchedPathname, _match.pathnameBase])),
              route: route
            });
            if (_match.pathnameBase !== "/") {
              matchedPathname = joinPaths([matchedPathname, _match.pathnameBase]);
            }
          }
          return matches;
        }
        function matchPath(pattern, pathname) {
          if (typeof pattern === "string") {
            pattern = {
              path: pattern,
              caseSensitive: false,
              end: true
            };
          }
          var _compilePath = compilePath(pattern.path, pattern.caseSensitive, pattern.end),
            _compilePath2 = _slicedToArray(_compilePath, 2),
            matcher = _compilePath2[0],
            compiledParams = _compilePath2[1];
          var match = pathname.match(matcher);
          if (!match) return null;
          var matchedPathname = match[0];
          var pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
          var captureGroups = match.slice(1);
          var params = compiledParams.reduce(function (memo2, _ref9, index) {
            var paramName = _ref9.paramName,
              isOptional = _ref9.isOptional;
            if (paramName === "*") {
              var splatValue = captureGroups[index] || "";
              pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
            }
            var value = captureGroups[index];
            if (isOptional && !value) {
              memo2[paramName] = void 0;
            } else {
              memo2[paramName] = (value || "").replace(/%2F/g, "/");
            }
            return memo2;
          }, {});
          return {
            params: params,
            pathname: matchedPathname,
            pathnameBase: pathnameBase,
            pattern: pattern
          };
        }
        function compilePath(path) {
          var caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"".concat(path, "\" will be treated as if it were \"").concat(path.replace(/\*$/, "/*"), "\" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to \"").concat(path.replace(/\*$/, "/*"), "\"."));
          var params = [];
          var regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, function (_, paramName, isOptional) {
            params.push({
              paramName: paramName,
              isOptional: isOptional != null
            });
            return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
          }).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
          if (path.endsWith("*")) {
            params.push({
              paramName: "*"
            });
            regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
          } else if (end) {
            regexpSource += "\\/*$";
          } else if (path !== "" && path !== "/") {
            regexpSource += "(?:(?=\\/|$))";
          } else ;
          var matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
          return [matcher, params];
        }
        function decodePath(value) {
          try {
            return value.split("/").map(function (v) {
              return decodeURIComponent(v).replace(/\//g, "%2F");
            }).join("/");
          } catch (error) {
            warning(false, "The URL path \"".concat(value, "\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (").concat(error, ")."));
            return value;
          }
        }
        function stripBasename(pathname, basename) {
          if (basename === "/") return pathname;
          if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
            return null;
          }
          var startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
          var nextChar = pathname.charAt(startIndex);
          if (nextChar && nextChar !== "/") {
            return null;
          }
          return pathname.slice(startIndex) || "/";
        }
        var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
        var isAbsoluteUrl = function isAbsoluteUrl(url) {
          return ABSOLUTE_URL_REGEX.test(url);
        };
        function resolvePath(to) {
          var fromPathname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "/";
          var _ref0 = typeof to === "string" ? parsePath(to) : to,
            toPathname = _ref0.pathname,
            _ref0$search = _ref0.search,
            search = _ref0$search === void 0 ? "" : _ref0$search,
            _ref0$hash = _ref0.hash,
            hash = _ref0$hash === void 0 ? "" : _ref0$hash;
          var pathname;
          if (toPathname) {
            if (isAbsoluteUrl(toPathname)) {
              pathname = toPathname;
            } else {
              if (toPathname.includes("//")) {
                var oldPathname = toPathname;
                toPathname = toPathname.replace(/\/\/+/g, "/");
                warning(false, "Pathnames cannot have embedded double slashes - normalizing ".concat(oldPathname, " -> ").concat(toPathname));
              }
              if (toPathname.startsWith("/")) {
                pathname = resolvePathname(toPathname.substring(1), "/");
              } else {
                pathname = resolvePathname(toPathname, fromPathname);
              }
            }
          } else {
            pathname = fromPathname;
          }
          return {
            pathname: pathname,
            search: normalizeSearch(search),
            hash: normalizeHash(hash)
          };
        }
        function resolvePathname(relativePath, fromPathname) {
          var segments = fromPathname.replace(/\/+$/, "").split("/");
          var relativeSegments = relativePath.split("/");
          relativeSegments.forEach(function (segment) {
            if (segment === "..") {
              if (segments.length > 1) segments.pop();
            } else if (segment !== ".") {
              segments.push(segment);
            }
          });
          return segments.length > 1 ? segments.join("/") : "/";
        }
        function getInvalidPathError(char, field, dest, path) {
          return "Cannot include a '".concat(char, "' character in a manually specified `to.").concat(field, "` field [").concat(JSON.stringify(path), "].  Please separate it out to the `to.").concat(dest, "` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.");
        }
        function getPathContributingMatches(matches) {
          return matches.filter(function (match, index) {
            return index === 0 || match.route.path && match.route.path.length > 0;
          });
        }
        function getResolveToMatches(matches) {
          var pathMatches = getPathContributingMatches(matches);
          return pathMatches.map(function (match, idx) {
            return idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase;
          });
        }
        function resolveTo(toArg, routePathnames, locationPathname) {
          var isPathRelative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var to;
          if (typeof toArg === "string") {
            to = parsePath(toArg);
          } else {
            to = _objectSpread3({}, toArg);
            invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
            invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
            invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
          }
          var isEmptyPath = toArg === "" || to.pathname === "";
          var toPathname = isEmptyPath ? "/" : to.pathname;
          var from;
          if (toPathname == null) {
            from = locationPathname;
          } else {
            var routePathnameIndex = routePathnames.length - 1;
            if (!isPathRelative && toPathname.startsWith("..")) {
              var toSegments = toPathname.split("/");
              while (toSegments[0] === "..") {
                toSegments.shift();
                routePathnameIndex -= 1;
              }
              to.pathname = toSegments.join("/");
            }
            from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
          }
          var path = resolvePath(to, from);
          var hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
          var hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
          if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
            path.pathname += "/";
          }
          return path;
        }
        var joinPaths = function joinPaths(paths) {
          return paths.join("/").replace(/\/\/+/g, "/");
        };
        var normalizePathname = function normalizePathname(pathname) {
          return pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
        };
        var normalizeSearch = function normalizeSearch(search) {
          return !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
        };
        var normalizeHash = function normalizeHash(hash) {
          return !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
        };
        var ErrorResponseImpl = /*#__PURE__*/_createClass(function ErrorResponseImpl(status, statusText, data2) {
          var internal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          _classCallCheck(this, ErrorResponseImpl);
          this.status = status;
          this.statusText = statusText || "";
          this.internal = internal;
          if (data2 instanceof Error) {
            this.data = data2.toString();
            this.error = data2;
          } else {
            this.data = data2;
          }
        });
        function isRouteErrorResponse(error) {
          return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
        }
        function getRoutePattern(matches) {
          return matches.map(function (m) {
            return m.route.path;
          }).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
        }
        var isBrowser$4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
        function parseToInfo(_to, basename) {
          var to = _to;
          if (typeof to !== "string" || !ABSOLUTE_URL_REGEX.test(to)) {
            return {
              absoluteURL: void 0,
              isExternal: false,
              to: to
            };
          }
          var absoluteURL = to;
          var isExternal = false;
          if (isBrowser$4) {
            try {
              var currentUrl = new URL(window.location.href);
              var targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              var path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(false, "<Link to=\"".concat(to, "\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path."));
            }
          }
          return {
            absoluteURL: absoluteURL,
            isExternal: isExternal,
            to: to
          };
        }
        Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
        var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"];
        new Set(validMutationMethodsArr);
        var validRequestMethodsArr = ["GET"].concat(validMutationMethodsArr);
        new Set(validRequestMethodsArr);
        var DataRouterContext = reactExports.createContext(null);
        DataRouterContext.displayName = "DataRouter";
        var DataRouterStateContext = reactExports.createContext(null);
        DataRouterStateContext.displayName = "DataRouterState";
        var RSCRouterContext = reactExports.createContext(false);
        var ViewTransitionContext = reactExports.createContext({
          isTransitioning: false
        });
        ViewTransitionContext.displayName = "ViewTransition";
        var FetchersContext = reactExports.createContext(/* @__PURE__ */new Map());
        FetchersContext.displayName = "Fetchers";
        var AwaitContext = reactExports.createContext(null);
        AwaitContext.displayName = "Await";
        var NavigationContext = reactExports.createContext(null);
        NavigationContext.displayName = "Navigation";
        var LocationContext = reactExports.createContext(null);
        LocationContext.displayName = "Location";
        var RouteContext = reactExports.createContext({
          outlet: null,
          matches: [],
          isDataRoute: false
        });
        RouteContext.displayName = "Route";
        var RouteErrorContext = reactExports.createContext(null);
        RouteErrorContext.displayName = "RouteError";
        var ERROR_DIGEST_BASE = "REACT_ROUTER_ERROR";
        var ERROR_DIGEST_REDIRECT = "REDIRECT";
        var ERROR_DIGEST_ROUTE_ERROR_RESPONSE = "ROUTE_ERROR_RESPONSE";
        function decodeRedirectErrorDigest(digest) {
          if (digest.startsWith("".concat(ERROR_DIGEST_BASE, ":").concat(ERROR_DIGEST_REDIRECT, ":{"))) {
            try {
              var parsed = JSON.parse(digest.slice(28));
              if (_typeof2(parsed) === "object" && parsed && typeof parsed.status === "number" && typeof parsed.statusText === "string" && typeof parsed.location === "string" && typeof parsed.reloadDocument === "boolean" && typeof parsed.replace === "boolean") {
                return parsed;
              }
            } catch (_unused2) {}
          }
        }
        function decodeRouteErrorResponseDigest(digest) {
          if (digest.startsWith("".concat(ERROR_DIGEST_BASE, ":").concat(ERROR_DIGEST_ROUTE_ERROR_RESPONSE, ":{"))) {
            try {
              var parsed = JSON.parse(digest.slice(40));
              if (_typeof2(parsed) === "object" && parsed && typeof parsed.status === "number" && typeof parsed.statusText === "string") {
                return new ErrorResponseImpl(parsed.status, parsed.statusText, parsed.data);
              }
            } catch (_unused3) {}
          }
        }
        function useHref(to) {
          var _ref1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            relative = _ref1.relative;
          invariant$1(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useHref() may be used only in the context of a <Router> component.");
          var _reactExports$useCont = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont.basename,
            navigator = _reactExports$useCont.navigator;
          var _useResolvedPath = useResolvedPath(to, {
              relative: relative
            }),
            hash = _useResolvedPath.hash,
            pathname = _useResolvedPath.pathname,
            search = _useResolvedPath.search;
          var joinedPathname = pathname;
          if (basename !== "/") {
            joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
          }
          return navigator.createHref({
            pathname: joinedPathname,
            search: search,
            hash: hash
          });
        }
        function useInRouterContext() {
          return reactExports.useContext(LocationContext) != null;
        }
        function useLocation() {
          invariant$1(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useLocation() may be used only in the context of a <Router> component.");
          return reactExports.useContext(LocationContext).location;
        }
        var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
        function useIsomorphicLayoutEffect$2(cb) {
          var isStatic = reactExports.useContext(NavigationContext).static;
          if (!isStatic) {
            reactExports.useLayoutEffect(cb);
          }
        }
        function useNavigate() {
          var _reactExports$useCont2 = reactExports.useContext(RouteContext),
            isDataRoute = _reactExports$useCont2.isDataRoute;
          return isDataRoute ? useNavigateStable() : useNavigateUnstable();
        }
        function useNavigateUnstable() {
          invariant$1(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useNavigate() may be used only in the context of a <Router> component.");
          var dataRouterContext = reactExports.useContext(DataRouterContext);
          var _reactExports$useCont3 = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont3.basename,
            navigator = _reactExports$useCont3.navigator;
          var _reactExports$useCont4 = reactExports.useContext(RouteContext),
            matches = _reactExports$useCont4.matches;
          var _useLocation = useLocation(),
            locationPathname = _useLocation.pathname;
          var routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
          var activeRef = reactExports.useRef(false);
          useIsomorphicLayoutEffect$2(function () {
            activeRef.current = true;
          });
          var navigate = reactExports.useCallback(function (to) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            warning(activeRef.current, navigateEffectWarning);
            if (!activeRef.current) return;
            if (typeof to === "number") {
              navigator.go(to);
              return;
            }
            var path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
            if (dataRouterContext == null && basename !== "/") {
              path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
            }
            (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
          }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
          return navigate;
        }
        reactExports.createContext(null);
        function useParams() {
          var _reactExports$useCont5 = reactExports.useContext(RouteContext),
            matches = _reactExports$useCont5.matches;
          var routeMatch = matches[matches.length - 1];
          return routeMatch ? routeMatch.params : {};
        }
        function useResolvedPath(to) {
          var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            relative = _ref10.relative;
          var _reactExports$useCont6 = reactExports.useContext(RouteContext),
            matches = _reactExports$useCont6.matches;
          var _useLocation2 = useLocation(),
            locationPathname = _useLocation2.pathname;
          var routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
          return reactExports.useMemo(function () {
            return resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path");
          }, [to, routePathnamesJson, locationPathname, relative]);
        }
        function useRoutes(routes, locationArg) {
          return useRoutesImpl(routes, locationArg);
        }
        function useRoutesImpl(routes, locationArg, dataRouterState, onError, future) {
          invariant$1(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useRoutes() may be used only in the context of a <Router> component.");
          var _reactExports$useCont7 = reactExports.useContext(NavigationContext),
            navigator = _reactExports$useCont7.navigator;
          var _reactExports$useCont8 = reactExports.useContext(RouteContext),
            parentMatches = _reactExports$useCont8.matches;
          var routeMatch = parentMatches[parentMatches.length - 1];
          var parentParams = routeMatch ? routeMatch.params : {};
          var parentPathname = routeMatch ? routeMatch.pathname : "/";
          var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
          var parentRoute = routeMatch && routeMatch.route;
          {
            var parentPath = parentRoute && parentRoute.path || "";
            warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"), "You rendered descendant <Routes> (or called `useRoutes()`) at \"".concat(parentPathname, "\" (under <Route path=\"").concat(parentPath, "\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"").concat(parentPath, "\"> to <Route path=\"").concat(parentPath === "/" ? "*" : "".concat(parentPath, "/*"), "\">."));
          }
          var locationFromContext = useLocation();
          var location;
          if (locationArg) {
            var _parsedLocationArg$pa;
            var parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
            invariant$1(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) === null || _parsedLocationArg$pa === void 0 ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase)), "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"".concat(parentPathnameBase, "\" but pathname \"").concat(parsedLocationArg.pathname, "\" was given in the `location` prop."));
            location = parsedLocationArg;
          } else {
            location = locationFromContext;
          }
          var pathname = location.pathname || "/";
          var remainingPathname = pathname;
          if (parentPathnameBase !== "/") {
            var parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
            var segments = pathname.replace(/^\//, "").split("/");
            remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
          }
          var matches = matchRoutes(routes, {
            pathname: remainingPathname
          });
          {
            warning(parentRoute || matches != null, "No routes matched location \"".concat(location.pathname).concat(location.search).concat(location.hash, "\" "));
            warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, "Matched leaf route at location \"".concat(location.pathname).concat(location.search).concat(location.hash, "\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page."));
          }
          var renderedMatches = _renderMatches(matches && matches.map(function (match) {
            return Object.assign({}, match, {
              params: Object.assign({}, parentParams, match.params),
              pathname: joinPaths([parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes.
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator.encodeLocation ? navigator.encodeLocation(match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : match.pathname]),
              pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : match.pathnameBase])
            });
          }), parentMatches, dataRouterState, onError, future);
          if (locationArg && renderedMatches) {
            return /* @__PURE__ */reactExports.createElement(LocationContext.Provider, {
              value: {
                location: _objectSpread3({
                  pathname: "/",
                  search: "",
                  hash: "",
                  state: null,
                  key: "default"
                }, location),
                navigationType: "POP"
                /* Pop */
              }
            }, renderedMatches);
          }
          return renderedMatches;
        }
        function DefaultErrorComponent() {
          var error = useRouteError();
          var message = isRouteErrorResponse(error) ? "".concat(error.status, " ").concat(error.statusText) : error instanceof Error ? error.message : JSON.stringify(error);
          var stack = error instanceof Error ? error.stack : null;
          var lightgrey = "rgba(200,200,200, 0.5)";
          var preStyles = {
            padding: "0.5rem",
            backgroundColor: lightgrey
          };
          var codeStyles = {
            padding: "2px 4px",
            backgroundColor: lightgrey
          };
          var devInfo = null;
          {
            console.error("Error handled by React Router default ErrorBoundary:", error);
            devInfo = /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */reactExports.createElement("code", {
              style: codeStyles
            }, "ErrorBoundary"), " or", " ", /* @__PURE__ */reactExports.createElement("code", {
              style: codeStyles
            }, "errorElement"), " prop on your route."));
          }
          return /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */reactExports.createElement("h3", {
            style: {
              fontStyle: "italic"
            }
          }, message), stack ? /* @__PURE__ */reactExports.createElement("pre", {
            style: preStyles
          }, stack) : null, devInfo);
        }
        var defaultErrorElement = /* @__PURE__ */reactExports.createElement(DefaultErrorComponent, null);
        var RenderErrorBoundary = /*#__PURE__*/function (_reactExports$Compone) {
          function RenderErrorBoundary(props) {
            var _this0;
            _classCallCheck(this, RenderErrorBoundary);
            _this0 = _callSuper(this, RenderErrorBoundary, [props]);
            _this0.state = {
              location: props.location,
              revalidation: props.revalidation,
              error: props.error
            };
            return _this0;
          }
          _inherits(RenderErrorBoundary, _reactExports$Compone);
          return _createClass(RenderErrorBoundary, [{
            key: "componentDidCatch",
            value: function componentDidCatch(error, errorInfo) {
              if (this.props.onError) {
                this.props.onError(error, errorInfo);
              } else {
                console.error("React Router caught the following error during render", error);
              }
            }
          }, {
            key: "render",
            value: function render() {
              var error = this.state.error;
              if (this.context && _typeof2(error) === "object" && error && "digest" in error && typeof error.digest === "string") {
                var decoded = decodeRouteErrorResponseDigest(error.digest);
                if (decoded) error = decoded;
              }
              var result = error !== void 0 ? /* @__PURE__ */reactExports.createElement(RouteContext.Provider, {
                value: this.props.routeContext
              }, /* @__PURE__ */reactExports.createElement(RouteErrorContext.Provider, {
                value: error,
                children: this.props.component
              })) : this.props.children;
              if (this.context) {
                return /* @__PURE__ */reactExports.createElement(RSCErrorHandler, {
                  error: error
                }, result);
              }
              return result;
            }
          }], [{
            key: "getDerivedStateFromError",
            value: function getDerivedStateFromError(error) {
              return {
                error: error
              };
            }
          }, {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(props, state) {
              if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
                return {
                  error: props.error,
                  location: props.location,
                  revalidation: props.revalidation
                };
              }
              return {
                error: props.error !== void 0 ? props.error : state.error,
                location: state.location,
                revalidation: props.revalidation || state.revalidation
              };
            }
          }]);
        }(reactExports.Component);
        RenderErrorBoundary.contextType = RSCRouterContext;
        var errorRedirectHandledMap = /* @__PURE__ */new WeakMap();
        function RSCErrorHandler(_ref11) {
          var children = _ref11.children,
            error = _ref11.error;
          var _reactExports$useCont9 = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont9.basename;
          if (_typeof2(error) === "object" && error && "digest" in error && typeof error.digest === "string") {
            var redirect2 = decodeRedirectErrorDigest(error.digest);
            if (redirect2) {
              var existingRedirect = errorRedirectHandledMap.get(error);
              if (existingRedirect) throw existingRedirect;
              var parsed = parseToInfo(redirect2.location, basename);
              if (isBrowser$4 && !errorRedirectHandledMap.get(error)) {
                if (parsed.isExternal || redirect2.reloadDocument) {
                  window.location.href = parsed.absoluteURL || parsed.to;
                } else {
                  var redirectPromise = Promise.resolve().then(function () {
                    return window.__reactRouterDataRouter.navigate(parsed.to, {
                      replace: redirect2.replace
                    });
                  });
                  errorRedirectHandledMap.set(error, redirectPromise);
                  throw redirectPromise;
                }
              }
              return /* @__PURE__ */reactExports.createElement("meta", {
                httpEquiv: "refresh",
                content: "0;url=".concat(parsed.absoluteURL || parsed.to)
              });
            }
          }
          return children;
        }
        function RenderedRoute(_ref12) {
          var routeContext = _ref12.routeContext,
            match = _ref12.match,
            children = _ref12.children;
          var dataRouterContext = reactExports.useContext(DataRouterContext);
          if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
            dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
          }
          return /* @__PURE__ */reactExports.createElement(RouteContext.Provider, {
            value: routeContext
          }, children);
        }
        function _renderMatches(matches) {
          var parentMatches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var dataRouterState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var onErrorHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var future = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (matches == null) {
            if (!dataRouterState) {
              return null;
            }
            if (dataRouterState.errors) {
              matches = dataRouterState.matches;
            } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
              matches = dataRouterState.matches;
            } else {
              return null;
            }
          }
          var renderedMatches = matches;
          var errors = dataRouterState === null || dataRouterState === void 0 ? void 0 : dataRouterState.errors;
          if (errors != null) {
            var errorIndex = renderedMatches.findIndex(function (m) {
              return m.route.id && (errors === null || errors === void 0 ? void 0 : errors[m.route.id]) !== void 0;
            });
            invariant$1(errorIndex >= 0, "Could not find a matching route for errors on route IDs: ".concat(Object.keys(errors).join(",")));
            renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
          }
          var renderFallback = false;
          var fallbackIndex = -1;
          if (dataRouterState) {
            for (var i = 0; i < renderedMatches.length; i++) {
              var _match2 = renderedMatches[i];
              if (_match2.route.HydrateFallback || _match2.route.hydrateFallbackElement) {
                fallbackIndex = i;
              }
              if (_match2.route.id) {
                var loaderData = dataRouterState.loaderData,
                  errors2 = dataRouterState.errors;
                var needsToRunLoader = _match2.route.loader && !loaderData.hasOwnProperty(_match2.route.id) && (!errors2 || errors2[_match2.route.id] === void 0);
                if (_match2.route.lazy || needsToRunLoader) {
                  renderFallback = true;
                  if (fallbackIndex >= 0) {
                    renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
                  } else {
                    renderedMatches = [renderedMatches[0]];
                  }
                  break;
                }
              }
            }
          }
          var onError = dataRouterState && onErrorHandler ? function (error, errorInfo) {
            var _dataRouterState$matc, _dataRouterState$matc2;
            onErrorHandler(error, {
              location: dataRouterState.location,
              params: (_dataRouterState$matc = (_dataRouterState$matc2 = dataRouterState.matches) === null || _dataRouterState$matc2 === void 0 || (_dataRouterState$matc2 = _dataRouterState$matc2[0]) === null || _dataRouterState$matc2 === void 0 ? void 0 : _dataRouterState$matc2.params) !== null && _dataRouterState$matc !== void 0 ? _dataRouterState$matc : {},
              unstable_pattern: getRoutePattern(dataRouterState.matches),
              errorInfo: errorInfo
            });
          } : void 0;
          return renderedMatches.reduceRight(function (outlet, match, index) {
            var error;
            var shouldRenderHydrateFallback = false;
            var errorElement = null;
            var hydrateFallbackElement = null;
            if (dataRouterState) {
              error = errors && match.route.id ? errors[match.route.id] : void 0;
              errorElement = match.route.errorElement || defaultErrorElement;
              if (renderFallback) {
                if (fallbackIndex < 0 && index === 0) {
                  warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
                  shouldRenderHydrateFallback = true;
                  hydrateFallbackElement = null;
                } else if (fallbackIndex === index) {
                  shouldRenderHydrateFallback = true;
                  hydrateFallbackElement = match.route.hydrateFallbackElement || null;
                }
              }
            }
            var matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
            var getChildren = function getChildren() {
              var children;
              if (error) {
                children = errorElement;
              } else if (shouldRenderHydrateFallback) {
                children = hydrateFallbackElement;
              } else if (match.route.Component) {
                children = /* @__PURE__ */reactExports.createElement(match.route.Component, null);
              } else if (match.route.element) {
                children = match.route.element;
              } else {
                children = outlet;
              }
              return /* @__PURE__ */reactExports.createElement(RenderedRoute, {
                match: match,
                routeContext: {
                  outlet: outlet,
                  matches: matches2,
                  isDataRoute: dataRouterState != null
                },
                children: children
              });
            };
            return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */reactExports.createElement(RenderErrorBoundary, {
              location: dataRouterState.location,
              revalidation: dataRouterState.revalidation,
              component: errorElement,
              error: error,
              children: getChildren(),
              routeContext: {
                outlet: null,
                matches: matches2,
                isDataRoute: true
              },
              onError: onError
            }) : getChildren();
          }, null);
        }
        function getDataRouterConsoleError(hookName) {
          return "".concat(hookName, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.");
        }
        function useDataRouterContext(hookName) {
          var ctx = reactExports.useContext(DataRouterContext);
          invariant$1(ctx, getDataRouterConsoleError(hookName));
          return ctx;
        }
        function useDataRouterState(hookName) {
          var state = reactExports.useContext(DataRouterStateContext);
          invariant$1(state, getDataRouterConsoleError(hookName));
          return state;
        }
        function useRouteContext(hookName) {
          var route = reactExports.useContext(RouteContext);
          invariant$1(route, getDataRouterConsoleError(hookName));
          return route;
        }
        function useCurrentRouteId(hookName) {
          var route = useRouteContext(hookName);
          var thisRoute = route.matches[route.matches.length - 1];
          invariant$1(thisRoute.route.id, "".concat(hookName, " can only be used on routes that contain a unique \"id\""));
          return thisRoute.route.id;
        }
        function useRouteId() {
          return useCurrentRouteId("useRouteId"
          /* UseRouteId */);
        }
        function useRouteError() {
          var _state$errors;
          var error = reactExports.useContext(RouteErrorContext);
          var state = useDataRouterState("useRouteError"
          /* UseRouteError */);
          var routeId = useCurrentRouteId("useRouteError"
          /* UseRouteError */);
          if (error !== void 0) {
            return error;
          }
          return (_state$errors = state.errors) === null || _state$errors === void 0 ? void 0 : _state$errors[routeId];
        }
        function useNavigateStable() {
          var _useDataRouterContext = useDataRouterContext("useNavigate"
            /* UseNavigateStable */),
            router = _useDataRouterContext.router;
          var id = useCurrentRouteId("useNavigate"
          /* UseNavigateStable */);
          var activeRef = reactExports.useRef(false);
          useIsomorphicLayoutEffect$2(function () {
            activeRef.current = true;
          });
          var navigate = reactExports.useCallback(/*#__PURE__*/function () {
            var _ref13 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(to) {
              var options,
                _args = arguments;
              return _regenerator().w(function (_context) {
                while (1) switch (_context.n) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                    warning(activeRef.current, navigateEffectWarning);
                    if (activeRef.current) {
                      _context.n = 1;
                      break;
                    }
                    return _context.a(2);
                  case 1:
                    if (!(typeof to === "number")) {
                      _context.n = 3;
                      break;
                    }
                    _context.n = 2;
                    return router.navigate(to);
                  case 2:
                    _context.n = 4;
                    break;
                  case 3:
                    _context.n = 4;
                    return router.navigate(to, _objectSpread3({
                      fromRouteId: id
                    }, options));
                  case 4:
                    return _context.a(2);
                }
              }, _callee);
            }));
            return function (_x) {
              return _ref13.apply(this, arguments);
            };
          }(), [router, id]);
          return navigate;
        }
        var alreadyWarned = {};
        function warningOnce(key, cond, message) {
          if (!cond && !alreadyWarned[key]) {
            alreadyWarned[key] = true;
            warning(false, message);
          }
        }
        reactExports.memo(DataRoutes);
        function DataRoutes(_ref14) {
          var routes = _ref14.routes,
            future = _ref14.future,
            state = _ref14.state,
            onError = _ref14.onError;
          return useRoutesImpl(routes, void 0, state, onError, future);
        }
        function Route(props) {
          invariant$1(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
        }
        function Router(_ref15) {
          var _ref15$basename = _ref15.basename,
            basenameProp = _ref15$basename === void 0 ? "/" : _ref15$basename,
            _ref15$children = _ref15.children,
            children = _ref15$children === void 0 ? null : _ref15$children,
            locationProp = _ref15.location,
            _ref15$navigationType = _ref15.navigationType,
            navigationType = _ref15$navigationType === void 0 ? "POP" : _ref15$navigationType,
            navigator = _ref15.navigator,
            _ref15$static = _ref15.static,
            staticProp = _ref15$static === void 0 ? false : _ref15$static,
            unstable_useTransitions = _ref15.unstable_useTransitions;
          invariant$1(!useInRouterContext(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
          var basename = basenameProp.replace(/^\/*/, "/");
          var navigationContext = reactExports.useMemo(function () {
            return {
              basename: basename,
              navigator: navigator,
              static: staticProp,
              unstable_useTransitions: unstable_useTransitions,
              future: {}
            };
          }, [basename, navigator, staticProp, unstable_useTransitions]);
          if (typeof locationProp === "string") {
            locationProp = parsePath(locationProp);
          }
          var _locationProp = locationProp,
            _locationProp$pathnam = _locationProp.pathname,
            pathname = _locationProp$pathnam === void 0 ? "/" : _locationProp$pathnam,
            _locationProp$search = _locationProp.search,
            search = _locationProp$search === void 0 ? "" : _locationProp$search,
            _locationProp$hash = _locationProp.hash,
            hash = _locationProp$hash === void 0 ? "" : _locationProp$hash,
            _locationProp$state = _locationProp.state,
            state = _locationProp$state === void 0 ? null : _locationProp$state,
            _locationProp$key = _locationProp.key,
            key = _locationProp$key === void 0 ? "default" : _locationProp$key;
          var locationContext = reactExports.useMemo(function () {
            var trailingPathname = stripBasename(pathname, basename);
            if (trailingPathname == null) {
              return null;
            }
            return {
              location: {
                pathname: trailingPathname,
                search: search,
                hash: hash,
                state: state,
                key: key
              },
              navigationType: navigationType
            };
          }, [basename, pathname, search, hash, state, key, navigationType]);
          warning(locationContext != null, "<Router basename=\"".concat(basename, "\"> is not able to match the URL \"").concat(pathname).concat(search).concat(hash, "\" because it does not start with the basename, so the <Router> won't render anything."));
          if (locationContext == null) {
            return null;
          }
          return /* @__PURE__ */reactExports.createElement(NavigationContext.Provider, {
            value: navigationContext
          }, /* @__PURE__ */reactExports.createElement(LocationContext.Provider, {
            children: children,
            value: locationContext
          }));
        }
        function Routes(_ref16) {
          var children = _ref16.children,
            location = _ref16.location;
          return useRoutes(createRoutesFromChildren(children), location);
        }
        function createRoutesFromChildren(children) {
          var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var routes = [];
          reactExports.Children.forEach(children, function (element, index) {
            if (!reactExports.isValidElement(element)) {
              return;
            }
            var treePath = [].concat(_toConsumableArray(parentPath), [index]);
            if (element.type === reactExports.Fragment) {
              routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
              return;
            }
            invariant$1(element.type === Route, "[".concat(typeof element.type === "string" ? element.type : element.type.name, "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"));
            invariant$1(!element.props.index || !element.props.children, "An index route cannot have child routes.");
            var route = {
              id: element.props.id || treePath.join("-"),
              caseSensitive: element.props.caseSensitive,
              element: element.props.element,
              Component: element.props.Component,
              index: element.props.index,
              path: element.props.path,
              middleware: element.props.middleware,
              loader: element.props.loader,
              action: element.props.action,
              hydrateFallbackElement: element.props.hydrateFallbackElement,
              HydrateFallback: element.props.HydrateFallback,
              errorElement: element.props.errorElement,
              ErrorBoundary: element.props.ErrorBoundary,
              hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
              shouldRevalidate: element.props.shouldRevalidate,
              handle: element.props.handle,
              lazy: element.props.lazy
            };
            if (element.props.children) {
              route.children = createRoutesFromChildren(element.props.children, treePath);
            }
            routes.push(route);
          });
          return routes;
        }
        var defaultMethod = "get";
        var defaultEncType = "application/x-www-form-urlencoded";
        function isHtmlElement(object) {
          return typeof HTMLElement !== "undefined" && object instanceof HTMLElement;
        }
        function isButtonElement(object) {
          return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
        }
        function isFormElement(object) {
          return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
        }
        function isInputElement(object) {
          return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
        }
        function isModifiedEvent(event) {
          return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }
        function shouldProcessLinkClick(event, target) {
          return event.button === 0 && (
          // Ignore everything but left clicks
          !target || target === "_self") &&
          // Let browser handle "target=_blank" etc.
          !isModifiedEvent(event);
        }
        var _formDataSupportsSubmitter = null;
        function isFormDataSubmitterSupported() {
          if (_formDataSupportsSubmitter === null) {
            try {
              new FormData(document.createElement("form"),
              // @ts-expect-error if FormData supports the submitter parameter, this will throw
              0);
              _formDataSupportsSubmitter = false;
            } catch (e) {
              _formDataSupportsSubmitter = true;
            }
          }
          return _formDataSupportsSubmitter;
        }
        var supportedFormEncTypes = /* @__PURE__ */new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
        function getFormEncType(encType) {
          if (encType != null && !supportedFormEncTypes.has(encType)) {
            warning(false, "\"".concat(encType, "\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` and will default to \"").concat(defaultEncType, "\""));
            return null;
          }
          return encType;
        }
        function getFormSubmissionInfo(target, basename) {
          var method;
          var action;
          var encType;
          var formData;
          var body;
          if (isFormElement(target)) {
            var attr = target.getAttribute("action");
            action = attr ? stripBasename(attr, basename) : null;
            method = target.getAttribute("method") || defaultMethod;
            encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
            formData = new FormData(target);
          } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
            var form = target.form;
            if (form == null) {
              throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
            }
            var _attr = target.getAttribute("formaction") || form.getAttribute("action");
            action = _attr ? stripBasename(_attr, basename) : null;
            method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
            encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
            formData = new FormData(form, target);
            if (!isFormDataSubmitterSupported()) {
              var name = target.name,
                type = target.type,
                value = target.value;
              if (type === "image") {
                var _prefix = name ? "".concat(name, ".") : "";
                formData.append("".concat(_prefix, "x"), "0");
                formData.append("".concat(_prefix, "y"), "0");
              } else if (name) {
                formData.append(name, value);
              }
            }
          } else if (isHtmlElement(target)) {
            throw new Error("Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">");
          } else {
            method = defaultMethod;
            action = null;
            encType = defaultEncType;
            body = target;
          }
          if (formData && encType === "text/plain") {
            body = formData;
            formData = void 0;
          }
          return {
            action: action,
            method: method.toLowerCase(),
            encType: encType,
            formData: formData,
            body: body
          };
        }
        Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
        function invariant2(value, message) {
          if (value === false || value === null || typeof value === "undefined") {
            throw new Error(message);
          }
        }
        function singleFetchUrl(reqUrl, basename, trailingSlashAware, extension) {
          var url = typeof reqUrl === "string" ? new URL(reqUrl,
          // This can be called during the SSR flow via PrefetchPageLinksImpl so
          // don't assume window is available
          typeof window === "undefined" ? "server://singlefetch/" : window.location.origin) : reqUrl;
          if (trailingSlashAware) {
            if (url.pathname.endsWith("/")) {
              url.pathname = "".concat(url.pathname, "_.").concat(extension);
            } else {
              url.pathname = "".concat(url.pathname, ".").concat(extension);
            }
          } else {
            if (url.pathname === "/") {
              url.pathname = "_root.".concat(extension);
            } else if (basename && stripBasename(url.pathname, basename) === "/") {
              url.pathname = "".concat(basename.replace(/\/$/, ""), "/_root.").concat(extension);
            } else {
              url.pathname = "".concat(url.pathname.replace(/\/$/, ""), ".").concat(extension);
            }
          }
          return url;
        }
        function loadRouteModule(_x2, _x3) {
          return _loadRouteModule.apply(this, arguments);
        }
        function _loadRouteModule() {
          _loadRouteModule = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee255(route, routeModulesCache) {
            var routeModule, _t165;
            return _regenerator().w(function (_context256) {
              while (1) switch (_context256.p = _context256.n) {
                case 0:
                  if (!(route.id in routeModulesCache)) {
                    _context256.n = 1;
                    break;
                  }
                  return _context256.a(2, routeModulesCache[route.id]);
                case 1:
                  _context256.p = 1;
                  _context256.n = 2;
                  return module.import(/* @vite-ignore */
                  /* webpackIgnore: true */
                  route.module);
                case 2:
                  routeModule = _context256.v;
                  routeModulesCache[route.id] = routeModule;
                  return _context256.a(2, routeModule);
                case 3:
                  _context256.p = 3;
                  _t165 = _context256.v;
                  console.error("Error loading route module `".concat(route.module, "`, reloading page..."));
                  console.error(_t165);
                  if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode &&
                  // @ts-expect-error
                  void 0) ;
                  window.location.reload();
                  return _context256.a(2, new Promise(function () {}));
              }
            }, _callee255, null, [[1, 3]]);
          }));
          return _loadRouteModule.apply(this, arguments);
        }
        function isHtmlLinkDescriptor(object) {
          if (object == null) {
            return false;
          }
          if (object.href == null) {
            return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
          }
          return typeof object.rel === "string" && typeof object.href === "string";
        }
        function getKeyedPrefetchLinks(_x4, _x5, _x6) {
          return _getKeyedPrefetchLinks.apply(this, arguments);
        }
        function _getKeyedPrefetchLinks() {
          _getKeyedPrefetchLinks = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee257(matches, manifest, routeModules) {
            var links;
            return _regenerator().w(function (_context258) {
              while (1) switch (_context258.n) {
                case 0:
                  _context258.n = 1;
                  return Promise.all(matches.map(/*#__PURE__*/function () {
                    var _ref283 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee256(match) {
                      var route, mod;
                      return _regenerator().w(function (_context257) {
                        while (1) switch (_context257.n) {
                          case 0:
                            route = manifest.routes[match.route.id];
                            if (!route) {
                              _context257.n = 2;
                              break;
                            }
                            _context257.n = 1;
                            return loadRouteModule(route, routeModules);
                          case 1:
                            mod = _context257.v;
                            return _context257.a(2, mod.links ? mod.links() : []);
                          case 2:
                            return _context257.a(2, []);
                        }
                      }, _callee256);
                    }));
                    return function (_x328) {
                      return _ref283.apply(this, arguments);
                    };
                  }()));
                case 1:
                  links = _context258.v;
                  return _context258.a(2, dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(function (link) {
                    return link.rel === "stylesheet" || link.rel === "preload";
                  }).map(function (link) {
                    return link.rel === "stylesheet" ? _objectSpread3(_objectSpread3({}, link), {}, {
                      rel: "prefetch",
                      as: "style"
                    }) : _objectSpread3(_objectSpread3({}, link), {}, {
                      rel: "prefetch"
                    });
                  })));
              }
            }, _callee257);
          }));
          return _getKeyedPrefetchLinks.apply(this, arguments);
        }
        function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
          var isNew = function isNew(match, index) {
            if (!currentMatches[index]) return true;
            return match.route.id !== currentMatches[index].route.id;
          };
          var matchPathChanged = function matchPathChanged(match, index) {
            var _currentMatches$index;
            return (
              // param change, /users/123 -> /users/456
              currentMatches[index].pathname !== match.pathname ||
              // splat param changed, which is not present in match.path
              // e.g. /files/images/avatar.jpg -> files/finances.xls
              ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
            );
          };
          if (mode === "assets") {
            return nextMatches.filter(function (match, index) {
              return isNew(match, index) || matchPathChanged(match, index);
            });
          }
          if (mode === "data") {
            return nextMatches.filter(function (match, index) {
              var manifestRoute = manifest.routes[match.route.id];
              if (!manifestRoute || !manifestRoute.hasLoader) {
                return false;
              }
              if (isNew(match, index) || matchPathChanged(match, index)) {
                return true;
              }
              if (match.route.shouldRevalidate) {
                var _currentMatches$;
                var routeChoice = match.route.shouldRevalidate({
                  currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
                  currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
                  nextUrl: new URL(page, window.origin),
                  nextParams: match.params,
                  defaultShouldRevalidate: true
                });
                if (typeof routeChoice === "boolean") {
                  return routeChoice;
                }
              }
              return true;
            });
          }
          return [];
        }
        function getModuleLinkHrefs(matches, manifest) {
          var _ref17 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            includeHydrateFallback = _ref17.includeHydrateFallback;
          return dedupeHrefs(matches.map(function (match) {
            var route = manifest.routes[match.route.id];
            if (!route) return [];
            var hrefs = [route.module];
            if (route.clientActionModule) {
              hrefs = hrefs.concat(route.clientActionModule);
            }
            if (route.clientLoaderModule) {
              hrefs = hrefs.concat(route.clientLoaderModule);
            }
            if (includeHydrateFallback && route.hydrateFallbackModule) {
              hrefs = hrefs.concat(route.hydrateFallbackModule);
            }
            if (route.imports) {
              hrefs = hrefs.concat(route.imports);
            }
            return hrefs;
          }).flat(1));
        }
        function dedupeHrefs(hrefs) {
          return _toConsumableArray(new Set(hrefs));
        }
        function sortKeys(obj) {
          var sorted = {};
          var keys = Object.keys(obj).sort();
          var _iterator6 = _createForOfIteratorHelper(keys),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var key = _step6.value;
              sorted[key] = obj[key];
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return sorted;
        }
        function dedupeLinkDescriptors(descriptors, preloads) {
          var set = /* @__PURE__ */new Set();
          new Set(preloads);
          return descriptors.reduce(function (deduped, descriptor) {
            var key = JSON.stringify(sortKeys(descriptor));
            if (!set.has(key)) {
              set.add(key);
              deduped.push({
                key: key,
                link: descriptor
              });
            }
            return deduped;
          }, []);
        }
        function useDataRouterContext2() {
          var context = reactExports.useContext(DataRouterContext);
          invariant2(context, "You must render this element inside a <DataRouterContext.Provider> element");
          return context;
        }
        function useDataRouterStateContext() {
          var context = reactExports.useContext(DataRouterStateContext);
          invariant2(context, "You must render this element inside a <DataRouterStateContext.Provider> element");
          return context;
        }
        var FrameworkContext = reactExports.createContext(void 0);
        FrameworkContext.displayName = "FrameworkContext";
        function useFrameworkContext() {
          var context = reactExports.useContext(FrameworkContext);
          invariant2(context, "You must render this element inside a <HydratedRouter> element");
          return context;
        }
        function usePrefetchBehavior(prefetch, theirElementProps) {
          var frameworkContext = reactExports.useContext(FrameworkContext);
          var _reactExports$useStat = reactExports.useState(false),
            _reactExports$useStat2 = _slicedToArray(_reactExports$useStat, 2),
            maybePrefetch = _reactExports$useStat2[0],
            setMaybePrefetch = _reactExports$useStat2[1];
          var _reactExports$useStat3 = reactExports.useState(false),
            _reactExports$useStat4 = _slicedToArray(_reactExports$useStat3, 2),
            shouldPrefetch = _reactExports$useStat4[0],
            setShouldPrefetch = _reactExports$useStat4[1];
          var onFocus = theirElementProps.onFocus,
            onBlur = theirElementProps.onBlur,
            onMouseEnter = theirElementProps.onMouseEnter,
            onMouseLeave = theirElementProps.onMouseLeave,
            onTouchStart = theirElementProps.onTouchStart;
          var ref = reactExports.useRef(null);
          reactExports.useEffect(function () {
            if (prefetch === "render") {
              setShouldPrefetch(true);
            }
            if (prefetch === "viewport") {
              var callback = function callback(entries) {
                entries.forEach(function (entry) {
                  setShouldPrefetch(entry.isIntersecting);
                });
              };
              var observer = new IntersectionObserver(callback, {
                threshold: 0.5
              });
              if (ref.current) observer.observe(ref.current);
              return function () {
                observer.disconnect();
              };
            }
          }, [prefetch]);
          reactExports.useEffect(function () {
            if (maybePrefetch) {
              var _id = setTimeout(function () {
                setShouldPrefetch(true);
              }, 100);
              return function () {
                clearTimeout(_id);
              };
            }
          }, [maybePrefetch]);
          var setIntent = function setIntent() {
            setMaybePrefetch(true);
          };
          var cancelIntent = function cancelIntent() {
            setMaybePrefetch(false);
            setShouldPrefetch(false);
          };
          if (!frameworkContext) {
            return [false, ref, {}];
          }
          if (prefetch !== "intent") {
            return [shouldPrefetch, ref, {}];
          }
          return [shouldPrefetch, ref, {
            onFocus: composeEventHandlers(onFocus, setIntent),
            onBlur: composeEventHandlers(onBlur, cancelIntent),
            onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
            onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
            onTouchStart: composeEventHandlers(onTouchStart, setIntent)
          }];
        }
        function composeEventHandlers(theirHandler, ourHandler) {
          return function (event) {
            theirHandler && theirHandler(event);
            if (!event.defaultPrevented) {
              ourHandler(event);
            }
          };
        }
        function PrefetchPageLinks(_ref18) {
          var page = _ref18.page,
            linkProps = _objectWithoutProperties2(_ref18, _excluded2);
          var _useDataRouterContext2 = useDataRouterContext2(),
            router = _useDataRouterContext2.router;
          var matches = reactExports.useMemo(function () {
            return matchRoutes(router.routes, page, router.basename);
          }, [router.routes, page, router.basename]);
          if (!matches) {
            return null;
          }
          return /* @__PURE__ */reactExports.createElement(PrefetchPageLinksImpl, _objectSpread3({
            page: page,
            matches: matches
          }, linkProps));
        }
        function useKeyedPrefetchLinks(matches) {
          var _useFrameworkContext = useFrameworkContext(),
            manifest = _useFrameworkContext.manifest,
            routeModules = _useFrameworkContext.routeModules;
          var _reactExports$useStat5 = reactExports.useState([]),
            _reactExports$useStat6 = _slicedToArray(_reactExports$useStat5, 2),
            keyedPrefetchLinks = _reactExports$useStat6[0],
            setKeyedPrefetchLinks = _reactExports$useStat6[1];
          reactExports.useEffect(function () {
            var interrupted = false;
            void getKeyedPrefetchLinks(matches, manifest, routeModules).then(function (links) {
              if (!interrupted) {
                setKeyedPrefetchLinks(links);
              }
            });
            return function () {
              interrupted = true;
            };
          }, [matches, manifest, routeModules]);
          return keyedPrefetchLinks;
        }
        function PrefetchPageLinksImpl(_ref19) {
          var page = _ref19.page,
            nextMatches = _ref19.matches,
            linkProps = _objectWithoutProperties2(_ref19, _excluded3);
          var location = useLocation();
          var _useFrameworkContext2 = useFrameworkContext(),
            future = _useFrameworkContext2.future,
            manifest = _useFrameworkContext2.manifest,
            routeModules = _useFrameworkContext2.routeModules;
          var _useDataRouterContext3 = useDataRouterContext2(),
            basename = _useDataRouterContext3.basename;
          var _useDataRouterStateCo = useDataRouterStateContext(),
            loaderData = _useDataRouterStateCo.loaderData,
            matches = _useDataRouterStateCo.matches;
          var newMatchesForData = reactExports.useMemo(function () {
            return getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data");
          }, [page, nextMatches, matches, manifest, location]);
          var newMatchesForAssets = reactExports.useMemo(function () {
            return getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets");
          }, [page, nextMatches, matches, manifest, location]);
          var dataHrefs = reactExports.useMemo(function () {
            if (page === location.pathname + location.search + location.hash) {
              return [];
            }
            var routesParams = /* @__PURE__ */new Set();
            var foundOptOutRoute = false;
            nextMatches.forEach(function (m) {
              var _routeModules$m$route;
              var manifestRoute = manifest.routes[m.route.id];
              if (!manifestRoute || !manifestRoute.hasLoader) {
                return;
              }
              if (!newMatchesForData.some(function (m2) {
                return m2.route.id === m.route.id;
              }) && m.route.id in loaderData && (_routeModules$m$route = routeModules[m.route.id]) !== null && _routeModules$m$route !== void 0 && _routeModules$m$route.shouldRevalidate) {
                foundOptOutRoute = true;
              } else if (manifestRoute.hasClientLoader) {
                foundOptOutRoute = true;
              } else {
                routesParams.add(m.route.id);
              }
            });
            if (routesParams.size === 0) {
              return [];
            }
            var url = singleFetchUrl(page, basename, future.unstable_trailingSlashAwareDataRequests, "data");
            if (foundOptOutRoute && routesParams.size > 0) {
              url.searchParams.set("_routes", nextMatches.filter(function (m) {
                return routesParams.has(m.route.id);
              }).map(function (m) {
                return m.route.id;
              }).join(","));
            }
            return [url.pathname + url.search];
          }, [basename, future.unstable_trailingSlashAwareDataRequests, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]);
          var moduleHrefs = reactExports.useMemo(function () {
            return getModuleLinkHrefs(newMatchesForAssets, manifest);
          }, [newMatchesForAssets, manifest]);
          var keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
          return /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, dataHrefs.map(function (href) {
            return /* @__PURE__ */reactExports.createElement("link", _objectSpread3({
              key: href,
              rel: "prefetch",
              as: "fetch",
              href: href
            }, linkProps));
          }), moduleHrefs.map(function (href) {
            return /* @__PURE__ */reactExports.createElement("link", _objectSpread3({
              key: href,
              rel: "modulepreload",
              href: href
            }, linkProps));
          }), keyedPrefetchLinks.map(function (_ref20) {
            var key = _ref20.key,
              link = _ref20.link;
            return (
              // these don't spread `linkProps` because they are full link descriptors
              // already with their own props
              /* @__PURE__ */
              reactExports.createElement("link", _objectSpread3({
                key: key,
                nonce: linkProps.nonce
              }, link))
            );
          }));
        }
        function mergeRefs$1() {
          for (var _len2 = arguments.length, refs = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
            refs[_key3] = arguments[_key3];
          }
          return function (value) {
            refs.forEach(function (ref) {
              if (typeof ref === "function") {
                ref(value);
              } else if (ref != null) {
                ref.current = value;
              }
            });
          };
        }
        var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
        try {
          if (isBrowser2) {
            window.__reactRouterVersion =
            // @ts-expect-error
            "7.12.0";
          }
        } catch (e) {}
        function HashRouter(_ref21) {
          var basename = _ref21.basename,
            children = _ref21.children,
            unstable_useTransitions = _ref21.unstable_useTransitions,
            window2 = _ref21.window;
          var historyRef = reactExports.useRef();
          if (historyRef.current == null) {
            historyRef.current = createHashHistory({
              window: window2,
              v5Compat: true
            });
          }
          var history = historyRef.current;
          var _reactExports$useStat7 = reactExports.useState({
              action: history.action,
              location: history.location
            }),
            _reactExports$useStat8 = _slicedToArray(_reactExports$useStat7, 2),
            state = _reactExports$useStat8[0],
            setStateImpl = _reactExports$useStat8[1];
          var setState = reactExports.useCallback(function (newState) {
            if (unstable_useTransitions === false) {
              setStateImpl(newState);
            } else {
              reactExports.startTransition(function () {
                return setStateImpl(newState);
              });
            }
          }, [unstable_useTransitions]);
          reactExports.useLayoutEffect(function () {
            return history.listen(setState);
          }, [history, setState]);
          return /* @__PURE__ */reactExports.createElement(Router, {
            basename: basename,
            children: children,
            location: state.location,
            navigationType: state.action,
            navigator: history,
            unstable_useTransitions: unstable_useTransitions
          });
        }
        var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
        var Link$1 = reactExports.forwardRef(function LinkWithRef(_ref22, forwardedRef) {
          var onClick = _ref22.onClick,
            _ref22$discover = _ref22.discover,
            discover = _ref22$discover === void 0 ? "render" : _ref22$discover,
            _ref22$prefetch = _ref22.prefetch,
            prefetch = _ref22$prefetch === void 0 ? "none" : _ref22$prefetch,
            relative = _ref22.relative,
            reloadDocument = _ref22.reloadDocument,
            replace2 = _ref22.replace,
            state = _ref22.state,
            target = _ref22.target,
            to = _ref22.to,
            preventScrollReset = _ref22.preventScrollReset,
            viewTransition = _ref22.viewTransition,
            unstable_defaultShouldRevalidate = _ref22.unstable_defaultShouldRevalidate,
            rest = _objectWithoutProperties2(_ref22, _excluded4);
          var _reactExports$useCont0 = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont0.basename,
            unstable_useTransitions = _reactExports$useCont0.unstable_useTransitions;
          var isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
          var parsed = parseToInfo(to, basename);
          to = parsed.to;
          var href = useHref(to, {
            relative: relative
          });
          var _usePrefetchBehavior = usePrefetchBehavior(prefetch, rest),
            _usePrefetchBehavior2 = _slicedToArray(_usePrefetchBehavior, 3),
            shouldPrefetch = _usePrefetchBehavior2[0],
            prefetchRef = _usePrefetchBehavior2[1],
            prefetchHandlers = _usePrefetchBehavior2[2];
          var internalOnClick = useLinkClickHandler(to, {
            replace: replace2,
            state: state,
            target: target,
            preventScrollReset: preventScrollReset,
            relative: relative,
            viewTransition: viewTransition,
            unstable_defaultShouldRevalidate: unstable_defaultShouldRevalidate,
            unstable_useTransitions: unstable_useTransitions
          });
          function handleClick(event) {
            if (onClick) onClick(event);
            if (!event.defaultPrevented) {
              internalOnClick(event);
            }
          }
          var link =
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */
          reactExports.createElement("a", _objectSpread3(_objectSpread3(_objectSpread3({}, rest), prefetchHandlers), {}, {
            href: parsed.absoluteURL || href,
            onClick: parsed.isExternal || reloadDocument ? onClick : handleClick,
            ref: mergeRefs$1(forwardedRef, prefetchRef),
            target: target,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }));
          return shouldPrefetch && !isAbsolute ? /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */reactExports.createElement(PrefetchPageLinks, {
            page: href
          })) : link;
        });
        Link$1.displayName = "Link";
        var NavLink = reactExports.forwardRef(function NavLinkWithRef(_ref23, ref) {
          var _ref23$ariaCurrent = _ref23["aria-current"],
            ariaCurrentProp = _ref23$ariaCurrent === void 0 ? "page" : _ref23$ariaCurrent,
            _ref23$caseSensitive = _ref23.caseSensitive,
            caseSensitive = _ref23$caseSensitive === void 0 ? false : _ref23$caseSensitive,
            _ref23$className = _ref23.className,
            classNameProp = _ref23$className === void 0 ? "" : _ref23$className,
            _ref23$end = _ref23.end,
            end = _ref23$end === void 0 ? false : _ref23$end,
            styleProp = _ref23.style,
            to = _ref23.to,
            viewTransition = _ref23.viewTransition,
            children = _ref23.children,
            rest = _objectWithoutProperties2(_ref23, _excluded5);
          var path = useResolvedPath(to, {
            relative: rest.relative
          });
          var location = useLocation();
          var routerState = reactExports.useContext(DataRouterStateContext);
          var _reactExports$useCont1 = reactExports.useContext(NavigationContext),
            navigator = _reactExports$useCont1.navigator,
            basename = _reactExports$useCont1.basename;
          var isTransitioning = routerState != null &&
          // Conditional usage is OK here because the usage of a data router is static
          // eslint-disable-next-line react-hooks/rules-of-hooks
          useViewTransitionState(path) && viewTransition === true;
          var toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
          var locationPathname = location.pathname;
          var nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
          if (!caseSensitive) {
            locationPathname = locationPathname.toLowerCase();
            nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
            toPathname = toPathname.toLowerCase();
          }
          if (nextLocationPathname && basename) {
            nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
          }
          var endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
          var isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
          var isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
          var renderProps = {
            isActive: isActive,
            isPending: isPending,
            isTransitioning: isTransitioning
          };
          var ariaCurrent = isActive ? ariaCurrentProp : void 0;
          var className;
          if (typeof classNameProp === "function") {
            className = classNameProp(renderProps);
          } else {
            className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
          }
          var style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
          return /* @__PURE__ */reactExports.createElement(Link$1, _objectSpread3(_objectSpread3({}, rest), {}, {
            "aria-current": ariaCurrent,
            className: className,
            ref: ref,
            style: style,
            to: to,
            viewTransition: viewTransition
          }), typeof children === "function" ? children(renderProps) : children);
        });
        NavLink.displayName = "NavLink";
        var Form = reactExports.forwardRef(function (_ref24, forwardedRef) {
          var _ref24$discover = _ref24.discover,
            discover = _ref24$discover === void 0 ? "render" : _ref24$discover,
            fetcherKey = _ref24.fetcherKey,
            navigate = _ref24.navigate,
            reloadDocument = _ref24.reloadDocument,
            replace2 = _ref24.replace,
            state = _ref24.state,
            _ref24$method = _ref24.method,
            method = _ref24$method === void 0 ? defaultMethod : _ref24$method,
            action = _ref24.action,
            onSubmit = _ref24.onSubmit,
            relative = _ref24.relative,
            preventScrollReset = _ref24.preventScrollReset,
            viewTransition = _ref24.viewTransition,
            unstable_defaultShouldRevalidate = _ref24.unstable_defaultShouldRevalidate,
            props = _objectWithoutProperties2(_ref24, _excluded6);
          var _reactExports$useCont10 = reactExports.useContext(NavigationContext),
            unstable_useTransitions = _reactExports$useCont10.unstable_useTransitions;
          var submit = useSubmit();
          var formAction = useFormAction(action, {
            relative: relative
          });
          var formMethod = method.toLowerCase() === "get" ? "get" : "post";
          var isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
          var submitHandler = function submitHandler(event) {
            onSubmit && onSubmit(event);
            if (event.defaultPrevented) return;
            event.preventDefault();
            var submitter = event.nativeEvent.submitter;
            var submitMethod = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || method;
            var doSubmit = function doSubmit() {
              return submit(submitter || event.currentTarget, {
                fetcherKey: fetcherKey,
                method: submitMethod,
                navigate: navigate,
                replace: replace2,
                state: state,
                relative: relative,
                preventScrollReset: preventScrollReset,
                viewTransition: viewTransition,
                unstable_defaultShouldRevalidate: unstable_defaultShouldRevalidate
              });
            };
            if (unstable_useTransitions && navigate !== false) {
              reactExports.startTransition(function () {
                return doSubmit();
              });
            } else {
              doSubmit();
            }
          };
          return /* @__PURE__ */reactExports.createElement("form", _objectSpread3(_objectSpread3({
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler
          }, props), {}, {
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }));
        });
        Form.displayName = "Form";
        function getDataRouterConsoleError2(hookName) {
          return "".concat(hookName, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.");
        }
        function useDataRouterContext3(hookName) {
          var ctx = reactExports.useContext(DataRouterContext);
          invariant$1(ctx, getDataRouterConsoleError2(hookName));
          return ctx;
        }
        function useLinkClickHandler(to) {
          var _ref25 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            target = _ref25.target,
            replaceProp = _ref25.replace,
            state = _ref25.state,
            preventScrollReset = _ref25.preventScrollReset,
            relative = _ref25.relative,
            viewTransition = _ref25.viewTransition,
            unstable_defaultShouldRevalidate = _ref25.unstable_defaultShouldRevalidate,
            unstable_useTransitions = _ref25.unstable_useTransitions;
          var navigate = useNavigate();
          var location = useLocation();
          var path = useResolvedPath(to, {
            relative: relative
          });
          return reactExports.useCallback(function (event) {
            if (shouldProcessLinkClick(event, target)) {
              event.preventDefault();
              var replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
              var doNavigate = function doNavigate() {
                return navigate(to, {
                  replace: replace2,
                  state: state,
                  preventScrollReset: preventScrollReset,
                  relative: relative,
                  viewTransition: viewTransition,
                  unstable_defaultShouldRevalidate: unstable_defaultShouldRevalidate
                });
              };
              if (unstable_useTransitions) {
                reactExports.startTransition(function () {
                  return doNavigate();
                });
              } else {
                doNavigate();
              }
            }
          }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition, unstable_defaultShouldRevalidate, unstable_useTransitions]);
        }
        var fetcherId = 0;
        var getUniqueFetcherId = function getUniqueFetcherId() {
          return "__".concat(String(++fetcherId), "__");
        };
        function useSubmit() {
          var _useDataRouterContext4 = useDataRouterContext3("useSubmit"
            /* UseSubmit */),
            router = _useDataRouterContext4.router;
          var _reactExports$useCont11 = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont11.basename;
          var currentRouteId = useRouteId();
          var routerFetch = router.fetch;
          var routerNavigate = router.navigate;
          return reactExports.useCallback(/*#__PURE__*/function () {
            var _ref26 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(target) {
              var options,
                _getFormSubmissionInf,
                action,
                method,
                encType,
                formData,
                body,
                key,
                _args2 = arguments;
              return _regenerator().w(function (_context2) {
                while (1) switch (_context2.n) {
                  case 0:
                    options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                    _getFormSubmissionInf = getFormSubmissionInfo(target, basename), action = _getFormSubmissionInf.action, method = _getFormSubmissionInf.method, encType = _getFormSubmissionInf.encType, formData = _getFormSubmissionInf.formData, body = _getFormSubmissionInf.body;
                    if (!(options.navigate === false)) {
                      _context2.n = 2;
                      break;
                    }
                    key = options.fetcherKey || getUniqueFetcherId();
                    _context2.n = 1;
                    return routerFetch(key, currentRouteId, options.action || action, {
                      unstable_defaultShouldRevalidate: options.unstable_defaultShouldRevalidate,
                      preventScrollReset: options.preventScrollReset,
                      formData: formData,
                      body: body,
                      formMethod: options.method || method,
                      formEncType: options.encType || encType,
                      flushSync: options.flushSync
                    });
                  case 1:
                    _context2.n = 3;
                    break;
                  case 2:
                    _context2.n = 3;
                    return routerNavigate(options.action || action, {
                      unstable_defaultShouldRevalidate: options.unstable_defaultShouldRevalidate,
                      preventScrollReset: options.preventScrollReset,
                      formData: formData,
                      body: body,
                      formMethod: options.method || method,
                      formEncType: options.encType || encType,
                      replace: options.replace,
                      state: options.state,
                      fromRouteId: currentRouteId,
                      flushSync: options.flushSync,
                      viewTransition: options.viewTransition
                    });
                  case 3:
                    return _context2.a(2);
                }
              }, _callee2);
            }));
            return function (_x7) {
              return _ref26.apply(this, arguments);
            };
          }(), [routerFetch, routerNavigate, basename, currentRouteId]);
        }
        function useFormAction(action) {
          var _ref27 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            relative = _ref27.relative;
          var _reactExports$useCont12 = reactExports.useContext(NavigationContext),
            basename = _reactExports$useCont12.basename;
          var routeContext = reactExports.useContext(RouteContext);
          invariant$1(routeContext, "useFormAction must be used inside a RouteContext");
          var _routeContext$matches = routeContext.matches.slice(-1),
            _routeContext$matches2 = _slicedToArray(_routeContext$matches, 1),
            match = _routeContext$matches2[0];
          var path = _objectSpread3({}, useResolvedPath(action ? action : ".", {
            relative: relative
          }));
          var location = useLocation();
          if (action == null) {
            path.search = location.search;
            var params = new URLSearchParams(path.search);
            var indexValues = params.getAll("index");
            var hasNakedIndexParam = indexValues.some(function (v) {
              return v === "";
            });
            if (hasNakedIndexParam) {
              params.delete("index");
              indexValues.filter(function (v) {
                return v;
              }).forEach(function (v) {
                return params.append("index", v);
              });
              var qs = params.toString();
              path.search = qs ? "?".concat(qs) : "";
            }
          }
          if ((!action || action === ".") && match.route.index) {
            path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
          }
          if (basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
          }
          return createPath(path);
        }
        function useViewTransitionState(to) {
          var _ref28 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            relative = _ref28.relative;
          var vtContext = reactExports.useContext(ViewTransitionContext);
          invariant$1(vtContext != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
          var _useDataRouterContext5 = useDataRouterContext3("useViewTransitionState"
            /* useViewTransitionState */),
            basename = _useDataRouterContext5.basename;
          var path = useResolvedPath(to, {
            relative: relative
          });
          if (!vtContext.isTransitioning) {
            return false;
          }
          var currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
          var nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
          return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
        }
        function isHTMLElement$1(el) {
          return el != null && _typeof2(el) == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
        }
        function isBrowser$3() {
          return Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document);
        }
        function isHiddenElement(element) {
          if (element.parentElement && isHiddenElement(element.parentElement)) return true;
          return element.hidden;
        }
        function isContentEditableElement(element) {
          var value = element.getAttribute("contenteditable");
          return value !== "false" && value != null;
        }
        function isDisabledElement(element) {
          return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
        }
        function assignAfter(target) {
          if (target == null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var result = _objectSpread3({}, target);
          for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
            sources[_key4 - 1] = arguments[_key4];
          }
          for (var _i2 = 0, _sources = sources; _i2 < _sources.length; _i2++) {
            var nextSource = _sources[_i2];
            if (nextSource == null) continue;
            for (var nextKey in nextSource) {
              if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue;
              if (nextKey in result) delete result[nextKey];
              result[nextKey] = nextSource[nextKey];
            }
          }
          return result;
        }
        var dataAttr = function dataAttr(condition) {
          return condition ? "" : void 0;
        };
        var ariaAttr = function ariaAttr(condition) {
          return condition ? true : void 0;
        };
        function isArray(value) {
          return Array.isArray(value);
        }
        function isObject(value) {
          var type = _typeof2(value);
          return value != null && (type === "object" || type === "function") && !isArray(value);
        }
        function getLastItem(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : void 0;
        }
        function analyzeCSSValue$1(value) {
          var num = parseFloat(value.toString());
          var unit = value.toString().replace(String(num), "");
          return {
            unitless: !unit,
            value: num,
            unit: unit
          };
        }
        function px$1(value) {
          if (value == null) return value;
          var _analyzeCSSValue$ = analyzeCSSValue$1(value),
            unitless = _analyzeCSSValue$.unitless;
          return unitless || typeof value === "number" ? "".concat(value, "px") : value;
        }
        var sortByBreakpointValue = function sortByBreakpointValue(a, b) {
          return parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
        };
        var sortBps = function sortBps(breakpoints) {
          return Object.fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
        };
        function normalize$1(breakpoints) {
          var sorted = sortBps(breakpoints);
          return Object.assign(Object.values(sorted), sorted);
        }
        function keys(breakpoints) {
          var value = Object.keys(sortBps(breakpoints));
          return new Set(value);
        }
        function subtract$2(value) {
          var _px$;
          if (!value) return value;
          value = (_px$ = px$1(value)) !== null && _px$ !== void 0 ? _px$ : value;
          var OFFSET = -0.02;
          return typeof value === "number" ? "".concat(value + OFFSET) : value.replace(/([0-9]+\.?[0-9]*)/, function (m) {
            return "".concat(parseFloat(m) + OFFSET);
          });
        }
        function toMediaQueryString(min, max) {
          var query = ["@media screen"];
          if (min) query.push("and", "(min-width: ".concat(px$1(min), ")"));
          if (max) query.push("and", "(max-width: ".concat(px$1(max), ")"));
          return query.join(" ");
        }
        function analyzeBreakpoints(breakpoints) {
          var _breakpoints$base;
          if (!breakpoints) return null;
          breakpoints.base = (_breakpoints$base = breakpoints.base) !== null && _breakpoints$base !== void 0 ? _breakpoints$base : "0px";
          var normalized = normalize$1(breakpoints);
          var queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(function (_ref29, index, entry) {
            var _entry;
            var _ref30 = _slicedToArray(_ref29, 2),
              breakpoint = _ref30[0],
              minW = _ref30[1];
            var _ref31 = (_entry = entry[index + 1]) !== null && _entry !== void 0 ? _entry : [],
              _ref32 = _slicedToArray(_ref31, 2),
              maxW = _ref32[1];
            maxW = parseFloat(maxW) > 0 ? subtract$2(maxW) : void 0;
            return {
              _minW: subtract$2(minW),
              breakpoint: breakpoint,
              minW: minW,
              maxW: maxW,
              maxWQuery: toMediaQueryString(null, maxW),
              minWQuery: toMediaQueryString(minW),
              minMaxQuery: toMediaQueryString(minW, maxW)
            };
          });
          var _keys = keys(breakpoints);
          var _keysArr = Array.from(_keys.values());
          return {
            keys: _keys,
            normalized: normalized,
            isResponsive: function isResponsive(test) {
              var keys2 = Object.keys(test);
              return keys2.length > 0 && keys2.every(function (key) {
                return _keys.has(key);
              });
            },
            asObject: sortBps(breakpoints),
            asArray: normalize$1(breakpoints),
            details: queries,
            get: function get(key) {
              return queries.find(function (q) {
                return q.breakpoint === key;
              });
            },
            media: [null].concat(_toConsumableArray(normalized.map(function (minW) {
              return toMediaQueryString(minW);
            }).slice(1))),
            /**
             * Converts the object responsive syntax to array syntax
             *
             * @example
             * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
             */
            toArrayValue: function toArrayValue(test) {
              if (!isObject(test)) {
                throw new Error("toArrayValue: value must be an object");
              }
              var result = _keysArr.map(function (bp) {
                var _test$bp;
                return (_test$bp = test[bp]) !== null && _test$bp !== void 0 ? _test$bp : null;
              });
              while (getLastItem(result) === null) {
                result.pop();
              }
              return result;
            },
            /**
             * Converts the array responsive syntax to object syntax
             *
             * @example
             * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
             */
            toObjectValue: function toObjectValue(test) {
              if (!Array.isArray(test)) {
                throw new Error("toObjectValue: value must be an array");
              }
              return test.reduce(function (acc, value, index) {
                var key = _keysArr[index];
                if (key != null && value != null) acc[key] = value;
                return acc;
              }, {});
            }
          };
        }
        function callAllHandlers() {
          for (var _len4 = arguments.length, fns = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
            fns[_key5] = arguments[_key5];
          }
          return function func(event) {
            fns.some(function (fn) {
              fn === null || fn === void 0 || fn(event);
              return event === null || event === void 0 ? void 0 : event.defaultPrevented;
            });
          };
        }
        function getValidChildren(children) {
          return reactExports.Children.toArray(children).filter(function (child) {
            return reactExports.isValidElement(child);
          });
        }
        function compact(object) {
          var clone = Object.assign({}, object);
          for (var key in clone) {
            if (clone[key] === void 0) delete clone[key];
          }
          return clone;
        }
        function getErrorMessage(hook, provider) {
          return "".concat(hook, " returned `undefined`. Seems you forgot to wrap component within ").concat(provider);
        }
        function createContext() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var name = options.name,
            _options$strict = options.strict,
            strict = _options$strict === void 0 ? true : _options$strict,
            _options$hookName = options.hookName,
            hookName = _options$hookName === void 0 ? "useContext" : _options$hookName,
            _options$providerName = options.providerName,
            providerName = _options$providerName === void 0 ? "Provider" : _options$providerName,
            errorMessage = options.errorMessage,
            defaultValue = options.defaultValue;
          var Context = reactExports.createContext(defaultValue);
          Context.displayName = name;
          function useContext$1() {
            var context = reactExports.useContext(Context);
            if (!context && strict) {
              var _Error$captureStackTr;
              var error = new Error(errorMessage !== null && errorMessage !== void 0 ? errorMessage : getErrorMessage(hookName, providerName));
              error.name = "ContextError";
              (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, error, useContext$1);
              throw error;
            }
            return context;
          }
          return [Context.Provider, useContext$1, Context];
        }
        var cx = exports("d", function () {
          for (var _len5 = arguments.length, classNames = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
            classNames[_key6] = arguments[_key6];
          }
          return classNames.filter(Boolean).join(" ");
        });
        var hasTabIndex = function hasTabIndex(element) {
          return element.hasAttribute("tabindex");
        };
        function isFocusable(element) {
          if (!isHTMLElement$1(element) || isHiddenElement(element) || isDisabledElement(element)) {
            return false;
          }
          var localName = element.localName;
          var focusableTags = ["input", "select", "textarea", "button"];
          if (focusableTags.indexOf(localName) >= 0) return true;
          var others = {
            a: function a() {
              return element.hasAttribute("href");
            },
            audio: function audio() {
              return element.hasAttribute("controls");
            },
            video: function video() {
              return element.hasAttribute("controls");
            }
          };
          if (localName in others) {
            return others[localName]();
          }
          if (isContentEditableElement(element)) return true;
          return hasTabIndex(element);
        }
        var focusableElList = ["input:not(:disabled):not([disabled])", "select:not(:disabled):not([disabled])", "textarea:not(:disabled):not([disabled])", "embed", "iframe", "object", "a[href]", "area[href]", "button:not(:disabled):not([disabled])", "[tabindex]", "audio[controls]", "video[controls]", "*[tabindex]:not([aria-disabled])", "*[contenteditable]"];
        var focusableElSelector = focusableElList.join();
        var isVisible = function isVisible(el) {
          return el.offsetWidth > 0 && el.offsetHeight > 0;
        };
        function getAllFocusable(container) {
          var focusableEls = Array.from(container.querySelectorAll(focusableElSelector));
          focusableEls.unshift(container);
          return focusableEls.filter(function (el) {
            return isFocusable(el) && isVisible(el);
          });
        }
        function get$3(obj, path, fallback, index) {
          var key = typeof path === "string" ? path.split(".") : [path];
          for (index = 0; index < key.length; index += 1) {
            if (!obj) break;
            obj = obj[key[index]];
          }
          return obj === void 0 ? fallback : obj;
        }
        var memoize$2 = function memoize$2(fn) {
          var cache = /* @__PURE__ */new WeakMap();
          var memoizedFn = function memoizedFn(obj, path, fallback, index) {
            if (typeof obj === "undefined") {
              return fn(obj, path, fallback);
            }
            if (!cache.has(obj)) {
              cache.set(obj, /* @__PURE__ */new Map());
            }
            var map = cache.get(obj);
            if (map.has(path)) {
              return map.get(path);
            }
            var value = fn(obj, path, fallback, index);
            map.set(path, value);
            return value;
          };
          return memoizedFn;
        };
        var memoizedGet$1 = memoize$2(get$3);
        var interopDefault = function interopDefault(mod) {
          return mod.default || mod;
        };
        function lazyDisclosure(options) {
          var wasSelected = options.wasSelected,
            enabled = options.enabled,
            isSelected = options.isSelected,
            _options$mode = options.mode,
            mode = _options$mode === void 0 ? "unmount" : _options$mode;
          if (!enabled) return true;
          if (isSelected) return true;
          if (mode === "keepMounted" && wasSelected) return true;
          return false;
        }
        function omit(object) {
          var keysToOmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var clone = Object.assign({}, object);
          var _iterator7 = _createForOfIteratorHelper(keysToOmit),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var key = _step7.value;
              if (key in clone) {
                delete clone[key];
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          return clone;
        }
        function pick(object, keysToPick) {
          var result = {};
          var _iterator8 = _createForOfIteratorHelper(keysToPick),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var key = _step8.value;
              if (key in object) {
                result[key] = object[key];
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
          return result;
        }
        var breakpoints$1 = exports("_", Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]));
        function mapResponsive(prop, mapper) {
          if (Array.isArray(prop)) {
            return prop.map(function (item) {
              return item === null ? null : mapper(item);
            });
          }
          if (isObject(prop)) {
            return Object.keys(prop).reduce(function (result, key) {
              result[key] = mapper(prop[key]);
              return result;
            }, {});
          }
          if (prop != null) {
            return mapper(prop);
          }
          return null;
        }
        function arrayToObjectNotation(values) {
          var bps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : breakpoints$1;
          var result = {};
          values.forEach(function (value, index) {
            var key = bps[index];
            if (value == null) return;
            result[key] = value;
          });
          return result;
        }
        var isFunction$2 = function isFunction$2(value) {
          return typeof value === "function";
        };
        function runIfFn$1(valueOrFn) {
          for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {
            args[_key7 - 1] = arguments[_key7];
          }
          return isFunction$2(valueOrFn) ? valueOrFn.apply(void 0, args) : valueOrFn;
        }
        function isScrollParent$1(el) {
          var win = el.ownerDocument.defaultView || window;
          var _win$getComputedStyle = win.getComputedStyle(el),
            overflow = _win$getComputedStyle.overflow,
            overflowX = _win$getComputedStyle.overflowX,
            overflowY = _win$getComputedStyle.overflowY;
          return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function getParent(el) {
          if (el.localName === "html") return el;
          return el.assignedSlot || el.parentElement || el.ownerDocument.documentElement;
        }
        function getScrollParent$1(el) {
          if (["html", "body", "#document"].includes(el.localName)) {
            return el.ownerDocument.body;
          }
          if (isHTMLElement$1(el) && isScrollParent$1(el)) {
            return el;
          }
          return getScrollParent$1(getParent(el));
        }
        function split(object, keys) {
          var picked = {};
          var omitted = {};
          for (var _i3 = 0, _Object$entries = Object.entries(object); _i3 < _Object$entries.length; _i3++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];
            if (keys.includes(key)) picked[key] = value;else omitted[key] = value;
          }
          return [picked, omitted];
        }
        function splitProps(props) {
          var descriptors = Object.getOwnPropertyDescriptors(props);
          var dKeys = Object.keys(descriptors);
          var split = function split(k) {
            var clone = {};
            for (var i = 0; i < k.length; i++) {
              var key = k[i];
              if (descriptors[key]) {
                Object.defineProperty(clone, key, descriptors[key]);
                delete descriptors[key];
              }
            }
            return clone;
          };
          var fn = function fn(key) {
            return split(Array.isArray(key) ? key : dKeys.filter(key));
          };
          for (var _len7 = arguments.length, keys = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {
            keys[_key8 - 1] = arguments[_key8];
          }
          return keys.map(fn).concat(split(dKeys));
        }
        function walkObject(target, predicate) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var stop = options.stop,
            getKey = options.getKey;
          function inner(value) {
            var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (isObject(value) || Array.isArray(value)) {
              var result = {};
              for (var _i4 = 0, _Object$entries2 = Object.entries(value); _i4 < _Object$entries2.length; _i4++) {
                var _getKey;
                var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
                  prop = _Object$entries2$_i[0],
                  child = _Object$entries2$_i[1];
                var key = (_getKey = getKey === null || getKey === void 0 ? void 0 : getKey(prop)) !== null && _getKey !== void 0 ? _getKey : prop;
                var childPath = [].concat(_toConsumableArray(path), [key]);
                if (stop !== null && stop !== void 0 && stop(value, childPath)) {
                  return predicate(value, path);
                }
                result[key] = inner(child, childPath);
              }
              return result;
            }
            return predicate(value, path);
          }
          return inner(target);
        }
        var lodash_mergewith = {
          exports: {}
        };

        /**
         * Lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        lodash_mergewith.exports;
        (function (module, exports$1) {
          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200;

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';

          /** Used to detect hot functions by number of calls within a span of milliseconds. */
          var HOT_COUNT = 800,
            HOT_SPAN = 16;

          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          /** Used to identify `toStringTag` values of typed arrays. */
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal = _typeof2(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

          /** Detect free variable `self`. */
          var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == 'object' && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();

          /** Detect free variable `exports`. */
          var freeExports = exports$1 && !exports$1.nodeType && exports$1;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;

          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              if (types) {
                return types;
              }

              // Legacy `process.binding('util')` for Node.js < 10.
              return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
          }();

          /* Node.js helper references. */
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

          /**
           * A faster alternative to `Function#apply`, this function invokes `func`
           * with the `this` binding of `thisArg` and the arguments of `args`.
           *
           * @private
           * @param {Function} func The function to invoke.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} args The arguments to invoke `func` with.
           * @returns {*} Returns the result of `func`.
           */
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }

          /**
           * The base implementation of `_.times` without support for iteratee shorthands
           * or max array length checks.
           *
           * @private
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           */
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }

          /**
           * The base implementation of `_.unary` without support for storing metadata.
           *
           * @private
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           */
          function baseUnary(func) {
            return function (value) {
              return func(value);
            };
          }

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Creates a unary function that invokes `func` with its argument transformed.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {Function} transform The argument transform.
           * @returns {Function} Returns the new function.
           */
          function overArg(func, transform) {
            return function (arg) {
              return func(transform(arg));
            };
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var nativeObjectToString = objectProto.toString;

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object);

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            _Symbol = root.Symbol,
            Uint8Array = root.Uint8Array;
          Buffer ? Buffer.allocUnsafe : undefined;
          var getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeMax = Math.max,
            nativeNow = Date.now;

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map'),
            nativeCreate = getNative(Object, 'create');

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key);
            this.size = data.size;
            return result;
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key);
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key);
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;
            for (var key in value) {
              if (!(skipIndexes && (
              // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' ||
              // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') ||
              // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
              // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }

          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }

          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }

          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
                if (newValue === undefined) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }

          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }

          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            {
              return buffer.slice();
            }
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = cloneArrayBuffer(typedArray.buffer);
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = undefined;
              if (newValue === undefined) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }

          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
              while (length--) {
                var key = props[++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            var type = _typeof2(value);
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = _typeof2(index);
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }
            return false;
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = _typeof2(value);
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }

          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }

          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }

          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }
            if (key == '__proto__') {
              return;
            }
            return object[key];
          }

          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var setToString = shortOut(baseSetToString);

          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined, arguments);
            };
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + '';
              } catch (e) {}
            }
            return '';
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = _typeof2(value);
            return value != null && (type == 'object' || type == 'function');
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return value != null && _typeof2(value) == 'object';
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
          }

          /**
           * This method is like `_.merge` except that it accepts `customizer` which
           * is invoked to produce the merged values of the destination and source
           * properties. If `customizer` returns `undefined`, merging is handled by the
           * method instead. The `customizer` is invoked with six arguments:
           * (objValue, srcValue, key, object, source, stack).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   if (_.isArray(objValue)) {
           *     return objValue.concat(srcValue);
           *   }
           * }
           *
           * var object = { 'a': [1], 'b': [2] };
           * var other = { 'a': [3], 'b': [4] };
           *
           * _.mergeWith(object, other, customizer);
           * // => { 'a': [1, 3], 'b': [2, 4] }
           */
          var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false;
          }
          module.exports = mergeWith;
        })(lodash_mergewith, lodash_mergewith.exports);
        var lodash_mergewithExports = lodash_mergewith.exports;
        var mergeWith = /*@__PURE__*/getDefaultExportFromCjs(lodash_mergewithExports);
        function useCallbackRef$1(callback) {
          var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var callbackRef = reactExports.useRef(callback);
          reactExports.useEffect(function () {
            callbackRef.current = callback;
          });
          return reactExports.useCallback(function () {
            var _callbackRef$current;
            for (var _len8 = arguments.length, args = new Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
              args[_key9] = arguments[_key9];
            }
            return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call.apply(_callbackRef$current, [callbackRef].concat(args));
          }, deps);
        }
        function useEventListener(target, event, handler, options) {
          var listener = useCallbackRef$1(handler);
          reactExports.useEffect(function () {
            var node = typeof target === "function" ? target() : target !== null && target !== void 0 ? target : document;
            if (!handler || !node) return;
            node.addEventListener(event, listener, options);
            return function () {
              node.removeEventListener(event, listener, options);
            };
          }, [event, target, options, listener, handler]);
          return function () {
            var node = typeof target === "function" ? target() : target !== null && target !== void 0 ? target : document;
            node === null || node === void 0 || node.removeEventListener(event, listener, options);
          };
        }
        function useControllableState(props) {
          var valueProp = props.value,
            defaultValue = props.defaultValue,
            onChange = props.onChange,
            _props$shouldUpdate = props.shouldUpdate,
            shouldUpdate = _props$shouldUpdate === void 0 ? function (prev, next) {
              return prev !== next;
            } : _props$shouldUpdate;
          var onChangeProp = useCallbackRef$1(onChange);
          var shouldUpdateProp = useCallbackRef$1(shouldUpdate);
          var _reactExports$useStat9 = reactExports.useState(defaultValue),
            _reactExports$useStat0 = _slicedToArray(_reactExports$useStat9, 2),
            uncontrolledState = _reactExports$useStat0[0],
            setUncontrolledState = _reactExports$useStat0[1];
          var controlled = valueProp !== void 0;
          var value = controlled ? valueProp : uncontrolledState;
          var setValue = useCallbackRef$1(function (next) {
            var setter = next;
            var nextValue = typeof next === "function" ? setter(value) : next;
            if (!shouldUpdateProp(value, nextValue)) {
              return;
            }
            if (!controlled) {
              setUncontrolledState(nextValue);
            }
            onChangeProp(nextValue);
          }, [controlled, onChangeProp, value, shouldUpdateProp]);
          return [value, setValue];
        }
        function useDisclosure() {
          var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var onCloseProp = props.onClose,
            onOpenProp = props.onOpen,
            isOpenProp = props.isOpen,
            idProp = props.id;
          var handleOpen = useCallbackRef$1(onOpenProp);
          var handleClose = useCallbackRef$1(onCloseProp);
          var _reactExports$useStat1 = reactExports.useState(props.defaultIsOpen || false),
            _reactExports$useStat10 = _slicedToArray(_reactExports$useStat1, 2),
            isOpenState = _reactExports$useStat10[0],
            setIsOpen = _reactExports$useStat10[1];
          var isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
          var isControlled = isOpenProp !== void 0;
          var uid = reactExports.useId();
          var id = idProp !== null && idProp !== void 0 ? idProp : "disclosure-".concat(uid);
          var onClose = reactExports.useCallback(function () {
            if (!isControlled) {
              setIsOpen(false);
            }
            handleClose === null || handleClose === void 0 || handleClose();
          }, [isControlled, handleClose]);
          var onOpen = reactExports.useCallback(function () {
            if (!isControlled) {
              setIsOpen(true);
            }
            handleOpen === null || handleOpen === void 0 || handleOpen();
          }, [isControlled, handleOpen]);
          var onToggle = reactExports.useCallback(function () {
            if (isOpen) {
              onClose();
            } else {
              onOpen();
            }
          }, [isOpen, onOpen, onClose]);
          function getButtonProps() {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              "aria-expanded": isOpen,
              "aria-controls": id,
              onClick: function onClick(event) {
                var _props2$onClick;
                (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 || _props2$onClick.call(props2, event);
                onToggle();
              }
            });
          }
          function getDisclosureProps() {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              hidden: !isOpen,
              id: id
            });
          }
          return {
            isOpen: isOpen,
            onOpen: onOpen,
            onClose: onClose,
            onToggle: onToggle,
            isControlled: isControlled,
            getButtonProps: getButtonProps,
            getDisclosureProps: getDisclosureProps
          };
        }
        var useSafeLayoutEffect$2 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : reactExports.useEffect;
        var useUpdateEffect = function useUpdateEffect(effect, deps) {
          var renderCycleRef = reactExports.useRef(false);
          var effectCycleRef = reactExports.useRef(false);
          reactExports.useEffect(function () {
            var isMounted = renderCycleRef.current;
            var shouldRun = isMounted && effectCycleRef.current;
            if (shouldRun) {
              return effect();
            }
            effectCycleRef.current = true;
          }, deps);
          reactExports.useEffect(function () {
            renderCycleRef.current = true;
            return function () {
              renderCycleRef.current = false;
            };
          }, []);
        };
        function assignRef$1(ref, value) {
          if (ref == null) return;
          if (typeof ref === "function") {
            ref(value);
            return;
          }
          try {
            ref.current = value;
          } catch (error) {
            throw new Error("Cannot assign value '".concat(value, "' to ref '").concat(ref, "'"));
          }
        }
        function mergeRefs() {
          for (var _len9 = arguments.length, refs = new Array(_len9), _key0 = 0; _key0 < _len9; _key0++) {
            refs[_key0] = arguments[_key0];
          }
          return function (node) {
            refs.forEach(function (ref) {
              assignRef$1(ref, node);
            });
          };
        }
        function useMergeRefs$1() {
          for (var _len0 = arguments.length, refs = new Array(_len0), _key1 = 0; _key1 < _len0; _key1++) {
            refs[_key1] = arguments[_key1];
          }
          return reactExports.useMemo(function () {
            return mergeRefs.apply(void 0, refs);
          }, refs);
        }
        function useTimeout(callback, delay) {
          var fn = useCallbackRef$1(callback);
          reactExports.useEffect(function () {
            if (delay == null) return void 0;
            var timeoutId = null;
            timeoutId = window.setTimeout(function () {
              fn();
            }, delay);
            return function () {
              if (timeoutId) {
                window.clearTimeout(timeoutId);
              }
            };
          }, [delay, fn]);
        }
        var state = {
          open: function open(str, post) {
            return "".concat(str, "[data-open], ").concat(str, "[open], ").concat(str, "[data-state=open] ").concat(post);
          },
          closed: function closed(str, post) {
            return "".concat(str, "[data-closed], ").concat(str, "[data-state=closed] ").concat(post);
          },
          hover: function hover(str, post) {
            return "".concat(str, ":hover ").concat(post, ", ").concat(str, "[data-hover] ").concat(post);
          },
          focus: function focus(str, post) {
            return "".concat(str, ":focus ").concat(post, ", ").concat(str, "[data-focus] ").concat(post);
          },
          focusVisible: function focusVisible(str, post) {
            return "".concat(str, ":focus-visible ").concat(post);
          },
          focusWithin: function focusWithin(str, post) {
            return "".concat(str, ":focus-within ").concat(post);
          },
          active: function active(str, post) {
            return "".concat(str, ":active ").concat(post, ", ").concat(str, "[data-active] ").concat(post);
          },
          disabled: function disabled(str, post) {
            return "".concat(str, ":disabled ").concat(post, ", ").concat(str, "[data-disabled] ").concat(post);
          },
          invalid: function invalid(str, post) {
            return "".concat(str, ":invalid ").concat(post, ", ").concat(str, "[data-invalid] ").concat(post);
          },
          checked: function checked(str, post) {
            return "".concat(str, ":checked ").concat(post, ", ").concat(str, "[data-checked] ").concat(post);
          },
          placeholderShown: function placeholderShown(str, post) {
            return "".concat(str, ":placeholder-shown ").concat(post);
          }
        };
        var toGroup = function toGroup(fn) {
          return merge(function (v) {
            return fn(v, "&");
          }, "[role=group]", "[data-group]", ".group");
        };
        var toPeer = function toPeer(fn) {
          return merge(function (v) {
            return fn(v, "~ &");
          }, "[data-peer]", ".peer");
        };
        var merge = function merge(fn) {
          for (var _len1 = arguments.length, selectors = new Array(_len1 > 1 ? _len1 - 1 : 0), _key10 = 1; _key10 < _len1; _key10++) {
            selectors[_key10 - 1] = arguments[_key10];
          }
          return selectors.map(fn).join(", ");
        };
        var pseudoSelectors = {
          /**
           * Styles for CSS selector `&:hover`
           */
          _hover: "&:hover, &[data-hover]",
          /**
           * Styles for CSS Selector `&:active`
           */
          _active: "&:active, &[data-active]",
          /**
           * Styles for CSS selector `&:focus`
           *
           */
          _focus: "&:focus, &[data-focus]",
          /**
           * Styles for the highlighted state.
           */
          _highlighted: "&[data-highlighted]",
          /**
           * Styles to apply when a child of this element has received focus
           * - CSS Selector `&:focus-within`
           */
          _focusWithin: "&:focus-within, &[data-focus-within]",
          /**
           * Styles to apply when this element has received focus via tabbing
           * - CSS Selector `&:focus-visible`
           */
          _focusVisible: "&:focus-visible, &[data-focus-visible]",
          /**
           * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
           * - `&[aria-disabled=true]`
           * - `&:disabled`
           * - `&[data-disabled]`
           * - `&[disabled]`
           */
          _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
          /**
           * Styles for CSS Selector `&:readonly`
           */
          _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
          /**
           * Styles for CSS selector `&::before`
           *
           * NOTE:When using this, ensure the `content` is wrapped in a backtick.
           * @example
           * ```jsx
           * <Box _before={{content:`""` }}/>
           * ```
           */
          _before: "&::before",
          /**
           * Styles for CSS selector `&::after`
           *
           * NOTE:When using this, ensure the `content` is wrapped in a backtick.
           * @example
           * ```jsx
           * <Box _after={{content:`""` }}/>
           * ```
           */
          _after: "&::after",
          /**
           * Styles for CSS selector `&:empty`
           */
          _empty: "&:empty, &[data-empty]",
          /**
           * Styles to apply when the ARIA attribute `aria-expanded` is `true`
           * - CSS selector `&[aria-expanded=true]`
           */
          _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
          /**
           * Styles to apply when the ARIA attribute `aria-checked` is `true`
           * - CSS selector `&[aria-checked=true]`
           */
          _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
          /**
           * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
           * - CSS selector `&[aria-grabbed=true]`
           */
          _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
          /**
           * Styles for CSS Selector `&[aria-pressed=true]`
           * Typically used to style the current "pressed" state of toggle buttons
           */
          _pressed: "&[aria-pressed=true], &[data-pressed]",
          /**
           * Styles to apply when the ARIA attribute `aria-invalid` is `true`
           * - CSS selector `&[aria-invalid=true]`
           */
          _invalid: "&[aria-invalid=true], &[data-invalid]",
          /**
           * Styles for the valid state
           * - CSS selector `&[data-valid], &[data-state=valid]`
           */
          _valid: "&[data-valid], &[data-state=valid]",
          /**
           * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
           * Useful for styling loading states
           */
          _loading: "&[data-loading], &[aria-busy=true]",
          /**
           * Styles to apply when the ARIA attribute `aria-selected` is `true`
           *
           * - CSS selector `&[aria-selected=true]`
           */
          _selected: "&[aria-selected=true], &[data-selected]",
          /**
           * Styles for CSS Selector `[hidden=true]`
           */
          _hidden: "&[hidden], &[data-hidden]",
          /**
           * Styles for CSS Selector `&:-webkit-autofill`
           */
          _autofill: "&:-webkit-autofill",
          /**
           * Styles for CSS Selector `&:nth-child(even)`
           */
          _even: "&:nth-of-type(even)",
          /**
           * Styles for CSS Selector `&:nth-child(odd)`
           */
          _odd: "&:nth-of-type(odd)",
          /**
           * Styles for CSS Selector `&:first-of-type`
           */
          _first: "&:first-of-type",
          /**
           * Styles for CSS selector `&::first-letter`
           *
           * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
           * @example
           * ```jsx
           * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
           * ```
           */
          _firstLetter: "&::first-letter",
          /**
           * Styles for CSS Selector `&:last-of-type`
           */
          _last: "&:last-of-type",
          /**
           * Styles for CSS Selector `&:not(:first-of-type)`
           */
          _notFirst: "&:not(:first-of-type)",
          /**
           * Styles for CSS Selector `&:not(:last-of-type)`
           */
          _notLast: "&:not(:last-of-type)",
          /**
           * Styles for CSS Selector `&:visited`
           */
          _visited: "&:visited",
          /**
           * Used to style the active link in a navigation
           * Styles for CSS Selector `&[aria-current=page]`
           */
          _activeLink: "&[aria-current=page]",
          /**
           * Used to style the current step within a process
           * Styles for CSS Selector `&[aria-current=step]`
           */
          _activeStep: "&[aria-current=step]",
          /**
           * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
           * - CSS selector `&[aria-checked=mixed]`
           */
          _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is open
           */
          _groupOpen: toGroup(state.open),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is closed
           */
          _groupClosed: toGroup(state.closed),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
           */
          _groupHover: toGroup(state.hover),
          /**
           * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
           */
          _peerHover: toPeer(state.hover),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
           */
          _groupFocus: toGroup(state.focus),
          /**
           * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
           */
          _peerFocus: toPeer(state.focus),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
           */
          _groupFocusVisible: toGroup(state.focusVisible),
          /**
           * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
           */
          _peerFocusVisible: toPeer(state.focusVisible),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
           */
          _groupActive: toGroup(state.active),
          /**
           * Styles to apply when a sibling element with `.peer` or `data-peer` is active
           */
          _peerActive: toPeer(state.active),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
           */
          _groupDisabled: toGroup(state.disabled),
          /**
           *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
           */
          _peerDisabled: toPeer(state.disabled),
          /**
           *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
           */
          _groupInvalid: toGroup(state.invalid),
          /**
           *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
           */
          _peerInvalid: toPeer(state.invalid),
          /**
           * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
           */
          _groupChecked: toGroup(state.checked),
          /**
           * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
           */
          _peerChecked: toPeer(state.checked),
          /**
           *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
           */
          _groupFocusWithin: toGroup(state.focusWithin),
          /**
           *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
           */
          _peerFocusWithin: toPeer(state.focusWithin),
          /**
           * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
           */
          _peerPlaceholderShown: toPeer(state.placeholderShown),
          /**
           * Styles for CSS Selector `&::placeholder`.
           */
          _placeholder: "&::placeholder, &[data-placeholder]",
          /**
           * Styles for CSS Selector `&:placeholder-shown`.
           */
          _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
          /**
           * Styles for CSS Selector `&:fullscreen`.
           */
          _fullScreen: "&:fullscreen, &[data-fullscreen]",
          /**
           * Styles for CSS Selector `&::selection`
           */
          _selection: "&::selection",
          /**
           * Styles for CSS Selector `[dir=rtl] &`
           * It is applied when a parent element or this element has `dir="rtl"`
           */
          _rtl: "[dir=rtl] &, &[dir=rtl]",
          /**
           * Styles for CSS Selector `[dir=ltr] &`
           * It is applied when a parent element or this element has `dir="ltr"`
           */
          _ltr: "[dir=ltr] &, &[dir=ltr]",
          /**
           * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
           * It is used when the user has requested the system use a light or dark color theme.
           */
          _mediaDark: "@media (prefers-color-scheme: dark)",
          /**
           * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
           * It is used when the user has requested the system to reduce the amount of animations.
           */
          _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
          /**
           * Styles for when `data-theme` is applied to any parent of
           * this component or element.
           */
          _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
          /**
           * Styles for when `data-theme` is applied to any parent of
           * this component or element.
           */
          _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
          /**
           * Styles for the CSS Selector `&[data-orientation=horizontal]`
           */
          _horizontal: "&[data-orientation=horizontal]",
          /**
           * Styles for the CSS Selector `&[data-orientation=vertical]`
           */
          _vertical: "&[data-orientation=vertical]",
          /**
           * Styles for the CSS Selector `&[data-open], &[open], &[data-state=open]`
           */
          _open: "&[data-open], &[open], &[data-state=open]",
          /**
           * Styles for the CSS Selector `&[data-closed], &[data-state=closed]`
           */
          _closed: "&[data-closed], &[data-state=closed]",
          /**
           * Styles for the CSS Selector `&[data-complete]`
           */
          _complete: "&[data-complete]",
          /**
           * Styles for the CSS Selector `&[data-incomplete]`
           */
          _incomplete: "&[data-incomplete]",
          /**
           * Styles for the CSS Selector `&[data-current]`
           */
          _current: "&[data-current]"
        };
        var pseudoPropNames = Object.keys(pseudoSelectors);
        var isImportant = function isImportant(value) {
          return /!(important)?$/.test(value);
        };
        var withoutImportant = function withoutImportant(value) {
          return typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
        };
        var tokenToCSSVar = function tokenToCSSVar(scale, value) {
          return function (theme) {
            var valueStr = String(value);
            var important = isImportant(valueStr);
            var valueWithoutImportant = withoutImportant(valueStr);
            var key = scale ? "".concat(scale, ".").concat(valueWithoutImportant) : valueWithoutImportant;
            var transformed = isObject(theme.__cssMap) && key in theme.__cssMap ? theme.__cssMap[key].varRef : value;
            transformed = withoutImportant(transformed);
            return important ? "".concat(transformed, " !important") : transformed;
          };
        };
        function createTransform(options) {
          var scale = options.scale,
            transform = options.transform,
            compose = options.compose;
          var fn = function fn(value, theme) {
            var _transform;
            var _value = tokenToCSSVar(scale, value)(theme);
            var result = (_transform = transform === null || transform === void 0 ? void 0 : transform(_value, theme)) !== null && _transform !== void 0 ? _transform : _value;
            if (compose) {
              result = compose(result, theme);
            }
            return result;
          };
          return fn;
        }
        var pipe$2 = function pipe$2() {
          for (var _len10 = arguments.length, fns = new Array(_len10), _key11 = 0; _key11 < _len10; _key11++) {
            fns[_key11] = arguments[_key11];
          }
          return function (v) {
            return fns.reduce(function (a, b) {
              return b(a);
            }, v);
          };
        };
        function toConfig(scale, transform) {
          return function (property) {
            var result = {
              property: property,
              scale: scale
            };
            result.transform = createTransform({
              scale: scale,
              transform: transform
            });
            return result;
          };
        }
        var getRtl = function getRtl(_ref33) {
          var rtl = _ref33.rtl,
            ltr = _ref33.ltr;
          return function (theme) {
            return theme.direction === "rtl" ? rtl : ltr;
          };
        };
        function logical(options) {
          var property = options.property,
            scale = options.scale,
            transform = options.transform;
          return {
            scale: scale,
            property: getRtl(property),
            transform: scale ? createTransform({
              scale: scale,
              compose: transform
            }) : transform
          };
        }
        var transformTemplate = ["rotate(var(--chakra-rotate, 0))", "scaleX(var(--chakra-scale-x, 1))", "scaleY(var(--chakra-scale-y, 1))", "skewX(var(--chakra-skew-x, 0))", "skewY(var(--chakra-skew-y, 0))"];
        function getTransformTemplate() {
          return ["translateX(var(--chakra-translate-x, 0))", "translateY(var(--chakra-translate-y, 0))"].concat(transformTemplate).join(" ");
        }
        function getTransformGpuTemplate() {
          return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)"].concat(transformTemplate).join(" ");
        }
        var filterTemplate = {
          "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
          filter: ["var(--chakra-blur)", "var(--chakra-brightness)", "var(--chakra-contrast)", "var(--chakra-grayscale)", "var(--chakra-hue-rotate)", "var(--chakra-invert)", "var(--chakra-saturate)", "var(--chakra-sepia)", "var(--chakra-drop-shadow)"].join(" ")
        };
        var backdropFilterTemplate = {
          backdropFilter: ["var(--chakra-backdrop-blur)", "var(--chakra-backdrop-brightness)", "var(--chakra-backdrop-contrast)", "var(--chakra-backdrop-grayscale)", "var(--chakra-backdrop-hue-rotate)", "var(--chakra-backdrop-invert)", "var(--chakra-backdrop-opacity)", "var(--chakra-backdrop-saturate)", "var(--chakra-backdrop-sepia)"].join(" "),
          "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
          "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
        };
        function getRingTemplate(value) {
          return {
            "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
            "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
            "--chakra-ring-width": value,
            boxShadow: ["var(--chakra-ring-offset-shadow)", "var(--chakra-ring-shadow)", "var(--chakra-shadow, 0 0 #0000)"].join(", ")
          };
        }
        var flexDirectionTemplate = {
          "row-reverse": {
            space: "--chakra-space-x-reverse",
            divide: "--chakra-divide-x-reverse"
          },
          "column-reverse": {
            space: "--chakra-space-y-reverse",
            divide: "--chakra-divide-y-reverse"
          }
        };
        var directionMap = {
          "to-t": "to top",
          "to-tr": "to top right",
          "to-r": "to right",
          "to-br": "to bottom right",
          "to-b": "to bottom",
          "to-bl": "to bottom left",
          "to-l": "to left",
          "to-tl": "to top left"
        };
        var valueSet = new Set(Object.values(directionMap));
        var globalSet = /* @__PURE__ */new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]);
        var trimSpace = function trimSpace(str) {
          return str.trim();
        };
        function parseGradient(value, theme) {
          if (value == null || globalSet.has(value)) return value;
          var prevent = isCSSFunction(value) || globalSet.has(value);
          if (!prevent) return "url('".concat(value, "')");
          var regex = /(^[a-z-A-Z]+)\((.*)\)/g;
          var results = regex.exec(value);
          var type = results === null || results === void 0 ? void 0 : results[1];
          var values = results === null || results === void 0 ? void 0 : results[2];
          if (!type || !values) return value;
          var _type = type.includes("-gradient") ? type : "".concat(type, "-gradient");
          var _values$split$map$fil = values.split(",").map(trimSpace).filter(Boolean),
            _values$split$map$fil2 = _toArray(_values$split$map$fil),
            maybeDirection = _values$split$map$fil2[0],
            stops = _arrayLikeToArray(_values$split$map$fil2).slice(1);
          if ((stops === null || stops === void 0 ? void 0 : stops.length) === 0) return value;
          var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
          stops.unshift(direction);
          var _values = stops.map(function (stop) {
            if (valueSet.has(stop)) return stop;
            var firstStop = stop.indexOf(" ");
            var _ref34 = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop],
              _ref35 = _slicedToArray(_ref34, 2),
              _color = _ref35[0],
              _stop = _ref35[1];
            var _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
            var key = "colors.".concat(_color);
            var color = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
            return _stopOrFunc ? [color].concat(_toConsumableArray(Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc])).join(" ") : color;
          });
          return "".concat(_type, "(").concat(_values.join(", "), ")");
        }
        var isCSSFunction = function isCSSFunction(value) {
          return typeof value === "string" && value.includes("(") && value.includes(")");
        };
        var gradientTransform = function gradientTransform(value, theme) {
          return parseGradient(value, theme !== null && theme !== void 0 ? theme : {});
        };
        function isCssVar$1(value) {
          return /^var\(--.+\)$/.test(value);
        }
        var analyzeCSSValue = function analyzeCSSValue(value) {
          var num = parseFloat(value.toString());
          var unit = value.toString().replace(String(num), "");
          return {
            unitless: !unit,
            value: num,
            unit: unit
          };
        };
        var wrap = function wrap(str) {
          return function (value) {
            return "".concat(str, "(").concat(value, ")");
          };
        };
        var transformFunctions = {
          filter: function filter(value) {
            return value !== "auto" ? value : filterTemplate;
          },
          backdropFilter: function backdropFilter(value) {
            return value !== "auto" ? value : backdropFilterTemplate;
          },
          ring: function ring(value) {
            return getRingTemplate(transformFunctions.px(value));
          },
          bgClip: function bgClip(value) {
            return value === "text" ? {
              color: "transparent",
              backgroundClip: "text"
            } : {
              backgroundClip: value
            };
          },
          transform: function transform(value) {
            if (value === "auto") return getTransformTemplate();
            if (value === "auto-gpu") return getTransformGpuTemplate();
            return value;
          },
          vh: function vh(value) {
            return value === "$100vh" ? "var(--chakra-vh)" : value;
          },
          px: function px(value) {
            if (value == null) return value;
            var _analyzeCSSValue = analyzeCSSValue(value),
              unitless = _analyzeCSSValue.unitless;
            return unitless || typeof value === "number" ? "".concat(value, "px") : value;
          },
          fraction: function fraction(value) {
            return !(typeof value === "number") || value > 1 ? value : "".concat(value * 100, "%");
          },
          float: function float(value, theme) {
            var map = {
              left: "right",
              right: "left"
            };
            return theme.direction === "rtl" ? map[value] : value;
          },
          degree: function degree(value) {
            if (isCssVar$1(value) || value == null) return value;
            var unitless = typeof value === "string" && !value.endsWith("deg");
            return typeof value === "number" || unitless ? "".concat(value, "deg") : value;
          },
          gradient: gradientTransform,
          blur: wrap("blur"),
          opacity: wrap("opacity"),
          brightness: wrap("brightness"),
          contrast: wrap("contrast"),
          dropShadow: wrap("drop-shadow"),
          grayscale: wrap("grayscale"),
          hueRotate: function hueRotate(value) {
            return wrap("hue-rotate")(transformFunctions.degree(value));
          },
          invert: wrap("invert"),
          saturate: wrap("saturate"),
          sepia: wrap("sepia"),
          bgImage: function bgImage(value) {
            if (value == null) return value;
            var prevent = isCSSFunction(value) || globalSet.has(value);
            return !prevent ? "url(".concat(value, ")") : value;
          },
          outline: function outline(value) {
            var isNoneOrZero = String(value) === "0" || String(value) === "none";
            return value !== null && isNoneOrZero ? {
              outline: "2px solid transparent",
              outlineOffset: "2px"
            } : {
              outline: value
            };
          },
          flexDirection: function flexDirection(value) {
            var _flexDirectionTemplat;
            var _ref36 = (_flexDirectionTemplat = flexDirectionTemplate[value]) !== null && _flexDirectionTemplat !== void 0 ? _flexDirectionTemplat : {},
              space = _ref36.space,
              divide = _ref36.divide;
            var result = {
              flexDirection: value
            };
            if (space) result[space] = 1;
            if (divide) result[divide] = 1;
            return result;
          }
        };
        var t$1 = {
          borderWidths: toConfig("borderWidths"),
          borderStyles: toConfig("borderStyles"),
          colors: toConfig("colors"),
          borders: toConfig("borders"),
          gradients: toConfig("gradients", transformFunctions.gradient),
          radii: toConfig("radii", transformFunctions.px),
          space: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
          spaceT: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
          degreeT: function degreeT(property) {
            return {
              property: property,
              transform: transformFunctions.degree
            };
          },
          prop: function prop(property, scale, transform) {
            return _objectSpread3({
              property: property,
              scale: scale
            }, scale && {
              transform: createTransform({
                scale: scale,
                transform: transform
              })
            });
          },
          propT: function propT(property, transform) {
            return {
              property: property,
              transform: transform
            };
          },
          sizes: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.px)),
          sizesT: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.fraction)),
          shadows: toConfig("shadows"),
          logical: logical,
          blur: toConfig("blur", transformFunctions.blur)
        };
        var background = {
          background: t$1.colors("background"),
          backgroundColor: t$1.colors("backgroundColor"),
          backgroundImage: t$1.gradients("backgroundImage"),
          backgroundSize: true,
          backgroundPosition: true,
          backgroundRepeat: true,
          backgroundAttachment: true,
          backgroundClip: {
            transform: transformFunctions.bgClip
          },
          bgSize: t$1.prop("backgroundSize"),
          bgPosition: t$1.prop("backgroundPosition"),
          bg: t$1.colors("background"),
          bgColor: t$1.colors("backgroundColor"),
          bgPos: t$1.prop("backgroundPosition"),
          bgRepeat: t$1.prop("backgroundRepeat"),
          bgAttachment: t$1.prop("backgroundAttachment"),
          bgGradient: t$1.gradients("backgroundImage"),
          bgClip: {
            transform: transformFunctions.bgClip
          }
        };
        Object.assign(background, {
          bgImage: background.backgroundImage,
          bgImg: background.backgroundImage
        });
        var border = {
          border: t$1.borders("border"),
          borderWidth: t$1.borderWidths("borderWidth"),
          borderStyle: t$1.borderStyles("borderStyle"),
          borderColor: t$1.colors("borderColor"),
          borderRadius: t$1.radii("borderRadius"),
          borderTop: t$1.borders("borderTop"),
          borderBlockStart: t$1.borders("borderBlockStart"),
          borderTopLeftRadius: t$1.radii("borderTopLeftRadius"),
          borderStartStartRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: "borderTopLeftRadius",
              rtl: "borderTopRightRadius"
            }
          }),
          borderEndStartRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: "borderBottomLeftRadius",
              rtl: "borderBottomRightRadius"
            }
          }),
          borderTopRightRadius: t$1.radii("borderTopRightRadius"),
          borderStartEndRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: "borderTopRightRadius",
              rtl: "borderTopLeftRadius"
            }
          }),
          borderEndEndRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: "borderBottomRightRadius",
              rtl: "borderBottomLeftRadius"
            }
          }),
          borderRight: t$1.borders("borderRight"),
          borderInlineEnd: t$1.borders("borderInlineEnd"),
          borderBottom: t$1.borders("borderBottom"),
          borderBlockEnd: t$1.borders("borderBlockEnd"),
          borderBottomLeftRadius: t$1.radii("borderBottomLeftRadius"),
          borderBottomRightRadius: t$1.radii("borderBottomRightRadius"),
          borderLeft: t$1.borders("borderLeft"),
          borderInlineStart: {
            property: "borderInlineStart",
            scale: "borders"
          },
          borderInlineStartRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
              rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
            }
          }),
          borderInlineEndRadius: t$1.logical({
            scale: "radii",
            property: {
              ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
              rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
            }
          }),
          borderX: t$1.borders(["borderLeft", "borderRight"]),
          borderInline: t$1.borders("borderInline"),
          borderY: t$1.borders(["borderTop", "borderBottom"]),
          borderBlock: t$1.borders("borderBlock"),
          borderTopWidth: t$1.borderWidths("borderTopWidth"),
          borderBlockStartWidth: t$1.borderWidths("borderBlockStartWidth"),
          borderTopColor: t$1.colors("borderTopColor"),
          borderBlockStartColor: t$1.colors("borderBlockStartColor"),
          borderTopStyle: t$1.borderStyles("borderTopStyle"),
          borderBlockStartStyle: t$1.borderStyles("borderBlockStartStyle"),
          borderBottomWidth: t$1.borderWidths("borderBottomWidth"),
          borderBlockEndWidth: t$1.borderWidths("borderBlockEndWidth"),
          borderBottomColor: t$1.colors("borderBottomColor"),
          borderBlockEndColor: t$1.colors("borderBlockEndColor"),
          borderBottomStyle: t$1.borderStyles("borderBottomStyle"),
          borderBlockEndStyle: t$1.borderStyles("borderBlockEndStyle"),
          borderLeftWidth: t$1.borderWidths("borderLeftWidth"),
          borderInlineStartWidth: t$1.borderWidths("borderInlineStartWidth"),
          borderLeftColor: t$1.colors("borderLeftColor"),
          borderInlineStartColor: t$1.colors("borderInlineStartColor"),
          borderLeftStyle: t$1.borderStyles("borderLeftStyle"),
          borderInlineStartStyle: t$1.borderStyles("borderInlineStartStyle"),
          borderRightWidth: t$1.borderWidths("borderRightWidth"),
          borderInlineEndWidth: t$1.borderWidths("borderInlineEndWidth"),
          borderRightColor: t$1.colors("borderRightColor"),
          borderInlineEndColor: t$1.colors("borderInlineEndColor"),
          borderRightStyle: t$1.borderStyles("borderRightStyle"),
          borderInlineEndStyle: t$1.borderStyles("borderInlineEndStyle"),
          borderTopRadius: t$1.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
          borderBottomRadius: t$1.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
          borderLeftRadius: t$1.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
          borderRightRadius: t$1.radii(["borderTopRightRadius", "borderBottomRightRadius"])
        };
        Object.assign(border, {
          rounded: border.borderRadius,
          roundedTop: border.borderTopRadius,
          roundedTopLeft: border.borderTopLeftRadius,
          roundedTopRight: border.borderTopRightRadius,
          roundedTopStart: border.borderStartStartRadius,
          roundedTopEnd: border.borderStartEndRadius,
          roundedBottom: border.borderBottomRadius,
          roundedBottomLeft: border.borderBottomLeftRadius,
          roundedBottomRight: border.borderBottomRightRadius,
          roundedBottomStart: border.borderEndStartRadius,
          roundedBottomEnd: border.borderEndEndRadius,
          roundedLeft: border.borderLeftRadius,
          roundedRight: border.borderRightRadius,
          roundedStart: border.borderInlineStartRadius,
          roundedEnd: border.borderInlineEndRadius,
          borderStart: border.borderInlineStart,
          borderEnd: border.borderInlineEnd,
          borderTopStartRadius: border.borderStartStartRadius,
          borderTopEndRadius: border.borderStartEndRadius,
          borderBottomStartRadius: border.borderEndStartRadius,
          borderBottomEndRadius: border.borderEndEndRadius,
          borderStartRadius: border.borderInlineStartRadius,
          borderEndRadius: border.borderInlineEndRadius,
          borderStartWidth: border.borderInlineStartWidth,
          borderEndWidth: border.borderInlineEndWidth,
          borderStartColor: border.borderInlineStartColor,
          borderEndColor: border.borderInlineEndColor,
          borderStartStyle: border.borderInlineStartStyle,
          borderEndStyle: border.borderInlineEndStyle
        });
        var color$1 = {
          color: t$1.colors("color"),
          textColor: t$1.colors("color"),
          fill: t$1.colors("fill"),
          stroke: t$1.colors("stroke"),
          accentColor: t$1.colors("accentColor"),
          textFillColor: t$1.colors("textFillColor")
        };
        var flexbox = {
          alignItems: true,
          alignContent: true,
          justifyItems: true,
          justifyContent: true,
          flexWrap: true,
          flexDirection: {
            transform: transformFunctions.flexDirection
          },
          flex: true,
          flexFlow: true,
          flexGrow: true,
          flexShrink: true,
          flexBasis: t$1.sizes("flexBasis"),
          justifySelf: true,
          alignSelf: true,
          order: true,
          placeItems: true,
          placeContent: true,
          placeSelf: true,
          gap: t$1.space("gap"),
          rowGap: t$1.space("rowGap"),
          columnGap: t$1.space("columnGap")
        };
        Object.assign(flexbox, {
          flexDir: flexbox.flexDirection
        });
        var layout$1 = {
          width: t$1.sizesT("width"),
          inlineSize: t$1.sizesT("inlineSize"),
          height: t$1.sizes("height"),
          blockSize: t$1.sizes("blockSize"),
          boxSize: t$1.sizes(["width", "height"]),
          minWidth: t$1.sizes("minWidth"),
          minInlineSize: t$1.sizes("minInlineSize"),
          minHeight: t$1.sizes("minHeight"),
          minBlockSize: t$1.sizes("minBlockSize"),
          maxWidth: t$1.sizes("maxWidth"),
          maxInlineSize: t$1.sizes("maxInlineSize"),
          maxHeight: t$1.sizes("maxHeight"),
          maxBlockSize: t$1.sizes("maxBlockSize"),
          overflow: true,
          overflowX: true,
          overflowY: true,
          overscrollBehavior: true,
          overscrollBehaviorX: true,
          overscrollBehaviorY: true,
          display: true,
          aspectRatio: true,
          hideFrom: {
            scale: "breakpoints",
            transform: function transform(value, theme) {
              var _theme$__breakpoints$, _theme$__breakpoints;
              var breakpoint = (_theme$__breakpoints$ = (_theme$__breakpoints = theme.__breakpoints) === null || _theme$__breakpoints === void 0 || (_theme$__breakpoints = _theme$__breakpoints.get(value)) === null || _theme$__breakpoints === void 0 ? void 0 : _theme$__breakpoints.minW) !== null && _theme$__breakpoints$ !== void 0 ? _theme$__breakpoints$ : value;
              var mq = "@media screen and (min-width: ".concat(breakpoint, ")");
              return _defineProperty2({}, mq, {
                display: "none"
              });
            }
          },
          hideBelow: {
            scale: "breakpoints",
            transform: function transform(value, theme) {
              var _theme$__breakpoints$2, _theme$__breakpoints2;
              var breakpoint = (_theme$__breakpoints$2 = (_theme$__breakpoints2 = theme.__breakpoints) === null || _theme$__breakpoints2 === void 0 || (_theme$__breakpoints2 = _theme$__breakpoints2.get(value)) === null || _theme$__breakpoints2 === void 0 ? void 0 : _theme$__breakpoints2._minW) !== null && _theme$__breakpoints$2 !== void 0 ? _theme$__breakpoints$2 : value;
              var mq = "@media screen and (max-width: ".concat(breakpoint, ")");
              return _defineProperty2({}, mq, {
                display: "none"
              });
            }
          },
          verticalAlign: true,
          boxSizing: true,
          boxDecorationBreak: true,
          float: t$1.propT("float", transformFunctions.float),
          objectFit: true,
          objectPosition: true,
          visibility: true,
          isolation: true
        };
        Object.assign(layout$1, {
          w: layout$1.width,
          h: layout$1.height,
          minW: layout$1.minWidth,
          maxW: layout$1.maxWidth,
          minH: layout$1.minHeight,
          maxH: layout$1.maxHeight,
          overscroll: layout$1.overscrollBehavior,
          overscrollX: layout$1.overscrollBehaviorX,
          overscrollY: layout$1.overscrollBehaviorY
        });
        var filter$1 = {
          filter: {
            transform: transformFunctions.filter
          },
          blur: t$1.blur("--chakra-blur"),
          brightness: t$1.propT("--chakra-brightness", transformFunctions.brightness),
          contrast: t$1.propT("--chakra-contrast", transformFunctions.contrast),
          hueRotate: t$1.propT("--chakra-hue-rotate", transformFunctions.hueRotate),
          invert: t$1.propT("--chakra-invert", transformFunctions.invert),
          saturate: t$1.propT("--chakra-saturate", transformFunctions.saturate),
          dropShadow: t$1.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
          backdropFilter: {
            transform: transformFunctions.backdropFilter
          },
          backdropBlur: t$1.blur("--chakra-backdrop-blur"),
          backdropBrightness: t$1.propT("--chakra-backdrop-brightness", transformFunctions.brightness),
          backdropContrast: t$1.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
          backdropHueRotate: t$1.propT("--chakra-backdrop-hue-rotate", transformFunctions.hueRotate),
          backdropInvert: t$1.propT("--chakra-backdrop-invert", transformFunctions.invert),
          backdropSaturate: t$1.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
        };
        var ring = {
          ring: {
            transform: transformFunctions.ring
          },
          ringColor: t$1.colors("--chakra-ring-color"),
          ringOffset: t$1.prop("--chakra-ring-offset-width"),
          ringOffsetColor: t$1.colors("--chakra-ring-offset-color"),
          ringInset: t$1.prop("--chakra-ring-inset")
        };
        var interactivity = {
          appearance: true,
          cursor: true,
          resize: true,
          userSelect: true,
          pointerEvents: true,
          outline: {
            transform: transformFunctions.outline
          },
          outlineOffset: true,
          outlineColor: t$1.colors("outlineColor")
        };
        var grid = {
          gridGap: t$1.space("gridGap"),
          gridColumnGap: t$1.space("gridColumnGap"),
          gridRowGap: t$1.space("gridRowGap"),
          gridColumn: true,
          gridRow: true,
          gridAutoFlow: true,
          gridAutoColumns: true,
          gridColumnStart: true,
          gridColumnEnd: true,
          gridRowStart: true,
          gridRowEnd: true,
          gridAutoRows: true,
          gridTemplate: true,
          gridTemplateColumns: true,
          gridTemplateRows: true,
          gridTemplateAreas: true,
          gridArea: true
        };
        function get$2(obj, path, fallback, index) {
          var key = typeof path === "string" ? path.split(".") : [path];
          for (index = 0; index < key.length; index += 1) {
            if (!obj) break;
            obj = obj[key[index]];
          }
          return obj === void 0 ? fallback : obj;
        }
        var memoize$1 = function memoize$1(fn) {
          var cache = /* @__PURE__ */new WeakMap();
          var memoizedFn = function memoizedFn(obj, path, fallback, index) {
            if (typeof obj === "undefined") {
              return fn(obj, path, fallback);
            }
            if (!cache.has(obj)) {
              cache.set(obj, /* @__PURE__ */new Map());
            }
            var map = cache.get(obj);
            if (map.has(path)) {
              return map.get(path);
            }
            var value = fn(obj, path, fallback, index);
            map.set(path, value);
            return value;
          };
          return memoizedFn;
        };
        var memoizedGet = memoize$1(get$2);
        var srOnly = {
          border: "0px",
          clip: "rect(0, 0, 0, 0)",
          width: "1px",
          height: "1px",
          margin: "-1px",
          padding: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          position: "absolute"
        };
        var srFocusable = {
          position: "static",
          width: "auto",
          height: "auto",
          clip: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          whiteSpace: "normal"
        };
        var getWithPriority = function getWithPriority(theme, key, styles) {
          var result = {};
          var obj = memoizedGet(theme, key, {});
          for (var prop in obj) {
            var isInStyles = prop in styles && styles[prop] != null;
            if (!isInStyles) result[prop] = obj[prop];
          }
          return result;
        };
        var others = {
          srOnly: {
            transform: function transform(value) {
              if (value === true) return srOnly;
              if (value === "focusable") return srFocusable;
              return {};
            }
          },
          layerStyle: {
            processResult: true,
            transform: function transform(value, theme, styles) {
              return getWithPriority(theme, "layerStyles.".concat(value), styles);
            }
          },
          textStyle: {
            processResult: true,
            transform: function transform(value, theme, styles) {
              return getWithPriority(theme, "textStyles.".concat(value), styles);
            }
          },
          apply: {
            processResult: true,
            transform: function transform(value, theme, styles) {
              return getWithPriority(theme, value, styles);
            }
          }
        };
        var position$1 = {
          position: true,
          pos: t$1.prop("position"),
          zIndex: t$1.prop("zIndex", "zIndices"),
          inset: t$1.spaceT("inset"),
          insetX: t$1.spaceT(["left", "right"]),
          insetInline: t$1.spaceT("insetInline"),
          insetY: t$1.spaceT(["top", "bottom"]),
          insetBlock: t$1.spaceT("insetBlock"),
          top: t$1.spaceT("top"),
          insetBlockStart: t$1.spaceT("insetBlockStart"),
          bottom: t$1.spaceT("bottom"),
          insetBlockEnd: t$1.spaceT("insetBlockEnd"),
          left: t$1.spaceT("left"),
          insetInlineStart: t$1.logical({
            scale: "space",
            property: {
              ltr: "left",
              rtl: "right"
            }
          }),
          right: t$1.spaceT("right"),
          insetInlineEnd: t$1.logical({
            scale: "space",
            property: {
              ltr: "right",
              rtl: "left"
            }
          })
        };
        Object.assign(position$1, {
          insetStart: position$1.insetInlineStart,
          insetEnd: position$1.insetInlineEnd
        });
        var effect$3 = {
          boxShadow: t$1.shadows("boxShadow"),
          mixBlendMode: true,
          blendMode: t$1.prop("mixBlendMode"),
          backgroundBlendMode: true,
          bgBlendMode: t$1.prop("backgroundBlendMode"),
          opacity: true
        };
        Object.assign(effect$3, {
          shadow: effect$3.boxShadow
        });
        var space = {
          margin: t$1.spaceT("margin"),
          marginTop: t$1.spaceT("marginTop"),
          marginBlockStart: t$1.spaceT("marginBlockStart"),
          marginRight: t$1.spaceT("marginRight"),
          marginInlineEnd: t$1.spaceT("marginInlineEnd"),
          marginBottom: t$1.spaceT("marginBottom"),
          marginBlockEnd: t$1.spaceT("marginBlockEnd"),
          marginLeft: t$1.spaceT("marginLeft"),
          marginInlineStart: t$1.spaceT("marginInlineStart"),
          marginX: t$1.spaceT(["marginInlineStart", "marginInlineEnd"]),
          marginInline: t$1.spaceT("marginInline"),
          marginY: t$1.spaceT(["marginTop", "marginBottom"]),
          marginBlock: t$1.spaceT("marginBlock"),
          padding: t$1.space("padding"),
          paddingTop: t$1.space("paddingTop"),
          paddingBlockStart: t$1.space("paddingBlockStart"),
          paddingRight: t$1.space("paddingRight"),
          paddingBottom: t$1.space("paddingBottom"),
          paddingBlockEnd: t$1.space("paddingBlockEnd"),
          paddingLeft: t$1.space("paddingLeft"),
          paddingInlineStart: t$1.space("paddingInlineStart"),
          paddingInlineEnd: t$1.space("paddingInlineEnd"),
          paddingX: t$1.space(["paddingInlineStart", "paddingInlineEnd"]),
          paddingInline: t$1.space("paddingInline"),
          paddingY: t$1.space(["paddingTop", "paddingBottom"]),
          paddingBlock: t$1.space("paddingBlock")
        };
        Object.assign(space, {
          m: space.margin,
          mt: space.marginTop,
          mr: space.marginRight,
          me: space.marginInlineEnd,
          marginEnd: space.marginInlineEnd,
          mb: space.marginBottom,
          ml: space.marginLeft,
          ms: space.marginInlineStart,
          marginStart: space.marginInlineStart,
          mx: space.marginX,
          my: space.marginY,
          p: space.padding,
          pt: space.paddingTop,
          py: space.paddingY,
          px: space.paddingX,
          pb: space.paddingBottom,
          pl: space.paddingLeft,
          ps: space.paddingInlineStart,
          paddingStart: space.paddingInlineStart,
          pr: space.paddingRight,
          pe: space.paddingInlineEnd,
          paddingEnd: space.paddingInlineEnd
        });
        var scroll = {
          scrollBehavior: true,
          scrollSnapAlign: true,
          scrollSnapStop: true,
          scrollSnapType: true,
          // scroll margin
          scrollMargin: t$1.spaceT("scrollMargin"),
          scrollMarginTop: t$1.spaceT("scrollMarginTop"),
          scrollMarginBottom: t$1.spaceT("scrollMarginBottom"),
          scrollMarginLeft: t$1.spaceT("scrollMarginLeft"),
          scrollMarginRight: t$1.spaceT("scrollMarginRight"),
          scrollMarginX: t$1.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
          scrollMarginY: t$1.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
          // scroll padding
          scrollPadding: t$1.spaceT("scrollPadding"),
          scrollPaddingTop: t$1.spaceT("scrollPaddingTop"),
          scrollPaddingBottom: t$1.spaceT("scrollPaddingBottom"),
          scrollPaddingLeft: t$1.spaceT("scrollPaddingLeft"),
          scrollPaddingRight: t$1.spaceT("scrollPaddingRight"),
          scrollPaddingX: t$1.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
          scrollPaddingY: t$1.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
        };
        var typography$1 = {
          fontFamily: t$1.prop("fontFamily", "fonts"),
          fontSize: t$1.prop("fontSize", "fontSizes", transformFunctions.px),
          fontWeight: t$1.prop("fontWeight", "fontWeights"),
          lineHeight: t$1.prop("lineHeight", "lineHeights"),
          letterSpacing: t$1.prop("letterSpacing", "letterSpacings"),
          textAlign: true,
          fontStyle: true,
          textIndent: true,
          wordBreak: true,
          overflowWrap: true,
          textOverflow: true,
          textTransform: true,
          whiteSpace: true,
          isTruncated: {
            transform: function transform(value) {
              if (value === true) {
                return {
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                  whiteSpace: "nowrap"
                };
              }
            }
          },
          noOfLines: {
            static: {
              overflow: "hidden",
              textOverflow: "ellipsis",
              display: "-webkit-box",
              WebkitBoxOrient: "vertical",
              //@ts-ignore
              WebkitLineClamp: "var(--chakra-line-clamp)"
            },
            property: "--chakra-line-clamp"
          }
        };
        var textDecoration = {
          textDecorationColor: t$1.colors("textDecorationColor"),
          textDecoration: true,
          textDecor: {
            property: "textDecoration"
          },
          textDecorationLine: true,
          textDecorationStyle: true,
          textDecorationThickness: true,
          textUnderlineOffset: true,
          textShadow: t$1.shadows("textShadow")
        };
        var transform = {
          clipPath: true,
          transform: t$1.propT("transform", transformFunctions.transform),
          transformOrigin: true,
          translateX: t$1.spaceT("--chakra-translate-x"),
          translateY: t$1.spaceT("--chakra-translate-y"),
          skewX: t$1.degreeT("--chakra-skew-x"),
          skewY: t$1.degreeT("--chakra-skew-y"),
          scaleX: t$1.prop("--chakra-scale-x"),
          scaleY: t$1.prop("--chakra-scale-y"),
          scale: t$1.prop(["--chakra-scale-x", "--chakra-scale-y"]),
          rotate: t$1.degreeT("--chakra-rotate")
        };
        var list = {
          listStyleType: true,
          listStylePosition: true,
          listStylePos: t$1.prop("listStylePosition"),
          listStyleImage: true,
          listStyleImg: t$1.prop("listStyleImage")
        };
        var transition$1 = {
          transition: true,
          transitionDelay: true,
          animation: true,
          willChange: true,
          transitionDuration: t$1.prop("transitionDuration", "transition.duration"),
          transitionProperty: t$1.prop("transitionProperty", "transition.property"),
          transitionTimingFunction: t$1.prop("transitionTimingFunction", "transition.easing")
        };
        var systemProps = mergeWith({}, background, border, color$1, flexbox, layout$1, filter$1, ring, interactivity, grid, others, position$1, effect$3, space, scroll, typography$1, textDecoration, transform, list, transition$1);
        var layoutSystem = Object.assign({}, space, layout$1, flexbox, grid, position$1);
        var layoutPropNames = Object.keys(layoutSystem);
        var propNames = [].concat(_toConsumableArray(Object.keys(systemProps)), pseudoPropNames);
        var styleProps = _objectSpread3(_objectSpread3({}, systemProps), pseudoSelectors);
        var isStyleProp = function isStyleProp(prop) {
          return prop in styleProps;
        };
        var expandResponsive = function expandResponsive(styles) {
          return function (theme) {
            if (!theme.__breakpoints) return styles;
            var _theme$__breakpoints3 = theme.__breakpoints,
              isResponsive = _theme$__breakpoints3.isResponsive,
              toArrayValue = _theme$__breakpoints3.toArrayValue,
              medias = _theme$__breakpoints3.media;
            var computedStyles = {};
            for (var key in styles) {
              var value = runIfFn$1(styles[key], theme);
              if (value == null) continue;
              value = isObject(value) && isResponsive(value) ? toArrayValue(value) : value;
              if (!Array.isArray(value)) {
                computedStyles[key] = value;
                continue;
              }
              var queries = value.slice(0, medias.length).length;
              for (var index = 0; index < queries; index += 1) {
                var media = medias === null || medias === void 0 ? void 0 : medias[index];
                if (!media) {
                  computedStyles[key] = value[index];
                  continue;
                }
                computedStyles[media] = computedStyles[media] || {};
                if (value[index] == null) {
                  continue;
                }
                computedStyles[media][key] = value[index];
              }
            }
            return computedStyles;
          };
        };
        function splitByComma(value) {
          var chunks = [];
          var chunk = "";
          var inParens = false;
          for (var i = 0; i < value.length; i++) {
            var _char = value[i];
            if (_char === "(") {
              inParens = true;
              chunk += _char;
            } else if (_char === ")") {
              inParens = false;
              chunk += _char;
            } else if (_char === "," && !inParens) {
              chunks.push(chunk);
              chunk = "";
            } else {
              chunk += _char;
            }
          }
          chunk = chunk.trim();
          if (chunk) {
            chunks.push(chunk);
          }
          return chunks;
        }
        function isCssVar(value) {
          return /^var\(--.+\)$/.test(value);
        }
        var isCSSVariableTokenValue = function isCSSVariableTokenValue(key, value) {
          return key.startsWith("--") && typeof value === "string" && !isCssVar(value);
        };
        var resolveTokenValue = function resolveTokenValue(theme, value) {
          var _ref39, _getVar2;
          if (value == null) return value;
          var getVar = function getVar(val) {
            var _theme$__cssMap;
            return (_theme$__cssMap = theme.__cssMap) === null || _theme$__cssMap === void 0 || (_theme$__cssMap = _theme$__cssMap[val]) === null || _theme$__cssMap === void 0 ? void 0 : _theme$__cssMap.varRef;
          };
          var getValue = function getValue(val) {
            var _getVar;
            return (_getVar = getVar(val)) !== null && _getVar !== void 0 ? _getVar : val;
          };
          var _splitByComma = splitByComma(value),
            _splitByComma2 = _slicedToArray(_splitByComma, 2),
            tokenValue = _splitByComma2[0],
            fallbackValue = _splitByComma2[1];
          value = (_ref39 = (_getVar2 = getVar(tokenValue)) !== null && _getVar2 !== void 0 ? _getVar2 : getValue(fallbackValue)) !== null && _ref39 !== void 0 ? _ref39 : getValue(value);
          return value;
        };
        function getCss(options) {
          var _options$configs = options.configs,
            configs = _options$configs === void 0 ? {} : _options$configs,
            _options$pseudos = options.pseudos,
            pseudos = _options$pseudos === void 0 ? {} : _options$pseudos,
            theme = options.theme;
          var _css = function css2(stylesOrFn) {
            var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var _styles = runIfFn$1(stylesOrFn, theme);
            var styles = expandResponsive(_styles)(theme);
            var computedStyles = {};
            for (var key in styles) {
              var _config$transform, _config2, _config2$transform, _config3, _config4, _config5;
              var valueOrFn = styles[key];
              var value = runIfFn$1(valueOrFn, theme);
              if (key in pseudos) {
                key = pseudos[key];
              }
              if (isCSSVariableTokenValue(key, value)) {
                value = resolveTokenValue(theme, value);
              }
              var _config = configs[key];
              if (_config === true) {
                _config = {
                  property: key
                };
              }
              if (isObject(value)) {
                var _computedStyles$key;
                computedStyles[key] = (_computedStyles$key = computedStyles[key]) !== null && _computedStyles$key !== void 0 ? _computedStyles$key : {};
                computedStyles[key] = mergeWith({}, computedStyles[key], _css(value, true));
                continue;
              }
              var rawValue = (_config$transform = (_config2 = _config) === null || _config2 === void 0 || (_config2$transform = _config2.transform) === null || _config2$transform === void 0 ? void 0 : _config2$transform.call(_config2, value, theme, _styles)) !== null && _config$transform !== void 0 ? _config$transform : value;
              rawValue = (_config3 = _config) !== null && _config3 !== void 0 && _config3.processResult ? _css(rawValue, true) : rawValue;
              var configProperty = runIfFn$1((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.property, theme);
              if (!nested && (_config5 = _config) !== null && _config5 !== void 0 && _config5.static) {
                var staticStyles = runIfFn$1(_config.static, theme);
                computedStyles = mergeWith({}, computedStyles, staticStyles);
              }
              if (configProperty && Array.isArray(configProperty)) {
                var _iterator9 = _createForOfIteratorHelper(configProperty),
                  _step9;
                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var property = _step9.value;
                    computedStyles[property] = rawValue;
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
                continue;
              }
              if (configProperty) {
                if (configProperty === "&" && isObject(rawValue)) {
                  computedStyles = mergeWith({}, computedStyles, rawValue);
                } else {
                  computedStyles[configProperty] = rawValue;
                }
                continue;
              }
              if (isObject(rawValue)) {
                computedStyles = mergeWith({}, computedStyles, rawValue);
                continue;
              }
              computedStyles[key] = rawValue;
            }
            return computedStyles;
          };
          return _css;
        }
        var css$2 = function css$2(styles) {
          return function (theme) {
            var cssFn = getCss({
              theme: theme,
              pseudos: pseudoSelectors,
              configs: systemProps
            });
            return cssFn(styles);
          };
        };
        function defineStyle(styles) {
          return styles;
        }
        function defineStyleConfig(config) {
          return config;
        }
        function createMultiStyleConfigHelpers(parts) {
          return {
            definePartsStyle: function definePartsStyle(config) {
              return config;
            },
            defineMultiStyleConfig: function defineMultiStyleConfig(config) {
              return _objectSpread3({
                parts: parts
              }, config);
            }
          };
        }
        function getCSSVar(theme, scale, value) {
          var _theme$__cssMap$varRe, _theme$__cssMap2;
          return (_theme$__cssMap$varRe = (_theme$__cssMap2 = theme.__cssMap) === null || _theme$__cssMap2 === void 0 || (_theme$__cssMap2 = _theme$__cssMap2["".concat(scale, ".").concat(value)]) === null || _theme$__cssMap2 === void 0 ? void 0 : _theme$__cssMap2.varRef) !== null && _theme$__cssMap$varRe !== void 0 ? _theme$__cssMap$varRe : value;
        }
        function normalize(value, toArray) {
          if (Array.isArray(value)) return value;
          if (isObject(value)) return toArray(value);
          if (value != null) return [value];
        }
        function getNextIndex$1(values, i) {
          for (var j = i + 1; j < values.length; j++) {
            if (values[j] != null) return j;
          }
          return -1;
        }
        function createResolver(theme) {
          var breakpointUtil = theme.__breakpoints;
          return function resolver(config, prop, value, props) {
            if (!breakpointUtil) return;
            var result = {};
            var normalized = normalize(value, breakpointUtil.toArrayValue);
            if (!normalized) return result;
            var len = normalized.length;
            var isSingle = len === 1;
            var isMultipart = !!config.parts;
            var _loop4 = function _loop4() {
                var _config$prop;
                var key = breakpointUtil.details[i];
                var nextKey = breakpointUtil.details[getNextIndex$1(normalized, i)];
                var query = toMediaQueryString(key.minW, nextKey === null || nextKey === void 0 ? void 0 : nextKey._minW);
                var styles = runIfFn$1((_config$prop = config[prop]) === null || _config$prop === void 0 ? void 0 : _config$prop[normalized[i]], props);
                if (!styles) return 0; // continue
                if (isMultipart) {
                  var _config$parts;
                  (_config$parts = config.parts) === null || _config$parts === void 0 || _config$parts.forEach(function (part) {
                    mergeWith(result, _defineProperty2({}, part, isSingle ? styles[part] : _defineProperty2({}, query, styles[part])));
                  });
                  return 0; // continue
                }
                if (!isMultipart) {
                  if (isSingle) mergeWith(result, styles);else result[query] = styles;
                  return 0; // continue
                }
                result[query] = styles;
              },
              _ret2;
            for (var i = 0; i < len; i++) {
              _ret2 = _loop4();
              if (_ret2 === 0) continue;
            }
            return result;
          };
        }
        function resolveStyleConfig(config) {
          return function (props) {
            var _config$baseStyle;
            var variant = props.variant,
              size = props.size,
              theme = props.theme;
            var recipe = createResolver(theme);
            return mergeWith({}, runIfFn$1((_config$baseStyle = config.baseStyle) !== null && _config$baseStyle !== void 0 ? _config$baseStyle : {}, props), recipe(config, "sizes", size, props), recipe(config, "variants", variant, props));
          };
        }
        function omitThemingProps(props) {
          return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
        }
        function resolveReference(operand) {
          if (isObject(operand) && operand.reference) {
            return operand.reference;
          }
          return String(operand);
        }
        var toExpression = function toExpression(operator) {
          for (var _len11 = arguments.length, operands = new Array(_len11 > 1 ? _len11 - 1 : 0), _key12 = 1; _key12 < _len11; _key12++) {
            operands[_key12 - 1] = arguments[_key12];
          }
          return operands.map(resolveReference).join(" ".concat(operator, " ")).replace(/calc/g, "");
        };
        var add$1 = function add$1() {
          for (var _len12 = arguments.length, operands = new Array(_len12), _key13 = 0; _key13 < _len12; _key13++) {
            operands[_key13] = arguments[_key13];
          }
          return "calc(".concat(toExpression.apply(void 0, ["+"].concat(operands)), ")");
        };
        var subtract$1 = function subtract$1() {
          for (var _len13 = arguments.length, operands = new Array(_len13), _key14 = 0; _key14 < _len13; _key14++) {
            operands[_key14] = arguments[_key14];
          }
          return "calc(".concat(toExpression.apply(void 0, ["-"].concat(operands)), ")");
        };
        var multiply$1 = function multiply$1() {
          for (var _len14 = arguments.length, operands = new Array(_len14), _key15 = 0; _key15 < _len14; _key15++) {
            operands[_key15] = arguments[_key15];
          }
          return "calc(".concat(toExpression.apply(void 0, ["*"].concat(operands)), ")");
        };
        var divide$1 = function divide$1() {
          for (var _len15 = arguments.length, operands = new Array(_len15), _key16 = 0; _key16 < _len15; _key16++) {
            operands[_key16] = arguments[_key16];
          }
          return "calc(".concat(toExpression.apply(void 0, ["/"].concat(operands)), ")");
        };
        var negate$1 = function negate$1(x) {
          var value = resolveReference(x);
          if (value != null && !Number.isNaN(parseFloat(value))) {
            return String(value).startsWith("-") ? String(value).slice(1) : "-".concat(value);
          }
          return multiply$1(value, -1);
        };
        var calc$1 = Object.assign(function (x) {
          return {
            add: function add() {
              for (var _len16 = arguments.length, operands = new Array(_len16), _key17 = 0; _key17 < _len16; _key17++) {
                operands[_key17] = arguments[_key17];
              }
              return calc$1(add$1.apply(void 0, [x].concat(operands)));
            },
            subtract: function subtract() {
              for (var _len17 = arguments.length, operands = new Array(_len17), _key18 = 0; _key18 < _len17; _key18++) {
                operands[_key18] = arguments[_key18];
              }
              return calc$1(subtract$1.apply(void 0, [x].concat(operands)));
            },
            multiply: function multiply() {
              for (var _len18 = arguments.length, operands = new Array(_len18), _key19 = 0; _key19 < _len18; _key19++) {
                operands[_key19] = arguments[_key19];
              }
              return calc$1(multiply$1.apply(void 0, [x].concat(operands)));
            },
            divide: function divide() {
              for (var _len19 = arguments.length, operands = new Array(_len19), _key20 = 0; _key20 < _len19; _key20++) {
                operands[_key20] = arguments[_key20];
              }
              return calc$1(divide$1.apply(void 0, [x].concat(operands)));
            },
            negate: function negate() {
              return calc$1(negate$1(x));
            },
            toString: function toString() {
              return x.toString();
            }
          };
        }, {
          add: add$1,
          subtract: subtract$1,
          multiply: multiply$1,
          divide: divide$1,
          negate: negate$1
        });
        function replaceWhiteSpace$1(value) {
          var replaceValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "-";
          return value.replace(/\s+/g, replaceValue);
        }
        function escape$1(value) {
          var valueStr = replaceWhiteSpace$1(value.toString());
          return escapeSymbol(escapeDot(valueStr));
        }
        function escapeDot(value) {
          if (value.includes("\\.")) return value;
          var isDecimal = !Number.isInteger(parseFloat(value.toString()));
          return isDecimal ? value.replace(".", "\\.") : value;
        }
        function escapeSymbol(value) {
          return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
        }
        function addPrefix$1(value) {
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return [prefix, value].filter(Boolean).join("-");
        }
        function toVarReference(name, fallback) {
          return "var(".concat(name).concat(fallback ? ", ".concat(fallback) : "", ")");
        }
        function toVarDefinition(value) {
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return escape$1("--".concat(addPrefix$1(value, prefix)));
        }
        function cssVar$1(name, fallback, cssVarPrefix) {
          var cssVariable = toVarDefinition(name, cssVarPrefix);
          return {
            variable: cssVariable,
            reference: toVarReference(cssVariable, fallback)
          };
        }
        function defineCssVars(scope, keys) {
          var vars = {};
          var _iterator0 = _createForOfIteratorHelper(keys),
            _step0;
          try {
            for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
              var key = _step0.value;
              if (Array.isArray(key)) {
                var _key21 = _slicedToArray(key, 2),
                  name = _key21[0],
                  fallback = _key21[1];
                vars[name] = cssVar$1("".concat(scope, "-").concat(name), fallback);
                continue;
              }
              vars[key] = cssVar$1("".concat(scope, "-").concat(key));
            }
          } catch (err) {
            _iterator0.e(err);
          } finally {
            _iterator0.f();
          }
          return vars;
        }
        var tokens = ["colors", "borders", "borderWidths", "borderStyles", "fonts", "fontSizes", "fontWeights", "gradients", "letterSpacings", "lineHeights", "radii", "space", "shadows", "sizes", "zIndices", "transition", "blur", "breakpoints"];
        function extractTokens(theme) {
          var _tokens = tokens;
          return pick(theme, _tokens);
        }
        function extractSemanticTokens(theme) {
          return theme.semanticTokens;
        }
        function omitVars(rawTheme) {
          var __cssMap = rawTheme.__cssMap,
            __cssVars = rawTheme.__cssVars,
            __breakpoints = rawTheme.__breakpoints,
            cleanTheme = _objectWithoutProperties2(rawTheme, _excluded7);
          return cleanTheme;
        }
        function flattenTokens(theme) {
          var tokens = extractTokens(theme);
          var semanticTokens = extractSemanticTokens(theme);
          var isSemanticCondition = function isSemanticCondition(key) {
            return (
              // @ts-ignore
              pseudoPropNames.includes(key) || "default" === key
            );
          };
          var result = {};
          walkObject(tokens, function (value, path) {
            if (value == null) return;
            result[path.join(".")] = {
              isSemantic: false,
              value: value
            };
          });
          walkObject(semanticTokens, function (value, path) {
            if (value == null) return;
            result[path.join(".")] = {
              isSemantic: true,
              value: value
            };
          }, {
            stop: function stop(value) {
              return Object.keys(value).every(isSemanticCondition);
            }
          });
          return result;
        }
        function tokenToCssVar(token, prefix) {
          return cssVar$1(String(token).replace(/\./g, "-"), void 0, prefix);
        }
        function createThemeVars(theme) {
          var _theme$config;
          var flatTokens = flattenTokens(theme);
          var cssVarPrefix = (_theme$config = theme.config) === null || _theme$config === void 0 ? void 0 : _theme$config.cssVarPrefix;
          var cssVars = {};
          var cssMap = {};
          function lookupToken(token, maybeToken) {
            var scale = String(token).split(".")[0];
            var withScale = [scale, maybeToken].join(".");
            var resolvedTokenValue = flatTokens[withScale];
            if (!resolvedTokenValue) return maybeToken;
            var _tokenToCssVar = tokenToCssVar(withScale, cssVarPrefix),
              reference = _tokenToCssVar.reference;
            return reference;
          }
          var _loop5 = function _loop5() {
            var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i5], 2),
              token = _Object$entries3$_i[0],
              tokenValue = _Object$entries3$_i[1];
            var isSemantic = tokenValue.isSemantic,
              value = tokenValue.value;
            var _tokenToCssVar2 = tokenToCssVar(token, cssVarPrefix),
              variable = _tokenToCssVar2.variable,
              reference = _tokenToCssVar2.reference;
            if (!isSemantic) {
              if (token.startsWith("space")) {
                var _keys2 = token.split(".");
                var _keys3 = _toArray(_keys2),
                  firstKey = _keys3[0],
                  referenceKeys = _arrayLikeToArray(_keys3).slice(1);
                var negativeLookupKey = "".concat(firstKey, ".-").concat(referenceKeys.join("."));
                var negativeValue = calc$1.negate(value);
                var negatedReference = calc$1.negate(reference);
                cssMap[negativeLookupKey] = {
                  value: negativeValue,
                  var: variable,
                  varRef: negatedReference
                };
              }
              cssVars[variable] = value;
              cssMap[token] = {
                value: value,
                var: variable,
                varRef: reference
              };
              return 1; // continue
            }
            var normalizedValue = isObject(value) ? value : {
              default: value
            };
            cssVars = mergeWith(cssVars, Object.entries(normalizedValue).reduce(function (acc, _ref41) {
              var _pseudoSelectors$cond;
              var _ref42 = _slicedToArray(_ref41, 2),
                conditionAlias = _ref42[0],
                conditionValue = _ref42[1];
              if (!conditionValue) return acc;
              var tokenReference = lookupToken(token, "".concat(conditionValue));
              if (conditionAlias === "default") {
                acc[variable] = tokenReference;
                return acc;
              }
              var conditionSelector = (_pseudoSelectors$cond = pseudoSelectors === null || pseudoSelectors === void 0 ? void 0 : pseudoSelectors[conditionAlias]) !== null && _pseudoSelectors$cond !== void 0 ? _pseudoSelectors$cond : conditionAlias;
              acc[conditionSelector] = _defineProperty2({}, variable, tokenReference);
              return acc;
            }, {}));
            cssMap[token] = {
              value: reference,
              var: variable,
              varRef: reference
            };
          };
          for (var _i5 = 0, _Object$entries3 = Object.entries(flatTokens); _i5 < _Object$entries3.length; _i5++) {
            if (_loop5()) continue;
          }
          return {
            cssVars: cssVars,
            cssMap: cssMap
          };
        }
        function toCSSVar(rawTheme) {
          var theme = omitVars(rawTheme);
          var _createThemeVars = createThemeVars(theme),
            cssMap = _createThemeVars.cssMap,
            cssVars = _createThemeVars.cssVars;
          var defaultCssVars = {
            "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
            "--chakra-ring-offset-width": "0px",
            "--chakra-ring-offset-color": "#fff",
            "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
            "--chakra-ring-offset-shadow": "0 0 #0000",
            "--chakra-ring-shadow": "0 0 #0000",
            "--chakra-space-x-reverse": "0",
            "--chakra-space-y-reverse": "0"
          };
          Object.assign(theme, {
            __cssVars: _objectSpread3(_objectSpread3({}, defaultCssVars), cssVars),
            __cssMap: cssMap,
            __breakpoints: analyzeBreakpoints(theme.breakpoints)
          });
          return theme;
        }
        function anatomy(name) {
          var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var called = false;
          function assert() {
            if (!called) {
              called = true;
              return;
            }
            throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
          }
          function parts() {
            assert();
            for (var _len20 = arguments.length, values = new Array(_len20), _key22 = 0; _key22 < _len20; _key22++) {
              values[_key22] = arguments[_key22];
            }
            for (var _i6 = 0, _values2 = values; _i6 < _values2.length; _i6++) {
              var part = _values2[_i6];
              map[part] = toPart(part);
            }
            return anatomy(name, map);
          }
          function extend() {
            for (var _len21 = arguments.length, parts2 = new Array(_len21), _key23 = 0; _key23 < _len21; _key23++) {
              parts2[_key23] = arguments[_key23];
            }
            for (var _i7 = 0, _parts = parts2; _i7 < _parts.length; _i7++) {
              var part = _parts[_i7];
              if (part in map) continue;
              map[part] = toPart(part);
            }
            return anatomy(name, map);
          }
          function selectors() {
            var value = Object.fromEntries(Object.entries(map).map(function (_ref43) {
              var _ref44 = _slicedToArray(_ref43, 2),
                key = _ref44[0],
                part = _ref44[1];
              return [key, part.selector];
            }));
            return value;
          }
          function classnames() {
            var value = Object.fromEntries(Object.entries(map).map(function (_ref45) {
              var _ref46 = _slicedToArray(_ref45, 2),
                key = _ref46[0],
                part = _ref46[1];
              return [key, part.className];
            }));
            return value;
          }
          function toPart(part) {
            var el = ["container", "root"].includes(part !== null && part !== void 0 ? part : "") ? [name] : [name, part];
            var attr = el.filter(Boolean).join("__");
            var className = "chakra-".concat(attr);
            var partObj = {
              className: className,
              selector: ".".concat(className),
              toString: function toString() {
                return part;
              }
            };
            return partObj;
          }
          var __type = {};
          return {
            parts: parts,
            toPart: toPart,
            extend: extend,
            selectors: selectors,
            classnames: classnames,
            get keys() {
              return Object.keys(map);
            },
            __type: __type
          };
        }
        var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel", "icon");
        var alertAnatomy = anatomy("alert").parts("title", "description", "container", "icon", "spinner");
        var avatarAnatomy = anatomy("avatar").parts("label", "badge", "container", "excessLabel", "group");
        var breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container", "separator");
        anatomy("button").parts();
        var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container", "label");
        anatomy("progress").parts("track", "filledTrack", "label");
        var drawerAnatomy = anatomy("drawer").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer");
        var editableAnatomy = anatomy("editable").parts("preview", "input", "textarea");
        var formAnatomy = anatomy("form").parts("container", "requiredIndicator", "helperText");
        var formErrorAnatomy = anatomy("formError").parts("text", "icon");
        var inputAnatomy = anatomy("input").parts("addon", "field", "element", "group");
        var listAnatomy = anatomy("list").parts("container", "item", "icon");
        var menuAnatomy = anatomy("menu").parts("button", "list", "item", "groupTitle", "icon", "command", "divider");
        var modalAnatomy = anatomy("modal").parts("overlay", "dialogContainer", "dialog", "header", "closeButton", "body", "footer");
        var numberInputAnatomy = anatomy("numberinput").parts("root", "field", "stepperGroup", "stepper");
        anatomy("pininput").parts("field");
        var popoverAnatomy = anatomy("popover").parts("content", "header", "body", "footer", "popper", "arrow", "closeButton");
        var progressAnatomy = anatomy("progress").parts("label", "filledTrack", "track");
        var radioAnatomy = anatomy("radio").parts("container", "control", "label");
        var selectAnatomy = anatomy("select").parts("field", "icon");
        var sliderAnatomy = anatomy("slider").parts("container", "track", "thumb", "filledTrack", "mark");
        var statAnatomy = anatomy("stat").parts("container", "label", "helpText", "number", "icon");
        var switchAnatomy = anatomy("switch").parts("container", "track", "thumb", "label");
        var tableAnatomy = anatomy("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption");
        var tabsAnatomy = anatomy("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator");
        var tagAnatomy = anatomy("tag").parts("container", "label", "closeButton");
        var cardAnatomy = anatomy("card").parts("container", "header", "body", "footer");
        anatomy("stepper").parts("stepper", "step", "title", "description", "indicator", "separator", "icon", "number");
        var _createMultiStyleConf = createMultiStyleConfigHelpers(accordionAnatomy.keys),
          definePartsStyle$p = _createMultiStyleConf.definePartsStyle,
          defineMultiStyleConfig$p = _createMultiStyleConf.defineMultiStyleConfig;
        var baseStyleContainer$4 = defineStyle({
          borderTopWidth: "1px",
          borderColor: "inherit",
          _last: {
            borderBottomWidth: "1px"
          }
        });
        var baseStyleButton$1 = defineStyle({
          transitionProperty: "common",
          transitionDuration: "normal",
          fontSize: "md",
          _focusVisible: {
            boxShadow: "outline"
          },
          _hover: {
            bg: "blackAlpha.50"
          },
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed"
          },
          px: "4",
          py: "2"
        });
        var baseStylePanel = defineStyle({
          pt: "2",
          px: "4",
          pb: "5"
        });
        var baseStyleIcon$6 = defineStyle({
          fontSize: "1.25em"
        });
        var baseStyle$G = definePartsStyle$p({
          container: baseStyleContainer$4,
          button: baseStyleButton$1,
          panel: baseStylePanel,
          icon: baseStyleIcon$6
        });
        var accordionTheme = defineMultiStyleConfig$p({
          baseStyle: baseStyle$G
        });

        /**
         * A simple guard function:
         *
         * ```js
         * Math.min(Math.max(low, value), high)
         * ```
         */
        function guard(low, high, value) {
          return Math.min(Math.max(low, value), high);
        }
        var ColorError = /*#__PURE__*/function (_Error) {
          function ColorError(color) {
            _classCallCheck(this, ColorError);
            return _callSuper(this, ColorError, ["Failed to parse color: \"".concat(color, "\"")]);
          }
          _inherits(ColorError, _Error);
          return _createClass(ColorError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        var ColorError$1 = ColorError;

        /**
         * Parses a color into red, gree, blue, alpha parts
         *
         * @param color the input color. Can be a RGB, RBGA, HSL, HSLA, or named color
         */
        function parseToRgba(color) {
          if (typeof color !== 'string') throw new ColorError$1(color);
          if (color.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0];
          var normalizedColor = color.trim();
          normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
          var reducedHexMatch = reducedHexRegex.exec(normalizedColor);
          if (reducedHexMatch) {
            var arr = Array.from(reducedHexMatch).slice(1);
            return [].concat(_toConsumableArray(arr.slice(0, 3).map(function (x) {
              return parseInt(r$1(x, 2), 16);
            })), [parseInt(r$1(arr[3] || 'f', 2), 16) / 255]);
          }
          var hexMatch = hexRegex.exec(normalizedColor);
          if (hexMatch) {
            var _arr = Array.from(hexMatch).slice(1);
            return [].concat(_toConsumableArray(_arr.slice(0, 3).map(function (x) {
              return parseInt(x, 16);
            })), [parseInt(_arr[3] || 'ff', 16) / 255]);
          }
          var rgbaMatch = rgbaRegex.exec(normalizedColor);
          if (rgbaMatch) {
            var _arr2 = Array.from(rgbaMatch).slice(1);
            return [].concat(_toConsumableArray(_arr2.slice(0, 3).map(function (x) {
              return parseInt(x, 10);
            })), [parseFloat(_arr2[3] || '1')]);
          }
          var hslaMatch = hslaRegex.exec(normalizedColor);
          if (hslaMatch) {
            var _Array$from$slice$map = Array.from(hslaMatch).slice(1).map(parseFloat),
              _Array$from$slice$map2 = _slicedToArray(_Array$from$slice$map, 4),
              _h2 = _Array$from$slice$map2[0],
              s = _Array$from$slice$map2[1],
              _l2 = _Array$from$slice$map2[2],
              a = _Array$from$slice$map2[3];
            if (guard(0, 100, s) !== s) throw new ColorError$1(color);
            if (guard(0, 100, _l2) !== _l2) throw new ColorError$1(color);
            return [].concat(_toConsumableArray(hslToRgb(_h2, s, _l2)), [Number.isNaN(a) ? 1 : a]);
          }
          throw new ColorError$1(color);
        }
        function hash$3(str) {
          var hash = 5381;
          var i = str.length;
          while (i) {
            hash = hash * 33 ^ str.charCodeAt(--i);
          }

          /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
           * integers. Since we want the results to be always positive, convert the
           * signed int to an unsigned by doing an unsigned bitshift. */
          return (hash >>> 0) % 2341;
        }
        var colorToInt = function colorToInt(x) {
          return parseInt(x.replace(/_/g, ''), 36);
        };
        var compressedColorMap = '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'.split(' ').reduce(function (acc, next) {
          var key = colorToInt(next.substring(0, 3));
          var hex = colorToInt(next.substring(3)).toString(16);

          // NOTE: padStart could be used here but it breaks Node 6 compat
          // https://github.com/ricokahler/color2k/issues/351
          var prefix = '';
          for (var i = 0; i < 6 - hex.length; i++) {
            prefix += '0';
          }
          acc[key] = "".concat(prefix).concat(hex);
          return acc;
        }, {});

        /**
         * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
         */
        function nameToHex(color) {
          var normalizedColorName = color.toLowerCase().trim();
          var result = compressedColorMap[hash$3(normalizedColorName)];
          if (!result) throw new ColorError$1(color);
          return "#".concat(result);
        }
        var r$1 = function r$1(str, amount) {
          return Array.from(Array(amount)).map(function () {
            return str;
          }).join('');
        };
        var reducedHexRegex = new RegExp("^#".concat(r$1('([a-f0-9])', 3), "([a-f0-9])?$"), 'i');
        var hexRegex = new RegExp("^#".concat(r$1('([a-f0-9]{2})', 3), "([a-f0-9]{2})?$"), 'i');
        var rgbaRegex = new RegExp("^rgba?\\(\\s*(\\d+)\\s*".concat(r$1(',\\s*(\\d+)\\s*', 2), "(?:,\\s*([\\d.]+))?\\s*\\)$"), 'i');
        var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
        var namedColorRegex = /^[a-z]+$/i;
        var roundColor = function roundColor(color) {
          return Math.round(color * 255);
        };
        var hslToRgb = function hslToRgb(hue, saturation, lightness) {
          var l = lightness / 100;
          if (saturation === 0) {
            // achromatic
            return [l, l, l].map(roundColor);
          }

          // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV
          var huePrime = (hue % 360 + 360) % 360 / 60;
          var chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
          var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
          var red = 0;
          var green = 0;
          var blue = 0;
          if (huePrime >= 0 && huePrime < 1) {
            red = chroma;
            green = secondComponent;
          } else if (huePrime >= 1 && huePrime < 2) {
            red = secondComponent;
            green = chroma;
          } else if (huePrime >= 2 && huePrime < 3) {
            green = chroma;
            blue = secondComponent;
          } else if (huePrime >= 3 && huePrime < 4) {
            green = secondComponent;
            blue = chroma;
          } else if (huePrime >= 4 && huePrime < 5) {
            red = secondComponent;
            blue = chroma;
          } else if (huePrime >= 5 && huePrime < 6) {
            red = chroma;
            blue = secondComponent;
          }
          var lightnessModification = l - chroma / 2;
          var finalRed = red + lightnessModification;
          var finalGreen = green + lightnessModification;
          var finalBlue = blue + lightnessModification;
          return [finalRed, finalGreen, finalBlue].map(roundColor);
        };

        /**
         * Takes in rgba parts and returns an rgba string
         *
         * @param red The amount of red in the red channel, given in a number between 0 and 255 inclusive
         * @param green The amount of green in the red channel, given in a number between 0 and 255 inclusive
         * @param blue The amount of blue in the red channel, given in a number between 0 and 255 inclusive
         * @param alpha Percentage of opacity, given as a decimal between 0 and 1
         */
        function rgba$1(red, green, blue, alpha) {
          return "rgba(".concat(guard(0, 255, red).toFixed(), ", ").concat(guard(0, 255, green).toFixed(), ", ").concat(guard(0, 255, blue).toFixed(), ", ").concat(parseFloat(guard(0, 1, alpha).toFixed(3)), ")");
        }

        /**
         * Takes in a color and makes it more transparent by convert to `rgba` and
         * decreasing the amount in the alpha channel.
         *
         * @param amount The amount to increase the transparency by, given as a decimal between 0 and 1
         */
        function transparentize$1(color, amount) {
          var _parseToRgba = parseToRgba(color),
            _parseToRgba2 = _slicedToArray(_parseToRgba, 4),
            r = _parseToRgba2[0],
            g = _parseToRgba2[1],
            b = _parseToRgba2[2],
            a = _parseToRgba2[3];
          return rgba$1(r, g, b, a - amount);
        }

        /**
         * Takes in any color and returns it as a hex code.
         */
        function toHex$1(color) {
          var _parseToRgba3 = parseToRgba(color),
            _parseToRgba4 = _slicedToArray(_parseToRgba3, 4),
            r = _parseToRgba4[0],
            g = _parseToRgba4[1],
            b = _parseToRgba4[2],
            a = _parseToRgba4[3];
          var hex = function hex(x) {
            var h = guard(0, 255, x).toString(16);
            // NOTE: padStart could be used here but it breaks Node 6 compat
            // https://github.com/ricokahler/color2k/issues/351
            return h.length === 1 ? "0".concat(h) : h;
          };
          return "#".concat(hex(r)).concat(hex(g)).concat(hex(b)).concat(a < 1 ? hex(Math.round(a * 255)) : '');
        }
        var isEmptyObject = function isEmptyObject(obj) {
          return Object.keys(obj).length === 0;
        };
        function get$1(obj, key, def, p, undef) {
          key = key.split ? key.split(".") : key;
          for (p = 0; p < key.length; p++) {
            obj = obj ? obj[key[p]] : undef;
          }
          return obj === undef ? def : obj;
        }
        var getColor = function getColor(theme, color, fallback) {
          var hex = get$1(theme, "colors.".concat(color), color);
          try {
            toHex$1(hex);
            return hex;
          } catch (_unused4) {
            return fallback !== null && fallback !== void 0 ? fallback : "#000000";
          }
        };
        var getBrightness = function getBrightness(color) {
          var _parseToRgba5 = parseToRgba(color),
            _parseToRgba6 = _slicedToArray(_parseToRgba5, 3),
            r = _parseToRgba6[0],
            g = _parseToRgba6[1],
            b = _parseToRgba6[2];
          return (r * 299 + g * 587 + b * 114) / 1e3;
        };
        var tone = function tone(color) {
          return function (theme) {
            var hex = getColor(theme, color);
            var brightness = getBrightness(hex);
            var isDark2 = brightness < 128;
            return isDark2 ? "dark" : "light";
          };
        };
        var isDark = function isDark(color) {
          return function (theme) {
            return tone(color)(theme) === "dark";
          };
        };
        var transparentize = function transparentize(color, opacity) {
          return function (theme) {
            var raw = getColor(theme, color);
            return transparentize$1(raw, 1 - opacity);
          };
        };
        function generateStripe() {
          var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "1rem";
          var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "rgba(255, 255, 255, 0.15)";
          return {
            backgroundImage: "linear-gradient(\n    45deg,\n    ".concat(color, " 25%,\n    transparent 25%,\n    transparent 50%,\n    ").concat(color, " 50%,\n    ").concat(color, " 75%,\n    transparent 75%,\n    transparent\n  )"),
            backgroundSize: "".concat(size, " ").concat(size)
          };
        }
        var randomHex = function randomHex() {
          return "#".concat(Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0"));
        };
        function randomColor(opts) {
          var fallback = randomHex();
          if (!opts || isEmptyObject(opts)) {
            return fallback;
          }
          if (opts.string && opts.colors) {
            return randomColorFromList(opts.string, opts.colors);
          }
          if (opts.string && !opts.colors) {
            return randomColorFromString(opts.string);
          }
          if (opts.colors && !opts.string) {
            return randomFromList(opts.colors);
          }
          return fallback;
        }
        function randomColorFromString(str) {
          var hash = 0;
          if (str.length === 0) return hash.toString();
          for (var i = 0; i < str.length; i += 1) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
            hash = hash & hash;
          }
          var color = "#";
          for (var j = 0; j < 3; j += 1) {
            var value = hash >> j * 8 & 255;
            color += "00".concat(value.toString(16)).substr(-2);
          }
          return color;
        }
        function randomColorFromList(str, list) {
          var index = 0;
          if (str.length === 0) return list[0];
          for (var i = 0; i < str.length; i += 1) {
            index = str.charCodeAt(i) + ((index << 5) - index);
            index = index & index;
          }
          index = (index % list.length + list.length) % list.length;
          return list[index];
        }
        function randomFromList(list) {
          return list[Math.floor(Math.random() * list.length)];
        }
        function mode(light, dark) {
          return function (props) {
            return props.colorMode === "dark" ? dark : light;
          };
        }
        function orient(options) {
          var orientation = options.orientation,
            vertical = options.vertical,
            horizontal = options.horizontal;
          if (!orientation) return {};
          return orientation === "vertical" ? vertical : horizontal;
        }
        function toRef(operand) {
          if (isObject(operand) && operand.reference) {
            return operand.reference;
          }
          return String(operand);
        }
        var toExpr = function toExpr(operator) {
          for (var _len22 = arguments.length, operands = new Array(_len22 > 1 ? _len22 - 1 : 0), _key24 = 1; _key24 < _len22; _key24++) {
            operands[_key24 - 1] = arguments[_key24];
          }
          return operands.map(toRef).join(" ".concat(operator, " ")).replace(/calc/g, "");
        };
        var _add = function add() {
          for (var _len23 = arguments.length, operands = new Array(_len23), _key25 = 0; _key25 < _len23; _key25++) {
            operands[_key25] = arguments[_key25];
          }
          return "calc(".concat(toExpr.apply(void 0, ["+"].concat(operands)), ")");
        };
        var _subtract = function subtract() {
          for (var _len24 = arguments.length, operands = new Array(_len24), _key26 = 0; _key26 < _len24; _key26++) {
            operands[_key26] = arguments[_key26];
          }
          return "calc(".concat(toExpr.apply(void 0, ["-"].concat(operands)), ")");
        };
        var _multiply = function multiply() {
          for (var _len25 = arguments.length, operands = new Array(_len25), _key27 = 0; _key27 < _len25; _key27++) {
            operands[_key27] = arguments[_key27];
          }
          return "calc(".concat(toExpr.apply(void 0, ["*"].concat(operands)), ")");
        };
        var _divide = function divide() {
          for (var _len26 = arguments.length, operands = new Array(_len26), _key28 = 0; _key28 < _len26; _key28++) {
            operands[_key28] = arguments[_key28];
          }
          return "calc(".concat(toExpr.apply(void 0, ["/"].concat(operands)), ")");
        };
        var _negate = function negate(x) {
          var value = toRef(x);
          if (value != null && !Number.isNaN(parseFloat(value))) {
            return String(value).startsWith("-") ? String(value).slice(1) : "-".concat(value);
          }
          return _multiply(value, -1);
        };
        var calc = Object.assign(function (x) {
          return {
            add: function add() {
              for (var _len27 = arguments.length, operands = new Array(_len27), _key29 = 0; _key29 < _len27; _key29++) {
                operands[_key29] = arguments[_key29];
              }
              return calc(_add.apply(void 0, [x].concat(operands)));
            },
            subtract: function subtract() {
              for (var _len28 = arguments.length, operands = new Array(_len28), _key30 = 0; _key30 < _len28; _key30++) {
                operands[_key30] = arguments[_key30];
              }
              return calc(_subtract.apply(void 0, [x].concat(operands)));
            },
            multiply: function multiply() {
              for (var _len29 = arguments.length, operands = new Array(_len29), _key31 = 0; _key31 < _len29; _key31++) {
                operands[_key31] = arguments[_key31];
              }
              return calc(_multiply.apply(void 0, [x].concat(operands)));
            },
            divide: function divide() {
              for (var _len30 = arguments.length, operands = new Array(_len30), _key32 = 0; _key32 < _len30; _key32++) {
                operands[_key32] = arguments[_key32];
              }
              return calc(_divide.apply(void 0, [x].concat(operands)));
            },
            negate: function negate() {
              return calc(_negate(x));
            },
            toString: function toString() {
              return x.toString();
            }
          };
        }, {
          add: _add,
          subtract: _subtract,
          multiply: _multiply,
          divide: _divide,
          negate: _negate
        });
        function isDecimal(value) {
          return !Number.isInteger(parseFloat(value.toString()));
        }
        function replaceWhiteSpace(value) {
          var replaceValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "-";
          return value.replace(/\s+/g, replaceValue);
        }
        function escape(value) {
          var valueStr = replaceWhiteSpace(value.toString());
          if (valueStr.includes("\\.")) return value;
          return isDecimal(value) ? valueStr.replace(".", "\\.") : value;
        }
        function addPrefix(value) {
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return [prefix, escape(value)].filter(Boolean).join("-");
        }
        function toVarRef(name, fallback) {
          return "var(".concat(escape(name)).concat(fallback ? ", ".concat(fallback) : "", ")");
        }
        function toVar$1(value) {
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return "--".concat(addPrefix(value, prefix));
        }
        function cssVar(name, options) {
          var cssVariable = toVar$1(name, options === null || options === void 0 ? void 0 : options.prefix);
          return {
            variable: cssVariable,
            reference: toVarRef(cssVariable, getFallback(options === null || options === void 0 ? void 0 : options.fallback))
          };
        }
        function getFallback(fallback) {
          return fallback === null || fallback === void 0 ? void 0 : fallback.reference;
        }
        var _createMultiStyleConf2 = createMultiStyleConfigHelpers(alertAnatomy.keys),
          definePartsStyle$o = _createMultiStyleConf2.definePartsStyle,
          defineMultiStyleConfig$o = _createMultiStyleConf2.defineMultiStyleConfig;
        var $fg$5 = cssVar$1("alert-fg");
        var $bg$f = cssVar$1("alert-bg");
        var baseStyle$F = definePartsStyle$o({
          container: {
            bg: $bg$f.reference,
            px: "4",
            py: "3"
          },
          title: {
            fontWeight: "bold",
            lineHeight: "6",
            marginEnd: "2"
          },
          description: {
            lineHeight: "6"
          },
          icon: {
            color: $fg$5.reference,
            flexShrink: 0,
            marginEnd: "3",
            w: "5",
            h: "6"
          },
          spinner: {
            color: $fg$5.reference,
            flexShrink: 0,
            marginEnd: "3",
            w: "5",
            h: "5"
          }
        });
        function getBg(props) {
          var theme = props.theme,
            c = props.colorScheme;
          var darkBg = transparentize("".concat(c, ".200"), 0.16)(theme);
          return {
            light: "colors.".concat(c, ".100"),
            dark: darkBg
          };
        }
        var variantSubtle$1 = definePartsStyle$o(function (props) {
          var c = props.colorScheme;
          var bg = getBg(props);
          return {
            container: _defineProperty2(_defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".600")), $bg$f.variable, bg.light), "_dark", _defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".200")), $bg$f.variable, bg.dark))
          };
        });
        var variantLeftAccent = definePartsStyle$o(function (props) {
          var c = props.colorScheme;
          var bg = getBg(props);
          return {
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".600")), $bg$f.variable, bg.light), "_dark", _defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".200")), $bg$f.variable, bg.dark)), "paddingStart", "3"), "borderStartWidth", "4px"), "borderStartColor", $fg$5.reference)
          };
        });
        var variantTopAccent = definePartsStyle$o(function (props) {
          var c = props.colorScheme;
          var bg = getBg(props);
          return {
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".600")), $bg$f.variable, bg.light), "_dark", _defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.".concat(c, ".200")), $bg$f.variable, bg.dark)), "pt", "2"), "borderTopWidth", "4px"), "borderTopColor", $fg$5.reference)
          };
        });
        var variantSolid$3 = definePartsStyle$o(function (props) {
          var c = props.colorScheme;
          return {
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.white"), $bg$f.variable, "colors.".concat(c, ".600")), "_dark", _defineProperty2(_defineProperty2({}, $fg$5.variable, "colors.gray.900"), $bg$f.variable, "colors.".concat(c, ".200"))), "color", $fg$5.reference)
          };
        });
        var variants$d = {
          subtle: variantSubtle$1,
          "left-accent": variantLeftAccent,
          "top-accent": variantTopAccent,
          solid: variantSolid$3
        };
        var alertTheme = defineMultiStyleConfig$o({
          baseStyle: baseStyle$F,
          variants: variants$d,
          defaultProps: {
            variant: "subtle",
            colorScheme: "blue"
          }
        });
        var spacing = {
          px: "1px",
          0.5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        };
        var largeSizes = {
          max: "max-content",
          min: "min-content",
          full: "100%",
          "3xs": "14rem",
          "2xs": "16rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          "8xl": "90rem",
          prose: "60ch"
        };
        var container = {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px"
        };
        var sizes$m = _objectSpread3(_objectSpread3(_objectSpread3({}, spacing), largeSizes), {}, {
          container: container
        });
        var isFunction$1 = function isFunction$1(value) {
          return typeof value === "function";
        };
        function runIfFn(valueOrFn) {
          for (var _len31 = arguments.length, args = new Array(_len31 > 1 ? _len31 - 1 : 0), _key33 = 1; _key33 < _len31; _key33++) {
            args[_key33 - 1] = arguments[_key33];
          }
          return isFunction$1(valueOrFn) ? valueOrFn.apply(void 0, args) : valueOrFn;
        }
        var _createMultiStyleConf3 = createMultiStyleConfigHelpers(avatarAnatomy.keys),
          definePartsStyle$n = _createMultiStyleConf3.definePartsStyle,
          defineMultiStyleConfig$n = _createMultiStyleConf3.defineMultiStyleConfig;
        var $border$3 = cssVar$1("avatar-border-color");
        var $bg$e = cssVar$1("avatar-bg");
        var $fs = cssVar$1("avatar-font-size");
        var $size$4 = cssVar$1("avatar-size");
        var baseStyleBadge = defineStyle(_defineProperty2(_defineProperty2({
          borderRadius: "full",
          border: "0.2em solid",
          borderColor: $border$3.reference
        }, $border$3.variable, "white"), "_dark", _defineProperty2({}, $border$3.variable, "colors.gray.800")));
        var baseStyleExcessLabel = defineStyle(_defineProperty2(_defineProperty2({
          bg: $bg$e.reference,
          fontSize: $fs.reference,
          width: $size$4.reference,
          height: $size$4.reference,
          lineHeight: "1"
        }, $bg$e.variable, "colors.gray.200"), "_dark", _defineProperty2({}, $bg$e.variable, "colors.whiteAlpha.400")));
        var baseStyleContainer$3 = defineStyle(function (props) {
          var name = props.name,
            theme = props.theme;
          var bg = name ? randomColor({
            string: name
          }) : "colors.gray.400";
          var isBgDark = isDark(bg)(theme);
          var color = "white";
          if (!isBgDark) color = "gray.800";
          return _defineProperty2(_defineProperty2({
            bg: $bg$e.reference,
            fontSize: $fs.reference,
            color: color,
            borderColor: $border$3.reference,
            verticalAlign: "top",
            width: $size$4.reference,
            height: $size$4.reference,
            "&:not([data-loaded])": _defineProperty2({}, $bg$e.variable, bg)
          }, $border$3.variable, "colors.white"), "_dark", _defineProperty2({}, $border$3.variable, "colors.gray.800"));
        });
        var baseStyleLabel$4 = defineStyle({
          fontSize: $fs.reference,
          lineHeight: "1"
        });
        var baseStyle$E = definePartsStyle$n(function (props) {
          return {
            badge: runIfFn(baseStyleBadge, props),
            excessLabel: runIfFn(baseStyleExcessLabel, props),
            container: runIfFn(baseStyleContainer$3, props),
            label: baseStyleLabel$4
          };
        });
        function getSize$3(size) {
          var themeSize = size !== "100%" ? sizes$m[size] : void 0;
          return definePartsStyle$n({
            container: _defineProperty2(_defineProperty2({}, $size$4.variable, themeSize !== null && themeSize !== void 0 ? themeSize : size), $fs.variable, "calc(".concat(themeSize !== null && themeSize !== void 0 ? themeSize : size, " / 2.5)")),
            excessLabel: _defineProperty2(_defineProperty2({}, $size$4.variable, themeSize !== null && themeSize !== void 0 ? themeSize : size), $fs.variable, "calc(".concat(themeSize !== null && themeSize !== void 0 ? themeSize : size, " / 2.5)"))
          });
        }
        var sizes$l = {
          "2xs": getSize$3(4),
          xs: getSize$3(6),
          sm: getSize$3(8),
          md: getSize$3(12),
          lg: getSize$3(16),
          xl: getSize$3(24),
          "2xl": getSize$3(32),
          full: getSize$3("100%")
        };
        var avatarTheme = defineMultiStyleConfig$n({
          baseStyle: baseStyle$E,
          sizes: sizes$l,
          defaultProps: {
            size: "md"
          }
        });
        var vars = defineCssVars("badge", ["bg", "color", "shadow"]);
        var baseStyle$D = defineStyle({
          px: 1,
          textTransform: "uppercase",
          fontSize: "xs",
          borderRadius: "sm",
          fontWeight: "bold",
          bg: vars.bg.reference,
          color: vars.color.reference,
          boxShadow: vars.shadow.reference
        });
        var variantSolid$2 = defineStyle(function (props) {
          var c = props.colorScheme,
            theme = props.theme;
          var dark = transparentize("".concat(c, ".500"), 0.6)(theme);
          return _defineProperty2(_defineProperty2(_defineProperty2({}, vars.bg.variable, "colors.".concat(c, ".500")), vars.color.variable, "colors.white"), "_dark", _defineProperty2(_defineProperty2({}, vars.bg.variable, dark), vars.color.variable, "colors.whiteAlpha.800"));
        });
        var variantSubtle = defineStyle(function (props) {
          var c = props.colorScheme,
            theme = props.theme;
          var darkBg = transparentize("".concat(c, ".200"), 0.16)(theme);
          return _defineProperty2(_defineProperty2(_defineProperty2({}, vars.bg.variable, "colors.".concat(c, ".100")), vars.color.variable, "colors.".concat(c, ".800")), "_dark", _defineProperty2(_defineProperty2({}, vars.bg.variable, darkBg), vars.color.variable, "colors.".concat(c, ".200")));
        });
        var variantOutline$2 = defineStyle(function (props) {
          var c = props.colorScheme,
            theme = props.theme;
          var darkColor = transparentize("".concat(c, ".200"), 0.8)(theme);
          return _defineProperty2(_defineProperty2(_defineProperty2({}, vars.color.variable, "colors.".concat(c, ".500")), "_dark", _defineProperty2({}, vars.color.variable, darkColor)), vars.shadow.variable, "inset 0 0 0px 1px ".concat(vars.color.reference));
        });
        var variants$c = {
          solid: variantSolid$2,
          subtle: variantSubtle,
          outline: variantOutline$2
        };
        var badgeTheme = defineStyleConfig({
          baseStyle: baseStyle$D,
          variants: variants$c,
          defaultProps: {
            variant: "subtle",
            colorScheme: "gray"
          }
        });
        var _createMultiStyleConf4 = createMultiStyleConfigHelpers(breadcrumbAnatomy.keys),
          defineMultiStyleConfig$m = _createMultiStyleConf4.defineMultiStyleConfig,
          definePartsStyle$m = _createMultiStyleConf4.definePartsStyle;
        var $decor = cssVar$1("breadcrumb-link-decor");
        var baseStyleLink = defineStyle(_defineProperty2(_defineProperty2({
          transitionProperty: "common",
          transitionDuration: "fast",
          transitionTimingFunction: "ease-out",
          outline: "none",
          color: "inherit",
          textDecoration: $decor.reference
        }, $decor.variable, "none"), "&:not([aria-current=page])", {
          cursor: "pointer",
          _hover: _defineProperty2({}, $decor.variable, "underline"),
          _focusVisible: {
            boxShadow: "outline"
          }
        }));
        var baseStyle$C = definePartsStyle$m({
          link: baseStyleLink
        });
        var breadcrumbTheme = defineMultiStyleConfig$m({
          baseStyle: baseStyle$C
        });
        var baseStyle$B = defineStyle({
          lineHeight: "1.2",
          borderRadius: "md",
          fontWeight: "semibold",
          transitionProperty: "common",
          transitionDuration: "normal",
          _focusVisible: {
            boxShadow: "outline"
          },
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed",
            boxShadow: "none"
          },
          _hover: {
            _disabled: {
              bg: "initial"
            }
          }
        });
        var variantGhost = defineStyle(function (props) {
          var c = props.colorScheme,
            theme = props.theme;
          if (c === "gray") {
            return {
              color: mode("gray.800", "whiteAlpha.900")(props),
              _hover: {
                bg: mode("gray.100", "whiteAlpha.200")(props)
              },
              _active: {
                bg: mode("gray.200", "whiteAlpha.300")(props)
              }
            };
          }
          var darkHoverBg = transparentize("".concat(c, ".200"), 0.12)(theme);
          var darkActiveBg = transparentize("".concat(c, ".200"), 0.24)(theme);
          return {
            color: mode("".concat(c, ".600"), "".concat(c, ".200"))(props),
            bg: "transparent",
            _hover: {
              bg: mode("".concat(c, ".50"), darkHoverBg)(props)
            },
            _active: {
              bg: mode("".concat(c, ".100"), darkActiveBg)(props)
            }
          };
        });
        var variantOutline$1 = defineStyle(function (props) {
          var c = props.colorScheme;
          var borderColor = mode("gray.200", "whiteAlpha.300")(props);
          return _objectSpread3({
            border: "1px solid",
            borderColor: c === "gray" ? borderColor : "currentColor",
            ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {
              marginEnd: "-1px"
            },
            ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {
              marginBottom: "-1px"
            }
          }, runIfFn(variantGhost, props));
        });
        var accessibleColorMap = {
          yellow: {
            bg: "yellow.400",
            color: "black",
            hoverBg: "yellow.500",
            activeBg: "yellow.600"
          },
          cyan: {
            bg: "cyan.400",
            color: "black",
            hoverBg: "cyan.500",
            activeBg: "cyan.600"
          }
        };
        var variantSolid$1 = defineStyle(function (props) {
          var _accessibleColorMap$c;
          var c = props.colorScheme;
          if (c === "gray") {
            var bg2 = mode("gray.100", "whiteAlpha.200")(props);
            return {
              bg: bg2,
              color: mode("gray.800", "whiteAlpha.900")(props),
              _hover: {
                bg: mode("gray.200", "whiteAlpha.300")(props),
                _disabled: {
                  bg: bg2
                }
              },
              _active: {
                bg: mode("gray.300", "whiteAlpha.400")(props)
              }
            };
          }
          var _ref51 = (_accessibleColorMap$c = accessibleColorMap[c]) !== null && _accessibleColorMap$c !== void 0 ? _accessibleColorMap$c : {},
            _ref51$bg = _ref51.bg,
            bg = _ref51$bg === void 0 ? "".concat(c, ".500") : _ref51$bg,
            _ref51$color = _ref51.color,
            color = _ref51$color === void 0 ? "white" : _ref51$color,
            _ref51$hoverBg = _ref51.hoverBg,
            hoverBg = _ref51$hoverBg === void 0 ? "".concat(c, ".600") : _ref51$hoverBg,
            _ref51$activeBg = _ref51.activeBg,
            activeBg = _ref51$activeBg === void 0 ? "".concat(c, ".700") : _ref51$activeBg;
          var background = mode(bg, "".concat(c, ".200"))(props);
          return {
            bg: background,
            color: mode(color, "gray.800")(props),
            _hover: {
              bg: mode(hoverBg, "".concat(c, ".300"))(props),
              _disabled: {
                bg: background
              }
            },
            _active: {
              bg: mode(activeBg, "".concat(c, ".400"))(props)
            }
          };
        });
        var variantLink = defineStyle(function (props) {
          var c = props.colorScheme;
          return {
            padding: 0,
            height: "auto",
            lineHeight: "normal",
            verticalAlign: "baseline",
            color: mode("".concat(c, ".500"), "".concat(c, ".200"))(props),
            _hover: {
              textDecoration: "underline",
              _disabled: {
                textDecoration: "none"
              }
            },
            _active: {
              color: mode("".concat(c, ".700"), "".concat(c, ".500"))(props)
            }
          };
        });
        var variantUnstyled$2 = defineStyle({
          bg: "none",
          color: "inherit",
          display: "inline",
          lineHeight: "inherit",
          m: "0",
          p: "0"
        });
        var variants$b = {
          ghost: variantGhost,
          outline: variantOutline$1,
          solid: variantSolid$1,
          link: variantLink,
          unstyled: variantUnstyled$2
        };
        var sizes$k = {
          lg: defineStyle({
            h: "12",
            minW: "12",
            fontSize: "lg",
            px: "6"
          }),
          md: defineStyle({
            h: "10",
            minW: "10",
            fontSize: "md",
            px: "4"
          }),
          sm: defineStyle({
            h: "8",
            minW: "8",
            fontSize: "sm",
            px: "3"
          }),
          xs: defineStyle({
            h: "6",
            minW: "6",
            fontSize: "xs",
            px: "2"
          })
        };
        var buttonTheme = defineStyleConfig({
          baseStyle: baseStyle$B,
          variants: variants$b,
          sizes: sizes$k,
          defaultProps: {
            variant: "solid",
            size: "md",
            colorScheme: "gray"
          }
        });
        var _createMultiStyleConf5 = createMultiStyleConfigHelpers(cardAnatomy.keys),
          definePartsStyle$l = _createMultiStyleConf5.definePartsStyle,
          defineMultiStyleConfig$l = _createMultiStyleConf5.defineMultiStyleConfig;
        var $bg$d = cssVar$1("card-bg");
        var $padding$1 = cssVar$1("card-padding");
        var $shadow$3 = cssVar$1("card-shadow");
        var $radius = cssVar$1("card-radius");
        var $border$2 = cssVar$1("card-border-width", "0");
        var $borderColor = cssVar$1("card-border-color");
        var baseStyle$A = definePartsStyle$l({
          container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $bg$d.variable, "colors.chakra-body-bg"), "backgroundColor", $bg$d.reference), "boxShadow", $shadow$3.reference), "borderRadius", $radius.reference), "color", "chakra-body-text"), "borderWidth", $border$2.reference), "borderColor", $borderColor.reference),
          body: {
            padding: $padding$1.reference,
            flex: "1 1 0%"
          },
          header: {
            padding: $padding$1.reference
          },
          footer: {
            padding: $padding$1.reference
          }
        });
        var sizes$j = {
          sm: definePartsStyle$l({
            container: _defineProperty2(_defineProperty2({}, $radius.variable, "radii.base"), $padding$1.variable, "space.3")
          }),
          md: definePartsStyle$l({
            container: _defineProperty2(_defineProperty2({}, $radius.variable, "radii.md"), $padding$1.variable, "space.5")
          }),
          lg: definePartsStyle$l({
            container: _defineProperty2(_defineProperty2({}, $radius.variable, "radii.xl"), $padding$1.variable, "space.7")
          })
        };
        var variants$a = {
          elevated: definePartsStyle$l({
            container: _defineProperty2(_defineProperty2({}, $shadow$3.variable, "shadows.base"), "_dark", _defineProperty2({}, $bg$d.variable, "colors.gray.700"))
          }),
          outline: definePartsStyle$l({
            container: _defineProperty2(_defineProperty2({}, $border$2.variable, "1px"), $borderColor.variable, "colors.chakra-border-color")
          }),
          filled: definePartsStyle$l({
            container: _defineProperty2({}, $bg$d.variable, "colors.chakra-subtle-bg")
          }),
          unstyled: {
            body: _defineProperty2({}, $padding$1.variable, 0),
            header: _defineProperty2({}, $padding$1.variable, 0),
            footer: _defineProperty2({}, $padding$1.variable, 0)
          }
        };
        var cardTheme = defineMultiStyleConfig$l({
          baseStyle: baseStyle$A,
          variants: variants$a,
          sizes: sizes$j,
          defaultProps: {
            variant: "elevated",
            size: "md"
          }
        });
        var _createMultiStyleConf6 = createMultiStyleConfigHelpers(checkboxAnatomy.keys),
          definePartsStyle$k = _createMultiStyleConf6.definePartsStyle,
          defineMultiStyleConfig$k = _createMultiStyleConf6.defineMultiStyleConfig;
        var $size$3 = cssVar$1("checkbox-size");
        var baseStyleControl$1 = defineStyle(function (props) {
          var c = props.colorScheme;
          return {
            w: $size$3.reference,
            h: $size$3.reference,
            transitionProperty: "box-shadow",
            transitionDuration: "normal",
            border: "2px solid",
            borderRadius: "sm",
            borderColor: "inherit",
            color: "white",
            _checked: {
              bg: mode("".concat(c, ".500"), "".concat(c, ".200"))(props),
              borderColor: mode("".concat(c, ".500"), "".concat(c, ".200"))(props),
              color: mode("white", "gray.900")(props),
              _hover: {
                bg: mode("".concat(c, ".600"), "".concat(c, ".300"))(props),
                borderColor: mode("".concat(c, ".600"), "".concat(c, ".300"))(props)
              },
              _disabled: {
                borderColor: mode("gray.200", "transparent")(props),
                bg: mode("gray.200", "whiteAlpha.300")(props),
                color: mode("gray.500", "whiteAlpha.500")(props)
              }
            },
            _indeterminate: {
              bg: mode("".concat(c, ".500"), "".concat(c, ".200"))(props),
              borderColor: mode("".concat(c, ".500"), "".concat(c, ".200"))(props),
              color: mode("white", "gray.900")(props)
            },
            _disabled: {
              bg: mode("gray.100", "whiteAlpha.100")(props),
              borderColor: mode("gray.100", "transparent")(props)
            },
            _focusVisible: {
              boxShadow: "outline"
            },
            _invalid: {
              borderColor: mode("red.500", "red.300")(props)
            }
          };
        });
        var baseStyleContainer$2 = defineStyle({
          _disabled: {
            cursor: "not-allowed"
          }
        });
        var baseStyleLabel$3 = defineStyle({
          userSelect: "none",
          _disabled: {
            opacity: 0.4
          }
        });
        var baseStyleIcon$5 = defineStyle({
          transitionProperty: "transform",
          transitionDuration: "normal"
        });
        var baseStyle$z = definePartsStyle$k(function (props) {
          return {
            icon: baseStyleIcon$5,
            container: baseStyleContainer$2,
            control: runIfFn(baseStyleControl$1, props),
            label: baseStyleLabel$3
          };
        });
        var sizes$i = {
          sm: definePartsStyle$k({
            control: _defineProperty2({}, $size$3.variable, "sizes.3"),
            label: {
              fontSize: "sm"
            },
            icon: {
              fontSize: "3xs"
            }
          }),
          md: definePartsStyle$k({
            control: _defineProperty2({}, $size$3.variable, "sizes.4"),
            label: {
              fontSize: "md"
            },
            icon: {
              fontSize: "2xs"
            }
          }),
          lg: definePartsStyle$k({
            control: _defineProperty2({}, $size$3.variable, "sizes.5"),
            label: {
              fontSize: "lg"
            },
            icon: {
              fontSize: "2xs"
            }
          })
        };
        var checkboxTheme = defineMultiStyleConfig$k({
          baseStyle: baseStyle$z,
          sizes: sizes$i,
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var $size$2 = cssVar("close-button-size");
        var $bg$c = cssVar("close-button-bg");
        var baseStyle$y = defineStyle({
          w: [$size$2.reference],
          h: [$size$2.reference],
          borderRadius: "md",
          transitionProperty: "common",
          transitionDuration: "normal",
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed",
            boxShadow: "none"
          },
          _hover: _defineProperty2(_defineProperty2({}, $bg$c.variable, "colors.blackAlpha.100"), "_dark", _defineProperty2({}, $bg$c.variable, "colors.whiteAlpha.100")),
          _active: _defineProperty2(_defineProperty2({}, $bg$c.variable, "colors.blackAlpha.200"), "_dark", _defineProperty2({}, $bg$c.variable, "colors.whiteAlpha.200")),
          _focusVisible: {
            boxShadow: "outline"
          },
          bg: $bg$c.reference
        });
        var sizes$h = {
          lg: defineStyle(_defineProperty2(_defineProperty2({}, $size$2.variable, "sizes.10"), "fontSize", "md")),
          md: defineStyle(_defineProperty2(_defineProperty2({}, $size$2.variable, "sizes.8"), "fontSize", "xs")),
          sm: defineStyle(_defineProperty2(_defineProperty2({}, $size$2.variable, "sizes.6"), "fontSize", "2xs"))
        };
        var closeButtonTheme = defineStyleConfig({
          baseStyle: baseStyle$y,
          sizes: sizes$h,
          defaultProps: {
            size: "md"
          }
        });
        var variants$9 = badgeTheme.variants,
          defaultProps = badgeTheme.defaultProps;
        var baseStyle$x = defineStyle({
          fontFamily: "mono",
          fontSize: "sm",
          px: "0.2em",
          borderRadius: "sm",
          bg: vars.bg.reference,
          color: vars.color.reference,
          boxShadow: vars.shadow.reference
        });
        var codeTheme = defineStyleConfig({
          baseStyle: baseStyle$x,
          variants: variants$9,
          defaultProps: defaultProps
        });
        var baseStyle$w = defineStyle({
          w: "100%",
          mx: "auto",
          maxW: "prose",
          px: "4"
        });
        var containerTheme = defineStyleConfig({
          baseStyle: baseStyle$w
        });
        var baseStyle$v = defineStyle({
          opacity: 0.6,
          borderColor: "inherit"
        });
        var variantSolid = defineStyle({
          borderStyle: "solid"
        });
        var variantDashed = defineStyle({
          borderStyle: "dashed"
        });
        var variants$8 = {
          solid: variantSolid,
          dashed: variantDashed
        };
        var dividerTheme = defineStyleConfig({
          baseStyle: baseStyle$v,
          variants: variants$8,
          defaultProps: {
            variant: "solid"
          }
        });
        var _createMultiStyleConf7 = createMultiStyleConfigHelpers(drawerAnatomy.keys),
          definePartsStyle$j = _createMultiStyleConf7.definePartsStyle,
          defineMultiStyleConfig$j = _createMultiStyleConf7.defineMultiStyleConfig;
        var $bg$b = cssVar$1("drawer-bg");
        var $bs = cssVar$1("drawer-box-shadow");
        function getSize$2(value) {
          if (value === "full") {
            return definePartsStyle$j({
              dialog: {
                maxW: "100vw",
                h: "100vh"
              }
            });
          }
          return definePartsStyle$j({
            dialog: {
              maxW: value
            }
          });
        }
        var baseStyleOverlay$1 = defineStyle({
          bg: "blackAlpha.600",
          zIndex: "modal"
        });
        var baseStyleDialogContainer$1 = defineStyle({
          display: "flex",
          zIndex: "modal",
          justifyContent: "center"
        });
        var baseStyleDialog$1 = defineStyle(function (props) {
          var isFullHeight = props.isFullHeight;
          return _objectSpread3(_objectSpread3({}, isFullHeight && {
            height: "100vh"
          }), {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
            zIndex: "modal",
            maxH: "100vh",
            color: "inherit"
          }, $bg$b.variable, "colors.white"), $bs.variable, "shadows.lg"), "_dark", _defineProperty2(_defineProperty2({}, $bg$b.variable, "colors.gray.700"), $bs.variable, "shadows.dark-lg")), "bg", $bg$b.reference), "boxShadow", $bs.reference));
        });
        var baseStyleHeader$2 = defineStyle({
          px: "6",
          py: "4",
          fontSize: "xl",
          fontWeight: "semibold"
        });
        var baseStyleCloseButton$3 = defineStyle({
          position: "absolute",
          top: "2",
          insetEnd: "3"
        });
        var baseStyleBody$2 = defineStyle({
          px: "6",
          py: "2",
          flex: "1",
          overflow: "auto"
        });
        var baseStyleFooter$2 = defineStyle({
          px: "6",
          py: "4"
        });
        var baseStyle$u = definePartsStyle$j(function (props) {
          return {
            overlay: baseStyleOverlay$1,
            dialogContainer: baseStyleDialogContainer$1,
            dialog: runIfFn(baseStyleDialog$1, props),
            header: baseStyleHeader$2,
            closeButton: baseStyleCloseButton$3,
            body: baseStyleBody$2,
            footer: baseStyleFooter$2
          };
        });
        var sizes$g = {
          xs: getSize$2("xs"),
          sm: getSize$2("md"),
          md: getSize$2("lg"),
          lg: getSize$2("2xl"),
          xl: getSize$2("4xl"),
          full: getSize$2("full")
        };
        var drawerTheme = defineMultiStyleConfig$j({
          baseStyle: baseStyle$u,
          sizes: sizes$g,
          defaultProps: {
            size: "xs"
          }
        });
        var _createMultiStyleConf8 = createMultiStyleConfigHelpers(editableAnatomy.keys),
          definePartsStyle$i = _createMultiStyleConf8.definePartsStyle,
          defineMultiStyleConfig$i = _createMultiStyleConf8.defineMultiStyleConfig;
        var baseStylePreview = defineStyle({
          borderRadius: "md",
          py: "1",
          transitionProperty: "common",
          transitionDuration: "normal"
        });
        var baseStyleInput = defineStyle({
          borderRadius: "md",
          py: "1",
          transitionProperty: "common",
          transitionDuration: "normal",
          width: "full",
          _focusVisible: {
            boxShadow: "outline"
          },
          _placeholder: {
            opacity: 0.6
          }
        });
        var baseStyleTextarea = defineStyle({
          borderRadius: "md",
          py: "1",
          transitionProperty: "common",
          transitionDuration: "normal",
          width: "full",
          _focusVisible: {
            boxShadow: "outline"
          },
          _placeholder: {
            opacity: 0.6
          }
        });
        var baseStyle$t = definePartsStyle$i({
          preview: baseStylePreview,
          input: baseStyleInput,
          textarea: baseStyleTextarea
        });
        var editableTheme = defineMultiStyleConfig$i({
          baseStyle: baseStyle$t
        });
        var _createMultiStyleConf9 = createMultiStyleConfigHelpers(formAnatomy.keys),
          definePartsStyle$h = _createMultiStyleConf9.definePartsStyle,
          defineMultiStyleConfig$h = _createMultiStyleConf9.defineMultiStyleConfig;
        var $fg$4 = cssVar$1("form-control-color");
        var baseStyleRequiredIndicator = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2({
          marginStart: "1"
        }, $fg$4.variable, "colors.red.500"), "_dark", _defineProperty2({}, $fg$4.variable, "colors.red.300")), "color", $fg$4.reference));
        var baseStyleHelperText = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
          mt: "2"
        }, $fg$4.variable, "colors.gray.600"), "_dark", _defineProperty2({}, $fg$4.variable, "colors.whiteAlpha.600")), "color", $fg$4.reference), "lineHeight", "normal"), "fontSize", "sm"));
        var baseStyle$s = definePartsStyle$h({
          container: {
            width: "100%",
            position: "relative"
          },
          requiredIndicator: baseStyleRequiredIndicator,
          helperText: baseStyleHelperText
        });
        var formTheme = defineMultiStyleConfig$h({
          baseStyle: baseStyle$s
        });
        var _createMultiStyleConf0 = createMultiStyleConfigHelpers(formErrorAnatomy.keys),
          definePartsStyle$g = _createMultiStyleConf0.definePartsStyle,
          defineMultiStyleConfig$g = _createMultiStyleConf0.defineMultiStyleConfig;
        var $fg$3 = cssVar$1("form-error-color");
        var baseStyleText = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fg$3.variable, "colors.red.500"), "_dark", _defineProperty2({}, $fg$3.variable, "colors.red.300")), "color", $fg$3.reference), "mt", "2"), "fontSize", "sm"), "lineHeight", "normal"));
        var baseStyleIcon$4 = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2({
          marginEnd: "0.5em"
        }, $fg$3.variable, "colors.red.500"), "_dark", _defineProperty2({}, $fg$3.variable, "colors.red.300")), "color", $fg$3.reference));
        var baseStyle$r = definePartsStyle$g({
          text: baseStyleText,
          icon: baseStyleIcon$4
        });
        var formErrorTheme = defineMultiStyleConfig$g({
          baseStyle: baseStyle$r
        });
        var baseStyle$q = defineStyle({
          fontSize: "md",
          marginEnd: "3",
          mb: "2",
          fontWeight: "medium",
          transitionProperty: "common",
          transitionDuration: "normal",
          opacity: 1,
          _disabled: {
            opacity: 0.4
          }
        });
        var formLabelTheme = defineStyleConfig({
          baseStyle: baseStyle$q
        });
        var baseStyle$p = defineStyle({
          fontFamily: "heading",
          fontWeight: "bold"
        });
        var sizes$f = {
          "4xl": defineStyle({
            fontSize: ["6xl", null, "7xl"],
            lineHeight: 1
          }),
          "3xl": defineStyle({
            fontSize: ["5xl", null, "6xl"],
            lineHeight: 1
          }),
          "2xl": defineStyle({
            fontSize: ["4xl", null, "5xl"],
            lineHeight: [1.2, null, 1]
          }),
          xl: defineStyle({
            fontSize: ["3xl", null, "4xl"],
            lineHeight: [1.33, null, 1.2]
          }),
          lg: defineStyle({
            fontSize: ["2xl", null, "3xl"],
            lineHeight: [1.33, null, 1.2]
          }),
          md: defineStyle({
            fontSize: "xl",
            lineHeight: 1.2
          }),
          sm: defineStyle({
            fontSize: "md",
            lineHeight: 1.2
          }),
          xs: defineStyle({
            fontSize: "sm",
            lineHeight: 1.2
          })
        };
        var headingTheme = defineStyleConfig({
          baseStyle: baseStyle$p,
          sizes: sizes$f,
          defaultProps: {
            size: "xl"
          }
        });
        var _createMultiStyleConf1 = createMultiStyleConfigHelpers(inputAnatomy.keys),
          definePartsStyle$f = _createMultiStyleConf1.definePartsStyle,
          defineMultiStyleConfig$f = _createMultiStyleConf1.defineMultiStyleConfig;
        var $height$1 = cssVar$1("input-height");
        var $fontSize$1 = cssVar$1("input-font-size");
        var $padding = cssVar$1("input-padding");
        var $borderRadius = cssVar$1("input-border-radius");
        var baseStyle$o = definePartsStyle$f({
          addon: {
            height: $height$1.reference,
            fontSize: $fontSize$1.reference,
            px: $padding.reference,
            borderRadius: $borderRadius.reference
          },
          field: {
            width: "100%",
            height: $height$1.reference,
            fontSize: $fontSize$1.reference,
            px: $padding.reference,
            borderRadius: $borderRadius.reference,
            minWidth: 0,
            outline: 0,
            position: "relative",
            appearance: "none",
            transitionProperty: "common",
            transitionDuration: "normal",
            _disabled: {
              opacity: 0.4,
              cursor: "not-allowed"
            }
          }
        });
        var size = {
          lg: defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fontSize$1.variable, "fontSizes.lg"), $padding.variable, "space.4"), $borderRadius.variable, "radii.md"), $height$1.variable, "sizes.12")),
          md: defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fontSize$1.variable, "fontSizes.md"), $padding.variable, "space.4"), $borderRadius.variable, "radii.md"), $height$1.variable, "sizes.10")),
          sm: defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fontSize$1.variable, "fontSizes.sm"), $padding.variable, "space.3"), $borderRadius.variable, "radii.sm"), $height$1.variable, "sizes.8")),
          xs: defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fontSize$1.variable, "fontSizes.xs"), $padding.variable, "space.2"), $borderRadius.variable, "radii.sm"), $height$1.variable, "sizes.6"))
        };
        var sizes$e = {
          lg: definePartsStyle$f({
            field: size.lg,
            group: size.lg
          }),
          md: definePartsStyle$f({
            field: size.md,
            group: size.md
          }),
          sm: definePartsStyle$f({
            field: size.sm,
            group: size.sm
          }),
          xs: definePartsStyle$f({
            field: size.xs,
            group: size.xs
          })
        };
        function getDefaults(props) {
          var fc = props.focusBorderColor,
            ec = props.errorBorderColor;
          return {
            focusBorderColor: fc || mode("blue.500", "blue.300")(props),
            errorBorderColor: ec || mode("red.500", "red.300")(props)
          };
        }
        var variantOutline = definePartsStyle$f(function (props) {
          var theme = props.theme;
          var _getDefaults = getDefaults(props),
            fc = _getDefaults.focusBorderColor,
            ec = _getDefaults.errorBorderColor;
          return {
            field: {
              border: "1px solid",
              borderColor: "inherit",
              bg: "inherit",
              _hover: {
                borderColor: mode("gray.300", "whiteAlpha.400")(props)
              },
              _readOnly: {
                boxShadow: "none !important",
                userSelect: "all"
              },
              _invalid: {
                borderColor: getColor(theme, ec),
                boxShadow: "0 0 0 1px ".concat(getColor(theme, ec))
              },
              _focusVisible: {
                zIndex: 1,
                borderColor: getColor(theme, fc),
                boxShadow: "0 0 0 1px ".concat(getColor(theme, fc))
              }
            },
            addon: {
              border: "1px solid",
              borderColor: mode("inherit", "whiteAlpha.50")(props),
              bg: mode("gray.100", "whiteAlpha.300")(props)
            }
          };
        });
        var variantFilled = definePartsStyle$f(function (props) {
          var theme = props.theme;
          var _getDefaults2 = getDefaults(props),
            fc = _getDefaults2.focusBorderColor,
            ec = _getDefaults2.errorBorderColor;
          return {
            field: {
              border: "2px solid",
              borderColor: "transparent",
              bg: mode("gray.100", "whiteAlpha.50")(props),
              _hover: {
                bg: mode("gray.200", "whiteAlpha.100")(props)
              },
              _readOnly: {
                boxShadow: "none !important",
                userSelect: "all"
              },
              _invalid: {
                borderColor: getColor(theme, ec)
              },
              _focusVisible: {
                bg: "transparent",
                borderColor: getColor(theme, fc)
              }
            },
            addon: {
              border: "2px solid",
              borderColor: "transparent",
              bg: mode("gray.100", "whiteAlpha.50")(props)
            }
          };
        });
        var variantFlushed = definePartsStyle$f(function (props) {
          var theme = props.theme;
          var _getDefaults3 = getDefaults(props),
            fc = _getDefaults3.focusBorderColor,
            ec = _getDefaults3.errorBorderColor;
          return {
            field: {
              borderBottom: "1px solid",
              borderColor: "inherit",
              borderRadius: "0",
              px: "0",
              bg: "transparent",
              _readOnly: {
                boxShadow: "none !important",
                userSelect: "all"
              },
              _invalid: {
                borderColor: getColor(theme, ec),
                boxShadow: "0px 1px 0px 0px ".concat(getColor(theme, ec))
              },
              _focusVisible: {
                borderColor: getColor(theme, fc),
                boxShadow: "0px 1px 0px 0px ".concat(getColor(theme, fc))
              }
            },
            addon: {
              borderBottom: "2px solid",
              borderColor: "inherit",
              borderRadius: "0",
              px: "0",
              bg: "transparent"
            }
          };
        });
        var variantUnstyled$1 = definePartsStyle$f({
          field: {
            bg: "transparent",
            px: "0",
            height: "auto"
          },
          addon: {
            bg: "transparent",
            px: "0",
            height: "auto"
          }
        });
        var variants$7 = {
          outline: variantOutline,
          filled: variantFilled,
          flushed: variantFlushed,
          unstyled: variantUnstyled$1
        };
        var inputTheme = defineMultiStyleConfig$f({
          baseStyle: baseStyle$o,
          sizes: sizes$e,
          variants: variants$7,
          defaultProps: {
            size: "md",
            variant: "outline"
          }
        });
        var $bg$a = cssVar$1("kbd-bg");
        var baseStyle$n = defineStyle((_defineStyle13 = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineStyle13, $bg$a.variable, "colors.gray.100"), "_dark", _defineProperty2({}, $bg$a.variable, "colors.whiteAlpha.100")), "bg", $bg$a.reference), "borderRadius", "md"), "borderWidth", "1px"), "borderBottomWidth", "3px"), "fontSize", "0.8em"), "fontWeight", "bold"), "lineHeight", "normal"), "px", "0.4em"), _defineProperty2(_defineStyle13, "whiteSpace", "nowrap")));
        var kbdTheme = defineStyleConfig({
          baseStyle: baseStyle$n
        });
        var baseStyle$m = defineStyle({
          transitionProperty: "common",
          transitionDuration: "fast",
          transitionTimingFunction: "ease-out",
          cursor: "pointer",
          textDecoration: "none",
          outline: "none",
          color: "inherit",
          _hover: {
            textDecoration: "underline"
          },
          _focusVisible: {
            boxShadow: "outline"
          }
        });
        var linkTheme = defineStyleConfig({
          baseStyle: baseStyle$m
        });
        var _createMultiStyleConf10 = createMultiStyleConfigHelpers(listAnatomy.keys),
          defineMultiStyleConfig$e = _createMultiStyleConf10.defineMultiStyleConfig,
          definePartsStyle$e = _createMultiStyleConf10.definePartsStyle;
        var baseStyleIcon$3 = defineStyle({
          marginEnd: "2",
          display: "inline",
          verticalAlign: "text-bottom"
        });
        var baseStyle$l = definePartsStyle$e({
          icon: baseStyleIcon$3
        });
        var listTheme = defineMultiStyleConfig$e({
          baseStyle: baseStyle$l
        });
        var _createMultiStyleConf11 = createMultiStyleConfigHelpers(menuAnatomy.keys),
          defineMultiStyleConfig$d = _createMultiStyleConf11.defineMultiStyleConfig,
          definePartsStyle$d = _createMultiStyleConf11.definePartsStyle;
        var $bg$9 = cssVar$1("menu-bg");
        var $shadow$2 = cssVar$1("menu-shadow");
        var baseStyleList = defineStyle((_defineStyle14 = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineStyle14, $bg$9.variable, "#fff"), $shadow$2.variable, "shadows.sm"), "_dark", _defineProperty2(_defineProperty2({}, $bg$9.variable, "colors.gray.700"), $shadow$2.variable, "shadows.dark-lg")), "color", "inherit"), "minW", "3xs"), "py", "2"), "zIndex", "dropdown"), "borderRadius", "md"), "borderWidth", "1px"), "bg", $bg$9.reference), _defineProperty2(_defineStyle14, "boxShadow", $shadow$2.reference)));
        var baseStyleItem = defineStyle({
          py: "1.5",
          px: "3",
          transitionProperty: "background",
          transitionDuration: "ultra-fast",
          transitionTimingFunction: "ease-in",
          _focus: _defineProperty2(_defineProperty2({}, $bg$9.variable, "colors.gray.100"), "_dark", _defineProperty2({}, $bg$9.variable, "colors.whiteAlpha.100")),
          _active: _defineProperty2(_defineProperty2({}, $bg$9.variable, "colors.gray.200"), "_dark", _defineProperty2({}, $bg$9.variable, "colors.whiteAlpha.200")),
          _expanded: _defineProperty2(_defineProperty2({}, $bg$9.variable, "colors.gray.100"), "_dark", _defineProperty2({}, $bg$9.variable, "colors.whiteAlpha.100")),
          _disabled: {
            opacity: 0.4,
            cursor: "not-allowed"
          },
          bg: $bg$9.reference
        });
        var baseStyleGroupTitle = defineStyle({
          mx: 4,
          my: 2,
          fontWeight: "semibold",
          fontSize: "sm"
        });
        var baseStyleIcon$2 = defineStyle({
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0
        });
        var baseStyleCommand = defineStyle({
          opacity: 0.6
        });
        var baseStyleDivider = defineStyle({
          border: 0,
          borderBottom: "1px solid",
          borderColor: "inherit",
          my: "2",
          opacity: 0.6
        });
        var baseStyleButton = defineStyle({
          transitionProperty: "common",
          transitionDuration: "normal"
        });
        var baseStyle$k = definePartsStyle$d({
          button: baseStyleButton,
          list: baseStyleList,
          item: baseStyleItem,
          groupTitle: baseStyleGroupTitle,
          icon: baseStyleIcon$2,
          command: baseStyleCommand,
          divider: baseStyleDivider
        });
        var menuTheme = defineMultiStyleConfig$d({
          baseStyle: baseStyle$k
        });
        var _createMultiStyleConf12 = createMultiStyleConfigHelpers(modalAnatomy.keys),
          defineMultiStyleConfig$c = _createMultiStyleConf12.defineMultiStyleConfig,
          definePartsStyle$c = _createMultiStyleConf12.definePartsStyle;
        var $bg$8 = cssVar$1("modal-bg");
        var $shadow$1 = cssVar$1("modal-shadow");
        var baseStyleOverlay = defineStyle({
          bg: "blackAlpha.600",
          zIndex: "modal"
        });
        var baseStyleDialogContainer = defineStyle(function (props) {
          var isCentered = props.isCentered,
            scrollBehavior = props.scrollBehavior;
          return {
            display: "flex",
            zIndex: "modal",
            justifyContent: "center",
            alignItems: isCentered ? "center" : "flex-start",
            overflow: scrollBehavior === "inside" ? "hidden" : "auto",
            overscrollBehaviorY: "none"
          };
        });
        var baseStyleDialog = defineStyle(function (props) {
          var isCentered = props.isCentered,
            scrollBehavior = props.scrollBehavior;
          return _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
            borderRadius: "md",
            color: "inherit",
            my: isCentered ? "auto" : "16",
            mx: isCentered ? "auto" : void 0,
            zIndex: "modal",
            maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0
          }, $bg$8.variable, "colors.white"), $shadow$1.variable, "shadows.lg"), "_dark", _defineProperty2(_defineProperty2({}, $bg$8.variable, "colors.gray.700"), $shadow$1.variable, "shadows.dark-lg")), "bg", $bg$8.reference), "boxShadow", $shadow$1.reference);
        });
        var baseStyleHeader$1 = defineStyle({
          px: "6",
          py: "4",
          fontSize: "xl",
          fontWeight: "semibold"
        });
        var baseStyleCloseButton$2 = defineStyle({
          position: "absolute",
          top: "2",
          insetEnd: "3"
        });
        var baseStyleBody$1 = defineStyle(function (props) {
          var scrollBehavior = props.scrollBehavior;
          return {
            px: "6",
            py: "2",
            flex: "1",
            overflow: scrollBehavior === "inside" ? "auto" : void 0
          };
        });
        var baseStyleFooter$1 = defineStyle({
          px: "6",
          py: "4"
        });
        var baseStyle$j = definePartsStyle$c(function (props) {
          return {
            overlay: baseStyleOverlay,
            dialogContainer: runIfFn(baseStyleDialogContainer, props),
            dialog: runIfFn(baseStyleDialog, props),
            header: baseStyleHeader$1,
            closeButton: baseStyleCloseButton$2,
            body: runIfFn(baseStyleBody$1, props),
            footer: baseStyleFooter$1
          };
        });
        function getSize$1(value) {
          if (value === "full") {
            return definePartsStyle$c({
              dialog: {
                maxW: "100vw",
                minH: "$100vh",
                my: "0",
                borderRadius: "0"
              }
            });
          }
          return definePartsStyle$c({
            dialog: {
              maxW: value
            }
          });
        }
        var sizes$d = {
          xs: getSize$1("xs"),
          sm: getSize$1("sm"),
          md: getSize$1("md"),
          lg: getSize$1("lg"),
          xl: getSize$1("xl"),
          "2xl": getSize$1("2xl"),
          "3xl": getSize$1("3xl"),
          "4xl": getSize$1("4xl"),
          "5xl": getSize$1("5xl"),
          "6xl": getSize$1("6xl"),
          full: getSize$1("full")
        };
        var modalTheme = defineMultiStyleConfig$c({
          baseStyle: baseStyle$j,
          sizes: sizes$d,
          defaultProps: {
            size: "md"
          }
        });
        var typography = {
          letterSpacings: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
          },
          lineHeights: {
            normal: "normal",
            none: 1,
            shorter: 1.25,
            short: 1.375,
            base: 1.5,
            tall: 1.625,
            taller: "2",
            "3": ".75rem",
            "4": "1rem",
            "5": "1.25rem",
            "6": "1.5rem",
            "7": "1.75rem",
            "8": "2rem",
            "9": "2.25rem",
            "10": "2.5rem"
          },
          fontWeights: {
            hairline: 100,
            thin: 200,
            light: 300,
            normal: 400,
            medium: 500,
            semibold: 600,
            bold: 700,
            extrabold: 800,
            black: 900
          },
          fonts: {
            heading: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
            body: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
            mono: "SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"
          },
          fontSizes: {
            "3xs": "0.45rem",
            "2xs": "0.625rem",
            xs: "0.75rem",
            sm: "0.875rem",
            md: "1rem",
            lg: "1.125rem",
            xl: "1.25rem",
            "2xl": "1.5rem",
            "3xl": "1.875rem",
            "4xl": "2.25rem",
            "5xl": "3rem",
            "6xl": "3.75rem",
            "7xl": "4.5rem",
            "8xl": "6rem",
            "9xl": "8rem"
          }
        };
        var _createMultiStyleConf13 = createMultiStyleConfigHelpers(numberInputAnatomy.keys),
          defineMultiStyleConfig$b = _createMultiStyleConf13.defineMultiStyleConfig,
          definePartsStyle$b = _createMultiStyleConf13.definePartsStyle;
        var $stepperWidth = cssVar("number-input-stepper-width");
        var $inputPadding = cssVar("number-input-input-padding");
        var inputPaddingValue = calc($stepperWidth).add("0.5rem").toString();
        var $bg$7 = cssVar("number-input-bg");
        var $fg$2 = cssVar("number-input-color");
        var $border$1 = cssVar("number-input-border-color");
        var baseStyleRoot$1 = defineStyle(_defineProperty2(_defineProperty2({}, $stepperWidth.variable, "sizes.6"), $inputPadding.variable, inputPaddingValue));
        var baseStyleField$1 = defineStyle(function (props) {
          var _runIfFn$field, _runIfFn;
          return (_runIfFn$field = (_runIfFn = runIfFn(inputTheme.baseStyle, props)) === null || _runIfFn === void 0 ? void 0 : _runIfFn.field) !== null && _runIfFn$field !== void 0 ? _runIfFn$field : {};
        });
        var baseStyleStepperGroup = defineStyle({
          width: $stepperWidth.reference
        });
        var baseStyleStepper = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
          borderStart: "1px solid",
          borderStartColor: $border$1.reference,
          color: $fg$2.reference,
          bg: $bg$7.reference
        }, $fg$2.variable, "colors.chakra-body-text"), $border$1.variable, "colors.chakra-border-color"), "_dark", _defineProperty2(_defineProperty2({}, $fg$2.variable, "colors.whiteAlpha.800"), $border$1.variable, "colors.whiteAlpha.300")), "_active", _defineProperty2(_defineProperty2({}, $bg$7.variable, "colors.gray.200"), "_dark", _defineProperty2({}, $bg$7.variable, "colors.whiteAlpha.300"))), "_disabled", {
          opacity: 0.4,
          cursor: "not-allowed"
        }));
        var baseStyle$i = definePartsStyle$b(function (props) {
          var _runIfFn2;
          return {
            root: baseStyleRoot$1,
            field: (_runIfFn2 = runIfFn(baseStyleField$1, props)) !== null && _runIfFn2 !== void 0 ? _runIfFn2 : {},
            stepperGroup: baseStyleStepperGroup,
            stepper: baseStyleStepper
          };
        });
        function getSize(size) {
          var _inputTheme$sizes, _sizeStyle$field$font, _sizeStyle$field;
          var sizeStyle = (_inputTheme$sizes = inputTheme.sizes) === null || _inputTheme$sizes === void 0 ? void 0 : _inputTheme$sizes[size];
          var radius = {
            lg: "md",
            md: "md",
            sm: "sm",
            xs: "sm"
          };
          var _fontSize = (_sizeStyle$field$font = (_sizeStyle$field = sizeStyle.field) === null || _sizeStyle$field === void 0 ? void 0 : _sizeStyle$field.fontSize) !== null && _sizeStyle$field$font !== void 0 ? _sizeStyle$field$font : "md";
          var fontSize = typography.fontSizes[_fontSize];
          return definePartsStyle$b({
            field: _objectSpread3(_objectSpread3({}, sizeStyle.field), {}, {
              paddingInlineEnd: $inputPadding.reference,
              verticalAlign: "top"
            }),
            stepper: {
              fontSize: calc(fontSize).multiply(0.75).toString(),
              _first: {
                borderTopEndRadius: radius[size]
              },
              _last: {
                borderBottomEndRadius: radius[size],
                mt: "-1px",
                borderTopWidth: 1
              }
            }
          });
        }
        var sizes$c = {
          xs: getSize("xs"),
          sm: getSize("sm"),
          md: getSize("md"),
          lg: getSize("lg")
        };
        var numberInputTheme = defineMultiStyleConfig$b({
          baseStyle: baseStyle$i,
          sizes: sizes$c,
          variants: inputTheme.variants,
          defaultProps: inputTheme.defaultProps
        });
        var baseStyle$h = defineStyle(_objectSpread3(_objectSpread3({}, (_inputTheme$baseStyle = inputTheme.baseStyle) === null || _inputTheme$baseStyle === void 0 ? void 0 : _inputTheme$baseStyle.field), {}, {
          textAlign: "center"
        }));
        var sizes$b = {
          lg: defineStyle({
            fontSize: "lg",
            w: 12,
            h: 12,
            borderRadius: "md"
          }),
          md: defineStyle({
            fontSize: "md",
            w: 10,
            h: 10,
            borderRadius: "md"
          }),
          sm: defineStyle({
            fontSize: "sm",
            w: 8,
            h: 8,
            borderRadius: "sm"
          }),
          xs: defineStyle({
            fontSize: "xs",
            w: 6,
            h: 6,
            borderRadius: "sm"
          })
        };
        var variants$6 = {
          outline: defineStyle(function (props) {
            var _runIfFn$field2, _runIfFn3, _inputTheme$variants;
            return (_runIfFn$field2 = (_runIfFn3 = runIfFn((_inputTheme$variants = inputTheme.variants) === null || _inputTheme$variants === void 0 ? void 0 : _inputTheme$variants.outline, props)) === null || _runIfFn3 === void 0 ? void 0 : _runIfFn3.field) !== null && _runIfFn$field2 !== void 0 ? _runIfFn$field2 : {};
          }),
          flushed: defineStyle(function (props) {
            var _runIfFn$field3, _runIfFn4, _inputTheme$variants2;
            return (_runIfFn$field3 = (_runIfFn4 = runIfFn((_inputTheme$variants2 = inputTheme.variants) === null || _inputTheme$variants2 === void 0 ? void 0 : _inputTheme$variants2.flushed, props)) === null || _runIfFn4 === void 0 ? void 0 : _runIfFn4.field) !== null && _runIfFn$field3 !== void 0 ? _runIfFn$field3 : {};
          }),
          filled: defineStyle(function (props) {
            var _runIfFn$field4, _runIfFn5, _inputTheme$variants3;
            return (_runIfFn$field4 = (_runIfFn5 = runIfFn((_inputTheme$variants3 = inputTheme.variants) === null || _inputTheme$variants3 === void 0 ? void 0 : _inputTheme$variants3.filled, props)) === null || _runIfFn5 === void 0 ? void 0 : _runIfFn5.field) !== null && _runIfFn$field4 !== void 0 ? _runIfFn$field4 : {};
          }),
          unstyled: (_inputTheme$variants$ = (_inputTheme$variants4 = inputTheme.variants) === null || _inputTheme$variants4 === void 0 ? void 0 : _inputTheme$variants4.unstyled.field) !== null && _inputTheme$variants$ !== void 0 ? _inputTheme$variants$ : {}
        };
        var pinInputTheme = defineStyleConfig({
          baseStyle: baseStyle$h,
          sizes: sizes$b,
          variants: variants$6,
          defaultProps: inputTheme.defaultProps
        });
        var _createMultiStyleConf14 = createMultiStyleConfigHelpers(popoverAnatomy.keys),
          defineMultiStyleConfig$a = _createMultiStyleConf14.defineMultiStyleConfig,
          definePartsStyle$a = _createMultiStyleConf14.definePartsStyle;
        var $popperBg = cssVar("popper-bg");
        var $arrowBg$1 = cssVar("popper-arrow-bg");
        var $arrowShadowColor = cssVar("popper-arrow-shadow-color");
        var baseStylePopper = defineStyle({
          zIndex: "popover"
        });
        var baseStyleContent = defineStyle((_defineStyle17 = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineStyle17, $popperBg.variable, "colors.white"), "bg", $popperBg.reference), $arrowBg$1.variable, $popperBg.reference), $arrowShadowColor.variable, "colors.gray.200"), "_dark", _defineProperty2(_defineProperty2({}, $popperBg.variable, "colors.gray.700"), $arrowShadowColor.variable, "colors.whiteAlpha.300")), "width", "xs"), "border", "1px solid"), "borderColor", "inherit"), "borderRadius", "md"), "boxShadow", "sm"), _defineProperty2(_defineProperty2(_defineStyle17, "zIndex", "inherit"), "_focusVisible", {
          outline: 0,
          boxShadow: "outline"
        })));
        var baseStyleHeader = defineStyle({
          px: 3,
          py: 2,
          borderBottomWidth: "1px"
        });
        var baseStyleBody = defineStyle({
          px: 3,
          py: 2
        });
        var baseStyleFooter = defineStyle({
          px: 3,
          py: 2,
          borderTopWidth: "1px"
        });
        var baseStyleCloseButton$1 = defineStyle({
          position: "absolute",
          borderRadius: "md",
          top: 1,
          insetEnd: 2,
          padding: 2
        });
        var baseStyle$g = definePartsStyle$a({
          popper: baseStylePopper,
          content: baseStyleContent,
          header: baseStyleHeader,
          body: baseStyleBody,
          footer: baseStyleFooter,
          closeButton: baseStyleCloseButton$1
        });
        var popoverTheme = defineMultiStyleConfig$a({
          baseStyle: baseStyle$g
        });
        var _createMultiStyleConf15 = createMultiStyleConfigHelpers(progressAnatomy.keys),
          defineMultiStyleConfig$9 = _createMultiStyleConf15.defineMultiStyleConfig,
          definePartsStyle$9 = _createMultiStyleConf15.definePartsStyle;
        var filledStyle = defineStyle(function (props) {
          var c = props.colorScheme,
            t = props.theme,
            isIndeterminate = props.isIndeterminate,
            hasStripe = props.hasStripe;
          var stripeStyle = mode(generateStripe(), generateStripe("1rem", "rgba(0,0,0,0.1)"))(props);
          var bgColor = mode("".concat(c, ".500"), "".concat(c, ".200"))(props);
          var gradient = "linear-gradient(\n    to right,\n    transparent 0%,\n    ".concat(getColor(t, bgColor), " 50%,\n    transparent 100%\n  )");
          var addStripe = !isIndeterminate && hasStripe;
          return _objectSpread3(_objectSpread3({}, addStripe && stripeStyle), isIndeterminate ? {
            bgImage: gradient
          } : {
            bgColor: bgColor
          });
        });
        var baseStyleLabel$2 = defineStyle({
          lineHeight: "1",
          fontSize: "0.25em",
          fontWeight: "bold",
          color: "white"
        });
        var baseStyleTrack$2 = defineStyle(function (props) {
          return {
            bg: mode("gray.100", "whiteAlpha.300")(props)
          };
        });
        var baseStyleFilledTrack$1 = defineStyle(function (props) {
          return _objectSpread3({
            transitionProperty: "common",
            transitionDuration: "slow"
          }, filledStyle(props));
        });
        var baseStyle$f = definePartsStyle$9(function (props) {
          return {
            label: baseStyleLabel$2,
            filledTrack: baseStyleFilledTrack$1(props),
            track: baseStyleTrack$2(props)
          };
        });
        var sizes$a = {
          xs: definePartsStyle$9({
            track: {
              h: "1"
            }
          }),
          sm: definePartsStyle$9({
            track: {
              h: "2"
            }
          }),
          md: definePartsStyle$9({
            track: {
              h: "3"
            }
          }),
          lg: definePartsStyle$9({
            track: {
              h: "4"
            }
          })
        };
        var progressTheme = defineMultiStyleConfig$9({
          sizes: sizes$a,
          baseStyle: baseStyle$f,
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var _createMultiStyleConf16 = createMultiStyleConfigHelpers(radioAnatomy.keys),
          defineMultiStyleConfig$8 = _createMultiStyleConf16.defineMultiStyleConfig,
          definePartsStyle$8 = _createMultiStyleConf16.definePartsStyle;
        var baseStyleControl = defineStyle(function (props) {
          var _runIfFn6;
          var controlStyle = (_runIfFn6 = runIfFn(checkboxTheme.baseStyle, props)) === null || _runIfFn6 === void 0 ? void 0 : _runIfFn6.control;
          return _objectSpread3(_objectSpread3({}, controlStyle), {}, {
            borderRadius: "full",
            _checked: _objectSpread3(_objectSpread3({}, controlStyle === null || controlStyle === void 0 ? void 0 : controlStyle["_checked"]), {}, {
              _before: {
                content: "\"\"",
                display: "inline-block",
                pos: "relative",
                w: "50%",
                h: "50%",
                borderRadius: "50%",
                bg: "currentColor"
              }
            })
          });
        });
        var baseStyle$e = definePartsStyle$8(function (props) {
          var _checkboxTheme$baseSt, _checkboxTheme$baseSt2;
          return {
            label: (_checkboxTheme$baseSt = checkboxTheme.baseStyle) === null || _checkboxTheme$baseSt === void 0 ? void 0 : _checkboxTheme$baseSt.call(checkboxTheme, props).label,
            container: (_checkboxTheme$baseSt2 = checkboxTheme.baseStyle) === null || _checkboxTheme$baseSt2 === void 0 ? void 0 : _checkboxTheme$baseSt2.call(checkboxTheme, props).container,
            control: baseStyleControl(props)
          };
        });
        var sizes$9 = {
          md: definePartsStyle$8({
            control: {
              w: "4",
              h: "4"
            },
            label: {
              fontSize: "md"
            }
          }),
          lg: definePartsStyle$8({
            control: {
              w: "5",
              h: "5"
            },
            label: {
              fontSize: "lg"
            }
          }),
          sm: definePartsStyle$8({
            control: {
              width: "3",
              height: "3"
            },
            label: {
              fontSize: "sm"
            }
          })
        };
        var radioTheme = defineMultiStyleConfig$8({
          baseStyle: baseStyle$e,
          sizes: sizes$9,
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var _createMultiStyleConf17 = createMultiStyleConfigHelpers(selectAnatomy.keys),
          defineMultiStyleConfig$7 = _createMultiStyleConf17.defineMultiStyleConfig,
          definePartsStyle$7 = _createMultiStyleConf17.definePartsStyle;
        var $bg$6 = cssVar$1("select-bg");
        var baseStyleField = defineStyle(_objectSpread3(_objectSpread3({}, (_inputTheme$baseStyle2 = inputTheme.baseStyle) === null || _inputTheme$baseStyle2 === void 0 ? void 0 : _inputTheme$baseStyle2.field), {}, _defineProperty2(_defineProperty2(_defineProperty2({
          appearance: "none",
          paddingBottom: "1px",
          lineHeight: "normal",
          bg: $bg$6.reference
        }, $bg$6.variable, "colors.white"), "_dark", _defineProperty2({}, $bg$6.variable, "colors.gray.700")), "> option, > optgroup", {
          bg: $bg$6.reference
        })));
        var baseStyleIcon$1 = defineStyle({
          width: "6",
          height: "100%",
          insetEnd: "2",
          position: "relative",
          color: "currentColor",
          fontSize: "xl",
          _disabled: {
            opacity: 0.5
          }
        });
        var baseStyle$d = definePartsStyle$7({
          field: baseStyleField,
          icon: baseStyleIcon$1
        });
        var iconSpacing = defineStyle({
          paddingInlineEnd: "8"
        });
        var sizes$8 = {
          lg: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes2 = inputTheme.sizes) === null || _inputTheme$sizes2 === void 0 ? void 0 : _inputTheme$sizes2.lg), {}, {
            field: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes3 = inputTheme.sizes) === null || _inputTheme$sizes3 === void 0 ? void 0 : _inputTheme$sizes3.lg.field), iconSpacing)
          }),
          md: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes4 = inputTheme.sizes) === null || _inputTheme$sizes4 === void 0 ? void 0 : _inputTheme$sizes4.md), {}, {
            field: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes5 = inputTheme.sizes) === null || _inputTheme$sizes5 === void 0 ? void 0 : _inputTheme$sizes5.md.field), iconSpacing)
          }),
          sm: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes6 = inputTheme.sizes) === null || _inputTheme$sizes6 === void 0 ? void 0 : _inputTheme$sizes6.sm), {}, {
            field: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes7 = inputTheme.sizes) === null || _inputTheme$sizes7 === void 0 ? void 0 : _inputTheme$sizes7.sm.field), iconSpacing)
          }),
          xs: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes8 = inputTheme.sizes) === null || _inputTheme$sizes8 === void 0 ? void 0 : _inputTheme$sizes8.xs), {}, {
            field: _objectSpread3(_objectSpread3({}, (_inputTheme$sizes9 = inputTheme.sizes) === null || _inputTheme$sizes9 === void 0 ? void 0 : _inputTheme$sizes9.xs.field), iconSpacing),
            icon: {
              insetEnd: "1"
            }
          })
        };
        var selectTheme = defineMultiStyleConfig$7({
          baseStyle: baseStyle$d,
          sizes: sizes$8,
          variants: inputTheme.variants,
          defaultProps: inputTheme.defaultProps
        });
        var $startColor = cssVar$1("skeleton-start-color");
        var $endColor = cssVar$1("skeleton-end-color");
        var baseStyle$c = defineStyle(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $startColor.variable, "colors.gray.100"), $endColor.variable, "colors.gray.400"), "_dark", _defineProperty2(_defineProperty2({}, $startColor.variable, "colors.gray.800"), $endColor.variable, "colors.gray.600")), "background", $startColor.reference), "borderColor", $endColor.reference), "opacity", 0.7), "borderRadius", "sm"));
        var skeletonTheme = defineStyleConfig({
          baseStyle: baseStyle$c
        });
        var $bg$5 = cssVar$1("skip-link-bg");
        var baseStyle$b = defineStyle({
          borderRadius: "md",
          fontWeight: "semibold",
          _focusVisible: _defineProperty2(_defineProperty2(_defineProperty2({
            boxShadow: "outline",
            padding: "4",
            position: "fixed",
            top: "6",
            insetStart: "6"
          }, $bg$5.variable, "colors.white"), "_dark", _defineProperty2({}, $bg$5.variable, "colors.gray.700")), "bg", $bg$5.reference)
        });
        var skipLinkTheme = defineStyleConfig({
          baseStyle: baseStyle$b
        });
        var _createMultiStyleConf18 = createMultiStyleConfigHelpers(sliderAnatomy.keys),
          defineMultiStyleConfig$6 = _createMultiStyleConf18.defineMultiStyleConfig,
          definePartsStyle$6 = _createMultiStyleConf18.definePartsStyle;
        var $thumbSize = cssVar$1("slider-thumb-size");
        var $trackSize = cssVar$1("slider-track-size");
        var $bg$4 = cssVar$1("slider-bg");
        var baseStyleContainer$1 = defineStyle(function (props) {
          var orientation = props.orientation;
          return _objectSpread3({
            display: "inline-block",
            position: "relative",
            cursor: "pointer",
            _disabled: {
              opacity: 0.6,
              cursor: "default",
              pointerEvents: "none"
            }
          }, orient({
            orientation: orientation,
            vertical: {
              h: "100%",
              px: calc$1($thumbSize.reference).divide(2).toString()
            },
            horizontal: {
              w: "100%",
              py: calc$1($thumbSize.reference).divide(2).toString()
            }
          }));
        });
        var baseStyleTrack$1 = defineStyle(function (props) {
          var orientationStyles = orient({
            orientation: props.orientation,
            horizontal: {
              h: $trackSize.reference
            },
            vertical: {
              w: $trackSize.reference
            }
          });
          return _objectSpread3(_objectSpread3({}, orientationStyles), {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
            overflow: "hidden",
            borderRadius: "sm"
          }, $bg$4.variable, "colors.gray.200"), "_dark", _defineProperty2({}, $bg$4.variable, "colors.whiteAlpha.200")), "_disabled", _defineProperty2(_defineProperty2({}, $bg$4.variable, "colors.gray.300"), "_dark", _defineProperty2({}, $bg$4.variable, "colors.whiteAlpha.300"))), "bg", $bg$4.reference));
        });
        var baseStyleThumb$1 = defineStyle(function (props) {
          var orientation = props.orientation;
          var orientationStyle = orient({
            orientation: orientation,
            vertical: {
              left: "50%"
            },
            horizontal: {
              top: "50%"
            }
          });
          return _objectSpread3(_objectSpread3({}, orientationStyle), {}, {
            w: $thumbSize.reference,
            h: $thumbSize.reference,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "absolute",
            outline: 0,
            zIndex: 1,
            borderRadius: "full",
            bg: "white",
            boxShadow: "base",
            border: "1px solid",
            borderColor: "transparent",
            transitionProperty: "transform",
            transitionDuration: "normal",
            _focusVisible: {
              boxShadow: "outline"
            },
            _active: {
              "--slider-thumb-scale": "1.15"
            },
            _disabled: {
              bg: "gray.300"
            }
          });
        });
        var baseStyleFilledTrack = defineStyle(function (props) {
          var c = props.colorScheme;
          return _defineProperty2(_defineProperty2(_defineProperty2({
            width: "inherit",
            height: "inherit"
          }, $bg$4.variable, "colors.".concat(c, ".500")), "_dark", _defineProperty2({}, $bg$4.variable, "colors.".concat(c, ".200"))), "bg", $bg$4.reference);
        });
        var baseStyle$a = definePartsStyle$6(function (props) {
          return {
            container: baseStyleContainer$1(props),
            track: baseStyleTrack$1(props),
            thumb: baseStyleThumb$1(props),
            filledTrack: baseStyleFilledTrack(props)
          };
        });
        var sizeLg = definePartsStyle$6({
          container: _defineProperty2(_defineProperty2({}, $thumbSize.variable, "sizes.4"), $trackSize.variable, "sizes.1")
        });
        var sizeMd = definePartsStyle$6({
          container: _defineProperty2(_defineProperty2({}, $thumbSize.variable, "sizes.3.5"), $trackSize.variable, "sizes.1")
        });
        var sizeSm = definePartsStyle$6({
          container: _defineProperty2(_defineProperty2({}, $thumbSize.variable, "sizes.2.5"), $trackSize.variable, "sizes.0.5")
        });
        var sizes$7 = {
          lg: sizeLg,
          md: sizeMd,
          sm: sizeSm
        };
        var sliderTheme = defineMultiStyleConfig$6({
          baseStyle: baseStyle$a,
          sizes: sizes$7,
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var $size$1 = cssVar("spinner-size");
        var baseStyle$9 = defineStyle({
          width: [$size$1.reference],
          height: [$size$1.reference]
        });
        var sizes$6 = {
          xs: defineStyle(_defineProperty2({}, $size$1.variable, "sizes.3")),
          sm: defineStyle(_defineProperty2({}, $size$1.variable, "sizes.4")),
          md: defineStyle(_defineProperty2({}, $size$1.variable, "sizes.6")),
          lg: defineStyle(_defineProperty2({}, $size$1.variable, "sizes.8")),
          xl: defineStyle(_defineProperty2({}, $size$1.variable, "sizes.12"))
        };
        var spinnerTheme = defineStyleConfig({
          baseStyle: baseStyle$9,
          sizes: sizes$6,
          defaultProps: {
            size: "md"
          }
        });
        var _createMultiStyleConf19 = createMultiStyleConfigHelpers(statAnatomy.keys),
          defineMultiStyleConfig$5 = _createMultiStyleConf19.defineMultiStyleConfig,
          definePartsStyle$5 = _createMultiStyleConf19.definePartsStyle;
        var baseStyleLabel$1 = defineStyle({
          fontWeight: "medium"
        });
        var baseStyleHelpText = defineStyle({
          opacity: 0.8,
          marginBottom: "2"
        });
        var baseStyleNumber = defineStyle({
          verticalAlign: "baseline",
          fontWeight: "semibold"
        });
        var baseStyleIcon = defineStyle({
          marginEnd: 1,
          w: "3.5",
          h: "3.5",
          verticalAlign: "middle"
        });
        var baseStyle$8 = definePartsStyle$5({
          container: {},
          label: baseStyleLabel$1,
          helpText: baseStyleHelpText,
          number: baseStyleNumber,
          icon: baseStyleIcon
        });
        var sizes$5 = {
          md: definePartsStyle$5({
            label: {
              fontSize: "sm"
            },
            helpText: {
              fontSize: "sm"
            },
            number: {
              fontSize: "2xl"
            }
          })
        };
        var statTheme = defineMultiStyleConfig$5({
          baseStyle: baseStyle$8,
          sizes: sizes$5,
          defaultProps: {
            size: "md"
          }
        });
        var _createMultiStyleConf20 = createMultiStyleConfigHelpers(["stepper", "step", "title", "description", "indicator", "separator", "icon", "number"]),
          defineMultiStyleConfig$4 = _createMultiStyleConf20.defineMultiStyleConfig,
          definePartsStyle$4 = _createMultiStyleConf20.definePartsStyle;
        var $size = cssVar$1("stepper-indicator-size");
        var $iconSize = cssVar$1("stepper-icon-size");
        var $titleFontSize = cssVar$1("stepper-title-font-size");
        var $descFontSize = cssVar$1("stepper-description-font-size");
        var $accentColor = cssVar$1("stepper-accent-color");
        var baseStyle$7 = definePartsStyle$4(function (_ref54) {
          var c = _ref54.colorScheme;
          return {
            stepper: _defineProperty2(_defineProperty2({
              display: "flex",
              justifyContent: "space-between",
              gap: "4",
              "&[data-orientation=vertical]": {
                flexDirection: "column",
                alignItems: "flex-start"
              },
              "&[data-orientation=horizontal]": {
                flexDirection: "row",
                alignItems: "center"
              }
            }, $accentColor.variable, "colors.".concat(c, ".500")), "_dark", _defineProperty2({}, $accentColor.variable, "colors.".concat(c, ".200"))),
            title: {
              fontSize: $titleFontSize.reference,
              fontWeight: "medium"
            },
            description: {
              fontSize: $descFontSize.reference,
              color: "chakra-subtle-text"
            },
            number: {
              fontSize: $titleFontSize.reference
            },
            step: {
              flexShrink: 0,
              position: "relative",
              display: "flex",
              gap: "2",
              "&[data-orientation=horizontal]": {
                alignItems: "center"
              },
              flex: "1",
              "&:last-of-type:not([data-stretch])": {
                flex: "initial"
              }
            },
            icon: {
              flexShrink: 0,
              width: $iconSize.reference,
              height: $iconSize.reference
            },
            indicator: {
              flexShrink: 0,
              borderRadius: "full",
              width: $size.reference,
              height: $size.reference,
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              "&[data-status=active]": {
                borderWidth: "2px",
                borderColor: $accentColor.reference
              },
              "&[data-status=complete]": {
                bg: $accentColor.reference,
                color: "chakra-inverse-text"
              },
              "&[data-status=incomplete]": {
                borderWidth: "2px"
              }
            },
            separator: {
              bg: "chakra-border-color",
              flex: "1",
              "&[data-status=complete]": {
                bg: $accentColor.reference
              },
              "&[data-orientation=horizontal]": {
                width: "100%",
                height: "2px",
                marginStart: "2"
              },
              "&[data-orientation=vertical]": {
                width: "2px",
                position: "absolute",
                height: "100%",
                maxHeight: "calc(100% - ".concat($size.reference, " - 8px)"),
                top: "calc(".concat($size.reference, " + 4px)"),
                insetStart: "calc(".concat($size.reference, " / 2 - 1px)")
              }
            }
          };
        });
        var stepperTheme = defineMultiStyleConfig$4({
          baseStyle: baseStyle$7,
          sizes: {
            xs: definePartsStyle$4({
              stepper: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $size.variable, "sizes.4"), $iconSize.variable, "sizes.3"), $titleFontSize.variable, "fontSizes.xs"), $descFontSize.variable, "fontSizes.xs")
            }),
            sm: definePartsStyle$4({
              stepper: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $size.variable, "sizes.6"), $iconSize.variable, "sizes.4"), $titleFontSize.variable, "fontSizes.sm"), $descFontSize.variable, "fontSizes.xs")
            }),
            md: definePartsStyle$4({
              stepper: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $size.variable, "sizes.8"), $iconSize.variable, "sizes.5"), $titleFontSize.variable, "fontSizes.md"), $descFontSize.variable, "fontSizes.sm")
            }),
            lg: definePartsStyle$4({
              stepper: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $size.variable, "sizes.10"), $iconSize.variable, "sizes.6"), $titleFontSize.variable, "fontSizes.lg"), $descFontSize.variable, "fontSizes.md")
            })
          },
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var _createMultiStyleConf21 = createMultiStyleConfigHelpers(switchAnatomy.keys),
          defineMultiStyleConfig$3 = _createMultiStyleConf21.defineMultiStyleConfig,
          definePartsStyle$3 = _createMultiStyleConf21.definePartsStyle;
        var $width = cssVar("switch-track-width");
        var $height = cssVar("switch-track-height");
        var $diff = cssVar("switch-track-diff");
        var diffValue = calc.subtract($width, $height);
        var $translateX = cssVar("switch-thumb-x");
        var $bg$3 = cssVar("switch-bg");
        var baseStyleTrack = defineStyle(function (props) {
          var c = props.colorScheme;
          return _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
            borderRadius: "full",
            p: "0.5",
            width: [$width.reference],
            height: [$height.reference],
            transitionProperty: "common",
            transitionDuration: "fast"
          }, $bg$3.variable, "colors.gray.300"), "_dark", _defineProperty2({}, $bg$3.variable, "colors.whiteAlpha.400")), "_focusVisible", {
            boxShadow: "outline"
          }), "_disabled", {
            opacity: 0.4,
            cursor: "not-allowed"
          }), "_checked", _defineProperty2(_defineProperty2({}, $bg$3.variable, "colors.".concat(c, ".500")), "_dark", _defineProperty2({}, $bg$3.variable, "colors.".concat(c, ".200")))), "bg", $bg$3.reference);
        });
        var baseStyleThumb = defineStyle({
          bg: "white",
          transitionProperty: "transform",
          transitionDuration: "normal",
          borderRadius: "inherit",
          width: [$height.reference],
          height: [$height.reference],
          _checked: {
            transform: "translateX(".concat($translateX.reference, ")")
          }
        });
        var baseStyle$6 = definePartsStyle$3(function (props) {
          return {
            container: _defineProperty2(_defineProperty2(_defineProperty2({}, $diff.variable, diffValue), $translateX.variable, $diff.reference), "_rtl", _defineProperty2({}, $translateX.variable, calc($diff).negate().toString())),
            track: baseStyleTrack(props),
            thumb: baseStyleThumb
          };
        });
        var sizes$4 = {
          sm: definePartsStyle$3({
            container: _defineProperty2(_defineProperty2({}, $width.variable, "1.375rem"), $height.variable, "sizes.3")
          }),
          md: definePartsStyle$3({
            container: _defineProperty2(_defineProperty2({}, $width.variable, "1.875rem"), $height.variable, "sizes.4")
          }),
          lg: definePartsStyle$3({
            container: _defineProperty2(_defineProperty2({}, $width.variable, "2.875rem"), $height.variable, "sizes.6")
          })
        };
        var switchTheme = defineMultiStyleConfig$3({
          baseStyle: baseStyle$6,
          sizes: sizes$4,
          defaultProps: {
            size: "md",
            colorScheme: "blue"
          }
        });
        var _createMultiStyleConf22 = createMultiStyleConfigHelpers(tableAnatomy.keys),
          defineMultiStyleConfig$2 = _createMultiStyleConf22.defineMultiStyleConfig,
          definePartsStyle$2 = _createMultiStyleConf22.definePartsStyle;
        var baseStyle$5 = definePartsStyle$2({
          table: {
            fontVariantNumeric: "lining-nums tabular-nums",
            borderCollapse: "collapse",
            width: "full"
          },
          th: {
            fontFamily: "heading",
            fontWeight: "bold",
            textTransform: "uppercase",
            letterSpacing: "wider",
            textAlign: "start"
          },
          td: {
            textAlign: "start"
          },
          caption: {
            mt: 4,
            fontFamily: "heading",
            textAlign: "center",
            fontWeight: "medium"
          }
        });
        var numericStyles = defineStyle({
          "&[data-is-numeric=true]": {
            textAlign: "end"
          }
        });
        var variantSimple = definePartsStyle$2(function (props) {
          var c = props.colorScheme;
          return {
            th: _objectSpread3({
              color: mode("gray.600", "gray.400")(props),
              borderBottom: "1px",
              borderColor: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
            }, numericStyles),
            td: _objectSpread3({
              borderBottom: "1px",
              borderColor: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
            }, numericStyles),
            caption: {
              color: mode("gray.600", "gray.100")(props)
            },
            tfoot: {
              tr: {
                "&:last-of-type": {
                  th: {
                    borderBottomWidth: 0
                  }
                }
              }
            }
          };
        });
        var variantStripe = definePartsStyle$2(function (props) {
          var c = props.colorScheme;
          return {
            th: _objectSpread3({
              color: mode("gray.600", "gray.400")(props),
              borderBottom: "1px",
              borderColor: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
            }, numericStyles),
            td: _objectSpread3({
              borderBottom: "1px",
              borderColor: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
            }, numericStyles),
            caption: {
              color: mode("gray.600", "gray.100")(props)
            },
            tbody: {
              tr: {
                "&:nth-of-type(odd)": {
                  "th, td": {
                    borderBottomWidth: "1px",
                    borderColor: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
                  },
                  td: {
                    background: mode("".concat(c, ".100"), "".concat(c, ".700"))(props)
                  }
                }
              }
            },
            tfoot: {
              tr: {
                "&:last-of-type": {
                  th: {
                    borderBottomWidth: 0
                  }
                }
              }
            }
          };
        });
        var variants$5 = {
          simple: variantSimple,
          striped: variantStripe,
          unstyled: defineStyle({})
        };
        var sizes$3 = {
          sm: definePartsStyle$2({
            th: {
              px: "4",
              py: "1",
              lineHeight: "4",
              fontSize: "xs"
            },
            td: {
              px: "4",
              py: "2",
              fontSize: "sm",
              lineHeight: "4"
            },
            caption: {
              px: "4",
              py: "2",
              fontSize: "xs"
            }
          }),
          md: definePartsStyle$2({
            th: {
              px: "6",
              py: "3",
              lineHeight: "4",
              fontSize: "xs"
            },
            td: {
              px: "6",
              py: "4",
              lineHeight: "5"
            },
            caption: {
              px: "6",
              py: "2",
              fontSize: "sm"
            }
          }),
          lg: definePartsStyle$2({
            th: {
              px: "8",
              py: "4",
              lineHeight: "5",
              fontSize: "sm"
            },
            td: {
              px: "8",
              py: "5",
              lineHeight: "6"
            },
            caption: {
              px: "6",
              py: "2",
              fontSize: "md"
            }
          })
        };
        var tableTheme = defineMultiStyleConfig$2({
          baseStyle: baseStyle$5,
          variants: variants$5,
          sizes: sizes$3,
          defaultProps: {
            variant: "simple",
            size: "md",
            colorScheme: "gray"
          }
        });
        var $fg$1 = cssVar$1("tabs-color");
        var $bg$2 = cssVar$1("tabs-bg");
        var $border = cssVar$1("tabs-border-color");
        var _createMultiStyleConf23 = createMultiStyleConfigHelpers(tabsAnatomy.keys),
          defineMultiStyleConfig$1 = _createMultiStyleConf23.defineMultiStyleConfig,
          definePartsStyle$1 = _createMultiStyleConf23.definePartsStyle;
        var baseStyleRoot = defineStyle(function (props) {
          var orientation = props.orientation;
          return {
            display: orientation === "vertical" ? "flex" : "block"
          };
        });
        var baseStyleTab = defineStyle(function (props) {
          var isFitted = props.isFitted;
          return {
            flex: isFitted ? 1 : void 0,
            transitionProperty: "common",
            transitionDuration: "normal",
            _focusVisible: {
              zIndex: 1,
              boxShadow: "outline"
            },
            _disabled: {
              cursor: "not-allowed",
              opacity: 0.4
            }
          };
        });
        var baseStyleTablist = defineStyle(function (props) {
          var _props$align = props.align,
            align = _props$align === void 0 ? "start" : _props$align,
            orientation = props.orientation;
          var alignments = {
            end: "flex-end",
            center: "center",
            start: "flex-start"
          };
          return {
            justifyContent: alignments[align],
            flexDirection: orientation === "vertical" ? "column" : "row"
          };
        });
        var baseStyleTabpanel = defineStyle({
          p: 4
        });
        var baseStyle$4 = definePartsStyle$1(function (props) {
          return {
            root: baseStyleRoot(props),
            tab: baseStyleTab(props),
            tablist: baseStyleTablist(props),
            tabpanel: baseStyleTabpanel
          };
        });
        var sizes$2 = {
          sm: definePartsStyle$1({
            tab: {
              py: 1,
              px: 4,
              fontSize: "sm"
            }
          }),
          md: definePartsStyle$1({
            tab: {
              fontSize: "md",
              py: 2,
              px: 4
            }
          }),
          lg: definePartsStyle$1({
            tab: {
              fontSize: "lg",
              py: 3,
              px: 4
            }
          })
        };
        var variantLine = definePartsStyle$1(function (props) {
          var c = props.colorScheme,
            orientation = props.orientation;
          var isVertical = orientation === "vertical";
          var borderProp = isVertical ? "borderStart" : "borderBottom";
          var marginProp = isVertical ? "marginStart" : "marginBottom";
          return {
            tablist: _defineProperty2(_defineProperty2({}, borderProp, "2px solid"), "borderColor", "inherit"),
            tab: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, borderProp, "2px solid"), "borderColor", "transparent"), marginProp, "-2px"), "_selected", _defineProperty2(_defineProperty2(_defineProperty2({}, $fg$1.variable, "colors.".concat(c, ".600")), "_dark", _defineProperty2({}, $fg$1.variable, "colors.".concat(c, ".300"))), "borderColor", "currentColor")), "_active", _defineProperty2(_defineProperty2({}, $bg$2.variable, "colors.gray.200"), "_dark", _defineProperty2({}, $bg$2.variable, "colors.whiteAlpha.300"))), "_disabled", {
              _active: {
                bg: "none"
              }
            }), "color", $fg$1.reference), "bg", $bg$2.reference)
          };
        });
        var variantEnclosed = definePartsStyle$1(function (props) {
          var c = props.colorScheme;
          return {
            tab: _defineProperty2(_defineProperty2(_defineProperty2({
              borderTopRadius: "md",
              border: "1px solid",
              borderColor: "transparent",
              mb: "-1px"
            }, $border.variable, "transparent"), "_selected", _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $fg$1.variable, "colors.".concat(c, ".600")), $border.variable, "colors.white"), "_dark", _defineProperty2(_defineProperty2({}, $fg$1.variable, "colors.".concat(c, ".300")), $border.variable, "colors.gray.800")), "borderColor", "inherit"), "borderBottomColor", $border.reference)), "color", $fg$1.reference),
            tablist: {
              mb: "-1px",
              borderBottom: "1px solid",
              borderColor: "inherit"
            }
          };
        });
        var variantEnclosedColored = definePartsStyle$1(function (props) {
          var c = props.colorScheme;
          return {
            tab: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
              border: "1px solid",
              borderColor: "inherit"
            }, $bg$2.variable, "colors.gray.50"), "_dark", _defineProperty2({}, $bg$2.variable, "colors.whiteAlpha.50")), "mb", "-1px"), "_notLast", {
              marginEnd: "-1px"
            }), "_selected", _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $bg$2.variable, "colors.white"), $fg$1.variable, "colors.".concat(c, ".600")), "_dark", _defineProperty2(_defineProperty2({}, $bg$2.variable, "colors.gray.800"), $fg$1.variable, "colors.".concat(c, ".300"))), "borderColor", "inherit"), "borderTopColor", "currentColor"), "borderBottomColor", "transparent")), "color", $fg$1.reference), "bg", $bg$2.reference),
            tablist: {
              mb: "-1px",
              borderBottom: "1px solid",
              borderColor: "inherit"
            }
          };
        });
        var variantSoftRounded = definePartsStyle$1(function (props) {
          var c = props.colorScheme,
            theme = props.theme;
          return {
            tab: {
              borderRadius: "full",
              fontWeight: "semibold",
              color: "gray.600",
              _selected: {
                color: getColor(theme, "".concat(c, ".700")),
                bg: getColor(theme, "".concat(c, ".100"))
              }
            }
          };
        });
        var variantSolidRounded = definePartsStyle$1(function (props) {
          var c = props.colorScheme;
          return {
            tab: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({
              borderRadius: "full",
              fontWeight: "semibold"
            }, $fg$1.variable, "colors.gray.600"), "_dark", _defineProperty2({}, $fg$1.variable, "inherit")), "_selected", _defineProperty2(_defineProperty2(_defineProperty2({}, $fg$1.variable, "colors.white"), $bg$2.variable, "colors.".concat(c, ".600")), "_dark", _defineProperty2(_defineProperty2({}, $fg$1.variable, "colors.gray.800"), $bg$2.variable, "colors.".concat(c, ".300")))), "color", $fg$1.reference), "bg", $bg$2.reference)
          };
        });
        var variantUnstyled = definePartsStyle$1({});
        var variants$4 = {
          line: variantLine,
          enclosed: variantEnclosed,
          "enclosed-colored": variantEnclosedColored,
          "soft-rounded": variantSoftRounded,
          "solid-rounded": variantSolidRounded,
          unstyled: variantUnstyled
        };
        var tabsTheme = defineMultiStyleConfig$1({
          baseStyle: baseStyle$4,
          sizes: sizes$2,
          variants: variants$4,
          defaultProps: {
            size: "md",
            variant: "line",
            colorScheme: "blue"
          }
        });
        var _createMultiStyleConf24 = createMultiStyleConfigHelpers(tagAnatomy.keys),
          defineMultiStyleConfig = _createMultiStyleConf24.defineMultiStyleConfig,
          definePartsStyle = _createMultiStyleConf24.definePartsStyle;
        var $bg$1 = cssVar$1("tag-bg");
        var $color = cssVar$1("tag-color");
        var $shadow = cssVar$1("tag-shadow");
        var $minH = cssVar$1("tag-min-height");
        var $minW = cssVar$1("tag-min-width");
        var $fontSize = cssVar$1("tag-font-size");
        var $paddingX = cssVar$1("tag-padding-inline");
        var baseStyleContainer = defineStyle((_defineStyle24 = {
          fontWeight: "medium",
          lineHeight: 1.2,
          outline: 0
        }, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineStyle24, $color.variable, vars.color.reference), $bg$1.variable, vars.bg.reference), $shadow.variable, vars.shadow.reference), "color", $color.reference), "bg", $bg$1.reference), "boxShadow", $shadow.reference), "borderRadius", "md"), "minH", $minH.reference), "minW", $minW.reference), "fontSize", $fontSize.reference), _defineProperty2(_defineProperty2(_defineStyle24, "px", $paddingX.reference), "_focusVisible", _defineProperty2({}, $shadow.variable, "shadows.outline"))));
        var baseStyleLabel = defineStyle({
          lineHeight: 1.2,
          overflow: "visible"
        });
        var baseStyleCloseButton = defineStyle({
          fontSize: "lg",
          w: "5",
          h: "5",
          transitionProperty: "common",
          transitionDuration: "normal",
          borderRadius: "full",
          marginStart: "1.5",
          marginEnd: "-1",
          opacity: 0.5,
          _disabled: {
            opacity: 0.4
          },
          _focusVisible: {
            boxShadow: "outline",
            bg: "rgba(0, 0, 0, 0.14)"
          },
          _hover: {
            opacity: 0.8
          },
          _active: {
            opacity: 1
          }
        });
        var baseStyle$3 = definePartsStyle({
          container: baseStyleContainer,
          label: baseStyleLabel,
          closeButton: baseStyleCloseButton
        });
        var sizes$1 = {
          sm: definePartsStyle({
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $minH.variable, "sizes.5"), $minW.variable, "sizes.5"), $fontSize.variable, "fontSizes.xs"), $paddingX.variable, "space.2"),
            closeButton: {
              marginEnd: "-2px",
              marginStart: "0.35rem"
            }
          }),
          md: definePartsStyle({
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $minH.variable, "sizes.6"), $minW.variable, "sizes.6"), $fontSize.variable, "fontSizes.sm"), $paddingX.variable, "space.2")
          }),
          lg: definePartsStyle({
            container: _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, $minH.variable, "sizes.8"), $minW.variable, "sizes.8"), $fontSize.variable, "fontSizes.md"), $paddingX.variable, "space.3")
          })
        };
        var variants$3 = {
          subtle: definePartsStyle(function (props) {
            var _badgeTheme$variants;
            return {
              container: (_badgeTheme$variants = badgeTheme.variants) === null || _badgeTheme$variants === void 0 ? void 0 : _badgeTheme$variants.subtle(props)
            };
          }),
          solid: definePartsStyle(function (props) {
            var _badgeTheme$variants2;
            return {
              container: (_badgeTheme$variants2 = badgeTheme.variants) === null || _badgeTheme$variants2 === void 0 ? void 0 : _badgeTheme$variants2.solid(props)
            };
          }),
          outline: definePartsStyle(function (props) {
            var _badgeTheme$variants3;
            return {
              container: (_badgeTheme$variants3 = badgeTheme.variants) === null || _badgeTheme$variants3 === void 0 ? void 0 : _badgeTheme$variants3.outline(props)
            };
          })
        };
        var tagTheme = defineMultiStyleConfig({
          variants: variants$3,
          baseStyle: baseStyle$3,
          sizes: sizes$1,
          defaultProps: {
            size: "md",
            variant: "subtle",
            colorScheme: "gray"
          }
        });
        var baseStyle$2 = defineStyle(_objectSpread3(_objectSpread3({}, (_inputTheme$baseStyle3 = inputTheme.baseStyle) === null || _inputTheme$baseStyle3 === void 0 ? void 0 : _inputTheme$baseStyle3.field), {}, {
          paddingY: "2",
          minHeight: "20",
          lineHeight: "short",
          verticalAlign: "top"
        }));
        var variants$2 = {
          outline: defineStyle(function (props) {
            var _inputTheme$variants$2, _inputTheme$variants5;
            return (_inputTheme$variants$2 = (_inputTheme$variants5 = inputTheme.variants) === null || _inputTheme$variants5 === void 0 ? void 0 : _inputTheme$variants5.outline(props).field) !== null && _inputTheme$variants$2 !== void 0 ? _inputTheme$variants$2 : {};
          }),
          flushed: defineStyle(function (props) {
            var _inputTheme$variants$3, _inputTheme$variants6;
            return (_inputTheme$variants$3 = (_inputTheme$variants6 = inputTheme.variants) === null || _inputTheme$variants6 === void 0 ? void 0 : _inputTheme$variants6.flushed(props).field) !== null && _inputTheme$variants$3 !== void 0 ? _inputTheme$variants$3 : {};
          }),
          filled: defineStyle(function (props) {
            var _inputTheme$variants$4, _inputTheme$variants7;
            return (_inputTheme$variants$4 = (_inputTheme$variants7 = inputTheme.variants) === null || _inputTheme$variants7 === void 0 ? void 0 : _inputTheme$variants7.filled(props).field) !== null && _inputTheme$variants$4 !== void 0 ? _inputTheme$variants$4 : {};
          }),
          unstyled: (_inputTheme$variants$5 = (_inputTheme$variants8 = inputTheme.variants) === null || _inputTheme$variants8 === void 0 ? void 0 : _inputTheme$variants8.unstyled.field) !== null && _inputTheme$variants$5 !== void 0 ? _inputTheme$variants$5 : {}
        };
        var sizes = {
          xs: (_inputTheme$sizes$xs$ = (_inputTheme$sizes0 = inputTheme.sizes) === null || _inputTheme$sizes0 === void 0 ? void 0 : _inputTheme$sizes0.xs.field) !== null && _inputTheme$sizes$xs$ !== void 0 ? _inputTheme$sizes$xs$ : {},
          sm: (_inputTheme$sizes$sm$ = (_inputTheme$sizes1 = inputTheme.sizes) === null || _inputTheme$sizes1 === void 0 ? void 0 : _inputTheme$sizes1.sm.field) !== null && _inputTheme$sizes$sm$ !== void 0 ? _inputTheme$sizes$sm$ : {},
          md: (_inputTheme$sizes$md$ = (_inputTheme$sizes10 = inputTheme.sizes) === null || _inputTheme$sizes10 === void 0 ? void 0 : _inputTheme$sizes10.md.field) !== null && _inputTheme$sizes$md$ !== void 0 ? _inputTheme$sizes$md$ : {},
          lg: (_inputTheme$sizes$lg$ = (_inputTheme$sizes11 = inputTheme.sizes) === null || _inputTheme$sizes11 === void 0 ? void 0 : _inputTheme$sizes11.lg.field) !== null && _inputTheme$sizes$lg$ !== void 0 ? _inputTheme$sizes$lg$ : {}
        };
        var textareaTheme = defineStyleConfig({
          baseStyle: baseStyle$2,
          sizes: sizes,
          variants: variants$2,
          defaultProps: {
            size: "md",
            variant: "outline"
          }
        });
        var $bg = cssVar("tooltip-bg");
        var $fg = cssVar("tooltip-fg");
        var $arrowBg = cssVar("popper-arrow-bg");
        var baseStyle$1 = defineStyle((_defineStyle25 = {
          bg: $bg.reference,
          color: $fg.reference
        }, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineStyle25, $bg.variable, "colors.gray.700"), $fg.variable, "colors.whiteAlpha.900"), "_dark", _defineProperty2(_defineProperty2({}, $bg.variable, "colors.gray.300"), $fg.variable, "colors.gray.900")), $arrowBg.variable, $bg.reference), "px", "2"), "py", "0.5"), "borderRadius", "sm"), "fontWeight", "medium"), "fontSize", "sm"), "boxShadow", "md"), _defineProperty2(_defineProperty2(_defineStyle25, "maxW", "xs"), "zIndex", "tooltip")));
        var tooltipTheme = defineStyleConfig({
          baseStyle: baseStyle$1
        });
        var components = {
          Accordion: accordionTheme,
          Alert: alertTheme,
          Avatar: avatarTheme,
          Badge: badgeTheme,
          Breadcrumb: breadcrumbTheme,
          Button: buttonTheme,
          Checkbox: checkboxTheme,
          CloseButton: closeButtonTheme,
          Code: codeTheme,
          Container: containerTheme,
          Divider: dividerTheme,
          Drawer: drawerTheme,
          Editable: editableTheme,
          Form: formTheme,
          FormError: formErrorTheme,
          FormLabel: formLabelTheme,
          Heading: headingTheme,
          Input: inputTheme,
          Kbd: kbdTheme,
          Link: linkTheme,
          List: listTheme,
          Menu: menuTheme,
          Modal: modalTheme,
          NumberInput: numberInputTheme,
          PinInput: pinInputTheme,
          Popover: popoverTheme,
          Progress: progressTheme,
          Radio: radioTheme,
          Select: selectTheme,
          Skeleton: skeletonTheme,
          SkipLink: skipLinkTheme,
          Slider: sliderTheme,
          Spinner: spinnerTheme,
          Stat: statTheme,
          Switch: switchTheme,
          Table: tableTheme,
          Tabs: tabsTheme,
          Tag: tagTheme,
          Textarea: textareaTheme,
          Tooltip: tooltipTheme,
          Card: cardTheme,
          Stepper: stepperTheme
        };
        var borders$1 = {
          none: 0,
          "1px": "1px solid",
          "2px": "2px solid",
          "4px": "4px solid",
          "8px": "8px solid"
        };
        var breakpoints = {
          base: "0em",
          sm: "30em",
          md: "48em",
          lg: "62em",
          xl: "80em",
          "2xl": "96em"
        };
        var colors = {
          transparent: "transparent",
          current: "currentColor",
          black: "#000000",
          white: "#FFFFFF",
          whiteAlpha: {
            50: "rgba(255, 255, 255, 0.04)",
            100: "rgba(255, 255, 255, 0.06)",
            200: "rgba(255, 255, 255, 0.08)",
            300: "rgba(255, 255, 255, 0.16)",
            400: "rgba(255, 255, 255, 0.24)",
            500: "rgba(255, 255, 255, 0.36)",
            600: "rgba(255, 255, 255, 0.48)",
            700: "rgba(255, 255, 255, 0.64)",
            800: "rgba(255, 255, 255, 0.80)",
            900: "rgba(255, 255, 255, 0.92)"
          },
          blackAlpha: {
            50: "rgba(0, 0, 0, 0.04)",
            100: "rgba(0, 0, 0, 0.06)",
            200: "rgba(0, 0, 0, 0.08)",
            300: "rgba(0, 0, 0, 0.16)",
            400: "rgba(0, 0, 0, 0.24)",
            500: "rgba(0, 0, 0, 0.36)",
            600: "rgba(0, 0, 0, 0.48)",
            700: "rgba(0, 0, 0, 0.64)",
            800: "rgba(0, 0, 0, 0.80)",
            900: "rgba(0, 0, 0, 0.92)"
          },
          gray: {
            50: "#F7FAFC",
            100: "#EDF2F7",
            200: "#E2E8F0",
            300: "#CBD5E0",
            400: "#A0AEC0",
            500: "#718096",
            600: "#4A5568",
            700: "#2D3748",
            800: "#1A202C",
            900: "#171923"
          },
          red: {
            50: "#FFF5F5",
            100: "#FED7D7",
            200: "#FEB2B2",
            300: "#FC8181",
            400: "#F56565",
            500: "#E53E3E",
            600: "#C53030",
            700: "#9B2C2C",
            800: "#822727",
            900: "#63171B"
          },
          orange: {
            50: "#FFFAF0",
            100: "#FEEBC8",
            200: "#FBD38D",
            300: "#F6AD55",
            400: "#ED8936",
            500: "#DD6B20",
            600: "#C05621",
            700: "#9C4221",
            800: "#7B341E",
            900: "#652B19"
          },
          yellow: {
            50: "#FFFFF0",
            100: "#FEFCBF",
            200: "#FAF089",
            300: "#F6E05E",
            400: "#ECC94B",
            500: "#D69E2E",
            600: "#B7791F",
            700: "#975A16",
            800: "#744210",
            900: "#5F370E"
          },
          green: {
            50: "#F0FFF4",
            100: "#C6F6D5",
            200: "#9AE6B4",
            300: "#68D391",
            400: "#48BB78",
            500: "#38A169",
            600: "#2F855A",
            700: "#276749",
            800: "#22543D",
            900: "#1C4532"
          },
          teal: {
            50: "#E6FFFA",
            100: "#B2F5EA",
            200: "#81E6D9",
            300: "#4FD1C5",
            400: "#38B2AC",
            500: "#319795",
            600: "#2C7A7B",
            700: "#285E61",
            800: "#234E52",
            900: "#1D4044"
          },
          blue: {
            50: "#ebf8ff",
            100: "#bee3f8",
            200: "#90cdf4",
            300: "#63b3ed",
            400: "#4299e1",
            500: "#3182ce",
            600: "#2b6cb0",
            700: "#2c5282",
            800: "#2a4365",
            900: "#1A365D"
          },
          cyan: {
            50: "#EDFDFD",
            100: "#C4F1F9",
            200: "#9DECF9",
            300: "#76E4F7",
            400: "#0BC5EA",
            500: "#00B5D8",
            600: "#00A3C4",
            700: "#0987A0",
            800: "#086F83",
            900: "#065666"
          },
          purple: {
            50: "#FAF5FF",
            100: "#E9D8FD",
            200: "#D6BCFA",
            300: "#B794F4",
            400: "#9F7AEA",
            500: "#805AD5",
            600: "#6B46C1",
            700: "#553C9A",
            800: "#44337A",
            900: "#322659"
          },
          pink: {
            50: "#FFF5F7",
            100: "#FED7E2",
            200: "#FBB6CE",
            300: "#F687B3",
            400: "#ED64A6",
            500: "#D53F8C",
            600: "#B83280",
            700: "#97266D",
            800: "#702459",
            900: "#521B41"
          }
        };
        var radii = {
          none: "0",
          sm: "0.125rem",
          base: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        };
        var shadows = {
          xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
          sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
          base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
          md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
          lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
          xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
          "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
          outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
          inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
          none: "none",
          "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
        };
        var transitionProperty = {
          common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
          colors: "background-color, border-color, color, fill, stroke",
          dimensions: "width, height",
          position: "left, right, top, bottom",
          background: "background-color, background-image, background-position"
        };
        var transitionTimingFunction = {
          "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
          "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
          "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        };
        var transitionDuration = {
          "ultra-fast": "50ms",
          faster: "100ms",
          fast: "150ms",
          normal: "200ms",
          slow: "300ms",
          slower: "400ms",
          "ultra-slow": "500ms"
        };
        var transition = {
          property: transitionProperty,
          easing: transitionTimingFunction,
          duration: transitionDuration
        };
        var zIndices = {
          hide: -1,
          auto: "auto",
          base: 0,
          docked: 10,
          dropdown: 1e3,
          sticky: 1100,
          banner: 1200,
          overlay: 1300,
          modal: 1400,
          popover: 1500,
          skipLink: 1600,
          toast: 1700,
          tooltip: 1800
        };
        var blur = {
          none: 0,
          sm: "4px",
          base: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        };
        var foundations = _objectSpread3(_objectSpread3({
          breakpoints: breakpoints,
          zIndices: zIndices,
          radii: radii,
          blur: blur,
          colors: colors
        }, typography), {}, {
          sizes: sizes$m,
          shadows: shadows,
          space: spacing,
          borders: borders$1,
          transition: transition
        });
        var semanticTokens = {
          colors: {
            "chakra-body-text": {
              _light: "gray.800",
              _dark: "whiteAlpha.900"
            },
            "chakra-body-bg": {
              _light: "white",
              _dark: "gray.800"
            },
            "chakra-border-color": {
              _light: "gray.200",
              _dark: "whiteAlpha.300"
            },
            "chakra-inverse-text": {
              _light: "white",
              _dark: "gray.800"
            },
            "chakra-subtle-bg": {
              _light: "gray.100",
              _dark: "gray.700"
            },
            "chakra-subtle-text": {
              _light: "gray.600",
              _dark: "gray.400"
            },
            "chakra-placeholder-color": {
              _light: "gray.500",
              _dark: "whiteAlpha.400"
            }
          }
        };
        var styles = {
          global: {
            body: {
              fontFamily: "body",
              color: "chakra-body-text",
              bg: "chakra-body-bg",
              transitionProperty: "background-color",
              transitionDuration: "normal",
              lineHeight: "base"
            },
            "*::placeholder": {
              color: "chakra-placeholder-color"
            },
            "*, *::before, &::after": {
              borderColor: "chakra-border-color"
            }
          }
        };
        var requiredChakraThemeKeys = ["borders", "breakpoints", "colors", "components", "config", "direction", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "shadows", "sizes", "space", "styles", "transition", "zIndices"];
        function isChakraTheme(unit) {
          if (!isObject(unit)) {
            return false;
          }
          return requiredChakraThemeKeys.every(function (propertyName) {
            return Object.prototype.hasOwnProperty.call(unit, propertyName);
          });
        }
        var direction = "ltr";
        var config$1 = {
          useSystemColorMode: false,
          initialColorMode: "light",
          cssVarPrefix: "chakra"
        };
        var theme$1 = _objectSpread3(_objectSpread3({
          semanticTokens: semanticTokens,
          direction: direction
        }, foundations), {}, {
          components: components,
          styles: styles,
          config: config$1
        });

        /*
         Based off glamor's StyleSheet, thanks Sunil 
         high performance StyleSheet for css-in-js systems
         - uses multiple style tags behind the scenes for millions of rules
        - uses `insertRule` for appending in production for *much* faster performance
         // usage
         import { StyleSheet } from '@emotion/sheet'
         let styleSheet = new StyleSheet({ key: '', container: document.head })
         styleSheet.insert('#box { border: 1px solid red; }')
        - appends a css rule into the stylesheet
         styleSheet.flush()
        - empties the stylesheet of all its contents
         */

        function sheetForTag(tag) {
          if (tag.sheet) {
            return tag.sheet;
          } // this weirdness brought to you by firefox

          /* istanbul ignore next */

          for (var i = 0; i < document.styleSheets.length; i++) {
            if (document.styleSheets[i].ownerNode === tag) {
              return document.styleSheets[i];
            }
          } // this function should always return with a value
          // TS can't understand it though so we make it stop complaining here

          return undefined;
        }
        function createStyleElement(options) {
          var tag = document.createElement('style');
          tag.setAttribute('data-emotion', options.key);
          if (options.nonce !== undefined) {
            tag.setAttribute('nonce', options.nonce);
          }
          tag.appendChild(document.createTextNode(''));
          tag.setAttribute('data-s', '');
          return tag;
        }
        var StyleSheet = /*#__PURE__*/function () {
          // Using Node instead of HTMLElement since container may be a ShadowRoot
          function StyleSheet(options) {
            var _this = this;
            this._insertTag = function (tag) {
              var before;
              if (_this.tags.length === 0) {
                if (_this.insertionPoint) {
                  before = _this.insertionPoint.nextSibling;
                } else if (_this.prepend) {
                  before = _this.container.firstChild;
                } else {
                  before = _this.before;
                }
              } else {
                before = _this.tags[_this.tags.length - 1].nextSibling;
              }
              _this.container.insertBefore(tag, before);
              _this.tags.push(tag);
            };
            this.isSpeedy = options.speedy === undefined ? true : options.speedy;
            this.tags = [];
            this.ctr = 0;
            this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

            this.key = options.key;
            this.container = options.container;
            this.prepend = options.prepend;
            this.insertionPoint = options.insertionPoint;
            this.before = null;
          }
          var _proto = StyleSheet.prototype;
          _proto.hydrate = function hydrate(nodes) {
            nodes.forEach(this._insertTag);
          };
          _proto.insert = function insert(rule) {
            // the max length is how many rules we have per style tag, it's 65000 in speedy mode
            // it's 1 in dev because we insert source maps that map a single rule to a location
            // and you can only have one source map per style tag
            if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
              this._insertTag(createStyleElement(this));
            }
            var tag = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
              var sheet = sheetForTag(tag);
              try {
                // this is the ultrafast version, works across browsers
                // the big drawback is that the css won't be editable in devtools
                sheet.insertRule(rule, sheet.cssRules.length);
              } catch (e) {}
            } else {
              tag.appendChild(document.createTextNode(rule));
            }
            this.ctr++;
          };
          _proto.flush = function flush() {
            this.tags.forEach(function (tag) {
              var _tag$parentNode;
              return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
            });
            this.tags = [];
            this.ctr = 0;
          };
          return StyleSheet;
        }();
        var MS = '-ms-';
        var MOZ = '-moz-';
        var WEBKIT = '-webkit-';
        var COMMENT = 'comm';
        var RULESET = 'rule';
        var DECLARATION = 'decl';
        var IMPORT = '@import';
        var KEYFRAMES = '@keyframes';
        var LAYER = '@layer';

        /**
         * @param {number}
         * @return {number}
         */
        var abs = Math.abs;

        /**
         * @param {number}
         * @return {string}
         */
        var from = String.fromCharCode;

        /**
         * @param {object}
         * @return {object}
         */
        var assign = Object.assign;

        /**
         * @param {string} value
         * @param {number} length
         * @return {number}
         */
        function hash$2(value, length) {
          return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
        }

        /**
         * @param {string} value
         * @return {string}
         */
        function trim(value) {
          return value.trim();
        }

        /**
         * @param {string} value
         * @param {RegExp} pattern
         * @return {string?}
         */
        function match(value, pattern) {
          return (value = pattern.exec(value)) ? value[0] : value;
        }

        /**
         * @param {string} value
         * @param {(string|RegExp)} pattern
         * @param {string} replacement
         * @return {string}
         */
        function replace(value, pattern, replacement) {
          return value.replace(pattern, replacement);
        }

        /**
         * @param {string} value
         * @param {string} search
         * @return {number}
         */
        function indexof(value, search) {
          return value.indexOf(search);
        }

        /**
         * @param {string} value
         * @param {number} index
         * @return {number}
         */
        function charat(value, index) {
          return value.charCodeAt(index) | 0;
        }

        /**
         * @param {string} value
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function substr(value, begin, end) {
          return value.slice(begin, end);
        }

        /**
         * @param {string} value
         * @return {number}
         */
        function strlen(value) {
          return value.length;
        }

        /**
         * @param {any[]} value
         * @return {number}
         */
        function sizeof(value) {
          return value.length;
        }

        /**
         * @param {any} value
         * @param {any[]} array
         * @return {any}
         */
        function append(value, array) {
          return array.push(value), value;
        }

        /**
         * @param {string[]} array
         * @param {function} callback
         * @return {string}
         */
        function combine(array, callback) {
          return array.map(callback).join('');
        }
        var line = 1;
        var column = 1;
        var length = 0;
        var position = 0;
        var character = 0;
        var characters = '';

        /**
         * @param {string} value
         * @param {object | null} root
         * @param {object | null} parent
         * @param {string} type
         * @param {string[] | string} props
         * @param {object[] | string} children
         * @param {number} length
         */
        function node(value, root, parent, type, props, children, length) {
          return {
            value: value,
            root: root,
            parent: parent,
            type: type,
            props: props,
            children: children,
            line: line,
            column: column,
            length: length,
            return: ''
          };
        }

        /**
         * @param {object} root
         * @param {object} props
         * @return {object}
         */
        function copy(root, props) {
          return assign(node('', null, null, '', null, null, 0), root, {
            length: -root.length
          }, props);
        }

        /**
         * @return {number}
         */
        function char() {
          return character;
        }

        /**
         * @return {number}
         */
        function prev() {
          character = position > 0 ? charat(characters, --position) : 0;
          if (column--, character === 10) column = 1, line--;
          return character;
        }

        /**
         * @return {number}
         */
        function next() {
          character = position < length ? charat(characters, position++) : 0;
          if (column++, character === 10) column = 1, line++;
          return character;
        }

        /**
         * @return {number}
         */
        function peek() {
          return charat(characters, position);
        }

        /**
         * @return {number}
         */
        function caret() {
          return position;
        }

        /**
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function slice(begin, end) {
          return substr(characters, begin, end);
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function token(type) {
          switch (type) {
            // \0 \t \n \r \s whitespace token
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
              return 5;
            // ! + , / > @ ~ isolate token
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            // ; { } breakpoint token
            case 59:
            case 123:
            case 125:
              return 4;
            // : accompanied token
            case 58:
              return 3;
            // " ' ( [ opening delimit token
            case 34:
            case 39:
            case 40:
            case 91:
              return 2;
            // ) ] closing delimit token
            case 41:
            case 93:
              return 1;
          }
          return 0;
        }

        /**
         * @param {string} value
         * @return {any[]}
         */
        function alloc(value) {
          return line = column = 1, length = strlen(characters = value), position = 0, [];
        }

        /**
         * @param {any} value
         * @return {any}
         */
        function dealloc(value) {
          return characters = '', value;
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function delimit(type) {
          return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function whitespace(type) {
          while (character = peek()) if (character < 33) next();else break;
          return token(type) > 2 || token(character) > 3 ? '' : ' ';
        }

        /**
         * @param {number} index
         * @param {number} count
         * @return {string}
         */
        function escaping(index, count) {
          while (--count && next())
          // not 0-9 A-F a-f
          if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
          return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function delimiter(type) {
          while (next()) switch (character) {
            // ] ) " '
            case type:
              return position;
            // " '
            case 34:
            case 39:
              if (type !== 34 && type !== 39) delimiter(character);
              break;
            // (
            case 40:
              if (type === 41) delimiter(type);
              break;
            // \
            case 92:
              next();
              break;
          }
          return position;
        }

        /**
         * @param {number} type
         * @param {number} index
         * @return {number}
         */
        function commenter(type, index) {
          while (next())
          // //
          if (type + character === 47 + 10) break;
          // /*
          else if (type + character === 42 + 42 && peek() === 47) break;
          return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next());
        }

        /**
         * @param {number} index
         * @return {string}
         */
        function identifier(index) {
          while (!token(peek())) next();
          return slice(index, position);
        }

        /**
         * @param {string} value
         * @return {object[]}
         */
        function compile(value) {
          return dealloc(parse$1('', null, null, null, [''], value = alloc(value), 0, [0], value));
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {string[]} rule
         * @param {string[]} rules
         * @param {string[]} rulesets
         * @param {number[]} pseudo
         * @param {number[]} points
         * @param {string[]} declarations
         * @return {object}
         */
        function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
          var index = 0;
          var offset = 0;
          var length = pseudo;
          var atrule = 0;
          var property = 0;
          var previous = 0;
          var variable = 1;
          var scanning = 1;
          var ampersand = 1;
          var character = 0;
          var type = '';
          var props = rules;
          var children = rulesets;
          var reference = rule;
          var characters = type;
          while (scanning) switch (previous = character, character = next()) {
            // (
            case 40:
              if (previous != 108 && charat(characters, length - 1) == 58) {
                if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
                break;
              }
            // " ' [
            case 34:
            case 39:
            case 91:
              characters += delimit(character);
              break;
            // \t \n \r \s
            case 9:
            case 10:
            case 13:
            case 32:
              characters += whitespace(previous);
              break;
            // \
            case 92:
              characters += escaping(caret() - 1, 7);
              continue;
            // /
            case 47:
              switch (peek()) {
                case 42:
                case 47:
                  append(comment(commenter(next(), caret()), root, parent), declarations);
                  break;
                default:
                  characters += '/';
              }
              break;
            // {
            case 123 * variable:
              points[index++] = strlen(characters) * ampersand;
            // } ; \0
            case 125 * variable:
            case 59:
            case 0:
              switch (character) {
                // \0 }
                case 0:
                case 125:
                  scanning = 0;
                // ;
                case 59 + offset:
                  if (ampersand == -1) characters = replace(characters, /\f/g, '');
                  if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
                  break;
                // @ ;
                case 59:
                  characters += ';';
                // { rule/at-rule
                default:
                  append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
                  if (character === 123) if (offset === 0) parse$1(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                      break;
                    default:
                      parse$1(characters, reference, reference, reference, [''], children, 0, points, children);
                  }
              }
              index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
              break;
            // :
            case 58:
              length = 1 + strlen(characters), property = previous;
            default:
              if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;
              switch (characters += from(character), character * variable) {
                // &
                case 38:
                  ampersand = offset > 0 ? 1 : (characters += '\f', -1);
                  break;
                // ,
                case 44:
                  points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
                  break;
                // @
                case 64:
                  // -
                  if (peek() === 45) characters += delimit(next());
                  atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
                  break;
                // -
                case 45:
                  if (previous === 45 && strlen(characters) == 2) variable = 0;
              }
          }
          return rulesets;
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} index
         * @param {number} offset
         * @param {string[]} rules
         * @param {number[]} points
         * @param {string} type
         * @param {string[]} props
         * @param {string[]} children
         * @param {number} length
         * @return {object}
         */
        function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
          var post = offset - 1;
          var rule = offset === 0 ? rules : [''];
          var size = sizeof(rule);
          for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
          return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);
        }

        /**
         * @param {number} value
         * @param {object} root
         * @param {object?} parent
         * @return {object}
         */
        function comment(value, root, parent) {
          return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} length
         * @return {object}
         */
        function declaration(value, root, parent, length) {
          return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);
        }

        /**
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function serialize(children, callback) {
          var output = '';
          var length = sizeof(children);
          for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';
          return output;
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function stringify(element, index, children, callback) {
          switch (element.type) {
            case LAYER:
              if (element.children.length) break;
            case IMPORT:
            case DECLARATION:
              return element.return = element.return || element.value;
            case COMMENT:
              return '';
            case KEYFRAMES:
              return element.return = element.value + '{' + serialize(element.children, callback) + '}';
            case RULESET:
              element.value = element.props.join(',');
          }
          return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
        }

        /**
         * @param {function[]} collection
         * @return {function}
         */
        function middleware(collection) {
          var length = sizeof(collection);
          return function (element, index, children, callback) {
            var output = '';
            for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
            return output;
          };
        }

        /**
         * @param {function} callback
         * @return {function}
         */
        function rulesheet(callback) {
          return function (element) {
            if (!element.root) if (element = element.return) callback(element);
          };
        }
        var weakMemoize = function weakMemoize(func) {
          var cache = new WeakMap();
          return function (arg) {
            if (cache.has(arg)) {
              // Use non-null assertion because we just checked that the cache `has` it
              // This allows us to remove `undefined` from the return value
              return cache.get(arg);
            }
            var ret = func(arg);
            cache.set(arg, ret);
            return ret;
          };
        };
        function memoize(fn) {
          var cache = Object.create(null);
          return function (arg) {
            if (cache[arg] === undefined) cache[arg] = fn(arg);
            return cache[arg];
          };
        }
        var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
          var previous = 0;
          var character = 0;
          while (true) {
            previous = character;
            character = peek(); // &\f

            if (previous === 38 && character === 12) {
              points[index] = 1;
            }
            if (token(character)) {
              break;
            }
            next();
          }
          return slice(begin, position);
        };
        var toRules = function toRules(parsed, points) {
          // pretend we've started with a comma
          var index = -1;
          var character = 44;
          do {
            switch (token(character)) {
              case 0:
                // &\f
                if (character === 38 && peek() === 12) {
                  // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
                  // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
                  // and when it should just concatenate the outer and inner selectors
                  // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
                  points[index] = 1;
                }
                parsed[index] += identifierWithPointTracking(position - 1, points, index);
                break;
              case 2:
                parsed[index] += delimit(character);
                break;
              case 4:
                // comma
                if (character === 44) {
                  // colon
                  parsed[++index] = peek() === 58 ? '&\f' : '';
                  points[index] = parsed[index].length;
                  break;
                }

              // fallthrough

              default:
                parsed[index] += from(character);
            }
          } while (character = next());
          return parsed;
        };
        var getRules = function getRules(value, points) {
          return dealloc(toRules(alloc(value), points));
        }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

        var fixedElements = /* #__PURE__ */new WeakMap();
        var compat = function compat(element) {
          if (element.type !== 'rule' || !element.parent ||
          // positive .length indicates that this rule contains pseudo
          // negative .length indicates that this rule has been already prefixed
          element.length < 1) {
            return;
          }
          var value = element.value;
          var parent = element.parent;
          var isImplicitRule = element.column === parent.column && element.line === parent.line;
          while (parent.type !== 'rule') {
            parent = parent.parent;
            if (!parent) return;
          } // short-circuit for the simplest case

          if (element.props.length === 1 && value.charCodeAt(0) !== 58
          /* colon */ && !fixedElements.get(parent)) {
            return;
          } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
          // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

          if (isImplicitRule) {
            return;
          }
          fixedElements.set(element, true);
          var points = [];
          var rules = getRules(value, points);
          var parentRules = parent.props;
          for (var i = 0, k = 0; i < rules.length; i++) {
            for (var j = 0; j < parentRules.length; j++, k++) {
              element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
            }
          }
        };
        var removeLabel = function removeLabel(element) {
          if (element.type === 'decl') {
            var value = element.value;
            if (
            // charcode for l
            value.charCodeAt(0) === 108 &&
            // charcode for b
            value.charCodeAt(2) === 98) {
              // this ignores label
              element["return"] = '';
              element.value = '';
            }
          }
        };

        /* eslint-disable no-fallthrough */

        function prefix(value, length) {
          switch (hash$2(value, length)) {
            // color-adjust
            case 5103:
              return WEBKIT + 'print-' + value + value;
            // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return WEBKIT + value + value;
            // appearance, user-select, transform, hyphens, text-size-adjust

            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return WEBKIT + value + MOZ + value + MS + value + value;
            // flex, flex-direction

            case 6828:
            case 4268:
              return WEBKIT + value + MS + value + value;
            // order

            case 6165:
              return WEBKIT + value + MS + 'flex-' + value + value;
            // align-items

            case 5187:
              return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
            // align-self

            case 5443:
              return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
            // align-content

            case 4675:
              return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
            // flex-shrink

            case 5548:
              return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
            // flex-basis

            case 5292:
              return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
            // flex-grow

            case 6060:
              return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
            // transition

            case 4554:
              return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
            // cursor

            case 6187:
              return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
            // background, background-image

            case 5495:
            case 3959:
              return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
            // justify-content

            case 4968:
              return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
            // (margin|padding)-inline-(start|end)

            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
            // (min|max)?(width|height|inline-size|block-size)

            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              // stretch, max-content, min-content, fill-available
              if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
                // (m)ax-content, (m)in-content
                case 109:
                  // -
                  if (charat(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content

                case 102:
                  return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                // (s)tretch

                case 115:
                  return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
              }
              break;
            // position: sticky

            case 4949:
              // (s)ticky?
              if (charat(value, length + 1) !== 115) break;
            // display: (flex|inline-flex)

            case 6444:
              switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
                // stic(k)y
                case 107:
                  return replace(value, ':', ':' + WEBKIT) + value;
                // (inline-)?fl(e)x

                case 101:
                  return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
              }
              break;
            // writing-mode

            case 5936:
              switch (charat(value, length + 11)) {
                // vertical-l(r)
                case 114:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                // vertical-r(l)

                case 108:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                // horizontal(-)tb

                case 45:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
              }
              return WEBKIT + value + MS + value + value;
          }
          return value;
        }
        var prefixer = function prefixer(element, index, children, callback) {
          if (element.length > -1) if (!element["return"]) switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, '@', '@' + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length) return combine(element.props, function (value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ':read-only':
                  case ':read-write':
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
                    })], callback);
                  // :placeholder

                  case '::placeholder':
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
                    })], callback);
                }
                return '';
              });
          }
        };
        var defaultStylisPlugins = [prefixer];
        var createCache = function createCache(options) {
          var key = options.key;
          if (key === 'css') {
            var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
            // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
            // note this very very intentionally targets all style elements regardless of the key to ensure
            // that creating a cache works inside of render of a React component

            Array.prototype.forEach.call(ssrStyles, function (node) {
              // we want to only move elements which have a space in the data-emotion attribute value
              // because that indicates that it is an Emotion 11 server-side rendered style elements
              // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
              // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
              // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
              // will not result in the Emotion 10 styles being destroyed
              var dataEmotionAttribute = node.getAttribute('data-emotion');
              if (dataEmotionAttribute.indexOf(' ') === -1) {
                return;
              }
              document.head.appendChild(node);
              node.setAttribute('data-s', '');
            });
          }
          var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
          var inserted = {};
          var container;
          var nodesToHydrate = [];
          {
            container = options.container || document.head;
            Array.prototype.forEach.call(
            // this means we will ignore elements which don't have a space in them which
            // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
            document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
              var attrib = node.getAttribute("data-emotion").split(' ');
              for (var i = 1; i < attrib.length; i++) {
                inserted[attrib[i]] = true;
              }
              nodesToHydrate.push(node);
            });
          }
          var _insert;
          var omnipresentPlugins = [compat, removeLabel];
          {
            var currentSheet;
            var finalizingPlugins = [stringify, rulesheet(function (rule) {
              currentSheet.insert(rule);
            })];
            var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
            var stylis = function stylis(styles) {
              return serialize(compile(styles), serializer);
            };
            _insert = function insert(selector, serialized, sheet, shouldCache) {
              currentSheet = sheet;
              stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
              if (shouldCache) {
                cache.inserted[serialized.name] = true;
              }
            };
          }
          var cache = {
            key: key,
            sheet: new StyleSheet({
              key: key,
              container: container,
              nonce: options.nonce,
              speedy: options.speedy,
              prepend: options.prepend,
              insertionPoint: options.insertionPoint
            }),
            nonce: options.nonce,
            inserted: inserted,
            registered: {},
            insert: _insert
          };
          cache.sheet.hydrate(nodesToHydrate);
          return cache;
        };
        function _extends$1() {
          return _extends$1 = Object.assign ? Object.assign.bind() : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }, _extends$1.apply(null, arguments);
        }
        var reactIs$1 = {
          exports: {}
        };
        var reactIs_production_min = {};

        /** @license React v16.13.1
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b = "function" === typeof Symbol && Symbol.for,
          c = b ? Symbol.for("react.element") : 60103,
          d = b ? Symbol.for("react.portal") : 60106,
          e = b ? Symbol.for("react.fragment") : 60107,
          f = b ? Symbol.for("react.strict_mode") : 60108,
          g = b ? Symbol.for("react.profiler") : 60114,
          h = b ? Symbol.for("react.provider") : 60109,
          k = b ? Symbol.for("react.context") : 60110,
          l = b ? Symbol.for("react.async_mode") : 60111,
          m = b ? Symbol.for("react.concurrent_mode") : 60111,
          n = b ? Symbol.for("react.forward_ref") : 60112,
          p = b ? Symbol.for("react.suspense") : 60113,
          q = b ? Symbol.for("react.suspense_list") : 60120,
          r = b ? Symbol.for("react.memo") : 60115,
          t = b ? Symbol.for("react.lazy") : 60116,
          v = b ? Symbol.for("react.block") : 60121,
          w = b ? Symbol.for("react.fundamental") : 60117,
          x = b ? Symbol.for("react.responder") : 60118,
          y = b ? Symbol.for("react.scope") : 60119;
        function z(a) {
          if ("object" === _typeof2(a) && null !== a) {
            var u = a.$$typeof;
            switch (u) {
              case c:
                switch (a = a.type, a) {
                  case l:
                  case m:
                  case e:
                  case g:
                  case f:
                  case p:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case k:
                      case n:
                      case t:
                      case r:
                      case h:
                        return a;
                      default:
                        return u;
                    }
                }
              case d:
                return u;
            }
          }
        }
        function A(a) {
          return z(a) === m;
        }
        reactIs_production_min.AsyncMode = l;
        reactIs_production_min.ConcurrentMode = m;
        reactIs_production_min.ContextConsumer = k;
        reactIs_production_min.ContextProvider = h;
        reactIs_production_min.Element = c;
        reactIs_production_min.ForwardRef = n;
        reactIs_production_min.Fragment = e;
        reactIs_production_min.Lazy = t;
        reactIs_production_min.Memo = r;
        reactIs_production_min.Portal = d;
        reactIs_production_min.Profiler = g;
        reactIs_production_min.StrictMode = f;
        reactIs_production_min.Suspense = p;
        reactIs_production_min.isAsyncMode = function (a) {
          return A(a) || z(a) === l;
        };
        reactIs_production_min.isConcurrentMode = A;
        reactIs_production_min.isContextConsumer = function (a) {
          return z(a) === k;
        };
        reactIs_production_min.isContextProvider = function (a) {
          return z(a) === h;
        };
        reactIs_production_min.isElement = function (a) {
          return "object" === _typeof2(a) && null !== a && a.$$typeof === c;
        };
        reactIs_production_min.isForwardRef = function (a) {
          return z(a) === n;
        };
        reactIs_production_min.isFragment = function (a) {
          return z(a) === e;
        };
        reactIs_production_min.isLazy = function (a) {
          return z(a) === t;
        };
        reactIs_production_min.isMemo = function (a) {
          return z(a) === r;
        };
        reactIs_production_min.isPortal = function (a) {
          return z(a) === d;
        };
        reactIs_production_min.isProfiler = function (a) {
          return z(a) === g;
        };
        reactIs_production_min.isStrictMode = function (a) {
          return z(a) === f;
        };
        reactIs_production_min.isSuspense = function (a) {
          return z(a) === p;
        };
        reactIs_production_min.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === _typeof2(a) && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
        };
        reactIs_production_min.typeOf = z;
        {
          reactIs$1.exports = reactIs_production_min;
        }
        var reactIsExports = reactIs$1.exports;
        var reactIs = reactIsExports;
        var FORWARD_REF_STATICS = {
          '$$typeof': true,
          render: true,
          defaultProps: true,
          displayName: true,
          propTypes: true
        };
        var MEMO_STATICS = {
          '$$typeof': true,
          compare: true,
          defaultProps: true,
          displayName: true,
          propTypes: true,
          type: true
        };
        var TYPE_STATICS = {};
        TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
        TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
        var isBrowser$2 = true;
        function getRegisteredStyles(registered, registeredStyles, classNames) {
          var rawClassName = '';
          classNames.split(' ').forEach(function (className) {
            if (registered[className] !== undefined) {
              registeredStyles.push(registered[className] + ";");
            } else if (className) {
              rawClassName += className + " ";
            }
          });
          return rawClassName;
        }
        var registerStyles = function registerStyles(cache, serialized, isStringTag) {
          var className = cache.key + "-" + serialized.name;
          if (
          // we only need to add the styles to the registered cache if the
          // class name could be used further down
          // the tree but if it's a string tag, we know it won't
          // so we don't have to add it to registered cache.
          // this improves memory usage since we can avoid storing the whole style string
          (isStringTag === false ||
          // we need to always store it if we're in compat mode and
          // in node since emotion-server relies on whether a style is in
          // the registered cache to know whether a style is global or not
          // also, note that this check will be dead code eliminated in the browser
          isBrowser$2 === false) && cache.registered[className] === undefined) {
            cache.registered[className] = serialized.styles;
          }
        };
        var insertStyles = function insertStyles(cache, serialized, isStringTag) {
          registerStyles(cache, serialized, isStringTag);
          var className = cache.key + "-" + serialized.name;
          if (cache.inserted[serialized.name] === undefined) {
            var current = serialized;
            do {
              cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
              current = current.next;
            } while (current !== undefined);
          }
        };

        /* eslint-disable */
        // Inspired by https://github.com/garycourt/murmurhash-js
        // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
        function murmur2(str) {
          // 'm' and 'r' are mixing constants generated offline.
          // They're not really 'magic', they just happen to work well.
          // const m = 0x5bd1e995;
          // const r = 24;
          // Initialize the hash
          var h = 0; // Mix 4 bytes at a time into the hash

          var k,
            i = 0,
            len = str.length;
          for (; len >= 4; ++i, len -= 4) {
            k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
            k = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
            k ^= /* k >>> r: */
            k >>> 24;
            h = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */
            (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Handle the last few bytes of the input array

          switch (len) {
            case 3:
              h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
            case 2:
              h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
            case 1:
              h ^= str.charCodeAt(i) & 0xff;
              h = /* Math.imul(h, m): */
              (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Do a few final mixes of the hash to ensure the last few
          // bytes are well-incorporated.

          h ^= h >>> 13;
          h = /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          return ((h ^ h >>> 15) >>> 0).toString(36);
        }
        var unitlessKeys = {
          animationIterationCount: 1,
          aspectRatio: 1,
          borderImageOutset: 1,
          borderImageSlice: 1,
          borderImageWidth: 1,
          boxFlex: 1,
          boxFlexGroup: 1,
          boxOrdinalGroup: 1,
          columnCount: 1,
          columns: 1,
          flex: 1,
          flexGrow: 1,
          flexPositive: 1,
          flexShrink: 1,
          flexNegative: 1,
          flexOrder: 1,
          gridRow: 1,
          gridRowEnd: 1,
          gridRowSpan: 1,
          gridRowStart: 1,
          gridColumn: 1,
          gridColumnEnd: 1,
          gridColumnSpan: 1,
          gridColumnStart: 1,
          msGridRow: 1,
          msGridRowSpan: 1,
          msGridColumn: 1,
          msGridColumnSpan: 1,
          fontWeight: 1,
          lineHeight: 1,
          opacity: 1,
          order: 1,
          orphans: 1,
          scale: 1,
          tabSize: 1,
          widows: 1,
          zIndex: 1,
          zoom: 1,
          WebkitLineClamp: 1,
          // SVG-related properties
          fillOpacity: 1,
          floodOpacity: 1,
          stopOpacity: 1,
          strokeDasharray: 1,
          strokeDashoffset: 1,
          strokeMiterlimit: 1,
          strokeOpacity: 1,
          strokeWidth: 1
        };
        var hyphenateRegex = /[A-Z]|^ms/g;
        var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
        var isCustomProperty = function isCustomProperty(property) {
          return property.charCodeAt(1) === 45;
        };
        var isProcessableValue = function isProcessableValue(value) {
          return value != null && typeof value !== 'boolean';
        };
        var processStyleName = /* #__PURE__ */memoize(function (styleName) {
          return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
        });
        var processStyleValue = function processStyleValue(key, value) {
          switch (key) {
            case 'animation':
            case 'animationName':
              {
                if (typeof value === 'string') {
                  return value.replace(animationRegex, function (match, p1, p2) {
                    cursor = {
                      name: p1,
                      styles: p2,
                      next: cursor
                    };
                    return p1;
                  });
                }
              }
          }
          if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
            return value + 'px';
          }
          return value;
        };
        function handleInterpolation(mergedProps, registered, interpolation) {
          if (interpolation == null) {
            return '';
          }
          var componentSelector = interpolation;
          if (componentSelector.__emotion_styles !== undefined) {
            return componentSelector;
          }
          switch (_typeof2(interpolation)) {
            case 'boolean':
              {
                return '';
              }
            case 'object':
              {
                var keyframes = interpolation;
                if (keyframes.anim === 1) {
                  cursor = {
                    name: keyframes.name,
                    styles: keyframes.styles,
                    next: cursor
                  };
                  return keyframes.name;
                }
                var serializedStyles = interpolation;
                if (serializedStyles.styles !== undefined) {
                  var next = serializedStyles.next;
                  if (next !== undefined) {
                    // not the most efficient thing ever but this is a pretty rare case
                    // and there will be very few iterations of this generally
                    while (next !== undefined) {
                      cursor = {
                        name: next.name,
                        styles: next.styles,
                        next: cursor
                      };
                      next = next.next;
                    }
                  }
                  var styles = serializedStyles.styles + ";";
                  return styles;
                }
                return createStringFromObject(mergedProps, registered, interpolation);
              }
            case 'function':
              {
                if (mergedProps !== undefined) {
                  var previousCursor = cursor;
                  var result = interpolation(mergedProps);
                  cursor = previousCursor;
                  return handleInterpolation(mergedProps, registered, result);
                }
                break;
              }
          } // finalize string values (regular strings and functions interpolated into css calls)

          var asString = interpolation;
          if (registered == null) {
            return asString;
          }
          var cached = registered[asString];
          return cached !== undefined ? cached : asString;
        }
        function createStringFromObject(mergedProps, registered, obj) {
          var string = '';
          if (Array.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
            }
          } else {
            for (var key in obj) {
              var value = obj[key];
              if (_typeof2(value) !== 'object') {
                var asString = value;
                if (registered != null && registered[asString] !== undefined) {
                  string += key + "{" + registered[asString] + "}";
                } else if (isProcessableValue(asString)) {
                  string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
                }
              } else {
                if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
                  for (var _i = 0; _i < value.length; _i++) {
                    if (isProcessableValue(value[_i])) {
                      string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
                    }
                  }
                } else {
                  var interpolated = handleInterpolation(mergedProps, registered, value);
                  switch (key) {
                    case 'animation':
                    case 'animationName':
                      {
                        string += processStyleName(key) + ":" + interpolated + ";";
                        break;
                      }
                    default:
                      {
                        string += key + "{" + interpolated + "}";
                      }
                  }
                }
              }
            }
          }
          return string;
        }
        var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
        // keyframes are stored on the SerializedStyles object as a linked list

        var cursor;
        function serializeStyles(args, registered, mergedProps) {
          if (args.length === 1 && _typeof2(args[0]) === 'object' && args[0] !== null && args[0].styles !== undefined) {
            return args[0];
          }
          var stringMode = true;
          var styles = '';
          cursor = undefined;
          var strings = args[0];
          if (strings == null || strings.raw === undefined) {
            stringMode = false;
            styles += handleInterpolation(mergedProps, registered, strings);
          } else {
            var asTemplateStringsArr = strings;
            styles += asTemplateStringsArr[0];
          } // we start at 1 since we've already handled the first arg

          for (var i = 1; i < args.length; i++) {
            styles += handleInterpolation(mergedProps, registered, args[i]);
            if (stringMode) {
              var templateStringsArr = strings;
              styles += templateStringsArr[i];
            }
          } // using a global regex with .exec is stateful so lastIndex has to be reset each time

          labelPattern.lastIndex = 0;
          var identifierName = '';
          var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

          while ((match = labelPattern.exec(styles)) !== null) {
            identifierName += '-' + match[1];
          }
          var name = murmur2(styles) + identifierName;
          return {
            name: name,
            styles: styles,
            next: cursor
          };
        }
        var syncFallback = function syncFallback(create) {
          return create();
        };
        var useInsertionEffect = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
        var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
        var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
        var EmotionCacheContext = /* #__PURE__ */reactExports.createContext(
        // we're doing this to avoid preconstruct's dead code elimination in this one case
        // because this module is primarily intended for the browser and node
        // but it's also required in react native and similar environments sometimes
        // and we could have a special build just for that
        // but this is much easier and the native packages
        // might use a different theme context in the future anyway
        typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
          key: 'css'
        }) : null);
        EmotionCacheContext.Provider;
        var __unsafe_useEmotionCache = function useEmotionCache() {
          return reactExports.useContext(EmotionCacheContext);
        };
        var withEmotionCache = function withEmotionCache(func) {
          return /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
            // the cache will never be null in the browser
            var cache = reactExports.useContext(EmotionCacheContext);
            return func(props, cache, ref);
          });
        };
        var ThemeContext = /* #__PURE__ */reactExports.createContext({});
        var getTheme$1 = function getTheme(outerTheme, theme) {
          if (typeof theme === 'function') {
            var mergedTheme = theme(outerTheme);
            return mergedTheme;
          }
          return _extends$1({}, outerTheme, theme);
        };
        var createCacheWithTheme = /* #__PURE__ */weakMemoize(function (outerTheme) {
          return weakMemoize(function (theme) {
            return getTheme$1(outerTheme, theme);
          });
        });
        var ThemeProvider$1 = function ThemeProvider(props) {
          var theme = reactExports.useContext(ThemeContext);
          if (props.theme !== theme) {
            theme = createCacheWithTheme(theme)(props.theme);
          }
          return /*#__PURE__*/reactExports.createElement(ThemeContext.Provider, {
            value: theme
          }, props.children);
        };
        var hasOwn = {}.hasOwnProperty;
        var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
        var createEmotionProps = function createEmotionProps(type, props) {
          var newProps = {};
          for (var _key in props) {
            if (hasOwn.call(props, _key)) {
              newProps[_key] = props[_key];
            }
          }
          newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:

          return newProps;
        };
        var Insertion$1 = function Insertion(_ref) {
          var cache = _ref.cache,
            serialized = _ref.serialized,
            isStringTag = _ref.isStringTag;
          registerStyles(cache, serialized, isStringTag);
          useInsertionEffectAlwaysWithSyncFallback(function () {
            return insertStyles(cache, serialized, isStringTag);
          });
          return null;
        };
        var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
          var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
          // not passing the registered cache to serializeStyles because it would
          // make certain babel optimisations not possible

          if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
            cssProp = cache.registered[cssProp];
          }
          var WrappedComponent = props[typePropName];
          var registeredStyles = [cssProp];
          var className = '';
          if (typeof props.className === 'string') {
            className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serializeStyles(registeredStyles, undefined, reactExports.useContext(ThemeContext));
          className += cache.key + "-" + serialized.name;
          var newProps = {};
          for (var _key2 in props) {
            if (hasOwn.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && true) {
              newProps[_key2] = props[_key2];
            }
          }
          newProps.className = className;
          if (ref) {
            newProps.ref = ref;
          }
          return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion$1, {
            cache: cache,
            serialized: serialized,
            isStringTag: typeof WrappedComponent === 'string'
          }), /*#__PURE__*/reactExports.createElement(WrappedComponent, newProps));
        });
        var Emotion$1 = Emotion;
        var jsx = function jsx(type, props) {
          // eslint-disable-next-line prefer-rest-params
          var args = arguments;
          if (props == null || !hasOwn.call(props, 'css')) {
            return reactExports.createElement.apply(undefined, args);
          }
          var argsLength = args.length;
          var createElementArgArray = new Array(argsLength);
          createElementArgArray[0] = Emotion$1;
          createElementArgArray[1] = createEmotionProps(type, props);
          for (var i = 2; i < argsLength; i++) {
            createElementArgArray[i] = args[i];
          }
          return reactExports.createElement.apply(null, createElementArgArray);
        };
        (function (_jsx) {
          var JSX;
          (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
        })(jsx || (jsx = {}));

        // initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
        // initial client-side render from SSR, use place of hydrating tag

        var Global = /* #__PURE__ */withEmotionCache(function (props, cache) {
          var styles = props.styles;
          var serialized = serializeStyles([styles], undefined, reactExports.useContext(ThemeContext));
          // but it is based on a constant that will never change at runtime
          // it's effectively like having two implementations and switching them out
          // so it's not actually breaking anything

          var sheetRef = reactExports.useRef();
          useInsertionEffectWithLayoutFallback(function () {
            var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

            var sheet = new cache.sheet.constructor({
              key: key,
              nonce: cache.sheet.nonce,
              container: cache.sheet.container,
              speedy: cache.sheet.isSpeedy
            });
            var rehydrating = false;
            var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");
            if (cache.sheet.tags.length) {
              sheet.before = cache.sheet.tags[0];
            }
            if (node !== null) {
              rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

              node.setAttribute('data-emotion', key);
              sheet.hydrate([node]);
            }
            sheetRef.current = [sheet, rehydrating];
            return function () {
              sheet.flush();
            };
          }, [cache]);
          useInsertionEffectWithLayoutFallback(function () {
            var sheetRefCurrent = sheetRef.current;
            var sheet = sheetRefCurrent[0],
              rehydrating = sheetRefCurrent[1];
            if (rehydrating) {
              sheetRefCurrent[1] = false;
              return;
            }
            if (serialized.next !== undefined) {
              // insert keyframes
              insertStyles(cache, serialized.next, true);
            }
            if (sheet.tags.length) {
              // if this doesn't exist then it will be null so the style element will be appended
              var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
              sheet.before = element;
              sheet.flush();
            }
            cache.insert("", serialized, sheet, false);
          }, [cache, serialized.name]);
          return null;
        });
        function css$1() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return serializeStyles(args);
        }
        function keyframes$1() {
          var insertable = css$1.apply(void 0, arguments);
          var name = "animation-" + insertable.name;
          return {
            name: name,
            styles: "@keyframes " + name + "{" + insertable.styles + "}",
            anim: 1,
            toString: function toString() {
              return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
            }
          };
        }
        var ColorModeContext = reactExports.createContext({});
        ColorModeContext.displayName = "ColorModeContext";
        function useColorMode() {
          var context = reactExports.useContext(ColorModeContext);
          if (context === void 0) {
            throw new Error("useColorMode must be used within a ColorModeProvider");
          }
          return context;
        }
        function useColorModeValue(light, dark) {
          var _useColorMode = useColorMode(),
            colorMode = _useColorMode.colorMode;
          return colorMode === "dark" ? dark : light;
        }
        var classNames = {
          light: "chakra-ui-light",
          dark: "chakra-ui-dark"
        };
        function getColorModeUtils() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _options$preventTrans = options.preventTransition,
            preventTransition = _options$preventTrans === void 0 ? true : _options$preventTrans,
            nonce = options.nonce;
          var utils = {
            setDataset: function setDataset(value) {
              var cleanup = preventTransition ? utils.preventTransition() : void 0;
              document.documentElement.dataset.theme = value;
              document.documentElement.style.colorScheme = value;
              cleanup === null || cleanup === void 0 || cleanup();
            },
            setClassName: function setClassName(dark) {
              document.body.classList.add(dark ? classNames.dark : classNames.light);
              document.body.classList.remove(dark ? classNames.light : classNames.dark);
            },
            query: function query() {
              return window.matchMedia("(prefers-color-scheme: dark)");
            },
            getSystemTheme: function getSystemTheme(fallback) {
              var _utils$query$matches;
              var dark = (_utils$query$matches = utils.query().matches) !== null && _utils$query$matches !== void 0 ? _utils$query$matches : fallback === "dark";
              return dark ? "dark" : "light";
            },
            addListener: function addListener(fn) {
              var mql = utils.query();
              var listener = function listener(e) {
                fn(e.matches ? "dark" : "light");
              };
              if (typeof mql.addListener === "function") mql.addListener(listener);else mql.addEventListener("change", listener);
              return function () {
                if (typeof mql.removeListener === "function") mql.removeListener(listener);else mql.removeEventListener("change", listener);
              };
            },
            preventTransition: function preventTransition() {
              var css = document.createElement("style");
              css.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"));
              if (nonce !== void 0) {
                css.nonce = nonce;
              }
              document.head.appendChild(css);
              return function () {
                (function () {
                  return window.getComputedStyle(document.body);
                })();
                requestAnimationFrame(function () {
                  requestAnimationFrame(function () {
                    document.head.removeChild(css);
                  });
                });
              };
            }
          };
          return utils;
        }
        var STORAGE_KEY$1 = "chakra-ui-color-mode";
        function createLocalStorageManager(key) {
          return {
            ssr: false,
            type: "localStorage",
            get: function get(init) {
              if (!(globalThis !== null && globalThis !== void 0 && globalThis.document)) return init;
              var value;
              try {
                value = localStorage.getItem(key) || init;
              } catch (e) {}
              return value || init;
            },
            set: function set(value) {
              try {
                localStorage.setItem(key, value);
              } catch (e) {}
            }
          };
        }
        var localStorageManager = createLocalStorageManager(STORAGE_KEY$1);
        var noop$3 = function noop$3() {};
        var useSafeLayoutEffect$1 = isBrowser$3() ? reactExports.useLayoutEffect : reactExports.useEffect;
        function getTheme(manager, fallback) {
          return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
        }
        var ColorModeProvider = function ColorModeProvider2(props) {
          var value = props.value,
            children = props.children,
            _props$options = props.options,
            _props$options2 = _props$options === void 0 ? {} : _props$options,
            useSystemColorMode = _props$options2.useSystemColorMode,
            initialColorMode = _props$options2.initialColorMode,
            disableTransitionOnChange = _props$options2.disableTransitionOnChange,
            _props$colorModeManag = props.colorModeManager,
            colorModeManager = _props$colorModeManag === void 0 ? localStorageManager : _props$colorModeManag;
          var cache = __unsafe_useEmotionCache();
          var defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
          var _reactExports$useStat11 = reactExports.useState(function () {
              return getTheme(colorModeManager, defaultColorMode);
            }),
            _reactExports$useStat12 = _slicedToArray(_reactExports$useStat11, 2),
            colorMode = _reactExports$useStat12[0],
            rawSetColorMode = _reactExports$useStat12[1];
          var _reactExports$useStat13 = reactExports.useState(function () {
              return getTheme(colorModeManager);
            }),
            _reactExports$useStat14 = _slicedToArray(_reactExports$useStat13, 2),
            resolvedColorMode = _reactExports$useStat14[0],
            setResolvedColorMode = _reactExports$useStat14[1];
          var _reactExports$useMemo = reactExports.useMemo(function () {
              return getColorModeUtils({
                preventTransition: disableTransitionOnChange,
                nonce: cache === null || cache === void 0 ? void 0 : cache.nonce
              });
            }, [disableTransitionOnChange, cache === null || cache === void 0 ? void 0 : cache.nonce]),
            getSystemTheme = _reactExports$useMemo.getSystemTheme,
            setClassName = _reactExports$useMemo.setClassName,
            setDataset = _reactExports$useMemo.setDataset,
            addListener = _reactExports$useMemo.addListener;
          var resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
          var setColorMode = reactExports.useCallback(function (value2) {
            var resolved = value2 === "system" ? getSystemTheme() : value2;
            rawSetColorMode(resolved);
            setClassName(resolved === "dark");
            setDataset(resolved);
            colorModeManager.set(resolved);
          }, [colorModeManager, getSystemTheme, setClassName, setDataset]);
          useSafeLayoutEffect$1(function () {
            if (initialColorMode === "system") {
              setResolvedColorMode(getSystemTheme());
            }
          }, []);
          reactExports.useEffect(function () {
            var managerValue = colorModeManager.get();
            if (managerValue) {
              setColorMode(managerValue);
              return;
            }
            if (initialColorMode === "system") {
              setColorMode("system");
              return;
            }
            setColorMode(defaultColorMode);
          }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
          var toggleColorMode = reactExports.useCallback(function () {
            setColorMode(resolvedValue === "dark" ? "light" : "dark");
          }, [resolvedValue, setColorMode]);
          reactExports.useEffect(function () {
            if (!useSystemColorMode) return;
            return addListener(setColorMode);
          }, [useSystemColorMode, addListener, setColorMode]);
          var context = reactExports.useMemo(function () {
            return {
              colorMode: value !== null && value !== void 0 ? value : resolvedValue,
              toggleColorMode: value ? noop$3 : toggleColorMode,
              setColorMode: value ? noop$3 : setColorMode,
              forced: value !== void 0
            };
          }, [resolvedValue, toggleColorMode, setColorMode, value]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ColorModeContext.Provider, {
            value: context,
            children: children
          });
        };
        ColorModeProvider.displayName = "ColorModeProvider";
        var css = String.raw;
        var vhPolyfill = css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  :root,\n  :host {\n    --chakra-vh: 100vh;\n  }\n\n  @supports (height: -webkit-fill-available) {\n    :root,\n    :host {\n      --chakra-vh: -webkit-fill-available;\n    }\n  }\n\n  @supports (height: -moz-fill-available) {\n    :root,\n    :host {\n      --chakra-vh: -moz-fill-available;\n    }\n  }\n\n  @supports (height: 100dvh) {\n    :root,\n    :host {\n      --chakra-vh: 100dvh;\n    }\n  }\n"])));
        var CSSPolyfill = function CSSPolyfill() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Global, {
            styles: vhPolyfill
          });
        };
        var CSSReset = function CSSReset(_ref56) {
          var _ref56$scope = _ref56.scope,
            scope = _ref56$scope === void 0 ? "" : _ref56$scope;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Global, {
            styles: css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      html {\n        line-height: 1.5;\n        -webkit-text-size-adjust: 100%;\n        font-family: system-ui, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        text-rendering: optimizeLegibility;\n        -moz-osx-font-smoothing: grayscale;\n        touch-action: manipulation;\n      }\n\n      body {\n        position: relative;\n        min-height: 100%;\n        margin: 0;\n        font-feature-settings: \"kern\";\n      }\n\n      ", " :where(*, *::before, *::after) {\n        border-width: 0;\n        border-style: solid;\n        box-sizing: border-box;\n        word-wrap: break-word;\n      }\n\n      main {\n        display: block;\n      }\n\n      ", " hr {\n        border-top-width: 1px;\n        box-sizing: content-box;\n        height: 0;\n        overflow: visible;\n      }\n\n      ", " :where(pre, code, kbd,samp) {\n        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n        font-size: 1em;\n      }\n\n      ", " a {\n        background-color: transparent;\n        color: inherit;\n        text-decoration: inherit;\n      }\n\n      ", " abbr[title] {\n        border-bottom: none;\n        text-decoration: underline;\n        -webkit-text-decoration: underline dotted;\n        text-decoration: underline dotted;\n      }\n\n      ", " :where(b, strong) {\n        font-weight: bold;\n      }\n\n      ", " small {\n        font-size: 80%;\n      }\n\n      ", " :where(sub,sup) {\n        font-size: 75%;\n        line-height: 0;\n        position: relative;\n        vertical-align: baseline;\n      }\n\n      ", " sub {\n        bottom: -0.25em;\n      }\n\n      ", " sup {\n        top: -0.5em;\n      }\n\n      ", " img {\n        border-style: none;\n      }\n\n      ", " :where(button, input, optgroup, select, textarea) {\n        font-family: inherit;\n        font-size: 100%;\n        line-height: 1.15;\n        margin: 0;\n      }\n\n      ", " :where(button, input) {\n        overflow: visible;\n      }\n\n      ", " :where(button, select) {\n        text-transform: none;\n      }\n\n      ", " :where(\n          button::-moz-focus-inner,\n          [type=\"button\"]::-moz-focus-inner,\n          [type=\"reset\"]::-moz-focus-inner,\n          [type=\"submit\"]::-moz-focus-inner\n        ) {\n        border-style: none;\n        padding: 0;\n      }\n\n      ", " fieldset {\n        padding: 0.35em 0.75em 0.625em;\n      }\n\n      ", " legend {\n        box-sizing: border-box;\n        color: inherit;\n        display: table;\n        max-width: 100%;\n        padding: 0;\n        white-space: normal;\n      }\n\n      ", " progress {\n        vertical-align: baseline;\n      }\n\n      ", " textarea {\n        overflow: auto;\n      }\n\n      ", " :where([type=\"checkbox\"], [type=\"radio\"]) {\n        box-sizing: border-box;\n        padding: 0;\n      }\n\n      ", " input[type=\"number\"]::-webkit-inner-spin-button,\n      ", " input[type=\"number\"]::-webkit-outer-spin-button {\n        -webkit-appearance: none !important;\n      }\n\n      ", " input[type=\"number\"] {\n        -moz-appearance: textfield;\n      }\n\n      ", " input[type=\"search\"] {\n        -webkit-appearance: textfield;\n        outline-offset: -2px;\n      }\n\n      ", " input[type=\"search\"]::-webkit-search-decoration {\n        -webkit-appearance: none !important;\n      }\n\n      ", " ::-webkit-file-upload-button {\n        -webkit-appearance: button;\n        font: inherit;\n      }\n\n      ", " details {\n        display: block;\n      }\n\n      ", " summary {\n        display: list-item;\n      }\n\n      template {\n        display: none;\n      }\n\n      [hidden] {\n        display: none !important;\n      }\n\n      ", " :where(\n          blockquote,\n          dl,\n          dd,\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6,\n          hr,\n          figure,\n          p,\n          pre\n        ) {\n        margin: 0;\n      }\n\n      ", " button {\n        background: transparent;\n        padding: 0;\n      }\n\n      ", " fieldset {\n        margin: 0;\n        padding: 0;\n      }\n\n      ", " :where(ol, ul) {\n        margin: 0;\n        padding: 0;\n      }\n\n      ", " textarea {\n        resize: vertical;\n      }\n\n      ", " :where(button, [role=\"button\"]) {\n        cursor: pointer;\n      }\n\n      ", " button::-moz-focus-inner {\n        border: 0 !important;\n      }\n\n      ", " table {\n        border-collapse: collapse;\n      }\n\n      ", " :where(h1, h2, h3, h4, h5, h6) {\n        font-size: inherit;\n        font-weight: inherit;\n      }\n\n      ", " :where(button, input, optgroup, select, textarea) {\n        padding: 0;\n        line-height: inherit;\n        color: inherit;\n      }\n\n      ", " :where(img, svg, video, canvas, audio, iframe, embed, object) {\n        display: block;\n      }\n\n      ", " :where(img, video) {\n        max-width: 100%;\n        height: auto;\n      }\n\n      [data-js-focus-visible]\n        :focus:not([data-focus-visible-added]):not(\n          [data-focus-visible-disabled]\n        ) {\n        outline: none;\n        box-shadow: none;\n      }\n\n      ", " select::-ms-expand {\n        display: none;\n      }\n\n      ", "\n    "])), scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, scope, vhPolyfill)
          });
        };
        function ThemeProvider(props) {
          var cssVarsRoot = props.cssVarsRoot,
            theme = props.theme,
            children = props.children;
          var computedTheme = reactExports.useMemo(function () {
            return toCSSVar(theme);
          }, [theme]);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(ThemeProvider$1, {
            theme: computedTheme,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(CSSVars, {
              root: cssVarsRoot
            }), children]
          });
        }
        function CSSVars(_ref57) {
          var _ref57$root = _ref57.root,
            root = _ref57$root === void 0 ? ":host, :root" : _ref57$root;
          var selector = [root, "[data-theme]"].join(",");
          return /* @__PURE__ */jsxRuntimeExports.jsx(Global, {
            styles: function styles(theme) {
              return _defineProperty2({}, selector, theme.__cssVars);
            }
          });
        }
        createContext({
          name: "StylesContext",
          errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
        });
        function createStylesContext(componentName) {
          return createContext({
            name: "".concat(componentName, "StylesContext"),
            errorMessage: "useStyles: \"styles\" is undefined. Seems you forgot to wrap the components in \"<".concat(componentName, " />\" ")
          });
        }
        function GlobalStyle() {
          var _useColorMode2 = useColorMode(),
            colorMode = _useColorMode2.colorMode;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Global, {
            styles: function styles(theme) {
              var styleObjectOrFn = memoizedGet$1(theme, "styles.global");
              var globalStyles = runIfFn$1(styleObjectOrFn, {
                theme: theme,
                colorMode: colorMode
              });
              if (!globalStyles) return void 0;
              var styles = css$2(globalStyles)(theme);
              return styles;
            }
          });
        }
        var _createContext = createContext({
            strict: false,
            name: "PortalManagerContext"
          }),
          _createContext2 = _slicedToArray(_createContext, 2),
          PortalManagerContextProvider = _createContext2[0],
          usePortalManager = _createContext2[1];
        function PortalManager(props) {
          var children = props.children,
            zIndex = props.zIndex;
          return /* @__PURE__ */jsxRuntimeExports.jsx(PortalManagerContextProvider, {
            value: {
              zIndex: zIndex
            },
            children: children
          });
        }
        PortalManager.displayName = "PortalManager";
        var EnvironmentContext = reactExports.createContext({
          getDocument: function getDocument() {
            return document;
          },
          getWindow: function getWindow() {
            return window;
          }
        });
        EnvironmentContext.displayName = "EnvironmentContext";
        function useEnvironment() {
          var _ref59 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            defer = _ref59.defer;
          var _reactExports$useRedu = reactExports.useReducer(function (c) {
              return c + 1;
            }, 0),
            _reactExports$useRedu2 = _slicedToArray(_reactExports$useRedu, 2),
            forceUpdate = _reactExports$useRedu2[1];
          useSafeLayoutEffect$2(function () {
            if (!defer) return;
            forceUpdate();
          }, [defer]);
          return reactExports.useContext(EnvironmentContext);
        }
        function EnvironmentProvider(props) {
          var children = props.children,
            environmentProp = props.environment,
            disabled = props.disabled;
          var ref = reactExports.useRef(null);
          var context = reactExports.useMemo(function () {
            if (environmentProp) return environmentProp;
            return {
              getDocument: function getDocument() {
                var _ref$current$ownerDoc, _ref$current;
                return (_ref$current$ownerDoc = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.ownerDocument) !== null && _ref$current$ownerDoc !== void 0 ? _ref$current$ownerDoc : document;
              },
              getWindow: function getWindow() {
                var _ref$current$ownerDoc2, _ref$current2;
                return (_ref$current$ownerDoc2 = (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.ownerDocument.defaultView) !== null && _ref$current$ownerDoc2 !== void 0 ? _ref$current$ownerDoc2 : window;
              }
            };
          }, [environmentProp]);
          var showSpan = !disabled || !environmentProp;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(EnvironmentContext.Provider, {
            value: context,
            children: [children, showSpan && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              id: "__chakra_env",
              hidden: true,
              ref: ref
            })]
          });
        }
        EnvironmentProvider.displayName = "EnvironmentProvider";
        var Provider = function Provider(props) {
          var children = props.children,
            colorModeManager = props.colorModeManager,
            portalZIndex = props.portalZIndex,
            resetScope = props.resetScope,
            _props$resetCSS = props.resetCSS,
            resetCSS = _props$resetCSS === void 0 ? true : _props$resetCSS,
            _props$theme = props.theme,
            theme = _props$theme === void 0 ? {} : _props$theme,
            environment = props.environment,
            cssVarsRoot = props.cssVarsRoot,
            disableEnvironment = props.disableEnvironment,
            disableGlobalStyle = props.disableGlobalStyle;
          var _children = /* @__PURE__ */jsxRuntimeExports.jsx(EnvironmentProvider, {
            environment: environment,
            disabled: disableEnvironment,
            children: children
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(ThemeProvider, {
            theme: theme,
            cssVarsRoot: cssVarsRoot,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(ColorModeProvider, {
              colorModeManager: colorModeManager,
              options: theme.config,
              children: [resetCSS ? /* @__PURE__ */jsxRuntimeExports.jsx(CSSReset, {
                scope: resetScope
              }) : /* @__PURE__ */jsxRuntimeExports.jsx(CSSPolyfill, {}), !disableGlobalStyle && /* @__PURE__ */jsxRuntimeExports.jsx(GlobalStyle, {}), portalZIndex ? /* @__PURE__ */jsxRuntimeExports.jsx(PortalManager, {
                zIndex: portalZIndex,
                children: _children
              }) : _children]
            })
          });
        };
        var LayoutGroupContext = reactExports.createContext({});

        /**
         * Creates a constant value over the lifecycle of a component.
         *
         * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
         * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
         * you can ensure that initialisers don't execute twice or more.
         */
        function useConstant(init) {
          var ref = reactExports.useRef(null);
          if (ref.current === null) {
            ref.current = init();
          }
          return ref.current;
        }

        /**
         * @public
         */
        var PresenceContext = reactExports.createContext(null);

        /**
         * @public
         */
        var MotionConfigContext = reactExports.createContext({
          transformPagePoint: function transformPagePoint(p) {
            return p;
          },
          isStatic: false,
          reducedMotion: "never"
        });

        /**
         * Measurement functionality has to be within a separate component
         * to leverage snapshot lifecycle.
         */
        var PopChildMeasure = /*#__PURE__*/function (_reactExports$Compone2) {
          function PopChildMeasure() {
            _classCallCheck(this, PopChildMeasure);
            return _callSuper(this, PopChildMeasure, arguments);
          }
          _inherits(PopChildMeasure, _reactExports$Compone2);
          return _createClass(PopChildMeasure, [{
            key: "getSnapshotBeforeUpdate",
            value: function getSnapshotBeforeUpdate(prevProps) {
              var element = this.props.childRef.current;
              if (element && prevProps.isPresent && !this.props.isPresent) {
                var _size = this.props.sizeRef.current;
                _size.height = element.offsetHeight || 0;
                _size.width = element.offsetWidth || 0;
                _size.top = element.offsetTop;
                _size.left = element.offsetLeft;
              }
              return null;
            }
            /**
             * Required with getSnapshotBeforeUpdate to stop React complaining.
             */
          }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {}
          }, {
            key: "render",
            value: function render() {
              return this.props.children;
            }
          }]);
        }(reactExports.Component);
        function PopChild(_ref60) {
          var children = _ref60.children,
            isPresent = _ref60.isPresent;
          var id = reactExports.useId();
          var ref = reactExports.useRef(null);
          var size = reactExports.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0
          });
          var _reactExports$useCont13 = reactExports.useContext(MotionConfigContext),
            nonce = _reactExports$useCont13.nonce;
          /**
           * We create and inject a style block so we can apply this explicit
           * sizing in a non-destructive manner by just deleting the style block.
           *
           * We can't apply size via render as the measurement happens
           * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
           * styles directly on the DOM node, we might be overwriting
           * styles set via the style prop.
           */
          reactExports.useInsertionEffect(function () {
            var _size$current = size.current,
              width = _size$current.width,
              height = _size$current.height,
              top = _size$current.top,
              left = _size$current.left;
            if (isPresent || !ref.current || !width || !height) return;
            ref.current.dataset.motionPopId = id;
            var style = document.createElement("style");
            if (nonce) style.nonce = nonce;
            document.head.appendChild(style);
            if (style.sheet) {
              style.sheet.insertRule("\n          [data-motion-pop-id=\"".concat(id, "\"] {\n            position: absolute !important;\n            width: ").concat(width, "px !important;\n            height: ").concat(height, "px !important;\n            top: ").concat(top, "px !important;\n            left: ").concat(left, "px !important;\n          }\n        "));
            }
            return function () {
              document.head.removeChild(style);
            };
          }, [isPresent]);
          return jsxRuntimeExports.jsx(PopChildMeasure, {
            isPresent: isPresent,
            childRef: ref,
            sizeRef: size,
            children: reactExports.cloneElement(children, {
              ref: ref
            })
          });
        }
        var PresenceChild = function PresenceChild(_ref61) {
          var children = _ref61.children,
            initial = _ref61.initial,
            isPresent = _ref61.isPresent,
            onExitComplete = _ref61.onExitComplete,
            custom = _ref61.custom,
            presenceAffectsLayout = _ref61.presenceAffectsLayout,
            mode = _ref61.mode;
          var presenceChildren = useConstant(newChildrenMap);
          var id = reactExports.useId();
          var memoizedOnExitComplete = reactExports.useCallback(function (childId) {
            presenceChildren.set(childId, true);
            var _iterator1 = _createForOfIteratorHelper(presenceChildren.values()),
              _step1;
            try {
              for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
                var isComplete = _step1.value;
                if (!isComplete) return; // can stop searching when any is incomplete
              }
            } catch (err) {
              _iterator1.e(err);
            } finally {
              _iterator1.f();
            }
            onExitComplete && onExitComplete();
          }, [presenceChildren, onExitComplete]);
          var context = reactExports.useMemo(function () {
            return {
              id: id,
              initial: initial,
              isPresent: isPresent,
              custom: custom,
              onExitComplete: memoizedOnExitComplete,
              register: function register(childId) {
                presenceChildren.set(childId, false);
                return function () {
                  return presenceChildren.delete(childId);
                };
              }
            };
          },
          /**
           * If the presence of a child affects the layout of the components around it,
           * we want to make a new context value to ensure they get re-rendered
           * so they can detect that layout change.
           */
          presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);
          reactExports.useMemo(function () {
            presenceChildren.forEach(function (_, key) {
              return presenceChildren.set(key, false);
            });
          }, [isPresent]);
          /**
           * If there's no `motion` components to fire exit animations, we want to remove this
           * component immediately.
           */
          reactExports.useEffect(function () {
            !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
          }, [isPresent]);
          if (mode === "popLayout") {
            children = jsxRuntimeExports.jsx(PopChild, {
              isPresent: isPresent,
              children: children
            });
          }
          return jsxRuntimeExports.jsx(PresenceContext.Provider, {
            value: context,
            children: children
          });
        };
        function newChildrenMap() {
          return new Map();
        }

        /**
         * When a component is the child of `AnimatePresence`, it can use `usePresence`
         * to access information about whether it's still present in the React tree.
         *
         * ```jsx
         * import { usePresence } from "framer-motion"
         *
         * export const Component = () => {
         *   const [isPresent, safeToRemove] = usePresence()
         *
         *   useEffect(() => {
         *     !isPresent && setTimeout(safeToRemove, 1000)
         *   }, [isPresent])
         *
         *   return <div />
         * }
         * ```
         *
         * If `isPresent` is `false`, it means that a component has been removed the tree, but
         * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
         *
         * @public
         */
        function usePresence() {
          var subscribe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var context = reactExports.useContext(PresenceContext);
          if (context === null) return [true, null];
          var isPresent = context.isPresent,
            onExitComplete = context.onExitComplete,
            register = context.register;
          // It's safe to call the following hooks conditionally (after an early return) because the context will always
          // either be null or non-null for the lifespan of the component.
          var id = reactExports.useId();
          reactExports.useEffect(function () {
            if (subscribe) register(id);
          }, [subscribe]);
          var safeToRemove = reactExports.useCallback(function () {
            return subscribe && onExitComplete && onExitComplete(id);
          }, [id, onExitComplete, subscribe]);
          return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
        }
        /**
         * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.
         * There is no `safeToRemove` function.
         *
         * ```jsx
         * import { useIsPresent } from "framer-motion"
         *
         * export const Component = () => {
         *   const isPresent = useIsPresent()
         *
         *   useEffect(() => {
         *     !isPresent && console.log("I've been removed!")
         *   }, [isPresent])
         *
         *   return <div />
         * }
         * ```
         *
         * @public
         */
        function useIsPresent() {
          return isPresent(reactExports.useContext(PresenceContext));
        }
        function isPresent(context) {
          return context === null ? true : context.isPresent;
        }
        var getChildKey = function getChildKey(child) {
          return child.key || "";
        };
        function onlyElements(children) {
          var filtered = [];
          // We use forEach here instead of map as map mutates the component key by preprending `.$`
          reactExports.Children.forEach(children, function (child) {
            if (reactExports.isValidElement(child)) filtered.push(child);
          });
          return filtered;
        }
        var isBrowser$1 = typeof window !== "undefined";
        var useIsomorphicLayoutEffect$1 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
        var AnimatePresence = exports("A", function (_ref62) {
          var children = _ref62.children,
            custom = _ref62.custom,
            _ref62$initial = _ref62.initial,
            initial = _ref62$initial === void 0 ? true : _ref62$initial,
            onExitComplete = _ref62.onExitComplete,
            _ref62$presenceAffect = _ref62.presenceAffectsLayout,
            presenceAffectsLayout = _ref62$presenceAffect === void 0 ? true : _ref62$presenceAffect,
            _ref62$mode = _ref62.mode,
            mode = _ref62$mode === void 0 ? "sync" : _ref62$mode,
            _ref62$propagate = _ref62.propagate,
            propagate = _ref62$propagate === void 0 ? false : _ref62$propagate;
          var _usePresence = usePresence(propagate),
            _usePresence2 = _slicedToArray(_usePresence, 2),
            isParentPresent = _usePresence2[0],
            safeToRemove = _usePresence2[1];
          var presentChildren = reactExports.useMemo(function () {
            return onlyElements(children);
          }, [children]);
          var presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
          var isInitialRender = reactExports.useRef(true);
          var pendingPresentChildren = reactExports.useRef(presentChildren);
          var exitComplete = useConstant(function () {
            return /* @__PURE__ */new Map();
          });
          var _reactExports$useStat15 = reactExports.useState(presentChildren),
            _reactExports$useStat16 = _slicedToArray(_reactExports$useStat15, 2),
            diffedChildren = _reactExports$useStat16[0],
            setDiffedChildren = _reactExports$useStat16[1];
          var _reactExports$useStat17 = reactExports.useState(presentChildren),
            _reactExports$useStat18 = _slicedToArray(_reactExports$useStat17, 2),
            renderedChildren = _reactExports$useStat18[0],
            setRenderedChildren = _reactExports$useStat18[1];
          useIsomorphicLayoutEffect$1(function () {
            isInitialRender.current = false;
            pendingPresentChildren.current = presentChildren;
            for (var i = 0; i < renderedChildren.length; i++) {
              var key = getChildKey(renderedChildren[i]);
              if (!presentKeys.includes(key)) {
                if (exitComplete.get(key) !== true) {
                  exitComplete.set(key, false);
                }
              } else {
                exitComplete.delete(key);
              }
            }
          }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
          var exitingChildren = [];
          if (presentChildren !== diffedChildren) {
            var nextChildren = _toConsumableArray(presentChildren);
            for (var i = 0; i < renderedChildren.length; i++) {
              var child = renderedChildren[i];
              var key = getChildKey(child);
              if (!presentKeys.includes(key)) {
                nextChildren.splice(i, 0, child);
                exitingChildren.push(child);
              }
            }
            if (mode === "wait" && exitingChildren.length) {
              nextChildren = exitingChildren;
            }
            setRenderedChildren(onlyElements(nextChildren));
            setDiffedChildren(presentChildren);
            return;
          }
          var _reactExports$useCont14 = reactExports.useContext(LayoutGroupContext),
            forceRender = _reactExports$useCont14.forceRender;
          return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: renderedChildren.map(function (child) {
              var key = getChildKey(child);
              var isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
              var onExit = function onExit() {
                if (exitComplete.has(key)) {
                  exitComplete.set(key, true);
                } else {
                  return;
                }
                var isEveryExitComplete = true;
                exitComplete.forEach(function (isExitComplete) {
                  if (!isExitComplete) isEveryExitComplete = false;
                });
                if (isEveryExitComplete) {
                  forceRender === null || forceRender === void 0 ? void 0 : forceRender();
                  setRenderedChildren(pendingPresentChildren.current);
                  propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
                  onExitComplete && onExitComplete();
                }
              };
              return jsxRuntimeExports.jsx(PresenceChild, {
                isPresent: isPresent,
                initial: !isInitialRender.current || initial ? void 0 : false,
                custom: isPresent ? void 0 : custom,
                presenceAffectsLayout: presenceAffectsLayout,
                mode: mode,
                onExitComplete: isPresent ? void 0 : onExit,
                children: child
              }, key);
            })
          });
        });

        /*#__NO_SIDE_EFFECTS__*/
        var noop$2 = function noop$2(any) {
          return any;
        };
        var invariant = noop$2;

        /*#__NO_SIDE_EFFECTS__*/
        function memo(callback) {
          var result;
          return function () {
            if (result === undefined) result = callback();
            return result;
          };
        }

        /*
          Progress within given range
           Given a lower limit and an upper limit, we return the progress
          (expressed as a number 0-1) represented by the given value, and
          limit that progress to within 0-1.
           @param [number]: Lower limit
          @param [number]: Upper limit
          @param [number]: Value to find progress within given range
          @return [number]: Progress of value within range as expressed 0-1
        */
        /*#__NO_SIDE_EFFECTS__*/
        var progress = function progress(from, to, value) {
          var toFromDifference = to - from;
          return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
        };

        /**
         * Converts seconds to milliseconds
         *
         * @param seconds - Time in seconds.
         * @return milliseconds - Converted time in milliseconds.
         */
        /*#__NO_SIDE_EFFECTS__*/
        var secondsToMilliseconds = function secondsToMilliseconds(seconds) {
          return seconds * 1000;
        };
        /*#__NO_SIDE_EFFECTS__*/
        var millisecondsToSeconds = function millisecondsToSeconds(milliseconds) {
          return milliseconds / 1000;
        };
        var MotionGlobalConfig = {
          useManualTiming: false
        };
        function createRenderStep(runNextFrame) {
          /**
           * We create and reuse two queues, one to queue jobs for the current frame
           * and one for the next. We reuse to avoid triggering GC after x frames.
           */
          var thisFrame = new Set();
          var nextFrame = new Set();
          /**
           * Track whether we're currently processing jobs in this step. This way
           * we can decide whether to schedule new jobs for this frame or next.
           */
          var isProcessing = false;
          var flushNextFrame = false;
          /**
           * A set of processes which were marked keepAlive when scheduled.
           */
          var toKeepAlive = new WeakSet();
          var latestFrameData = {
            delta: 0.0,
            timestamp: 0.0,
            isProcessing: false
          };
          function triggerCallback(callback) {
            if (toKeepAlive.has(callback)) {
              step.schedule(callback);
              runNextFrame();
            }
            callback(latestFrameData);
          }
          var step = {
            /**
             * Schedule a process to run on the next frame.
             */
            schedule: function schedule(callback) {
              var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              var addToCurrentFrame = immediate && isProcessing;
              var queue = addToCurrentFrame ? thisFrame : nextFrame;
              if (keepAlive) toKeepAlive.add(callback);
              if (!queue.has(callback)) queue.add(callback);
              return callback;
            },
            /**
             * Cancel the provided callback from running on the next frame.
             */
            cancel: function cancel(callback) {
              nextFrame.delete(callback);
              toKeepAlive.delete(callback);
            },
            /**
             * Execute all schedule callbacks.
             */
            process: function process(frameData) {
              latestFrameData = frameData;
              /**
               * If we're already processing we've probably been triggered by a flushSync
               * inside an existing process. Instead of executing, mark flushNextFrame
               * as true and ensure we flush the following frame at the end of this one.
               */
              if (isProcessing) {
                flushNextFrame = true;
                return;
              }
              isProcessing = true;
              // Execute this frame
              var _ref63 = [nextFrame, thisFrame];
              thisFrame = _ref63[0];
              nextFrame = _ref63[1];
              thisFrame.forEach(triggerCallback);
              // Clear the frame so no callbacks remain. This is to avoid
              // memory leaks should this render step not run for a while.
              thisFrame.clear();
              isProcessing = false;
              if (flushNextFrame) {
                flushNextFrame = false;
                step.process(frameData);
              }
            }
          };
          return step;
        }
        var stepsOrder = ["read",
        // Read
        "resolveKeyframes",
        // Write/Read/Write/Read
        "update",
        // Compute
        "preRender",
        // Compute
        "render",
        // Write
        "postRender" // Compute
        ];
        var maxElapsed = 40;
        function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
          var runNextFrame = false;
          var useDefaultElapsed = true;
          var state = {
            delta: 0.0,
            timestamp: 0.0,
            isProcessing: false
          };
          var flagRunNextFrame = function flagRunNextFrame() {
            return runNextFrame = true;
          };
          var steps = stepsOrder.reduce(function (acc, key) {
            acc[key] = createRenderStep(flagRunNextFrame);
            return acc;
          }, {});
          var read = steps.read,
            resolveKeyframes = steps.resolveKeyframes,
            update = steps.update,
            preRender = steps.preRender,
            render = steps.render,
            postRender = steps.postRender;
          var _processBatch = function processBatch() {
            var timestamp = performance.now();
            runNextFrame = false;
            state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
            state.timestamp = timestamp;
            state.isProcessing = true;
            // Unrolled render loop for better per-frame performance
            read.process(state);
            resolveKeyframes.process(state);
            update.process(state);
            preRender.process(state);
            render.process(state);
            postRender.process(state);
            state.isProcessing = false;
            if (runNextFrame && allowKeepAlive) {
              useDefaultElapsed = false;
              scheduleNextBatch(_processBatch);
            }
          };
          var wake = function wake() {
            runNextFrame = true;
            useDefaultElapsed = true;
            if (!state.isProcessing) {
              scheduleNextBatch(_processBatch);
            }
          };
          var schedule = stepsOrder.reduce(function (acc, key) {
            var step = steps[key];
            acc[key] = function (process) {
              var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              if (!runNextFrame) wake();
              return step.schedule(process, keepAlive, immediate);
            };
            return acc;
          }, {});
          var cancel = function cancel(process) {
            for (var i = 0; i < stepsOrder.length; i++) {
              steps[stepsOrder[i]].cancel(process);
            }
          };
          return {
            schedule: schedule,
            cancel: cancel,
            state: state,
            steps: steps
          };
        }
        var _createRenderBatcher = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$2, true),
          frame = _createRenderBatcher.schedule,
          cancelFrame = _createRenderBatcher.cancel,
          frameData = _createRenderBatcher.state,
          frameSteps = _createRenderBatcher.steps;
        var LazyContext = reactExports.createContext({
          strict: false
        });
        var featureProps = {
          animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
          exit: ["exit"],
          drag: ["drag", "dragControls"],
          focus: ["whileFocus"],
          hover: ["whileHover", "onHoverStart", "onHoverEnd"],
          tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
          pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
          inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
          layout: ["layout", "layoutId"]
        };
        var featureDefinitions = {};
        var _loop6 = function _loop6(key) {
          featureDefinitions[key] = {
            isEnabled: function isEnabled(props) {
              return featureProps[key].some(function (name) {
                return !!props[name];
              });
            }
          };
        };
        for (var key in featureProps) {
          _loop6(key);
        }
        function loadFeatures(features) {
          for (var _key34 in features) {
            featureDefinitions[_key34] = _objectSpread3(_objectSpread3({}, featureDefinitions[_key34]), features[_key34]);
          }
        }

        /**
         * A list of all valid MotionProps.
         *
         * @privateRemarks
         * This doesn't throw if a `MotionProp` name is missing - it should.
         */
        var validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
        /**
         * Check whether a prop name is a valid `MotionProp` key.
         *
         * @param key - Name of the property to check
         * @returns `true` is key is a valid `MotionProp`.
         *
         * @public
         */
        function isValidMotionProp(key) {
          return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
        }
        var shouldForward = function shouldForward(key) {
          return !isValidMotionProp(key);
        };
        function loadExternalIsValidProp(isValidProp) {
          if (!isValidProp) return;
          // Explicitly filter our events
          shouldForward = function shouldForward(key) {
            return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
          };
        }
        /**
         * Emotion and Styled Components both allow users to pass through arbitrary props to their components
         * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
         * of these should be passed to the underlying DOM node.
         *
         * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
         * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
         * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
         * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
         *
         * By making it an optionalDependency we can offer this functionality only in the situations where it's
         * actually required.
         */
        try {
          /**
           * We attempt to import this package but require won't be defined in esm environments, in that case
           * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
           * in favour of explicit injection.
           */
          loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
        } catch (_a) {
          // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
        }
        function filterProps(props, isDom, forwardMotionProps) {
          var filteredProps = {};
          for (var _key35 in props) {
            /**
             * values is considered a valid prop by Emotion, so if it's present
             * this will be rendered out to the DOM unless explicitly filtered.
             *
             * We check the type as it could be used with the `feColorMatrix`
             * element, which we support.
             */
            if (_key35 === "values" && _typeof2(props.values) === "object") continue;
            if (shouldForward(_key35) || forwardMotionProps === true && isValidMotionProp(_key35) || !isDom && !isValidMotionProp(_key35) ||
            // If trying to use native HTML drag events, forward drag listeners
            props["draggable"] && _key35.startsWith("onDrag")) {
              filteredProps[_key35] = props[_key35];
            }
          }
          return filteredProps;
        }
        function createDOMMotionComponentProxy(componentFactory) {
          if (typeof Proxy === "undefined") {
            return componentFactory;
          }
          var componentCache = /* @__PURE__ */new Map();
          var deprecatedFactoryFunction = function deprecatedFactoryFunction() {
            return componentFactory.apply(void 0, arguments);
          };
          return new Proxy(deprecatedFactoryFunction, {
            /**
             * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
             * The prop name is passed through as `key` and we can use that to generate a `motion`
             * DOM component with that name.
             */
            get: function get(_target, key) {
              if (key === "create") return componentFactory;
              if (!componentCache.has(key)) {
                componentCache.set(key, componentFactory(key));
              }
              return componentCache.get(key);
            }
          });
        }
        var MotionContext = reactExports.createContext({});

        /**
         * Decides if the supplied variable is variant label
         */
        function isVariantLabel(v) {
          return typeof v === "string" || Array.isArray(v);
        }
        function isAnimationControls(v) {
          return v !== null && _typeof2(v) === "object" && typeof v.start === "function";
        }
        var variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"];
        var variantProps = ["initial"].concat(variantPriorityOrder);
        function isControllingVariants(props) {
          return isAnimationControls(props.animate) || variantProps.some(function (name) {
            return isVariantLabel(props[name]);
          });
        }
        function isVariantNode(props) {
          return Boolean(isControllingVariants(props) || props.variants);
        }
        function getCurrentTreeVariants(props, context) {
          if (isControllingVariants(props)) {
            var initial = props.initial,
              animate = props.animate;
            return {
              initial: initial === false || isVariantLabel(initial) ? initial : undefined,
              animate: isVariantLabel(animate) ? animate : undefined
            };
          }
          return props.inherit !== false ? context : {};
        }
        function useCreateMotionContext(props) {
          var _getCurrentTreeVarian = getCurrentTreeVariants(props, reactExports.useContext(MotionContext)),
            initial = _getCurrentTreeVarian.initial,
            animate = _getCurrentTreeVarian.animate;
          return reactExports.useMemo(function () {
            return {
              initial: initial,
              animate: animate
            };
          }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
        }
        function variantLabelsAsDependency(prop) {
          return Array.isArray(prop) ? prop.join(" ") : prop;
        }
        var motionComponentSymbol = Symbol.for("motionComponentSymbol");
        function isRefObject(ref) {
          return ref && _typeof2(ref) === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
        }

        /**
         * Creates a ref function that, when called, hydrates the provided
         * external ref and VisualElement.
         */
        function useMotionRef(visualState, visualElement, externalRef) {
          return reactExports.useCallback(function (instance) {
            if (instance) {
              visualState.onMount && visualState.onMount(instance);
            }
            if (visualElement) {
              if (instance) {
                visualElement.mount(instance);
              } else {
                visualElement.unmount();
              }
            }
            if (externalRef) {
              if (typeof externalRef === "function") {
                externalRef(instance);
              } else if (isRefObject(externalRef)) {
                externalRef.current = instance;
              }
            }
          },
          /**
           * Only pass a new ref callback to React if we've received a visual element
           * factory. Otherwise we'll be mounting/remounting every time externalRef
           * or other dependencies change.
           */
          [visualElement]);
        }

        /**
         * Convert camelCase to dash-case properties.
         */
        var camelToDash = function camelToDash(str) {
          return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        };
        var optimizedAppearDataId = "framerAppearId";
        var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
        var _createRenderBatcher2 = createRenderBatcher(queueMicrotask, false),
          microtask = _createRenderBatcher2.schedule;

        /**
         * Internal, exported only for usage in Framer
         */
        var SwitchLayoutGroupContext = reactExports.createContext({});
        function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
          var _a, _b;
          var _reactExports$useCont15 = reactExports.useContext(MotionContext),
            parent = _reactExports$useCont15.visualElement;
          var lazyContext = reactExports.useContext(LazyContext);
          var presenceContext = reactExports.useContext(PresenceContext);
          var reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
          var visualElementRef = reactExports.useRef(null);
          /**
           * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
           */
          createVisualElement = createVisualElement || lazyContext.renderer;
          if (!visualElementRef.current && createVisualElement) {
            visualElementRef.current = createVisualElement(Component, {
              visualState: visualState,
              parent: parent,
              props: props,
              presenceContext: presenceContext,
              blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
              reducedMotionConfig: reducedMotionConfig
            });
          }
          var visualElement = visualElementRef.current;
          /**
           * Load Motion gesture and animation features. These are rendered as renderless
           * components so each feature can optionally make use of React lifecycle methods.
           */
          var initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
          if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
            createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
          }
          var isMounted = reactExports.useRef(false);
          reactExports.useInsertionEffect(function () {
            /**
             * Check the component has already mounted before calling
             * `update` unnecessarily. This ensures we skip the initial update.
             */
            if (visualElement && isMounted.current) {
              visualElement.update(props, presenceContext);
            }
          });
          /**
           * Cache this value as we want to know whether HandoffAppearAnimations
           * was present on initial render - it will be deleted after this.
           */
          var optimisedAppearId = props[optimizedAppearDataAttribute];
          var wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
          useIsomorphicLayoutEffect$1(function () {
            if (!visualElement) return;
            isMounted.current = true;
            window.MotionIsMounted = true;
            visualElement.updateFeatures();
            microtask.render(visualElement.render);
            /**
             * Ideally this function would always run in a useEffect.
             *
             * However, if we have optimised appear animations to handoff from,
             * it needs to happen synchronously to ensure there's no flash of
             * incorrect styles in the event of a hydration error.
             *
             * So if we detect a situtation where optimised appear animations
             * are running, we use useLayoutEffect to trigger animations.
             */
            if (wantsHandoff.current && visualElement.animationState) {
              visualElement.animationState.animateChanges();
            }
          });
          reactExports.useEffect(function () {
            if (!visualElement) return;
            if (!wantsHandoff.current && visualElement.animationState) {
              visualElement.animationState.animateChanges();
            }
            if (wantsHandoff.current) {
              // This ensures all future calls to animateChanges() in this component will run in useEffect
              queueMicrotask(function () {
                var _a;
                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);
              });
              wantsHandoff.current = false;
            }
          });
          return visualElement;
        }
        function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
          var layoutId = props.layoutId,
            layout = props.layout,
            drag = props.drag,
            dragConstraints = props.dragConstraints,
            layoutScroll = props.layoutScroll,
            layoutRoot = props.layoutRoot;
          visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? undefined : getClosestProjectingNode(visualElement.parent));
          visualElement.projection.setOptions({
            layoutId: layoutId,
            layout: layout,
            alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),
            visualElement: visualElement,
            /**
             * TODO: Update options in an effect. This could be tricky as it'll be too late
             * to update by the time layout animations run.
             * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
             * ensuring it gets called if there's no potential layout animations.
             *
             */
            animationType: typeof layout === "string" ? layout : "both",
            initialPromotionConfig: initialPromotionConfig,
            layoutScroll: layoutScroll,
            layoutRoot: layoutRoot
          });
        }
        function getClosestProjectingNode(visualElement) {
          if (!visualElement) return undefined;
          return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
        }
        function createRendererMotionComponent(_ref64) {
          var preloadedFeatures = _ref64.preloadedFeatures,
            createVisualElement = _ref64.createVisualElement,
            useRender = _ref64.useRender,
            useVisualState = _ref64.useVisualState,
            Component = _ref64.Component;
          var _a, _b;
          preloadedFeatures && loadFeatures(preloadedFeatures);
          function MotionComponent(props, externalRef) {
            var MeasureLayout;
            var configAndProps = _objectSpread3(_objectSpread3(_objectSpread3({}, reactExports.useContext(MotionConfigContext)), props), {}, {
              layoutId: useLayoutId(props)
            });
            var isStatic = configAndProps.isStatic;
            var context = useCreateMotionContext(props);
            var visualState = useVisualState(props, isStatic);
            if (!isStatic && isBrowser$1) {
              useStrictMode();
              var layoutProjection = getProjectionFunctionality(configAndProps);
              MeasureLayout = layoutProjection.MeasureLayout;
              context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
            }
            return jsxRuntimeExports.jsxs(MotionContext.Provider, {
              value: context,
              children: [MeasureLayout && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout, _objectSpread3({
                visualElement: context.visualElement
              }, configAndProps)) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)]
            });
          }
          MotionComponent.displayName = "motion.".concat(typeof Component === "string" ? Component : "create(".concat((_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : "", ")"));
          var ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
          ForwardRefMotionComponent[motionComponentSymbol] = Component;
          return ForwardRefMotionComponent;
        }
        function useLayoutId(_ref65) {
          var layoutId = _ref65.layoutId;
          var layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
          return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
        }
        function useStrictMode(configAndProps, preloadedFeatures) {
          reactExports.useContext(LazyContext).strict;
        }
        function getProjectionFunctionality(props) {
          var drag = featureDefinitions.drag,
            layout = featureDefinitions.layout;
          if (!drag && !layout) return {};
          var combined = _objectSpread3(_objectSpread3({}, drag), layout);
          return {
            MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props)) ? combined.MeasureLayout : void 0,
            ProjectionNode: combined.ProjectionNode
          };
        }

        /**
         * We keep these listed separately as we use the lowercase tag names as part
         * of the runtime bundle to detect SVG components
         */
        var lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
        function isSVGComponent(Component) {
          if (
          /**
           * If it's not a string, it's a custom React component. Currently we only support
           * HTML custom React components.
           */
          typeof Component !== "string" ||
          /**
           * If it contains a dash, the element is a custom HTML webcomponent.
           */
          Component.includes("-")) {
            return false;
          } else if (
          /**
           * If it's in our list of lowercase SVG tags, it's an SVG component
           */
          lowercaseSVGElements.indexOf(Component) > -1 ||
          /**
           * If it contains a capital letter, it's an SVG component
           */
          /[A-Z]/.test(Component)) {
            return true;
          }
          return false;
        }
        function getValueState(visualElement) {
          var state = [{}, {}];
          visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach(function (value, key) {
            state[0][key] = value.get();
            state[1][key] = value.getVelocity();
          });
          return state;
        }
        function resolveVariantFromProps(props, definition, custom, visualElement) {
          /**
           * If the variant definition is a function, resolve.
           */
          if (typeof definition === "function") {
            var _getValueState = getValueState(visualElement),
              _getValueState2 = _slicedToArray(_getValueState, 2),
              current = _getValueState2[0],
              velocity = _getValueState2[1];
            definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
          }
          /**
           * If the variant definition is a variant label, or
           * the function returned a variant label, resolve.
           */
          if (typeof definition === "string") {
            definition = props.variants && props.variants[definition];
          }
          /**
           * At this point we've resolved both functions and variant labels,
           * but the resolved variant label might itself have been a function.
           * If so, resolve. This can only have returned a valid target object.
           */
          if (typeof definition === "function") {
            var _getValueState3 = getValueState(visualElement),
              _getValueState4 = _slicedToArray(_getValueState3, 2),
              _current = _getValueState4[0],
              _velocity = _getValueState4[1];
            definition = definition(custom !== undefined ? custom : props.custom, _current, _velocity);
          }
          return definition;
        }
        var isKeyframesTarget = function isKeyframesTarget(v) {
          return Array.isArray(v);
        };
        var isCustomValue = function isCustomValue(v) {
          return Boolean(v && _typeof2(v) === "object" && v.mix && v.toValue);
        };
        var resolveFinalValueInKeyframes = function resolveFinalValueInKeyframes(v) {
          // TODO maybe throw if v.length - 1 is placeholder token?
          return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
        };
        var isMotionValue = function isMotionValue(value) {
          return Boolean(value && value.getVelocity);
        };

        /**
         * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
         *
         * TODO: Remove and move to library
         */
        function resolveMotionValue(value) {
          var unwrappedValue = isMotionValue(value) ? value.get() : value;
          return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
        }
        function makeState(_ref66, props, context, presenceContext) {
          var scrapeMotionValuesFromProps = _ref66.scrapeMotionValuesFromProps,
            createRenderState = _ref66.createRenderState,
            onUpdate = _ref66.onUpdate;
          var state = {
            latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
            renderState: createRenderState()
          };
          if (onUpdate) {
            /**
             * onMount works without the VisualElement because it could be
             * called before the VisualElement payload has been hydrated.
             * (e.g. if someone is using m components <m.circle />)
             */
            state.onMount = function (instance) {
              return onUpdate(_objectSpread3({
                props: props,
                current: instance
              }, state));
            };
            state.onUpdate = function (visualElement) {
              return onUpdate(visualElement);
            };
          }
          return state;
        }
        var makeUseVisualState = function makeUseVisualState(config) {
          return function (props, isStatic) {
            var context = reactExports.useContext(MotionContext);
            var presenceContext = reactExports.useContext(PresenceContext);
            var make = function make() {
              return makeState(config, props, context, presenceContext);
            };
            return isStatic ? make() : useConstant(make);
          };
        };
        function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
          var values = {};
          var motionValues = scrapeMotionValues(props, {});
          for (var _key36 in motionValues) {
            values[_key36] = resolveMotionValue(motionValues[_key36]);
          }
          var initial = props.initial,
            animate = props.animate;
          var isControllingVariants$1 = isControllingVariants(props);
          var isVariantNode$1 = isVariantNode(props);
          if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
            if (initial === undefined) initial = context.initial;
            if (animate === undefined) animate = context.animate;
          }
          var isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
          isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
          var variantToSet = isInitialAnimationBlocked ? animate : initial;
          if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
            var _list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
            for (var i = 0; i < _list.length; i++) {
              var resolved = resolveVariantFromProps(props, _list[i]);
              if (resolved) {
                var transitionEnd = resolved.transitionEnd,
                  _transition = resolved.transition,
                  target = _objectWithoutProperties2(resolved, _excluded8);
                for (var _key37 in target) {
                  var valueTarget = target[_key37];
                  if (Array.isArray(valueTarget)) {
                    /**
                     * Take final keyframe if the initial animation is blocked because
                     * we want to initialise at the end of that blocked animation.
                     */
                    var index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
                    valueTarget = valueTarget[index];
                  }
                  if (valueTarget !== null) {
                    values[_key37] = valueTarget;
                  }
                }
                for (var _key38 in transitionEnd) {
                  values[_key38] = transitionEnd[_key38];
                }
              }
            }
          }
          return values;
        }

        /**
         * Generate a list of every possible transform key.
         */
        var transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
        /**
         * A quick lookup for transform props.
         */
        var transformProps = new Set(transformPropOrder);
        var checkStringStartsWith = function checkStringStartsWith(token) {
          return function (key) {
            return typeof key === "string" && key.startsWith(token);
          };
        };
        var isCSSVariableName = /*@__PURE__*/checkStringStartsWith("--");
        var startsAsVariableToken = /*@__PURE__*/checkStringStartsWith("var(--");
        var isCSSVariableToken = function isCSSVariableToken(value) {
          var startsWithToken = startsAsVariableToken(value);
          if (!startsWithToken) return false;
          // Ensure any comments are stripped from the value as this can harm performance of the regex.
          return singleCssVariableRegex.test(value.split("/*")[0].trim());
        };
        var singleCssVariableRegex = /var\(--(?:[\x2D0-9A-Z_a-z\u017F\u212A]+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*|[\x2D0-9A-Z_a-z\u017F\u212A]+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*,(?:[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:(?![\t-\r \(\)\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uD800-\uDFFF\uFEFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])|[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\((?:(?:(?![\(\)\uD800-\uDFFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])|\((?:(?![\(\)\uD800-\uDFFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])*\))*\))+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)\)$/i;

        /**
         * Provided a value and a ValueType, returns the value as that value type.
         */
        var getValueAsType = function getValueAsType(value, type) {
          return type && typeof value === "number" ? type.transform(value) : value;
        };
        var clamp = function clamp(min, max, v) {
          if (v > max) return max;
          if (v < min) return min;
          return v;
        };
        var number = {
          test: function test(v) {
            return typeof v === "number";
          },
          parse: parseFloat,
          transform: function transform(v) {
            return v;
          }
        };
        var alpha = _objectSpread3(_objectSpread3({}, number), {}, {
          transform: function transform(v) {
            return clamp(0, 1, v);
          }
        });
        var scale$1 = _objectSpread3(_objectSpread3({}, number), {}, {
          default: 1
        });
        var createUnitType = function createUnitType(unit) {
          return {
            test: function test(v) {
              return typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1;
            },
            parse: parseFloat,
            transform: function transform(v) {
              return "".concat(v).concat(unit);
            }
          };
        };
        var degrees = /*@__PURE__*/createUnitType("deg");
        var percent = /*@__PURE__*/createUnitType("%");
        var px = /*@__PURE__*/createUnitType("px");
        var vh = /*@__PURE__*/createUnitType("vh");
        var vw = /*@__PURE__*/createUnitType("vw");
        var progressPercentage = _objectSpread3(_objectSpread3({}, percent), {}, {
          parse: function parse(v) {
            return percent.parse(v) / 100;
          },
          transform: function transform(v) {
            return percent.transform(v * 100);
          }
        });
        var browserNumberValueTypes = {
          // Border props
          borderWidth: px,
          borderTopWidth: px,
          borderRightWidth: px,
          borderBottomWidth: px,
          borderLeftWidth: px,
          borderRadius: px,
          radius: px,
          borderTopLeftRadius: px,
          borderTopRightRadius: px,
          borderBottomRightRadius: px,
          borderBottomLeftRadius: px,
          // Positioning props
          width: px,
          maxWidth: px,
          height: px,
          maxHeight: px,
          top: px,
          right: px,
          bottom: px,
          left: px,
          // Spacing props
          padding: px,
          paddingTop: px,
          paddingRight: px,
          paddingBottom: px,
          paddingLeft: px,
          margin: px,
          marginTop: px,
          marginRight: px,
          marginBottom: px,
          marginLeft: px,
          // Misc
          backgroundPositionX: px,
          backgroundPositionY: px
        };
        var transformValueTypes = {
          rotate: degrees,
          rotateX: degrees,
          rotateY: degrees,
          rotateZ: degrees,
          scale: scale$1,
          scaleX: scale$1,
          scaleY: scale$1,
          scaleZ: scale$1,
          skew: degrees,
          skewX: degrees,
          skewY: degrees,
          distance: px,
          translateX: px,
          translateY: px,
          translateZ: px,
          x: px,
          y: px,
          z: px,
          perspective: px,
          transformPerspective: px,
          opacity: alpha,
          originX: progressPercentage,
          originY: progressPercentage,
          originZ: px
        };
        var int = _objectSpread3(_objectSpread3({}, number), {}, {
          transform: Math.round
        });
        var numberValueTypes = _objectSpread3(_objectSpread3(_objectSpread3({}, browserNumberValueTypes), transformValueTypes), {}, {
          zIndex: int,
          size: px,
          // SVG
          fillOpacity: alpha,
          strokeOpacity: alpha,
          numOctaves: int
        });
        var translateAlias = {
          x: "translateX",
          y: "translateY",
          z: "translateZ",
          transformPerspective: "perspective"
        };
        var numTransforms = transformPropOrder.length;
        /**
         * Build a CSS transform style from individual x/y/scale etc properties.
         *
         * This outputs with a default order of transforms/scales/rotations, this can be customised by
         * providing a transformTemplate function.
         */
        function buildTransform(latestValues, transform, transformTemplate) {
          // The transform string we're going to build into.
          var transformString = "";
          var transformIsDefault = true;
          /**
           * Loop over all possible transforms in order, adding the ones that
           * are present to the transform string.
           */
          for (var i = 0; i < numTransforms; i++) {
            var _key39 = transformPropOrder[i];
            var value = latestValues[_key39];
            if (value === undefined) continue;
            var valueIsDefault = true;
            if (typeof value === "number") {
              valueIsDefault = value === (_key39.startsWith("scale") ? 1 : 0);
            } else {
              valueIsDefault = parseFloat(value) === 0;
            }
            if (!valueIsDefault || transformTemplate) {
              var valueAsType = getValueAsType(value, numberValueTypes[_key39]);
              if (!valueIsDefault) {
                transformIsDefault = false;
                var transformName = translateAlias[_key39] || _key39;
                transformString += "".concat(transformName, "(").concat(valueAsType, ") ");
              }
              if (transformTemplate) {
                transform[_key39] = valueAsType;
              }
            }
          }
          transformString = transformString.trim();
          // If we have a custom `transform` template, pass our transform values and
          // generated transformString to that before returning
          if (transformTemplate) {
            transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
          } else if (transformIsDefault) {
            transformString = "none";
          }
          return transformString;
        }
        function buildHTMLStyles(state, latestValues, transformTemplate) {
          var style = state.style,
            vars = state.vars,
            transformOrigin = state.transformOrigin;
          // Track whether we encounter any transform or transformOrigin values.
          var hasTransform = false;
          var hasTransformOrigin = false;
          /**
           * Loop over all our latest animated values and decide whether to handle them
           * as a style or CSS variable.
           *
           * Transforms and transform origins are kept separately for further processing.
           */
          for (var _key40 in latestValues) {
            var value = latestValues[_key40];
            if (transformProps.has(_key40)) {
              // If this is a transform, flag to enable further transform processing
              hasTransform = true;
              continue;
            } else if (isCSSVariableName(_key40)) {
              vars[_key40] = value;
              continue;
            } else {
              // Convert the value to its default value type, ie 0 -> "0px"
              var valueAsType = getValueAsType(value, numberValueTypes[_key40]);
              if (_key40.startsWith("origin")) {
                // If this is a transform origin, flag and enable further transform-origin processing
                hasTransformOrigin = true;
                transformOrigin[_key40] = valueAsType;
              } else {
                style[_key40] = valueAsType;
              }
            }
          }
          if (!latestValues.transform) {
            if (hasTransform || transformTemplate) {
              style.transform = buildTransform(latestValues, state.transform, transformTemplate);
            } else if (style.transform) {
              /**
               * If we have previously created a transform but currently don't have any,
               * reset transform style to none.
               */
              style.transform = "none";
            }
          }
          /**
           * Build a transformOrigin style. Uses the same defaults as the browser for
           * undefined origins.
           */
          if (hasTransformOrigin) {
            var _transformOrigin$orig = transformOrigin.originX,
              originX = _transformOrigin$orig === void 0 ? "50%" : _transformOrigin$orig,
              _transformOrigin$orig2 = transformOrigin.originY,
              originY = _transformOrigin$orig2 === void 0 ? "50%" : _transformOrigin$orig2,
              _transformOrigin$orig3 = transformOrigin.originZ,
              originZ = _transformOrigin$orig3 === void 0 ? 0 : _transformOrigin$orig3;
            style.transformOrigin = "".concat(originX, " ").concat(originY, " ").concat(originZ);
          }
        }
        var dashKeys = {
          offset: "stroke-dashoffset",
          array: "stroke-dasharray"
        };
        var camelKeys = {
          offset: "strokeDashoffset",
          array: "strokeDasharray"
        };
        /**
         * Build SVG path properties. Uses the path's measured length to convert
         * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
         * and stroke-dasharray attributes.
         *
         * This function is mutative to reduce per-frame GC.
         */
        function buildSVGPath(attrs, length) {
          var spacing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var useDashCase = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
          // Normalise path length by setting SVG attribute pathLength to 1
          attrs.pathLength = 1;
          // We use dash case when setting attributes directly to the DOM node and camel case
          // when defining props on a React component.
          var keys = useDashCase ? dashKeys : camelKeys;
          // Build the dash offset
          attrs[keys.offset] = px.transform(-offset);
          // Build the dash array
          var pathLength = px.transform(length);
          var pathSpacing = px.transform(spacing);
          attrs[keys.array] = "".concat(pathLength, " ").concat(pathSpacing);
        }
        function calcOrigin$1(origin, offset, size) {
          return typeof origin === "string" ? origin : px.transform(offset + size * origin);
        }
        /**
         * The SVG transform origin defaults are different to CSS and is less intuitive,
         * so we use the measured dimensions of the SVG to reconcile these.
         */
        function calcSVGTransformOrigin(dimensions, originX, originY) {
          var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
          var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
          return "".concat(pxOriginX, " ").concat(pxOriginY);
        }

        /**
         * Build SVG visual attrbutes, like cx and style.transform
         */
        function buildSVGAttrs(state, _ref67, isSVGTag, transformTemplate) {
          var attrX = _ref67.attrX,
            attrY = _ref67.attrY,
            attrScale = _ref67.attrScale,
            originX = _ref67.originX,
            originY = _ref67.originY,
            pathLength = _ref67.pathLength,
            _ref67$pathSpacing = _ref67.pathSpacing,
            pathSpacing = _ref67$pathSpacing === void 0 ? 1 : _ref67$pathSpacing,
            _ref67$pathOffset = _ref67.pathOffset,
            pathOffset = _ref67$pathOffset === void 0 ? 0 : _ref67$pathOffset,
            latest = _objectWithoutProperties2(_ref67, _excluded9);
          buildHTMLStyles(state, latest, transformTemplate);
          /**
           * For svg tags we just want to make sure viewBox is animatable and treat all the styles
           * as normal HTML tags.
           */
          if (isSVGTag) {
            if (state.style.viewBox) {
              state.attrs.viewBox = state.style.viewBox;
            }
            return;
          }
          state.attrs = state.style;
          state.style = {};
          var attrs = state.attrs,
            style = state.style,
            dimensions = state.dimensions;
          /**
           * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
           * and copy it into style.
           */
          if (attrs.transform) {
            if (dimensions) style.transform = attrs.transform;
            delete attrs.transform;
          }
          // Parse transformOrigin
          if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {
            style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
          }
          // Render attrX/attrY/attrScale as attributes
          if (attrX !== undefined) attrs.x = attrX;
          if (attrY !== undefined) attrs.y = attrY;
          if (attrScale !== undefined) attrs.scale = attrScale;
          // Build SVG path if one has been defined
          if (pathLength !== undefined) {
            buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
          }
        }
        var createHtmlRenderState = function createHtmlRenderState() {
          return {
            style: {},
            transform: {},
            transformOrigin: {},
            vars: {}
          };
        };
        var createSvgRenderState = function createSvgRenderState() {
          return _objectSpread3(_objectSpread3({}, createHtmlRenderState()), {}, {
            attrs: {}
          });
        };
        var isSVGTag = function isSVGTag(tag) {
          return typeof tag === "string" && tag.toLowerCase() === "svg";
        };
        function renderHTML(element, _ref68, styleProp, projection) {
          var style = _ref68.style,
            vars = _ref68.vars;
          Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
          // Loop over any CSS variables and assign those.
          for (var _key41 in vars) {
            element.style.setProperty(_key41, vars[_key41]);
          }
        }

        /**
         * A set of attribute names that are always read/written as camel case.
         */
        var camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
        function renderSVG(element, renderState, _styleProp, projection) {
          renderHTML(element, renderState, undefined, projection);
          for (var _key42 in renderState.attrs) {
            element.setAttribute(!camelCaseAttributes.has(_key42) ? camelToDash(_key42) : _key42, renderState.attrs[_key42]);
          }
        }
        var scaleCorrectors = {};
        function addScaleCorrector(correctors) {
          Object.assign(scaleCorrectors, correctors);
        }
        function isForcedMotionValue(key, _ref69) {
          var layout = _ref69.layout,
            layoutId = _ref69.layoutId;
          return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === "opacity");
        }
        function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
          var _a;
          var style = props.style;
          var newValues = {};
          for (var _key43 in style) {
            if (isMotionValue(style[_key43]) || prevProps.style && isMotionValue(prevProps.style[_key43]) || isForcedMotionValue(_key43, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(_key43)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {
              newValues[_key43] = style[_key43];
            }
          }
          return newValues;
        }
        function _scrapeMotionValuesFromProps(props, prevProps, visualElement) {
          var newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
          for (var _key44 in props) {
            if (isMotionValue(props[_key44]) || isMotionValue(prevProps[_key44])) {
              var targetKey = transformPropOrder.indexOf(_key44) !== -1 ? "attr" + _key44.charAt(0).toUpperCase() + _key44.substring(1) : _key44;
              newValues[targetKey] = props[_key44];
            }
          }
          return newValues;
        }
        function updateSVGDimensions(instance, renderState) {
          try {
            renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
          } catch (e) {
            // Most likely trying to measure an unrendered element under Firefox
            renderState.dimensions = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
        }
        var layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];
        var svgMotionConfig = {
          useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps: _scrapeMotionValuesFromProps,
            createRenderState: createSvgRenderState,
            onUpdate: function onUpdate(_ref70) {
              var props = _ref70.props,
                prevProps = _ref70.prevProps,
                current = _ref70.current,
                renderState = _ref70.renderState,
                latestValues = _ref70.latestValues;
              if (!current) return;
              var hasTransform = !!props.drag;
              if (!hasTransform) {
                for (var _key45 in latestValues) {
                  if (transformProps.has(_key45)) {
                    hasTransform = true;
                    break;
                  }
                }
              }
              if (!hasTransform) return;
              var needsMeasure = !prevProps;
              if (prevProps) {
                /**
                 * Check the layout props for changes, if any are found we need to
                 * measure the element again.
                 */
                for (var i = 0; i < layoutProps.length; i++) {
                  var _key46 = layoutProps[i];
                  if (props[_key46] !== prevProps[_key46]) {
                    needsMeasure = true;
                  }
                }
              }
              if (!needsMeasure) return;
              frame.read(function () {
                updateSVGDimensions(current, renderState);
                frame.render(function () {
                  buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);
                  renderSVG(current, renderState);
                });
              });
            }
          })
        };
        var htmlMotionConfig = {
          useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
            createRenderState: createHtmlRenderState
          })
        };
        function copyRawValuesOnly(target, source, props) {
          for (var _key47 in source) {
            if (!isMotionValue(source[_key47]) && !isForcedMotionValue(_key47, props)) {
              target[_key47] = source[_key47];
            }
          }
        }
        function useInitialMotionValues(_ref71, visualState) {
          var transformTemplate = _ref71.transformTemplate;
          return reactExports.useMemo(function () {
            var state = createHtmlRenderState();
            buildHTMLStyles(state, visualState, transformTemplate);
            return Object.assign({}, state.vars, state.style);
          }, [visualState]);
        }
        function useStyle(props, visualState) {
          var styleProp = props.style || {};
          var style = {};
          /**
           * Copy non-Motion Values straight into style
           */
          copyRawValuesOnly(style, styleProp, props);
          Object.assign(style, useInitialMotionValues(props, visualState));
          return style;
        }
        function useHTMLProps(props, visualState) {
          // The `any` isn't ideal but it is the type of createElement props argument
          var htmlProps = {};
          var style = useStyle(props, visualState);
          if (props.drag && props.dragListener !== false) {
            // Disable the ghost element when a user drags
            htmlProps.draggable = false;
            // Disable text selection
            style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
            // Disable scrolling on the draggable direction
            style.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
          }
          if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {
            htmlProps.tabIndex = 0;
          }
          htmlProps.style = style;
          return htmlProps;
        }
        function useSVGProps(props, visualState, _isStatic, Component) {
          var visualProps = reactExports.useMemo(function () {
            var state = createSvgRenderState();
            buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
            return _objectSpread3(_objectSpread3({}, state.attrs), {}, {
              style: _objectSpread3({}, state.style)
            });
          }, [visualState]);
          if (props.style) {
            var rawStyles = {};
            copyRawValuesOnly(rawStyles, props.style, props);
            visualProps.style = _objectSpread3(_objectSpread3({}, rawStyles), visualProps.style);
          }
          return visualProps;
        }
        function createUseRender() {
          var forwardMotionProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var useRender = function useRender(Component, props, ref, _ref72, isStatic) {
            var latestValues = _ref72.latestValues;
            var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
            var visualProps = useVisualProps(props, latestValues, isStatic, Component);
            var filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
            var elementProps = Component !== reactExports.Fragment ? _objectSpread3(_objectSpread3(_objectSpread3({}, filteredProps), visualProps), {}, {
              ref: ref
            }) : {};
            /**
             * If component has been handed a motion value as its child,
             * memoise its initial value and render that. Subsequent updates
             * will be handled by the onChange handler
             */
            var children = props.children;
            var renderedChildren = reactExports.useMemo(function () {
              return isMotionValue(children) ? children.get() : children;
            }, [children]);
            return reactExports.createElement(Component, _objectSpread3(_objectSpread3({}, elementProps), {}, {
              children: renderedChildren
            }));
          };
          return useRender;
        }
        function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
          return function createMotionComponent(Component) {
            var _ref73 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                forwardMotionProps: false
              },
              forwardMotionProps = _ref73.forwardMotionProps;
            var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
            var config = _objectSpread3(_objectSpread3({}, baseConfig), {}, {
              preloadedFeatures: preloadedFeatures,
              useRender: createUseRender(forwardMotionProps),
              createVisualElement: createVisualElement,
              Component: Component
            });
            return createRendererMotionComponent(config);
          };
        }
        function shallowCompare(next, prev) {
          if (!Array.isArray(prev)) return false;
          var prevLength = prev.length;
          if (prevLength !== next.length) return false;
          for (var i = 0; i < prevLength; i++) {
            if (prev[i] !== next[i]) return false;
          }
          return true;
        }
        function resolveVariant(visualElement, definition, custom) {
          var props = visualElement.getProps();
          return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);
        }
        var supportsScrollTimeline = memo(function () {
          return window.ScrollTimeline !== undefined;
        });
        var BaseGroupPlaybackControls = /*#__PURE__*/function () {
          function BaseGroupPlaybackControls(animations) {
            var _this1 = this;
            _classCallCheck(this, BaseGroupPlaybackControls);
            // Bound to accomodate common `return animation.stop` pattern
            this.stop = function () {
              return _this1.runAll("stop");
            };
            this.animations = animations.filter(Boolean);
          }
          return _createClass(BaseGroupPlaybackControls, [{
            key: "finished",
            get: function get() {
              // Support for new finished Promise and legacy thennable API
              return Promise.all(this.animations.map(function (animation) {
                return "finished" in animation ? animation.finished : animation;
              }));
            }
            /**
             * TODO: Filter out cancelled or stopped animations before returning
             */
          }, {
            key: "getAll",
            value: function getAll(propName) {
              return this.animations[0][propName];
            }
          }, {
            key: "setAll",
            value: function setAll(propName, newValue) {
              for (var i = 0; i < this.animations.length; i++) {
                this.animations[i][propName] = newValue;
              }
            }
          }, {
            key: "attachTimeline",
            value: function attachTimeline(timeline, fallback) {
              var _this15 = this;
              var subscriptions = this.animations.map(function (animation) {
                if (supportsScrollTimeline() && animation.attachTimeline) {
                  return animation.attachTimeline(timeline);
                } else if (typeof fallback === "function") {
                  return fallback(animation);
                }
              });
              return function () {
                subscriptions.forEach(function (cancel, i) {
                  cancel && cancel();
                  _this15.animations[i].stop();
                });
              };
            }
          }, {
            key: "time",
            get: function get() {
              return this.getAll("time");
            },
            set: function set(time) {
              this.setAll("time", time);
            }
          }, {
            key: "speed",
            get: function get() {
              return this.getAll("speed");
            },
            set: function set(speed) {
              this.setAll("speed", speed);
            }
          }, {
            key: "startTime",
            get: function get() {
              return this.getAll("startTime");
            }
          }, {
            key: "duration",
            get: function get() {
              var max = 0;
              for (var i = 0; i < this.animations.length; i++) {
                max = Math.max(max, this.animations[i].duration);
              }
              return max;
            }
          }, {
            key: "runAll",
            value: function runAll(methodName) {
              this.animations.forEach(function (controls) {
                return controls[methodName]();
              });
            }
          }, {
            key: "flatten",
            value: function flatten() {
              this.runAll("flatten");
            }
          }, {
            key: "play",
            value: function play() {
              this.runAll("play");
            }
          }, {
            key: "pause",
            value: function pause() {
              this.runAll("pause");
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this.runAll("cancel");
            }
          }, {
            key: "complete",
            value: function complete() {
              this.runAll("complete");
            }
          }]);
        }();
        /**
         * TODO: This is a temporary class to support the legacy
         * thennable API
         */
        var GroupPlaybackControls = /*#__PURE__*/function (_BaseGroupPlaybackCon) {
          function GroupPlaybackControls() {
            _classCallCheck(this, GroupPlaybackControls);
            return _callSuper(this, GroupPlaybackControls, arguments);
          }
          _inherits(GroupPlaybackControls, _BaseGroupPlaybackCon);
          return _createClass(GroupPlaybackControls, [{
            key: "then",
            value: function then(onResolve, onReject) {
              return Promise.all(this.animations).then(onResolve).catch(onReject);
            }
          }]);
        }(BaseGroupPlaybackControls);
        function getValueTransition(transition, key) {
          return transition ? transition[key] || transition["default"] || transition : undefined;
        }

        /**
         * Implement a practical max duration for keyframe generation
         * to prevent infinite loops
         */
        var maxGeneratorDuration = 20000;
        function calcGeneratorDuration(generator) {
          var duration = 0;
          var timeStep = 50;
          var state = generator.next(duration);
          while (!state.done && duration < maxGeneratorDuration) {
            duration += timeStep;
            state = generator.next(duration);
          }
          return duration >= maxGeneratorDuration ? Infinity : duration;
        }
        function isGenerator(type) {
          return typeof type === "function";
        }
        function _attachTimeline(animation, timeline) {
          animation.timeline = timeline;
          animation.onfinish = null;
        }
        var isBezierDefinition = function isBezierDefinition(easing) {
          return Array.isArray(easing) && typeof easing[0] === "number";
        };

        /**
         * Add the ability for test suites to manually set support flags
         * to better test more environments.
         */
        var supportsFlags = {
          linearEasing: undefined
        };
        function memoSupports(callback, supportsFlag) {
          var memoized = memo(callback);
          return function () {
            var _a;
            return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized();
          };
        }
        var supportsLinearEasing = /*@__PURE__*/memoSupports(function () {
          try {
            document.createElement("div").animate({
              opacity: 0
            }, {
              easing: "linear(0, 1)"
            });
          } catch (e) {
            return false;
          }
          return true;
        }, "linearEasing");
        var generateLinearEasing = function generateLinearEasing(easing, duration) {
          var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
          var points = "";
          var numPoints = Math.max(Math.round(duration / resolution), 2);
          for (var i = 0; i < numPoints; i++) {
            points += easing(progress(0, numPoints - 1, i)) + ", ";
          }
          return "linear(".concat(points.substring(0, points.length - 2), ")");
        };
        function isWaapiSupportedEasing(easing) {
          return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
        }
        var cubicBezierAsString = function cubicBezierAsString(_ref74) {
          var _ref75 = _slicedToArray(_ref74, 4),
            a = _ref75[0],
            b = _ref75[1],
            c = _ref75[2],
            d = _ref75[3];
          return "cubic-bezier(".concat(a, ", ").concat(b, ", ").concat(c, ", ").concat(d, ")");
        };
        var supportedWaapiEasing = {
          linear: "linear",
          ease: "ease",
          easeIn: "ease-in",
          easeOut: "ease-out",
          easeInOut: "ease-in-out",
          circIn: /*@__PURE__*/cubicBezierAsString([0, 0.65, 0.55, 1]),
          circOut: /*@__PURE__*/cubicBezierAsString([0.55, 0, 1, 0.45]),
          backIn: /*@__PURE__*/cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
          backOut: /*@__PURE__*/cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
        };
        function mapEasingToNativeEasing(easing, duration) {
          if (!easing) {
            return undefined;
          } else if (typeof easing === "function" && supportsLinearEasing()) {
            return generateLinearEasing(easing, duration);
          } else if (isBezierDefinition(easing)) {
            return cubicBezierAsString(easing);
          } else if (Array.isArray(easing)) {
            return easing.map(function (segmentEasing) {
              return mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut;
            });
          } else {
            return supportedWaapiEasing[easing];
          }
        }
        var isDragging = {
          x: false,
          y: false
        };
        function isDragActive() {
          return isDragging.x || isDragging.y;
        }
        function resolveElements(elementOrSelector, scope, selectorCache) {
          var _a;
          if (elementOrSelector instanceof Element) {
            return [elementOrSelector];
          } else if (typeof elementOrSelector === "string") {
            var root = document;
            var elements = (_a = void 0) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);
            return elements ? Array.from(elements) : [];
          }
          return Array.from(elementOrSelector);
        }
        function setupGesture(elementOrSelector, options) {
          var elements = resolveElements(elementOrSelector);
          var gestureAbortController = new AbortController();
          var eventOptions = _objectSpread3(_objectSpread3({
            passive: true
          }, options), {}, {
            signal: gestureAbortController.signal
          });
          var cancel = function cancel() {
            return gestureAbortController.abort();
          };
          return [elements, eventOptions, cancel];
        }

        /**
         * Filter out events that are not pointer events, or are triggering
         * while a Motion gesture is active.
         */
        function filterEvents$1(callback) {
          return function (event) {
            if (event.pointerType === "touch" || isDragActive()) return;
            callback(event);
          };
        }
        /**
         * Create a hover gesture. hover() is different to .addEventListener("pointerenter")
         * in that it has an easier syntax, filters out polyfilled touch events, interoperates
         * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.
         *
         * @public
         */
        function hover(elementOrSelector, onHoverStart) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _setupGesture = setupGesture(elementOrSelector, options),
            _setupGesture2 = _slicedToArray(_setupGesture, 3),
            elements = _setupGesture2[0],
            eventOptions = _setupGesture2[1],
            cancel = _setupGesture2[2];
          var onPointerEnter = filterEvents$1(function (enterEvent) {
            var target = enterEvent.target;
            var onHoverEnd = onHoverStart(enterEvent);
            if (typeof onHoverEnd !== "function" || !target) return;
            var onPointerLeave = filterEvents$1(function (leaveEvent) {
              onHoverEnd(leaveEvent);
              target.removeEventListener("pointerleave", onPointerLeave);
            });
            target.addEventListener("pointerleave", onPointerLeave, eventOptions);
          });
          elements.forEach(function (element) {
            element.addEventListener("pointerenter", onPointerEnter, eventOptions);
          });
          return cancel;
        }

        /**
         * Recursively traverse up the tree to check whether the provided child node
         * is the parent or a descendant of it.
         *
         * @param parent - Element to find
         * @param child - Element to test against parent
         */
        var _isNodeOrChild = function isNodeOrChild(parent, child) {
          if (!child) {
            return false;
          } else if (parent === child) {
            return true;
          } else {
            return _isNodeOrChild(parent, child.parentElement);
          }
        };
        var isPrimaryPointer = function isPrimaryPointer(event) {
          if (event.pointerType === "mouse") {
            return typeof event.button !== "number" || event.button <= 0;
          } else {
            /**
             * isPrimary is true for all mice buttons, whereas every touch point
             * is regarded as its own input. So subsequent concurrent touch points
             * will be false.
             *
             * Specifically match against false here as incomplete versions of
             * PointerEvents in very old browser might have it set as undefined.
             */
            return event.isPrimary !== false;
          }
        };
        var focusableElements = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
        function isElementKeyboardAccessible(element) {
          return focusableElements.has(element.tagName) || element.tabIndex !== -1;
        }
        var isPressing = new WeakSet();

        /**
         * Filter out events that are not "Enter" keys.
         */
        function filterEvents(callback) {
          return function (event) {
            if (event.key !== "Enter") return;
            callback(event);
          };
        }
        function firePointerEvent(target, type) {
          target.dispatchEvent(new PointerEvent("pointer" + type, {
            isPrimary: true,
            bubbles: true
          }));
        }
        var enableKeyboardPress = function enableKeyboardPress(focusEvent, eventOptions) {
          var element = focusEvent.currentTarget;
          if (!element) return;
          var handleKeydown = filterEvents(function () {
            if (isPressing.has(element)) return;
            firePointerEvent(element, "down");
            var handleKeyup = filterEvents(function () {
              firePointerEvent(element, "up");
            });
            var handleBlur = function handleBlur() {
              return firePointerEvent(element, "cancel");
            };
            element.addEventListener("keyup", handleKeyup, eventOptions);
            element.addEventListener("blur", handleBlur, eventOptions);
          });
          element.addEventListener("keydown", handleKeydown, eventOptions);
          /**
           * Add an event listener that fires on blur to remove the keydown events.
           */
          element.addEventListener("blur", function () {
            return element.removeEventListener("keydown", handleKeydown);
          }, eventOptions);
        };

        /**
         * Filter out events that are not primary pointer events, or are triggering
         * while a Motion gesture is active.
         */
        function isValidPressEvent(event) {
          return isPrimaryPointer(event) && !isDragActive();
        }
        /**
         * Create a press gesture.
         *
         * Press is different to `"pointerdown"`, `"pointerup"` in that it
         * automatically filters out secondary pointer events like right
         * click and multitouch.
         *
         * It also adds accessibility support for keyboards, where
         * an element with a press gesture will receive focus and
         *  trigger on Enter `"keydown"` and `"keyup"` events.
         *
         * This is different to a browser's `"click"` event, which does
         * respond to keyboards but only for the `"click"` itself, rather
         * than the press start and end/cancel. The element also needs
         * to be focusable for this to work, whereas a press gesture will
         * make an element focusable by default.
         *
         * @public
         */
        function press(elementOrSelector, onPressStart) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _setupGesture3 = setupGesture(elementOrSelector, options),
            _setupGesture4 = _slicedToArray(_setupGesture3, 3),
            elements = _setupGesture4[0],
            eventOptions = _setupGesture4[1],
            cancelEvents = _setupGesture4[2];
          var startPress = function startPress(startEvent) {
            var element = startEvent.currentTarget;
            if (!isValidPressEvent(startEvent) || isPressing.has(element)) return;
            isPressing.add(element);
            var onPressEnd = onPressStart(startEvent);
            var onPointerEnd = function onPointerEnd(endEvent, success) {
              window.removeEventListener("pointerup", onPointerUp);
              window.removeEventListener("pointercancel", onPointerCancel);
              if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
                return;
              }
              isPressing.delete(element);
              if (typeof onPressEnd === "function") {
                onPressEnd(endEvent, {
                  success: success
                });
              }
            };
            var onPointerUp = function onPointerUp(upEvent) {
              onPointerEnd(upEvent, options.useGlobalTarget || _isNodeOrChild(element, upEvent.target));
            };
            var onPointerCancel = function onPointerCancel(cancelEvent) {
              onPointerEnd(cancelEvent, false);
            };
            window.addEventListener("pointerup", onPointerUp, eventOptions);
            window.addEventListener("pointercancel", onPointerCancel, eventOptions);
          };
          elements.forEach(function (element) {
            if (!isElementKeyboardAccessible(element) && element.getAttribute("tabindex") === null) {
              element.tabIndex = 0;
            }
            var target = options.useGlobalTarget ? window : element;
            target.addEventListener("pointerdown", startPress, eventOptions);
            element.addEventListener("focus", function (event) {
              return enableKeyboardPress(event, eventOptions);
            }, eventOptions);
          });
          return cancelEvents;
        }
        function setDragLock(axis) {
          if (axis === "x" || axis === "y") {
            if (isDragging[axis]) {
              return null;
            } else {
              isDragging[axis] = true;
              return function () {
                isDragging[axis] = false;
              };
            }
          } else {
            if (isDragging.x || isDragging.y) {
              return null;
            } else {
              isDragging.x = isDragging.y = true;
              return function () {
                isDragging.x = isDragging.y = false;
              };
            }
          }
        }
        var positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom"].concat(transformPropOrder));
        var _now;
        function clearTime() {
          _now = undefined;
        }
        /**
         * An eventloop-synchronous alternative to performance.now().
         *
         * Ensures that time measurements remain consistent within a synchronous context.
         * Usually calling performance.now() twice within the same synchronous context
         * will return different values which isn't useful for animations when we're usually
         * trying to sync animations to the same frame.
         */
        var time = {
          now: function now() {
            if (_now === undefined) {
              time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
            }
            return _now;
          },
          set: function set(newTime) {
            _now = newTime;
            queueMicrotask(clearTime);
          }
        };
        function addUniqueItem(arr, item) {
          if (arr.indexOf(item) === -1) arr.push(item);
        }
        function removeItem(arr, item) {
          var index = arr.indexOf(item);
          if (index > -1) arr.splice(index, 1);
        }
        var SubscriptionManager = /*#__PURE__*/function () {
          function SubscriptionManager() {
            _classCallCheck(this, SubscriptionManager);
            this.subscriptions = [];
          }
          return _createClass(SubscriptionManager, [{
            key: "add",
            value: function add(handler) {
              var _this16 = this;
              addUniqueItem(this.subscriptions, handler);
              return function () {
                return removeItem(_this16.subscriptions, handler);
              };
            }
          }, {
            key: "notify",
            value: function notify(a, b, c) {
              var numSubscriptions = this.subscriptions.length;
              if (!numSubscriptions) return;
              if (numSubscriptions === 1) {
                /**
                 * If there's only a single handler we can just call it without invoking a loop.
                 */
                this.subscriptions[0](a, b, c);
              } else {
                for (var i = 0; i < numSubscriptions; i++) {
                  /**
                   * Check whether the handler exists before firing as it's possible
                   * the subscriptions were modified during this loop running.
                   */
                  var handler = this.subscriptions[i];
                  handler && handler(a, b, c);
                }
              }
            }
          }, {
            key: "getSize",
            value: function getSize() {
              return this.subscriptions.length;
            }
          }, {
            key: "clear",
            value: function clear() {
              this.subscriptions.length = 0;
            }
          }]);
        }();
        /*
          Convert velocity into velocity per second
           @param [number]: Unit per frame
          @param [number]: Frame duration in ms
        */
        function velocityPerSecond(velocity, frameDuration) {
          return frameDuration ? velocity * (1000 / frameDuration) : 0;
        }
        var MAX_VELOCITY_DELTA = 30;
        var isFloat = function isFloat(value) {
          return !isNaN(parseFloat(value));
        };
        var MotionValue = /*#__PURE__*/function () {
          /**
           * @param init - The initiating value
           * @param config - Optional configuration options
           *
           * -  `transformer`: A function to transform incoming values with.
           *
           * @internal
           */
          function MotionValue(init) {
            var _this17 = this;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, MotionValue);
            this.version = "11.18.2";
            this.canTrackVelocity = null;
            this.events = {};
            this.updateAndNotify = function (v) {
              var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var currentTime = time.now();
              if (_this17.updatedAt !== currentTime) {
                _this17.setPrevFrameValue();
              }
              _this17.prev = _this17.current;
              _this17.setCurrent(v);
              if (_this17.current !== _this17.prev && _this17.events.change) {
                _this17.events.change.notify(_this17.current);
              }
              if (render && _this17.events.renderRequest) {
                _this17.events.renderRequest.notify(_this17.current);
              }
            };
            this.hasAnimated = false;
            this.setCurrent(init);
            this.owner = options.owner;
          }
          return _createClass(MotionValue, [{
            key: "setCurrent",
            value: function setCurrent(current) {
              this.current = current;
              this.updatedAt = time.now();
              if (this.canTrackVelocity === null && current !== void 0) {
                this.canTrackVelocity = isFloat(this.current);
              }
            }
          }, {
            key: "setPrevFrameValue",
            value: function setPrevFrameValue() {
              var prevFrameValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.current;
              this.prevFrameValue = prevFrameValue;
              this.prevUpdatedAt = this.updatedAt;
            }
            /**
             * Adds a function that will be notified when the `MotionValue` is updated.
             *
             * It returns a function that, when called, will cancel the subscription.
             *
             * When calling `onChange` inside a React component, it should be wrapped with the
             * `useEffect` hook. As it returns an unsubscribe function, this should be returned
             * from the `useEffect` function to ensure you don't add duplicate subscribers..
             *
             * ```jsx
             * export const MyComponent = () => {
             *   const x = useMotionValue(0)
             *   const y = useMotionValue(0)
             *   const opacity = useMotionValue(1)
             *
             *   useEffect(() => {
             *     function updateOpacity() {
             *       const maxXY = Math.max(x.get(), y.get())
             *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
             *       opacity.set(newOpacity)
             *     }
             *
             *     const unsubscribeX = x.on("change", updateOpacity)
             *     const unsubscribeY = y.on("change", updateOpacity)
             *
             *     return () => {
             *       unsubscribeX()
             *       unsubscribeY()
             *     }
             *   }, [])
             *
             *   return <motion.div style={{ x }} />
             * }
             * ```
             *
             * @param subscriber - A function that receives the latest value.
             * @returns A function that, when called, will cancel this subscription.
             *
             * @deprecated
             */
          }, {
            key: "onChange",
            value: function onChange(subscription) {
              return this.on("change", subscription);
            }
          }, {
            key: "on",
            value: function on(eventName, callback) {
              var _this18 = this;
              if (!this.events[eventName]) {
                this.events[eventName] = new SubscriptionManager();
              }
              var unsubscribe = this.events[eventName].add(callback);
              if (eventName === "change") {
                return function () {
                  unsubscribe();
                  frame.read(function () {
                    if (!_this18.events.change.getSize()) {
                      _this18.stop();
                    }
                  });
                };
              }
              return unsubscribe;
            }
          }, {
            key: "clearListeners",
            value: function clearListeners() {
              for (var eventManagers in this.events) {
                this.events[eventManagers].clear();
              }
            }
            /**
             * Attaches a passive effect to the `MotionValue`.
             *
             * @internal
             */
          }, {
            key: "attach",
            value: function attach(passiveEffect, stopPassiveEffect) {
              this.passiveEffect = passiveEffect;
              this.stopPassiveEffect = stopPassiveEffect;
            }
            /**
             * Sets the state of the `MotionValue`.
             *
             * @remarks
             *
             * ```jsx
             * const x = useMotionValue(0)
             * x.set(10)
             * ```
             *
             * @param latest - Latest value to set.
             * @param render - Whether to notify render subscribers. Defaults to `true`
             *
             * @public
             */
          }, {
            key: "set",
            value: function set(v) {
              var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              if (!render || !this.passiveEffect) {
                this.updateAndNotify(v, render);
              } else {
                this.passiveEffect(v, this.updateAndNotify);
              }
            }
          }, {
            key: "setWithVelocity",
            value: function setWithVelocity(prev, current, delta) {
              this.set(current);
              this.prev = void 0;
              this.prevFrameValue = prev;
              this.prevUpdatedAt = this.updatedAt - delta;
            }
            /**
             * Set the state of the `MotionValue`, stopping any active animations,
             * effects, and resets velocity to `0`.
             */
          }, {
            key: "jump",
            value: function jump(v) {
              var endAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              this.updateAndNotify(v);
              this.prev = v;
              this.prevUpdatedAt = this.prevFrameValue = void 0;
              endAnimation && this.stop();
              if (this.stopPassiveEffect) this.stopPassiveEffect();
            }
            /**
             * Returns the latest state of `MotionValue`
             *
             * @returns - The latest state of `MotionValue`
             *
             * @public
             */
          }, {
            key: "get",
            value: function get() {
              return this.current;
            }
            /**
             * @public
             */
          }, {
            key: "getPrevious",
            value: function getPrevious() {
              return this.prev;
            }
            /**
             * Returns the latest velocity of `MotionValue`
             *
             * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
             *
             * @public
             */
          }, {
            key: "getVelocity",
            value: function getVelocity() {
              var currentTime = time.now();
              if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
                return 0;
              }
              var delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
              return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
            }
            /**
             * Registers a new animation to control this `MotionValue`. Only one
             * animation can drive a `MotionValue` at one time.
             *
             * ```jsx
             * value.start()
             * ```
             *
             * @param animation - A function that starts the provided animation
             *
             * @internal
             */
          }, {
            key: "start",
            value: function start(startAnimation) {
              var _this19 = this;
              this.stop();
              return new Promise(function (resolve) {
                _this19.hasAnimated = true;
                _this19.animation = startAnimation(resolve);
                if (_this19.events.animationStart) {
                  _this19.events.animationStart.notify();
                }
              }).then(function () {
                if (_this19.events.animationComplete) {
                  _this19.events.animationComplete.notify();
                }
                _this19.clearAnimation();
              });
            }
            /**
             * Stop the currently active animation.
             *
             * @public
             */
          }, {
            key: "stop",
            value: function stop() {
              if (this.animation) {
                this.animation.stop();
                if (this.events.animationCancel) {
                  this.events.animationCancel.notify();
                }
              }
              this.clearAnimation();
            }
            /**
             * Returns `true` if this value is currently animating.
             *
             * @public
             */
          }, {
            key: "isAnimating",
            value: function isAnimating() {
              return !!this.animation;
            }
          }, {
            key: "clearAnimation",
            value: function clearAnimation() {
              delete this.animation;
            }
            /**
             * Destroy and clean up subscribers to this `MotionValue`.
             *
             * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
             * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
             * created a `MotionValue` via the `motionValue` function.
             *
             * @public
             */
          }, {
            key: "destroy",
            value: function destroy() {
              this.clearListeners();
              this.stop();
              if (this.stopPassiveEffect) {
                this.stopPassiveEffect();
              }
            }
          }]);
        }();
        function motionValue(init, options) {
          return new MotionValue(init, options);
        }

        /**
         * Set VisualElement's MotionValue, creating a new MotionValue for it if
         * it doesn't exist.
         */
        function setMotionValue(visualElement, key, value) {
          if (visualElement.hasValue(key)) {
            visualElement.getValue(key).set(value);
          } else {
            visualElement.addValue(key, motionValue(value));
          }
        }
        function setTarget(visualElement, definition) {
          var resolved = resolveVariant(visualElement, definition);
          var _ref76 = resolved || {},
            _ref76$transitionEnd = _ref76.transitionEnd,
            transitionEnd = _ref76$transitionEnd === void 0 ? {} : _ref76$transitionEnd,
            _ref76$transition = _ref76.transition,
            transition = _ref76$transition === void 0 ? {} : _ref76$transition,
            target = _objectWithoutProperties2(_ref76, _excluded0);
          target = _objectSpread3(_objectSpread3({}, target), transitionEnd);
          for (var _key48 in target) {
            var value = resolveFinalValueInKeyframes(target[_key48]);
            setMotionValue(visualElement, _key48, value);
          }
        }
        function isWillChangeMotionValue(value) {
          return Boolean(isMotionValue(value) && value.add);
        }
        function addValueToWillChange(visualElement, key) {
          var willChange = visualElement.getValue("willChange");
          /**
           * It could be that a user has set willChange to a regular MotionValue,
           * in which case we can't add the value to it.
           */
          if (isWillChangeMotionValue(willChange)) {
            return willChange.add(key);
          }
        }
        function getOptimisedAppearId(visualElement) {
          return visualElement.props[optimizedAppearDataAttribute];
        }

        /*
          Bezier function generator
          This has been modified from Gatan Renaudeau's BezierEasing
          https://github.com/gre/bezier-easing/blob/master/src/index.js
          https://github.com/gre/bezier-easing/blob/master/LICENSE
          
          I've removed the newtonRaphsonIterate algo because in benchmarking it
          wasn't noticiably faster than binarySubdivision, indeed removing it
          usually improved times, depending on the curve.
          I also removed the lookup table, as for the added bundle size and loop we're
          only cutting ~4 or so subdivision iterations. I bumped the max iterations up
          to 12 to compensate and this still tended to be faster for no perceivable
          loss in accuracy.
          Usage
            const easeOut = cubicBezier(.17,.67,.83,.67);
            const x = easeOut(0.5); // returns 0.627...
        */
        // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
        var calcBezier = function calcBezier(t, a1, a2) {
          return (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
        };
        var subdivisionPrecision = 0.0000001;
        var subdivisionMaxIterations = 12;
        function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
          var currentX;
          var currentT;
          var i = 0;
          do {
            currentT = lowerBound + (upperBound - lowerBound) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - x;
            if (currentX > 0.0) {
              upperBound = currentT;
            } else {
              lowerBound = currentT;
            }
          } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
          return currentT;
        }
        function cubicBezier(mX1, mY1, mX2, mY2) {
          // If this is a linear gradient, return linear easing
          if (mX1 === mY1 && mX2 === mY2) return noop$2;
          var getTForX = function getTForX(aX) {
            return binarySubdivide(aX, 0, 1, mX1, mX2);
          };
          // If animation is at start/end, return t without easing
          return function (t) {
            return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
          };
        }

        // Accepts an easing function and returns a new one that outputs mirrored values for
        // the second half of the animation. Turns easeIn into easeInOut.
        var mirrorEasing = function mirrorEasing(easing) {
          return function (p) {
            return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
          };
        };

        // Accepts an easing function and returns a new one that outputs reversed values.
        // Turns easeIn into easeOut.
        var reverseEasing = function reverseEasing(easing) {
          return function (p) {
            return 1 - easing(1 - p);
          };
        };
        var backOut = /*@__PURE__*/cubicBezier(0.33, 1.53, 0.69, 0.99);
        var backIn = /*@__PURE__*/reverseEasing(backOut);
        var backInOut = /*@__PURE__*/mirrorEasing(backIn);
        var anticipate = function anticipate(p) {
          return (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
        };
        var circIn = function circIn(p) {
          return 1 - Math.sin(Math.acos(p));
        };
        var circOut = reverseEasing(circIn);
        var circInOut = mirrorEasing(circIn);

        /**
         * Check if the value is a zero value string like "0px" or "0%"
         */
        var isZeroValueString = function isZeroValueString(v) {
          return /^0(?:[\0-\x08\x0E-\x1F!-\x2D\/-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+$/.test(v);
        };
        function isNone(value) {
          if (typeof value === "number") {
            return value === 0;
          } else if (value !== null) {
            return value === "none" || value === "0" || isZeroValueString(value);
          } else {
            return true;
          }
        }

        // If this number is a decimal, make it just five decimal places
        // to avoid exponents
        var sanitize = function sanitize(v) {
          return Math.round(v * 100000) / 100000;
        };
        var floatRegex = /-?(?:[0-9]+(?:\.[0-9]+)?|\.[0-9]+)/g;
        function isNullish(v) {
          return v == null;
        }
        var singleColorRegex = /^(?:#[0-9a-f]{3,8}|(?:rgb|h[s\u017F]l)a?\((?:-?[\.0-9]+%?[\t-\r ,\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+){2}-?[\.0-9]+%?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:[,\/][\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)?(?:\b[0-9]+(?:\.[0-9]+)?|\.[0-9]+)?%?\))$/i;

        /**
         * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,
         * but false if a number or multiple colors
         */
        var isColorString = function isColorString(type, testProp) {
          return function (v) {
            return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
          };
        };
        var splitColor = function splitColor(aName, bName, cName) {
          return function (v) {
            if (typeof v !== "string") return v;
            var _v$match = v.match(floatRegex),
              _v$match2 = _slicedToArray(_v$match, 4),
              a = _v$match2[0],
              b = _v$match2[1],
              c = _v$match2[2],
              alpha = _v$match2[3];
            return _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, aName, parseFloat(a)), bName, parseFloat(b)), cName, parseFloat(c)), "alpha", alpha !== undefined ? parseFloat(alpha) : 1);
          };
        };
        var clampRgbUnit = function clampRgbUnit(v) {
          return clamp(0, 255, v);
        };
        var rgbUnit = _objectSpread3(_objectSpread3({}, number), {}, {
          transform: function transform(v) {
            return Math.round(clampRgbUnit(v));
          }
        });
        var rgba = {
          test: /*@__PURE__*/isColorString("rgb", "red"),
          parse: /*@__PURE__*/splitColor("red", "green", "blue"),
          transform: function transform(_ref78) {
            var red = _ref78.red,
              green = _ref78.green,
              blue = _ref78.blue,
              _ref78$alpha = _ref78.alpha,
              alpha$1 = _ref78$alpha === void 0 ? 1 : _ref78$alpha;
            return "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
          }
        };
        function parseHex(v) {
          var r = "";
          var g = "";
          var b = "";
          var a = "";
          // If we have 6 characters, ie #FF0000
          if (v.length > 5) {
            r = v.substring(1, 3);
            g = v.substring(3, 5);
            b = v.substring(5, 7);
            a = v.substring(7, 9);
            // Or we have 3 characters, ie #F00
          } else {
            r = v.substring(1, 2);
            g = v.substring(2, 3);
            b = v.substring(3, 4);
            a = v.substring(4, 5);
            r += r;
            g += g;
            b += b;
            a += a;
          }
          return {
            red: parseInt(r, 16),
            green: parseInt(g, 16),
            blue: parseInt(b, 16),
            alpha: a ? parseInt(a, 16) / 255 : 1
          };
        }
        var hex = {
          test: /*@__PURE__*/isColorString("#"),
          parse: parseHex,
          transform: rgba.transform
        };
        var hsla = {
          test: /*@__PURE__*/isColorString("hsl", "hue"),
          parse: /*@__PURE__*/splitColor("hue", "saturation", "lightness"),
          transform: function transform(_ref79) {
            var hue = _ref79.hue,
              saturation = _ref79.saturation,
              lightness = _ref79.lightness,
              _ref79$alpha = _ref79.alpha,
              alpha$1 = _ref79$alpha === void 0 ? 1 : _ref79$alpha;
            return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
          }
        };
        var color = {
          test: function test(v) {
            return rgba.test(v) || hex.test(v) || hsla.test(v);
          },
          parse: function parse(v) {
            if (rgba.test(v)) {
              return rgba.parse(v);
            } else if (hsla.test(v)) {
              return hsla.parse(v);
            } else {
              return hex.parse(v);
            }
          },
          transform: function transform(v) {
            return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
          }
        };
        var colorRegex = /(?:#[0-9a-f]{3,8}|(?:rgb|h[s\u017F]l)a?\((?:-?[\.0-9]+%?[\t-\r ,\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+){2}-?[\.0-9]+%?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:[,\/][\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)?(?:\b[0-9]+(?:\.[0-9]+)?|\.[0-9]+)?%?\))/gi;
        function test(v) {
          var _a, _b;
          return isNaN(v) && typeof v === "string" && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
        }
        var NUMBER_TOKEN = "number";
        var COLOR_TOKEN = "color";
        var VAR_TOKEN = "var";
        var VAR_FUNCTION_TOKEN = "var(";
        var SPLIT_TOKEN = "${}";
        // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
        var complexRegex = /var[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*--(?:[\x2D0-9A-Z_a-z\u017F\u212A]+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*|[\x2D0-9A-Z_a-z\u017F\u212A]+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*,(?:[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:(?![\t-\r \(\)\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uD800-\uDFFF\uFEFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])|[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\((?:(?:(?![\(\)\uD800-\uDFFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])|\((?:(?![\(\)\uD800-\uDFFF])[^]|[\uD800-\uDBFF][\uDC00-\uDFFF])*\))*\))+[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)\)|#[0-9a-f]{3,8}|(?:rgb|h[s\u017F]l)a?\((?:-?[\.0-9]+%?[\t-\r ,\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+){2}-?[\.0-9]+%?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:[,\/][\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)?(?:\b[0-9]+(?:\.[0-9]+)?|\.[0-9]+)?%?\)|-?(?:[0-9]+(?:\.[0-9]+)?|\.[0-9]+)/gi;
        function analyseComplexValue(value) {
          var originalValue = value.toString();
          var values = [];
          var indexes = {
            color: [],
            number: [],
            var: []
          };
          var types = [];
          var i = 0;
          var tokenised = originalValue.replace(complexRegex, function (parsedValue) {
            if (color.test(parsedValue)) {
              indexes.color.push(i);
              types.push(COLOR_TOKEN);
              values.push(color.parse(parsedValue));
            } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
              indexes.var.push(i);
              types.push(VAR_TOKEN);
              values.push(parsedValue);
            } else {
              indexes.number.push(i);
              types.push(NUMBER_TOKEN);
              values.push(parseFloat(parsedValue));
            }
            ++i;
            return SPLIT_TOKEN;
          });
          var split = tokenised.split(SPLIT_TOKEN);
          return {
            values: values,
            split: split,
            indexes: indexes,
            types: types
          };
        }
        function parseComplexValue(v) {
          return analyseComplexValue(v).values;
        }
        function createTransformer(source) {
          var _analyseComplexValue = analyseComplexValue(source),
            split = _analyseComplexValue.split,
            types = _analyseComplexValue.types;
          var numSections = split.length;
          return function (v) {
            var output = "";
            for (var i = 0; i < numSections; i++) {
              output += split[i];
              if (v[i] !== undefined) {
                var type = types[i];
                if (type === NUMBER_TOKEN) {
                  output += sanitize(v[i]);
                } else if (type === COLOR_TOKEN) {
                  output += color.transform(v[i]);
                } else {
                  output += v[i];
                }
              }
            }
            return output;
          };
        }
        var convertNumbersToZero = function convertNumbersToZero(v) {
          return typeof v === "number" ? 0 : v;
        };
        function getAnimatableNone$1(v) {
          var parsed = parseComplexValue(v);
          var transformer = createTransformer(v);
          return transformer(parsed.map(convertNumbersToZero));
        }
        var complex = {
          test: test,
          parse: parseComplexValue,
          createTransformer: createTransformer,
          getAnimatableNone: getAnimatableNone$1
        };

        /**
         * Properties that should default to 1 or 100%
         */
        var maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
        function applyDefaultFilter(v) {
          var _v$slice$split = v.slice(0, -1).split("("),
            _v$slice$split2 = _slicedToArray(_v$slice$split, 2),
            name = _v$slice$split2[0],
            value = _v$slice$split2[1];
          if (name === "drop-shadow") return v;
          var _ref80 = value.match(floatRegex) || [],
            _ref81 = _slicedToArray(_ref80, 1),
            number = _ref81[0];
          if (!number) return v;
          var unit = value.replace(number, "");
          var defaultValue = maxDefaults.has(name) ? 1 : 0;
          if (number !== value) defaultValue *= 100;
          return name + "(" + defaultValue + unit + ")";
        }
        var functionRegex = /\b([\x2Da-z]*)\((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\)/g;
        var filter = _objectSpread3(_objectSpread3({}, complex), {}, {
          getAnimatableNone: function getAnimatableNone(v) {
            var functions = v.match(functionRegex);
            return functions ? functions.map(applyDefaultFilter).join(" ") : v;
          }
        });

        /**
         * A map of default value types for common values
         */
        var defaultValueTypes = _objectSpread3(_objectSpread3({}, numberValueTypes), {}, {
          // Color props
          color: color,
          backgroundColor: color,
          outlineColor: color,
          fill: color,
          stroke: color,
          // Border props
          borderColor: color,
          borderTopColor: color,
          borderRightColor: color,
          borderBottomColor: color,
          borderLeftColor: color,
          filter: filter,
          WebkitFilter: filter
        });
        /**
         * Gets the default ValueType for the provided value key
         */
        var getDefaultValueType = function getDefaultValueType(key) {
          return defaultValueTypes[key];
        };
        function getAnimatableNone(key, value) {
          var defaultValueType = getDefaultValueType(key);
          if (defaultValueType !== filter) defaultValueType = complex;
          // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
          return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : undefined;
        }

        /**
         * If we encounter keyframes like "none" or "0" and we also have keyframes like
         * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for
         * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into
         * zero equivalents, i.e. "#fff0" or "0px 0px".
         */
        var invalidTemplates = new Set(["auto", "none", "0"]);
        function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
          var i = 0;
          var animatableTemplate = undefined;
          while (i < unresolvedKeyframes.length && !animatableTemplate) {
            var keyframe = unresolvedKeyframes[i];
            if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
              animatableTemplate = unresolvedKeyframes[i];
            }
            i++;
          }
          if (animatableTemplate && name) {
            var _iterator10 = _createForOfIteratorHelper(noneKeyframeIndexes),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var noneIndex = _step10.value;
                unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          }
        }
        var isNumOrPxType = function isNumOrPxType(v) {
          return v === number || v === px;
        };
        var getPosFromMatrix = function getPosFromMatrix(matrix, pos) {
          return parseFloat(matrix.split(", ")[pos]);
        };
        var getTranslateFromMatrix = function getTranslateFromMatrix(pos2, pos3) {
          return function (_bbox, _ref82) {
            var transform = _ref82.transform;
            if (transform === "none" || !transform) return 0;
            var matrix3d = transform.match(/^matrix3d\(((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)\)$/);
            if (matrix3d) {
              return getPosFromMatrix(matrix3d[1], pos3);
            } else {
              var matrix = transform.match(/^matrix\(((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)\)$/);
              if (matrix) {
                return getPosFromMatrix(matrix[1], pos2);
              } else {
                return 0;
              }
            }
          };
        };
        var transformKeys = new Set(["x", "y", "z"]);
        var nonTranslationalTransformKeys = transformPropOrder.filter(function (key) {
          return !transformKeys.has(key);
        });
        function removeNonTranslationalTransform(visualElement) {
          var removedTransforms = [];
          nonTranslationalTransformKeys.forEach(function (key) {
            var value = visualElement.getValue(key);
            if (value !== undefined) {
              removedTransforms.push([key, value.get()]);
              value.set(key.startsWith("scale") ? 1 : 0);
            }
          });
          return removedTransforms;
        }
        var positionalValues = {
          // Dimensions
          width: function width(_ref83, _ref84) {
            var x = _ref83.x;
            var _ref84$paddingLeft = _ref84.paddingLeft,
              paddingLeft = _ref84$paddingLeft === void 0 ? "0" : _ref84$paddingLeft,
              _ref84$paddingRight = _ref84.paddingRight,
              paddingRight = _ref84$paddingRight === void 0 ? "0" : _ref84$paddingRight;
            return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
          },
          height: function height(_ref85, _ref86) {
            var y = _ref85.y;
            var _ref86$paddingTop = _ref86.paddingTop,
              paddingTop = _ref86$paddingTop === void 0 ? "0" : _ref86$paddingTop,
              _ref86$paddingBottom = _ref86.paddingBottom,
              paddingBottom = _ref86$paddingBottom === void 0 ? "0" : _ref86$paddingBottom;
            return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
          },
          top: function top(_bbox, _ref87) {
            var _top = _ref87.top;
            return parseFloat(_top);
          },
          left: function left(_bbox, _ref88) {
            var _left = _ref88.left;
            return parseFloat(_left);
          },
          bottom: function bottom(_ref89, _ref90) {
            var y = _ref89.y;
            var top = _ref90.top;
            return parseFloat(top) + (y.max - y.min);
          },
          right: function right(_ref91, _ref92) {
            var x = _ref91.x;
            var left = _ref92.left;
            return parseFloat(left) + (x.max - x.min);
          },
          // Transform
          x: getTranslateFromMatrix(4, 13),
          y: getTranslateFromMatrix(5, 14)
        };
        // Alias translate longform names
        positionalValues.translateX = positionalValues.x;
        positionalValues.translateY = positionalValues.y;
        var toResolve = new Set();
        var isScheduled = false;
        var anyNeedsMeasurement = false;
        function measureAllKeyframes() {
          if (anyNeedsMeasurement) {
            var resolversToMeasure = Array.from(toResolve).filter(function (resolver) {
              return resolver.needsMeasurement;
            });
            var elementsToMeasure = new Set(resolversToMeasure.map(function (resolver) {
              return resolver.element;
            }));
            var transformsToRestore = new Map();
            /**
             * Write pass
             * If we're measuring elements we want to remove bounding box-changing transforms.
             */
            elementsToMeasure.forEach(function (element) {
              var removedTransforms = removeNonTranslationalTransform(element);
              if (!removedTransforms.length) return;
              transformsToRestore.set(element, removedTransforms);
              element.render();
            });
            // Read
            resolversToMeasure.forEach(function (resolver) {
              return resolver.measureInitialState();
            });
            // Write
            elementsToMeasure.forEach(function (element) {
              element.render();
              var restore = transformsToRestore.get(element);
              if (restore) {
                restore.forEach(function (_ref93) {
                  var _ref94 = _slicedToArray(_ref93, 2),
                    key = _ref94[0],
                    value = _ref94[1];
                  var _a;
                  (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
                });
              }
            });
            // Read
            resolversToMeasure.forEach(function (resolver) {
              return resolver.measureEndState();
            });
            // Write
            resolversToMeasure.forEach(function (resolver) {
              if (resolver.suspendedScrollY !== undefined) {
                window.scrollTo(0, resolver.suspendedScrollY);
              }
            });
          }
          anyNeedsMeasurement = false;
          isScheduled = false;
          toResolve.forEach(function (resolver) {
            return resolver.complete();
          });
          toResolve.clear();
        }
        function readAllKeyframes() {
          toResolve.forEach(function (resolver) {
            resolver.readKeyframes();
            if (resolver.needsMeasurement) {
              anyNeedsMeasurement = true;
            }
          });
        }
        function flushKeyframeResolvers() {
          readAllKeyframes();
          measureAllKeyframes();
        }
        var KeyframeResolver = /*#__PURE__*/function () {
          function KeyframeResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {
            var isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
            _classCallCheck(this, KeyframeResolver);
            /**
             * Track whether this resolver has completed. Once complete, it never
             * needs to attempt keyframe resolution again.
             */
            this.isComplete = false;
            /**
             * Track whether this resolver is async. If it is, it'll be added to the
             * resolver queue and flushed in the next frame. Resolvers that aren't going
             * to trigger read/write thrashing don't need to be async.
             */
            this.isAsync = false;
            /**
             * Track whether this resolver needs to perform a measurement
             * to resolve its keyframes.
             */
            this.needsMeasurement = false;
            /**
             * Track whether this resolver is currently scheduled to resolve
             * to allow it to be cancelled and resumed externally.
             */
            this.isScheduled = false;
            this.unresolvedKeyframes = _toConsumableArray(unresolvedKeyframes);
            this.onComplete = onComplete;
            this.name = name;
            this.motionValue = motionValue;
            this.element = element;
            this.isAsync = isAsync;
          }
          return _createClass(KeyframeResolver, [{
            key: "scheduleResolve",
            value: function scheduleResolve() {
              this.isScheduled = true;
              if (this.isAsync) {
                toResolve.add(this);
                if (!isScheduled) {
                  isScheduled = true;
                  frame.read(readAllKeyframes);
                  frame.resolveKeyframes(measureAllKeyframes);
                }
              } else {
                this.readKeyframes();
                this.complete();
              }
            }
          }, {
            key: "readKeyframes",
            value: function readKeyframes() {
              var unresolvedKeyframes = this.unresolvedKeyframes,
                name = this.name,
                element = this.element,
                motionValue = this.motionValue;
              /**
               * If a keyframe is null, we hydrate it either by reading it from
               * the instance, or propagating from previous keyframes.
               */
              for (var i = 0; i < unresolvedKeyframes.length; i++) {
                if (unresolvedKeyframes[i] === null) {
                  /**
                   * If the first keyframe is null, we need to find its value by sampling the element
                   */
                  if (i === 0) {
                    var currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();
                    var finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
                    if (currentValue !== undefined) {
                      unresolvedKeyframes[0] = currentValue;
                    } else if (element && name) {
                      var valueAsRead = element.readValue(name, finalKeyframe);
                      if (valueAsRead !== undefined && valueAsRead !== null) {
                        unresolvedKeyframes[0] = valueAsRead;
                      }
                    }
                    if (unresolvedKeyframes[0] === undefined) {
                      unresolvedKeyframes[0] = finalKeyframe;
                    }
                    if (motionValue && currentValue === undefined) {
                      motionValue.set(unresolvedKeyframes[0]);
                    }
                  } else {
                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
                  }
                }
              }
            }
          }, {
            key: "setFinalKeyframe",
            value: function setFinalKeyframe() {}
          }, {
            key: "measureInitialState",
            value: function measureInitialState() {}
          }, {
            key: "renderEndStyles",
            value: function renderEndStyles() {}
          }, {
            key: "measureEndState",
            value: function measureEndState() {}
          }, {
            key: "complete",
            value: function complete() {
              this.isComplete = true;
              this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
              toResolve.delete(this);
            }
          }, {
            key: "cancel",
            value: function cancel() {
              if (!this.isComplete) {
                this.isScheduled = false;
                toResolve.delete(this);
              }
            }
          }, {
            key: "resume",
            value: function resume() {
              if (!this.isComplete) this.scheduleResolve();
            }
          }]);
        }();
        /**
         * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
         */
        var isNumericalString = function isNumericalString(v) {
          return /^-?(?:[0-9]+(?:\.[0-9]+)?|\.[0-9]+)$/.test(v);
        };

        /**
         * Parse Framer's special CSS variable format into a CSS token and a fallback.
         *
         * ```
         * `var(--foo, #fff)` => [`--foo`, '#fff']
         * ```
         *
         * @param current
         */
        var splitCSSVariableRegex =
        // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
        /^var\(--(?:([\x2D0-9A-Z_a-z]+)|([\x2D0-9A-Z_a-z]+), ?([ #%\(\),-\.0-9A-Za-z]+))\)/;
        function parseCSSVariable(current) {
          var match = splitCSSVariableRegex.exec(current);
          if (!match) return [,];
          var _match3 = _slicedToArray(match, 4),
            token1 = _match3[1],
            token2 = _match3[2],
            fallback = _match3[3];
          return ["--".concat(token1 !== null && token1 !== void 0 ? token1 : token2), fallback];
        }
        function getVariableValue(current, element) {
          var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var _parseCSSVariable = parseCSSVariable(current),
            _parseCSSVariable2 = _slicedToArray(_parseCSSVariable, 2),
            token = _parseCSSVariable2[0],
            fallback = _parseCSSVariable2[1];
          // No CSS variable detected
          if (!token) return;
          // Attempt to read this CSS variable off the element
          var resolved = window.getComputedStyle(element).getPropertyValue(token);
          if (resolved) {
            var trimmed = resolved.trim();
            return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
          }
          return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
        }

        /**
         * Tests a provided value against a ValueType
         */
        var testValueType = function testValueType(v) {
          return function (type) {
            return type.test(v);
          };
        };

        /**
         * ValueType for "auto"
         */
        var auto$1 = {
          test: function test(v) {
            return v === "auto";
          },
          parse: function parse(v) {
            return v;
          }
        };

        /**
         * A list of value types commonly used for dimensions
         */
        var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto$1];
        /**
         * Tests a dimensional value against the list of dimension ValueTypes
         */
        var findDimensionValueType = function findDimensionValueType(v) {
          return dimensionValueTypes.find(testValueType(v));
        };
        var DOMKeyframesResolver = /*#__PURE__*/function (_KeyframeResolver) {
          function DOMKeyframesResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {
            _classCallCheck(this, DOMKeyframesResolver);
            return _callSuper(this, DOMKeyframesResolver, [unresolvedKeyframes, onComplete, name, motionValue, element, true]);
          }
          _inherits(DOMKeyframesResolver, _KeyframeResolver);
          return _createClass(DOMKeyframesResolver, [{
            key: "readKeyframes",
            value: function readKeyframes() {
              var unresolvedKeyframes = this.unresolvedKeyframes,
                element = this.element,
                name = this.name;
              if (!element || !element.current) return;
              _superPropGet(DOMKeyframesResolver, "readKeyframes", this, 3)([]);
              /**
               * If any keyframe is a CSS variable, we need to find its value by sampling the element
               */
              for (var i = 0; i < unresolvedKeyframes.length; i++) {
                var keyframe = unresolvedKeyframes[i];
                if (typeof keyframe === "string") {
                  keyframe = keyframe.trim();
                  if (isCSSVariableToken(keyframe)) {
                    var resolved = getVariableValue(keyframe, element.current);
                    if (resolved !== undefined) {
                      unresolvedKeyframes[i] = resolved;
                    }
                    if (i === unresolvedKeyframes.length - 1) {
                      this.finalKeyframe = keyframe;
                    }
                  }
                }
              }
              /**
               * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.
               * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which
               * have a far bigger performance impact.
               */
              this.resolveNoneKeyframes();
              /**
               * Check to see if unit type has changed. If so schedule jobs that will
               * temporarily set styles to the destination keyframes.
               * Skip if we have more than two keyframes or this isn't a positional value.
               * TODO: We can throw if there are multiple keyframes and the value type changes.
               */
              if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
                return;
              }
              var _unresolvedKeyframes = _slicedToArray(unresolvedKeyframes, 2),
                origin = _unresolvedKeyframes[0],
                target = _unresolvedKeyframes[1];
              var originType = findDimensionValueType(origin);
              var targetType = findDimensionValueType(target);
              /**
               * Either we don't recognise these value types or we can animate between them.
               */
              if (originType === targetType) return;
              /**
               * If both values are numbers or pixels, we can animate between them by
               * converting them to numbers.
               */
              if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
                for (var _i8 = 0; _i8 < unresolvedKeyframes.length; _i8++) {
                  var value = unresolvedKeyframes[_i8];
                  if (typeof value === "string") {
                    unresolvedKeyframes[_i8] = parseFloat(value);
                  }
                }
              } else {
                /**
                 * Else, the only way to resolve this is by measuring the element.
                 */
                this.needsMeasurement = true;
              }
            }
          }, {
            key: "resolveNoneKeyframes",
            value: function resolveNoneKeyframes() {
              var unresolvedKeyframes = this.unresolvedKeyframes,
                name = this.name;
              var noneKeyframeIndexes = [];
              for (var i = 0; i < unresolvedKeyframes.length; i++) {
                if (isNone(unresolvedKeyframes[i])) {
                  noneKeyframeIndexes.push(i);
                }
              }
              if (noneKeyframeIndexes.length) {
                makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
              }
            }
          }, {
            key: "measureInitialState",
            value: function measureInitialState() {
              var element = this.element,
                unresolvedKeyframes = this.unresolvedKeyframes,
                name = this.name;
              if (!element || !element.current) return;
              if (name === "height") {
                this.suspendedScrollY = window.pageYOffset;
              }
              this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
              unresolvedKeyframes[0] = this.measuredOrigin;
              // Set final key frame to measure after next render
              var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
              if (measureKeyframe !== undefined) {
                element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
              }
            }
          }, {
            key: "measureEndState",
            value: function measureEndState() {
              var _a;
              var element = this.element,
                name = this.name,
                unresolvedKeyframes = this.unresolvedKeyframes;
              if (!element || !element.current) return;
              var value = element.getValue(name);
              value && value.jump(this.measuredOrigin, false);
              var finalKeyframeIndex = unresolvedKeyframes.length - 1;
              var finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
              unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
              if (finalKeyframe !== null && this.finalKeyframe === undefined) {
                this.finalKeyframe = finalKeyframe;
              }
              // If we removed transform values, reapply them before the next render
              if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
                this.removedTransforms.forEach(function (_ref95) {
                  var _ref96 = _slicedToArray(_ref95, 2),
                    unsetTransformName = _ref96[0],
                    unsetTransformValue = _ref96[1];
                  element.getValue(unsetTransformName).set(unsetTransformValue);
                });
              }
              this.resolveNoneKeyframes();
            }
          }]);
        }(KeyframeResolver);
        /**
         * Check if a value is animatable. Examples:
         *
         * : 100, "100px", "#fff"
         * : "block", "url(2.jpg)"
         * @param value
         *
         * @internal
         */
        var isAnimatable = function isAnimatable(value, name) {
          // If the list of keys tat might be non-animatable grows, replace with Set
          if (name === "zIndex") return false;
          // If it's a number or a keyframes array, we can animate it. We might at some point
          // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
          // but for now lets leave it like this for performance reasons
          if (typeof value === "number" || Array.isArray(value)) return true;
          if (typeof value === "string" && (
          // It's animatable if we have a string
          complex.test(value) || value === "0") &&
          // And it contains numbers and/or colors
          !value.startsWith("url(") // Unless it starts with "url("
          ) {
            return true;
          }
          return false;
        };
        function hasKeyframesChanged(keyframes) {
          var current = keyframes[0];
          if (keyframes.length === 1) return true;
          for (var i = 0; i < keyframes.length; i++) {
            if (keyframes[i] !== current) return true;
          }
        }
        function canAnimate(keyframes, name, type, velocity) {
          /**
           * Check if we're able to animate between the start and end keyframes,
           * and throw a warning if we're attempting to animate between one that's
           * animatable and another that isn't.
           */
          var originKeyframe = keyframes[0];
          if (originKeyframe === null) return false;
          /**
           * These aren't traditionally animatable but we do support them.
           * In future we could look into making this more generic or replacing
           * this function with mix() === mixImmediate
           */
          if (name === "display" || name === "visibility") return true;
          var targetKeyframe = keyframes[keyframes.length - 1];
          var isOriginAnimatable = isAnimatable(originKeyframe, name);
          var isTargetAnimatable = isAnimatable(targetKeyframe, name);
          // Always skip if any of these are true
          if (!isOriginAnimatable || !isTargetAnimatable) {
            return false;
          }
          return hasKeyframesChanged(keyframes) || (type === "spring" || isGenerator(type)) && velocity;
        }
        var isNotNull = function isNotNull(value) {
          return value !== null;
        };
        function getFinalKeyframe(keyframes, _ref97, finalKeyframe) {
          var repeat = _ref97.repeat,
            _ref97$repeatType = _ref97.repeatType,
            repeatType = _ref97$repeatType === void 0 ? "loop" : _ref97$repeatType;
          var resolvedKeyframes = keyframes.filter(isNotNull);
          var index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
          return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;
        }

        /**
         * Maximum time allowed between an animation being created and it being
         * resolved for us to use the latter as the start time.
         *
         * This is to ensure that while we prefer to "start" an animation as soon
         * as it's triggered, we also want to avoid a visual jump if there's a big delay
         * between these two moments.
         */
        var MAX_RESOLVE_DELAY = 40;
        var BaseAnimation = /*#__PURE__*/function () {
          function BaseAnimation(_ref98) {
            var _ref98$autoplay = _ref98.autoplay,
              autoplay = _ref98$autoplay === void 0 ? true : _ref98$autoplay,
              _ref98$delay = _ref98.delay,
              delay = _ref98$delay === void 0 ? 0 : _ref98$delay,
              _ref98$type = _ref98.type,
              type = _ref98$type === void 0 ? "keyframes" : _ref98$type,
              _ref98$repeat = _ref98.repeat,
              repeat = _ref98$repeat === void 0 ? 0 : _ref98$repeat,
              _ref98$repeatDelay = _ref98.repeatDelay,
              repeatDelay = _ref98$repeatDelay === void 0 ? 0 : _ref98$repeatDelay,
              _ref98$repeatType = _ref98.repeatType,
              repeatType = _ref98$repeatType === void 0 ? "loop" : _ref98$repeatType,
              options = _objectWithoutProperties2(_ref98, _excluded1);
            _classCallCheck(this, BaseAnimation);
            // Track whether the animation has been stopped. Stopped animations won't restart.
            this.isStopped = false;
            this.hasAttemptedResolve = false;
            this.createdAt = time.now();
            this.options = _objectSpread3({
              autoplay: autoplay,
              delay: delay,
              type: type,
              repeat: repeat,
              repeatDelay: repeatDelay,
              repeatType: repeatType
            }, options);
            this.updateFinishedPromise();
          }
          /**
           * This method uses the createdAt and resolvedAt to calculate the
           * animation startTime. *Ideally*, we would use the createdAt time as t=0
           * as the following frame would then be the first frame of the animation in
           * progress, which would feel snappier.
           *
           * However, if there's a delay (main thread work) between the creation of
           * the animation and the first commited frame, we prefer to use resolvedAt
           * to avoid a sudden jump into the animation.
           */
          return _createClass(BaseAnimation, [{
            key: "calcStartTime",
            value: function calcStartTime() {
              if (!this.resolvedAt) return this.createdAt;
              return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
            }
            /**
             * A getter for resolved data. If keyframes are not yet resolved, accessing
             * this.resolved will synchronously flush all pending keyframe resolvers.
             * This is a deoptimisation, but at its worst still batches read/writes.
             */
          }, {
            key: "resolved",
            get: function get() {
              if (!this._resolved && !this.hasAttemptedResolve) {
                flushKeyframeResolvers();
              }
              return this._resolved;
            }
            /**
             * A method to be called when the keyframes resolver completes. This method
             * will check if its possible to run the animation and, if not, skip it.
             * Otherwise, it will call initPlayback on the implementing class.
             */
          }, {
            key: "onKeyframesResolved",
            value: function onKeyframesResolved(keyframes, finalKeyframe) {
              this.resolvedAt = time.now();
              this.hasAttemptedResolve = true;
              var _this$options = this.options,
                name = _this$options.name,
                type = _this$options.type,
                velocity = _this$options.velocity,
                delay = _this$options.delay,
                onComplete = _this$options.onComplete,
                onUpdate = _this$options.onUpdate,
                isGenerator = _this$options.isGenerator;
              /**
               * If we can't animate this value with the resolved keyframes
               * then we should complete it immediately.
               */
              if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {
                // Finish immediately
                if (!delay) {
                  onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));
                  onComplete && onComplete();
                  this.resolveFinishedPromise();
                  return;
                }
                // Finish after a delay
                else {
                  this.options.duration = 0;
                }
              }
              var resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);
              if (resolvedAnimation === false) return;
              this._resolved = _objectSpread3({
                keyframes: keyframes,
                finalKeyframe: finalKeyframe
              }, resolvedAnimation);
              this.onPostResolved();
            }
          }, {
            key: "onPostResolved",
            value: function onPostResolved() {}
            /**
             * Allows the returned animation to be awaited or promise-chained. Currently
             * resolves when the animation finishes at all but in a future update could/should
             * reject if its cancels.
             */
          }, {
            key: "then",
            value: function then(resolve, reject) {
              return this.currentFinishedPromise.then(resolve, reject);
            }
          }, {
            key: "flatten",
            value: function flatten() {
              this.options.type = "keyframes";
              this.options.ease = "linear";
            }
          }, {
            key: "updateFinishedPromise",
            value: function updateFinishedPromise() {
              var _this20 = this;
              this.currentFinishedPromise = new Promise(function (resolve) {
                _this20.resolveFinishedPromise = resolve;
              });
            }
          }]);
        }();
        /*
          Value in range from progress
           Given a lower limit and an upper limit, we return the value within
          that range as expressed by progress (usually a number from 0 to 1)
           So progress = 0.5 would change
           from -------- to
           to
           from ---- to
           E.g. from = 10, to = 20, progress = 0.5 => 15
           @param [number]: Lower limit of range
          @param [number]: Upper limit of range
          @param [number]: The progress between lower and upper limits expressed 0-1
          @return [number]: Value as calculated from progress within range (not limited within range)
        */
        var mixNumber$1 = function mixNumber$1(from, to, progress) {
          return from + (to - from) * progress;
        };

        // Adapted from https://gist.github.com/mjackson/5311256
        function hueToRgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }
        function hslaToRgba(_ref99) {
          var hue = _ref99.hue,
            saturation = _ref99.saturation,
            lightness = _ref99.lightness,
            alpha = _ref99.alpha;
          hue /= 360;
          saturation /= 100;
          lightness /= 100;
          var red = 0;
          var green = 0;
          var blue = 0;
          if (!saturation) {
            red = green = blue = lightness;
          } else {
            var _q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
            var _p = 2 * lightness - _q;
            red = hueToRgb(_p, _q, hue + 1 / 3);
            green = hueToRgb(_p, _q, hue);
            blue = hueToRgb(_p, _q, hue - 1 / 3);
          }
          return {
            red: Math.round(red * 255),
            green: Math.round(green * 255),
            blue: Math.round(blue * 255),
            alpha: alpha
          };
        }
        function mixImmediate(a, b) {
          return function (p) {
            return p > 0 ? b : a;
          };
        }

        // Linear color space blending
        // Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
        // Demonstrated http://codepen.io/osublake/pen/xGVVaN
        var mixLinearColor = function mixLinearColor(from, to, v) {
          var fromExpo = from * from;
          var expo = v * (to * to - fromExpo) + fromExpo;
          return expo < 0 ? 0 : Math.sqrt(expo);
        };
        var colorTypes = [hex, rgba, hsla];
        var getColorType = function getColorType(v) {
          return colorTypes.find(function (type) {
            return type.test(v);
          });
        };
        function asRGBA(color) {
          var type = getColorType(color);
          if (!Boolean(type)) return false;
          var model = type.parse(color);
          if (type === hsla) {
            // TODO Remove this cast - needed since Motion's stricter typing
            model = hslaToRgba(model);
          }
          return model;
        }
        var mixColor = function mixColor(from, to) {
          var fromRGBA = asRGBA(from);
          var toRGBA = asRGBA(to);
          if (!fromRGBA || !toRGBA) {
            return mixImmediate(from, to);
          }
          var blended = _objectSpread3({}, fromRGBA);
          return function (v) {
            blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
            blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
            blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
            blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
            return rgba.transform(blended);
          };
        };

        /**
         * Pipe
         * Compose other transformers to run linearily
         * pipe(min(20), max(40))
         * @param  {...functions} transformers
         * @return {function}
         */
        var combineFunctions = function combineFunctions(a, b) {
          return function (v) {
            return b(a(v));
          };
        };
        var pipe$1 = function pipe$1() {
          for (var _len32 = arguments.length, transformers = new Array(_len32), _key49 = 0; _key49 < _len32; _key49++) {
            transformers[_key49] = arguments[_key49];
          }
          return transformers.reduce(combineFunctions);
        };
        var invisibleValues = new Set(["none", "hidden"]);
        /**
         * Returns a function that, when provided a progress value between 0 and 1,
         * will return the "none" or "hidden" string only when the progress is that of
         * the origin or target.
         */
        function mixVisibility(origin, target) {
          if (invisibleValues.has(origin)) {
            return function (p) {
              return p <= 0 ? origin : target;
            };
          } else {
            return function (p) {
              return p >= 1 ? target : origin;
            };
          }
        }
        function mixNumber(a, b) {
          return function (p) {
            return mixNumber$1(a, b, p);
          };
        }
        function getMixer(a) {
          if (typeof a === "number") {
            return mixNumber;
          } else if (typeof a === "string") {
            return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
          } else if (Array.isArray(a)) {
            return mixArray;
          } else if (_typeof2(a) === "object") {
            return color.test(a) ? mixColor : mixObject;
          }
          return mixImmediate;
        }
        function mixArray(a, b) {
          var output = _toConsumableArray(a);
          var numValues = output.length;
          var blendValue = a.map(function (v, i) {
            return getMixer(v)(v, b[i]);
          });
          return function (p) {
            for (var i = 0; i < numValues; i++) {
              output[i] = blendValue[i](p);
            }
            return output;
          };
        }
        function mixObject(a, b) {
          var output = _objectSpread3(_objectSpread3({}, a), b);
          var blendValue = {};
          for (var _key50 in output) {
            if (a[_key50] !== undefined && b[_key50] !== undefined) {
              blendValue[_key50] = getMixer(a[_key50])(a[_key50], b[_key50]);
            }
          }
          return function (v) {
            for (var _key51 in blendValue) {
              output[_key51] = blendValue[_key51](v);
            }
            return output;
          };
        }
        function matchOrder(origin, target) {
          var _a;
          var orderedOrigin = [];
          var pointers = {
            color: 0,
            var: 0,
            number: 0
          };
          for (var i = 0; i < target.values.length; i++) {
            var type = target.types[i];
            var originIndex = origin.indexes[type][pointers[type]];
            var originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
            orderedOrigin[i] = originValue;
            pointers[type]++;
          }
          return orderedOrigin;
        }
        var mixComplex = function mixComplex(origin, target) {
          var template = complex.createTransformer(target);
          var originStats = analyseComplexValue(origin);
          var targetStats = analyseComplexValue(target);
          var canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
          if (canInterpolate) {
            if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
              return mixVisibility(origin, target);
            }
            return pipe$1(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
          } else {
            return mixImmediate(origin, target);
          }
        };
        function mix(from, to, p) {
          if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
            return mixNumber$1(from, to, p);
          }
          var mixer = getMixer(from);
          return mixer(from, to);
        }
        var velocitySampleDuration = 5; // ms
        function calcGeneratorVelocity(resolveValue, t, current) {
          var prevT = Math.max(t - velocitySampleDuration, 0);
          return velocityPerSecond(current - resolveValue(prevT), t - prevT);
        }
        var springDefaults = {
          // Default spring physics
          stiffness: 100,
          damping: 10,
          mass: 1.0,
          velocity: 0.0,
          // Default duration/bounce-based options
          duration: 800,
          // in ms
          bounce: 0.3,
          visualDuration: 0.3,
          // in seconds
          // Rest thresholds
          restSpeed: {
            granular: 0.01,
            default: 2
          },
          restDelta: {
            granular: 0.005,
            default: 0.5
          },
          // Limits
          minDuration: 0.01,
          // in seconds
          maxDuration: 10.0,
          // in seconds
          minDamping: 0.05,
          maxDamping: 1
        };
        var safeMin = 0.001;
        function findSpring(_ref100) {
          var _ref100$duration = _ref100.duration,
            duration = _ref100$duration === void 0 ? springDefaults.duration : _ref100$duration,
            _ref100$bounce = _ref100.bounce,
            bounce = _ref100$bounce === void 0 ? springDefaults.bounce : _ref100$bounce,
            _ref100$velocity = _ref100.velocity,
            velocity = _ref100$velocity === void 0 ? springDefaults.velocity : _ref100$velocity,
            _ref100$mass = _ref100.mass,
            mass = _ref100$mass === void 0 ? springDefaults.mass : _ref100$mass;
          var envelope;
          var derivative;
          var dampingRatio = 1 - bounce;
          /**
           * Restrict dampingRatio and duration to within acceptable ranges.
           */
          dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
          duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
          if (dampingRatio < 1) {
            /**
             * Underdamped spring
             */
            envelope = function envelope(undampedFreq) {
              var exponentialDecay = undampedFreq * dampingRatio;
              var delta = exponentialDecay * duration;
              var a = exponentialDecay - velocity;
              var b = calcAngularFreq(undampedFreq, dampingRatio);
              var c = Math.exp(-delta);
              return safeMin - a / b * c;
            };
            derivative = function derivative(undampedFreq) {
              var exponentialDecay = undampedFreq * dampingRatio;
              var delta = exponentialDecay * duration;
              var d = delta * velocity + velocity;
              var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
              var f = Math.exp(-delta);
              var g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
              var factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
              return factor * ((d - e) * f) / g;
            };
          } else {
            /**
             * Critically-damped spring
             */
            envelope = function envelope(undampedFreq) {
              var a = Math.exp(-undampedFreq * duration);
              var b = (undampedFreq - velocity) * duration + 1;
              return -safeMin + a * b;
            };
            derivative = function derivative(undampedFreq) {
              var a = Math.exp(-undampedFreq * duration);
              var b = (velocity - undampedFreq) * (duration * duration);
              return a * b;
            };
          }
          var initialGuess = 5 / duration;
          var undampedFreq = approximateRoot(envelope, derivative, initialGuess);
          duration = secondsToMilliseconds(duration);
          if (isNaN(undampedFreq)) {
            return {
              stiffness: springDefaults.stiffness,
              damping: springDefaults.damping,
              duration: duration
            };
          } else {
            var stiffness = Math.pow(undampedFreq, 2) * mass;
            return {
              stiffness: stiffness,
              damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
              duration: duration
            };
          }
        }
        var rootIterations = 12;
        function approximateRoot(envelope, derivative, initialGuess) {
          var result = initialGuess;
          for (var i = 1; i < rootIterations; i++) {
            result = result - envelope(result) / derivative(result);
          }
          return result;
        }
        function calcAngularFreq(undampedFreq, dampingRatio) {
          return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
        }
        var durationKeys = ["duration", "bounce"];
        var physicsKeys = ["stiffness", "damping", "mass"];
        function isSpringType(options, keys) {
          return keys.some(function (key) {
            return options[key] !== undefined;
          });
        }
        function getSpringOptions(options) {
          var springOptions = _objectSpread3({
            velocity: springDefaults.velocity,
            stiffness: springDefaults.stiffness,
            damping: springDefaults.damping,
            mass: springDefaults.mass,
            isResolvedFromDuration: false
          }, options);
          // stiffness/damping/mass overrides duration/bounce
          if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
            if (options.visualDuration) {
              var visualDuration = options.visualDuration;
              var root = 2 * Math.PI / (visualDuration * 1.2);
              var stiffness = root * root;
              var damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
              springOptions = _objectSpread3(_objectSpread3({}, springOptions), {}, {
                mass: springDefaults.mass,
                stiffness: stiffness,
                damping: damping
              });
            } else {
              var derived = findSpring(options);
              springOptions = _objectSpread3(_objectSpread3(_objectSpread3({}, springOptions), derived), {}, {
                mass: springDefaults.mass
              });
              springOptions.isResolvedFromDuration = true;
            }
          }
          return springOptions;
        }
        function spring() {
          var optionsOrVisualDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : springDefaults.visualDuration;
          var bounce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : springDefaults.bounce;
          var options = _typeof2(optionsOrVisualDuration) !== "object" ? {
            visualDuration: optionsOrVisualDuration,
            keyframes: [0, 1],
            bounce: bounce
          } : optionsOrVisualDuration;
          var restSpeed = options.restSpeed,
            restDelta = options.restDelta;
          var origin = options.keyframes[0];
          var target = options.keyframes[options.keyframes.length - 1];
          /**
           * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
           * to reduce GC during animation.
           */
          var state = {
            done: false,
            value: origin
          };
          var _getSpringOptions = getSpringOptions(_objectSpread3(_objectSpread3({}, options), {}, {
              velocity: -millisecondsToSeconds(options.velocity || 0)
            })),
            stiffness = _getSpringOptions.stiffness,
            damping = _getSpringOptions.damping,
            mass = _getSpringOptions.mass,
            duration = _getSpringOptions.duration,
            velocity = _getSpringOptions.velocity,
            isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;
          var initialVelocity = velocity || 0.0;
          var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
          var initialDelta = target - origin;
          var undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
          /**
           * If we're working on a granular scale, use smaller defaults for determining
           * when the spring is finished.
           *
           * These defaults have been selected emprically based on what strikes a good
           * ratio between feeling good and finishing as soon as changes are imperceptible.
           */
          var isGranularScale = Math.abs(initialDelta) < 5;
          restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
          restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
          var resolveSpring;
          if (dampingRatio < 1) {
            var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
            // Underdamped spring
            resolveSpring = function resolveSpring(t) {
              var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
              return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
            };
          } else if (dampingRatio === 1) {
            // Critically damped spring
            resolveSpring = function resolveSpring(t) {
              return target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
            };
          } else {
            // Overdamped spring
            var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
            resolveSpring = function resolveSpring(t) {
              var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
              // When performing sinh or cosh values can hit Infinity so we cap them here
              var freqForT = Math.min(dampedAngularFreq * t, 300);
              return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
            };
          }
          var generator = {
            calculatedDuration: isResolvedFromDuration ? duration || null : null,
            next: function next(t) {
              var current = resolveSpring(t);
              if (!isResolvedFromDuration) {
                var currentVelocity = 0.0;
                /**
                 * We only need to calculate velocity for under-damped springs
                 * as over- and critically-damped springs can't overshoot, so
                 * checking only for displacement is enough.
                 */
                if (dampingRatio < 1) {
                  currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
                }
                var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
                var isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
                state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
              } else {
                state.done = t >= duration;
              }
              state.value = state.done ? target : current;
              return state;
            },
            toString: function toString() {
              var calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
              var easing = generateLinearEasing(function (progress) {
                return generator.next(calculatedDuration * progress).value;
              }, calculatedDuration, 30);
              return calculatedDuration + "ms " + easing;
            }
          };
          return generator;
        }
        function inertia(_ref101) {
          var keyframes = _ref101.keyframes,
            _ref101$velocity = _ref101.velocity,
            velocity = _ref101$velocity === void 0 ? 0.0 : _ref101$velocity,
            _ref101$power = _ref101.power,
            power = _ref101$power === void 0 ? 0.8 : _ref101$power,
            _ref101$timeConstant = _ref101.timeConstant,
            timeConstant = _ref101$timeConstant === void 0 ? 325 : _ref101$timeConstant,
            _ref101$bounceDamping = _ref101.bounceDamping,
            bounceDamping = _ref101$bounceDamping === void 0 ? 10 : _ref101$bounceDamping,
            _ref101$bounceStiffne = _ref101.bounceStiffness,
            bounceStiffness = _ref101$bounceStiffne === void 0 ? 500 : _ref101$bounceStiffne,
            modifyTarget = _ref101.modifyTarget,
            min = _ref101.min,
            max = _ref101.max,
            _ref101$restDelta = _ref101.restDelta,
            restDelta = _ref101$restDelta === void 0 ? 0.5 : _ref101$restDelta,
            restSpeed = _ref101.restSpeed;
          var origin = keyframes[0];
          var state = {
            done: false,
            value: origin
          };
          var isOutOfBounds = function isOutOfBounds(v) {
            return min !== undefined && v < min || max !== undefined && v > max;
          };
          var nearestBoundary = function nearestBoundary(v) {
            if (min === undefined) return max;
            if (max === undefined) return min;
            return Math.abs(min - v) < Math.abs(max - v) ? min : max;
          };
          var amplitude = power * velocity;
          var ideal = origin + amplitude;
          var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
          /**
           * If the target has changed we need to re-calculate the amplitude, otherwise
           * the animation will start from the wrong position.
           */
          if (target !== ideal) amplitude = target - origin;
          var calcDelta = function calcDelta(t) {
            return -amplitude * Math.exp(-t / timeConstant);
          };
          var calcLatest = function calcLatest(t) {
            return target + calcDelta(t);
          };
          var applyFriction = function applyFriction(t) {
            var delta = calcDelta(t);
            var latest = calcLatest(t);
            state.done = Math.abs(delta) <= restDelta;
            state.value = state.done ? target : latest;
          };
          /**
           * Ideally this would resolve for t in a stateless way, we could
           * do that by always precalculating the animation but as we know
           * this will be done anyway we can assume that spring will
           * be discovered during that.
           */
          var timeReachedBoundary;
          var spring$1;
          var checkCatchBoundary = function checkCatchBoundary(t) {
            if (!isOutOfBounds(state.value)) return;
            timeReachedBoundary = t;
            spring$1 = spring({
              keyframes: [state.value, nearestBoundary(state.value)],
              velocity: calcGeneratorVelocity(calcLatest, t, state.value),
              // TODO: This should be passing * 1000
              damping: bounceDamping,
              stiffness: bounceStiffness,
              restDelta: restDelta,
              restSpeed: restSpeed
            });
          };
          checkCatchBoundary(0);
          return {
            calculatedDuration: null,
            next: function next(t) {
              /**
               * We need to resolve the friction to figure out if we need a
               * spring but we don't want to do this twice per frame. So here
               * we flag if we updated for this frame and later if we did
               * we can skip doing it again.
               */
              var hasUpdatedFrame = false;
              if (!spring$1 && timeReachedBoundary === undefined) {
                hasUpdatedFrame = true;
                applyFriction(t);
                checkCatchBoundary(t);
              }
              /**
               * If we have a spring and the provided t is beyond the moment the friction
               * animation crossed the min/max boundary, use the spring.
               */
              if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
                return spring$1.next(t - timeReachedBoundary);
              } else {
                !hasUpdatedFrame && applyFriction(t);
                return state;
              }
            }
          };
        }
        var easeIn = /*@__PURE__*/cubicBezier(0.42, 0, 1, 1);
        var easeOut = /*@__PURE__*/cubicBezier(0, 0, 0.58, 1);
        var easeInOut = /*@__PURE__*/cubicBezier(0.42, 0, 0.58, 1);
        var isEasingArray = function isEasingArray(ease) {
          return Array.isArray(ease) && typeof ease[0] !== "number";
        };
        var easingLookup = {
          linear: noop$2,
          easeIn: easeIn,
          easeInOut: easeInOut,
          easeOut: easeOut,
          circIn: circIn,
          circInOut: circInOut,
          circOut: circOut,
          backIn: backIn,
          backInOut: backInOut,
          backOut: backOut,
          anticipate: anticipate
        };
        var easingDefinitionToFunction = function easingDefinitionToFunction(definition) {
          if (isBezierDefinition(definition)) {
            // If cubic bezier definition, create bezier curve
            invariant(definition.length === 4);
            var _definition = _slicedToArray(definition, 4),
              x1 = _definition[0],
              y1 = _definition[1],
              x2 = _definition[2],
              y2 = _definition[3];
            return cubicBezier(x1, y1, x2, y2);
          } else if (typeof definition === "string") {
            return easingLookup[definition];
          }
          return definition;
        };
        function createMixers(output, ease, customMixer) {
          var mixers = [];
          var mixerFactory = customMixer || mix;
          var numMixers = output.length - 1;
          for (var i = 0; i < numMixers; i++) {
            var mixer = mixerFactory(output[i], output[i + 1]);
            if (ease) {
              var easingFunction = Array.isArray(ease) ? ease[i] || noop$2 : ease;
              mixer = pipe$1(easingFunction, mixer);
            }
            mixers.push(mixer);
          }
          return mixers;
        }
        /**
         * Create a function that maps from a numerical input array to a generic output array.
         *
         * Accepts:
         *   - Numbers
         *   - Colors (hex, hsl, hsla, rgb, rgba)
         *   - Complex (combinations of one or more numbers or strings)
         *
         * ```jsx
         * const mixColor = interpolate([0, 1], ['#fff', '#000'])
         *
         * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
         * ```
         *
         * TODO Revist this approach once we've moved to data models for values,
         * probably not needed to pregenerate mixer functions.
         *
         * @public
         */
        function interpolate(input, output) {
          var _ref102 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref102$clamp = _ref102.clamp,
            isClamp = _ref102$clamp === void 0 ? true : _ref102$clamp,
            ease = _ref102.ease,
            mixer = _ref102.mixer;
          var inputLength = input.length;
          invariant(inputLength === output.length);
          /**
           * If we're only provided a single input, we can just make a function
           * that returns the output.
           */
          if (inputLength === 1) return function () {
            return output[0];
          };
          if (inputLength === 2 && output[0] === output[1]) return function () {
            return output[1];
          };
          var isZeroDeltaRange = input[0] === input[1];
          // If input runs highest -> lowest, reverse both arrays
          if (input[0] > input[inputLength - 1]) {
            input = _toConsumableArray(input).reverse();
            output = _toConsumableArray(output).reverse();
          }
          var mixers = createMixers(output, ease, mixer);
          var numMixers = mixers.length;
          var interpolator = function interpolator(v) {
            if (isZeroDeltaRange && v < input[0]) return output[0];
            var i = 0;
            if (numMixers > 1) {
              for (; i < input.length - 2; i++) {
                if (v < input[i + 1]) break;
              }
            }
            var progressInRange = progress(input[i], input[i + 1], v);
            return mixers[i](progressInRange);
          };
          return isClamp ? function (v) {
            return interpolator(clamp(input[0], input[inputLength - 1], v));
          } : interpolator;
        }
        function fillOffset(offset, remaining) {
          var min = offset[offset.length - 1];
          for (var i = 1; i <= remaining; i++) {
            var offsetProgress = progress(0, remaining, i);
            offset.push(mixNumber$1(min, 1, offsetProgress));
          }
        }
        function defaultOffset(arr) {
          var offset = [0];
          fillOffset(offset, arr.length - 1);
          return offset;
        }
        function convertOffsetToTimes(offset, duration) {
          return offset.map(function (o) {
            return o * duration;
          });
        }
        function defaultEasing(values, easing) {
          return values.map(function () {
            return easing || easeInOut;
          }).splice(0, values.length - 1);
        }
        function keyframes(_ref103) {
          var _ref103$duration = _ref103.duration,
            duration = _ref103$duration === void 0 ? 300 : _ref103$duration,
            keyframeValues = _ref103.keyframes,
            times = _ref103.times,
            _ref103$ease = _ref103.ease,
            ease = _ref103$ease === void 0 ? "easeInOut" : _ref103$ease;
          /**
           * Easing functions can be externally defined as strings. Here we convert them
           * into actual functions.
           */
          var easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
          /**
           * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
           * to reduce GC during animation.
           */
          var state = {
            done: false,
            value: keyframeValues[0]
          };
          /**
           * Create a times array based on the provided 0-1 offsets
           */
          var absoluteTimes = convertOffsetToTimes(
          // Only use the provided offsets if they're the correct length
          // TODO Maybe we should warn here if there's a length mismatch
          times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues), duration);
          var mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
            ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
          });
          return {
            calculatedDuration: duration,
            next: function next(t) {
              state.value = mapTimeToKeyframe(t);
              state.done = t >= duration;
              return state;
            }
          };
        }
        var frameloopDriver = function frameloopDriver(update) {
          var passTimestamp = function passTimestamp(_ref104) {
            var timestamp = _ref104.timestamp;
            return update(timestamp);
          };
          return {
            start: function start() {
              return frame.update(passTimestamp, true);
            },
            stop: function stop() {
              return cancelFrame(passTimestamp);
            },
            /**
             * If we're processing this frame we can use the
             * framelocked timestamp to keep things in sync.
             */
            now: function now() {
              return frameData.isProcessing ? frameData.timestamp : time.now();
            }
          };
        };
        var generators = {
          decay: inertia,
          inertia: inertia,
          tween: keyframes,
          keyframes: keyframes,
          spring: spring
        };
        var percentToProgress = function percentToProgress(percent) {
          return percent / 100;
        };
        var MainThreadAnimation = /*#__PURE__*/function (_BaseAnimation) {
          function MainThreadAnimation(options) {
            var _this21;
            _classCallCheck(this, MainThreadAnimation);
            _this21 = _callSuper(this, MainThreadAnimation, [options]);
            _this21.holdTime = null;
            _this21.cancelTime = null;
            _this21.currentTime = 0;
            _this21.playbackSpeed = 1;
            _this21.pendingPlayState = "running";
            _this21.startTime = null;
            _this21.state = "idle";
            _this21.stop = function () {
              _this21.resolver.cancel();
              _this21.isStopped = true;
              if (_this21.state === "idle") return;
              _this21.teardown();
              var onStop = _this21.options.onStop;
              onStop && onStop();
            };
            var _this21$options = _this21.options,
              name = _this21$options.name,
              motionValue = _this21$options.motionValue,
              element = _this21$options.element,
              keyframes2 = _this21$options.keyframes;
            var KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
            var onResolved = function onResolved(resolvedKeyframes, finalKeyframe) {
              return _this21.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
            };
            _this21.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue, element);
            _this21.resolver.scheduleResolve();
            return _this21;
          }
          _inherits(MainThreadAnimation, _BaseAnimation);
          return _createClass(MainThreadAnimation, [{
            key: "flatten",
            value: function flatten() {
              _superPropGet(MainThreadAnimation, "flatten", this, 3)([]);
              if (this._resolved) {
                Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
              }
            }
          }, {
            key: "initPlayback",
            value: function initPlayback(keyframes$1) {
              var _this$options2 = this.options,
                _this$options2$type = _this$options2.type,
                type = _this$options2$type === void 0 ? "keyframes" : _this$options2$type,
                _this$options2$repeat = _this$options2.repeat,
                repeat = _this$options2$repeat === void 0 ? 0 : _this$options2$repeat,
                _this$options2$repeat2 = _this$options2.repeatDelay,
                repeatDelay = _this$options2$repeat2 === void 0 ? 0 : _this$options2$repeat2,
                repeatType = _this$options2.repeatType,
                _this$options2$veloci = _this$options2.velocity,
                velocity = _this$options2$veloci === void 0 ? 0 : _this$options2$veloci;
              var generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
              var mapPercentToKeyframes;
              var mirroredGenerator;
              if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
                mapPercentToKeyframes = pipe$1(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
                keyframes$1 = [0, 100];
              }
              var generator = generatorFactory(_objectSpread3(_objectSpread3({}, this.options), {}, {
                keyframes: keyframes$1
              }));
              if (repeatType === "mirror") {
                mirroredGenerator = generatorFactory(_objectSpread3(_objectSpread3({}, this.options), {}, {
                  keyframes: _toConsumableArray(keyframes$1).reverse(),
                  velocity: -velocity
                }));
              }
              if (generator.calculatedDuration === null) {
                generator.calculatedDuration = calcGeneratorDuration(generator);
              }
              var calculatedDuration = generator.calculatedDuration;
              var resolvedDuration = calculatedDuration + repeatDelay;
              var totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
              return {
                generator: generator,
                mirroredGenerator: mirroredGenerator,
                mapPercentToKeyframes: mapPercentToKeyframes,
                calculatedDuration: calculatedDuration,
                resolvedDuration: resolvedDuration,
                totalDuration: totalDuration
              };
            }
          }, {
            key: "onPostResolved",
            value: function onPostResolved() {
              var _this$options$autopla = this.options.autoplay,
                autoplay = _this$options$autopla === void 0 ? true : _this$options$autopla;
              this.play();
              if (this.pendingPlayState === "paused" || !autoplay) {
                this.pause();
              } else {
                this.state = this.pendingPlayState;
              }
            }
          }, {
            key: "tick",
            value: function tick(timestamp) {
              var sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var resolved = this.resolved;
              if (!resolved) {
                var keyframes3 = this.options.keyframes;
                return {
                  done: true,
                  value: keyframes3[keyframes3.length - 1]
                };
              }
              var finalKeyframe = resolved.finalKeyframe,
                generator = resolved.generator,
                mirroredGenerator = resolved.mirroredGenerator,
                mapPercentToKeyframes = resolved.mapPercentToKeyframes,
                keyframes2 = resolved.keyframes,
                calculatedDuration = resolved.calculatedDuration,
                totalDuration = resolved.totalDuration,
                resolvedDuration = resolved.resolvedDuration;
              if (this.startTime === null) return generator.next(0);
              var _this$options3 = this.options,
                delay = _this$options3.delay,
                repeat = _this$options3.repeat,
                repeatType = _this$options3.repeatType,
                repeatDelay = _this$options3.repeatDelay,
                onUpdate = _this$options3.onUpdate;
              if (this.speed > 0) {
                this.startTime = Math.min(this.startTime, timestamp);
              } else if (this.speed < 0) {
                this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
              }
              if (sample) {
                this.currentTime = timestamp;
              } else if (this.holdTime !== null) {
                this.currentTime = this.holdTime;
              } else {
                this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
              }
              var timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);
              var isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
              this.currentTime = Math.max(timeWithoutDelay, 0);
              if (this.state === "finished" && this.holdTime === null) {
                this.currentTime = totalDuration;
              }
              var elapsed = this.currentTime;
              var frameGenerator = generator;
              if (repeat) {
                var _progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
                var currentIteration = Math.floor(_progress);
                var iterationProgress = _progress % 1;
                if (!iterationProgress && _progress >= 1) {
                  iterationProgress = 1;
                }
                iterationProgress === 1 && currentIteration--;
                currentIteration = Math.min(currentIteration, repeat + 1);
                var isOddIteration = Boolean(currentIteration % 2);
                if (isOddIteration) {
                  if (repeatType === "reverse") {
                    iterationProgress = 1 - iterationProgress;
                    if (repeatDelay) {
                      iterationProgress -= repeatDelay / resolvedDuration;
                    }
                  } else if (repeatType === "mirror") {
                    frameGenerator = mirroredGenerator;
                  }
                }
                elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
              }
              var state = isInDelayPhase ? {
                done: false,
                value: keyframes2[0]
              } : frameGenerator.next(elapsed);
              if (mapPercentToKeyframes) {
                state.value = mapPercentToKeyframes(state.value);
              }
              var done = state.done;
              if (!isInDelayPhase && calculatedDuration !== null) {
                done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
              }
              var isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
              if (isAnimationFinished && finalKeyframe !== void 0) {
                state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
              }
              if (onUpdate) {
                onUpdate(state.value);
              }
              if (isAnimationFinished) {
                this.finish();
              }
              return state;
            }
          }, {
            key: "duration",
            get: function get() {
              var resolved = this.resolved;
              return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
            }
          }, {
            key: "time",
            get: function get() {
              return millisecondsToSeconds(this.currentTime);
            },
            set: function set(newTime) {
              newTime = secondsToMilliseconds(newTime);
              this.currentTime = newTime;
              if (this.holdTime !== null || this.speed === 0) {
                this.holdTime = newTime;
              } else if (this.driver) {
                this.startTime = this.driver.now() - newTime / this.speed;
              }
            }
          }, {
            key: "speed",
            get: function get() {
              return this.playbackSpeed;
            },
            set: function set(newSpeed) {
              var hasChanged = this.playbackSpeed !== newSpeed;
              this.playbackSpeed = newSpeed;
              if (hasChanged) {
                this.time = millisecondsToSeconds(this.currentTime);
              }
            }
          }, {
            key: "play",
            value: function play() {
              var _this22 = this;
              if (!this.resolver.isScheduled) {
                this.resolver.resume();
              }
              if (!this._resolved) {
                this.pendingPlayState = "running";
                return;
              }
              if (this.isStopped) return;
              var _this$options4 = this.options,
                _this$options4$driver = _this$options4.driver,
                driver = _this$options4$driver === void 0 ? frameloopDriver : _this$options4$driver,
                onPlay = _this$options4.onPlay,
                startTime = _this$options4.startTime;
              if (!this.driver) {
                this.driver = driver(function (timestamp) {
                  return _this22.tick(timestamp);
                });
              }
              onPlay && onPlay();
              var now = this.driver.now();
              if (this.holdTime !== null) {
                this.startTime = now - this.holdTime;
              } else if (!this.startTime) {
                this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
              } else if (this.state === "finished") {
                this.startTime = now;
              }
              if (this.state === "finished") {
                this.updateFinishedPromise();
              }
              this.cancelTime = this.startTime;
              this.holdTime = null;
              this.state = "running";
              this.driver.start();
            }
          }, {
            key: "pause",
            value: function pause() {
              var _a;
              if (!this._resolved) {
                this.pendingPlayState = "paused";
                return;
              }
              this.state = "paused";
              this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
            }
          }, {
            key: "complete",
            value: function complete() {
              if (this.state !== "running") {
                this.play();
              }
              this.pendingPlayState = this.state = "finished";
              this.holdTime = null;
            }
          }, {
            key: "finish",
            value: function finish() {
              this.teardown();
              this.state = "finished";
              var onComplete = this.options.onComplete;
              onComplete && onComplete();
            }
          }, {
            key: "cancel",
            value: function cancel() {
              if (this.cancelTime !== null) {
                this.tick(this.cancelTime);
              }
              this.teardown();
              this.updateFinishedPromise();
            }
          }, {
            key: "teardown",
            value: function teardown() {
              this.state = "idle";
              this.stopDriver();
              this.resolveFinishedPromise();
              this.updateFinishedPromise();
              this.startTime = this.cancelTime = null;
              this.resolver.cancel();
            }
          }, {
            key: "stopDriver",
            value: function stopDriver() {
              if (!this.driver) return;
              this.driver.stop();
              this.driver = void 0;
            }
          }, {
            key: "sample",
            value: function sample(time) {
              this.startTime = 0;
              return this.tick(time, true);
            }
          }]);
        }(BaseAnimation);
        /**
         * A list of values that can be hardware-accelerated.
         */
        var acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"
        // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
        // or until we implement support for linear() easing.
        // "background-color"
        ]);
        function startWaapiAnimation(element, valueName, keyframes) {
          var _ref105 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
            _ref105$delay = _ref105.delay,
            delay = _ref105$delay === void 0 ? 0 : _ref105$delay,
            _ref105$duration = _ref105.duration,
            duration = _ref105$duration === void 0 ? 300 : _ref105$duration,
            _ref105$repeat = _ref105.repeat,
            repeat = _ref105$repeat === void 0 ? 0 : _ref105$repeat,
            _ref105$repeatType = _ref105.repeatType,
            repeatType = _ref105$repeatType === void 0 ? "loop" : _ref105$repeatType,
            _ref105$ease = _ref105.ease,
            ease = _ref105$ease === void 0 ? "easeInOut" : _ref105$ease,
            times = _ref105.times;
          var keyframeOptions = _defineProperty2({}, valueName, keyframes);
          if (times) keyframeOptions.offset = times;
          var easing = mapEasingToNativeEasing(ease, duration);
          /**
           * If this is an easing array, apply to keyframes, not animation as a whole
           */
          if (Array.isArray(easing)) keyframeOptions.easing = easing;
          return element.animate(keyframeOptions, {
            delay: delay,
            duration: duration,
            easing: !Array.isArray(easing) ? easing : "linear",
            fill: "both",
            iterations: repeat + 1,
            direction: repeatType === "reverse" ? "alternate" : "normal"
          });
        }
        var supportsWaapi = /*@__PURE__*/memo(function () {
          return Object.hasOwnProperty.call(Element.prototype, "animate");
        });

        /**
         * 10ms is chosen here as it strikes a balance between smooth
         * results (more than one keyframe per frame at 60fps) and
         * keyframe quantity.
         */
        var sampleDelta = 10; //ms
        /**
         * Implement a practical max duration for keyframe generation
         * to prevent infinite loops
         */
        var maxDuration = 20000;
        /**
         * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.
         * WAAPI doesn't support spring or function easings so we run these as JS animation before
         * handing off.
         */
        function requiresPregeneratedKeyframes(options) {
          return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
        }
        function pregenerateKeyframes(keyframes, options) {
          /**
           * Create a main-thread animation to pregenerate keyframes.
           * We sample this at regular intervals to generate keyframes that we then
           * linearly interpolate between.
           */
          var sampleAnimation = new MainThreadAnimation(_objectSpread3(_objectSpread3({}, options), {}, {
            keyframes: keyframes,
            repeat: 0,
            delay: 0,
            isGenerator: true
          }));
          var state = {
            done: false,
            value: keyframes[0]
          };
          var pregeneratedKeyframes = [];
          /**
           * Bail after 20 seconds of pre-generated keyframes as it's likely
           * we're heading for an infinite loop.
           */
          var t = 0;
          while (!state.done && t < maxDuration) {
            state = sampleAnimation.sample(t);
            pregeneratedKeyframes.push(state.value);
            t += sampleDelta;
          }
          return {
            times: undefined,
            keyframes: pregeneratedKeyframes,
            duration: t - sampleDelta,
            ease: "linear"
          };
        }
        var unsupportedEasingFunctions = {
          anticipate: anticipate,
          backInOut: backInOut,
          circInOut: circInOut
        };
        function isUnsupportedEase(key) {
          return key in unsupportedEasingFunctions;
        }
        var AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation2) {
          function AcceleratedAnimation(options) {
            var _this23;
            _classCallCheck(this, AcceleratedAnimation);
            _this23 = _callSuper(this, AcceleratedAnimation, [options]);
            var _this23$options = _this23.options,
              name = _this23$options.name,
              motionValue = _this23$options.motionValue,
              element = _this23$options.element,
              keyframes = _this23$options.keyframes;
            _this23.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {
              return _this23.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
            }, name, motionValue, element);
            _this23.resolver.scheduleResolve();
            return _this23;
          }
          _inherits(AcceleratedAnimation, _BaseAnimation2);
          return _createClass(AcceleratedAnimation, [{
            key: "initPlayback",
            value: function initPlayback(keyframes, finalKeyframe) {
              var _this24 = this;
              var _this$options5 = this.options,
                _this$options5$durati = _this$options5.duration,
                duration = _this$options5$durati === void 0 ? 300 : _this$options5$durati,
                times = _this$options5.times,
                ease = _this$options5.ease,
                type = _this$options5.type,
                motionValue = _this$options5.motionValue,
                name = _this$options5.name,
                startTime = _this$options5.startTime;
              /**
               * If element has since been unmounted, return false to indicate
               * the animation failed to initialised.
               */
              if (!motionValue.owner || !motionValue.owner.current) {
                return false;
              }
              /**
               * If the user has provided an easing function name that isn't supported
               * by WAAPI (like "anticipate"), we need to provide the corressponding
               * function. This will later get converted to a linear() easing function.
               */
              if (typeof ease === "string" && supportsLinearEasing() && isUnsupportedEase(ease)) {
                ease = unsupportedEasingFunctions[ease];
              }
              /**
               * If this animation needs pre-generated keyframes then generate.
               */
              if (requiresPregeneratedKeyframes(this.options)) {
                var _this$options6 = this.options,
                  onComplete = _this$options6.onComplete,
                  onUpdate = _this$options6.onUpdate,
                  _motionValue = _this$options6.motionValue,
                  element = _this$options6.element,
                  _options2 = _objectWithoutProperties2(_this$options6, _excluded10);
                var pregeneratedAnimation = pregenerateKeyframes(keyframes, _options2);
                keyframes = pregeneratedAnimation.keyframes;
                // If this is a very short animation, ensure we have
                // at least two keyframes to animate between as older browsers
                // can't animate between a single keyframe.
                if (keyframes.length === 1) {
                  keyframes[1] = keyframes[0];
                }
                duration = pregeneratedAnimation.duration;
                times = pregeneratedAnimation.times;
                ease = pregeneratedAnimation.ease;
                type = "keyframes";
              }
              var animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, _objectSpread3(_objectSpread3({}, this.options), {}, {
                duration: duration,
                times: times,
                ease: ease
              }));
              // Override the browser calculated startTime with one synchronised to other JS
              // and WAAPI animations starting this event loop.
              animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
              if (this.pendingTimeline) {
                _attachTimeline(animation, this.pendingTimeline);
                this.pendingTimeline = undefined;
              } else {
                /**
                 * Prefer the `onfinish` prop as it's more widely supported than
                 * the `finished` promise.
                 *
                 * Here, we synchronously set the provided MotionValue to the end
                 * keyframe. If we didn't, when the WAAPI animation is finished it would
                 * be removed from the element which would then revert to its old styles.
                 */
                animation.onfinish = function () {
                  var onComplete = _this24.options.onComplete;
                  motionValue.set(getFinalKeyframe(keyframes, _this24.options, finalKeyframe));
                  onComplete && onComplete();
                  _this24.cancel();
                  _this24.resolveFinishedPromise();
                };
              }
              return {
                animation: animation,
                duration: duration,
                times: times,
                type: type,
                ease: ease,
                keyframes: keyframes
              };
            }
          }, {
            key: "duration",
            get: function get() {
              var resolved = this.resolved;
              if (!resolved) return 0;
              var duration = resolved.duration;
              return millisecondsToSeconds(duration);
            }
          }, {
            key: "time",
            get: function get() {
              var resolved = this.resolved;
              if (!resolved) return 0;
              var animation = resolved.animation;
              return millisecondsToSeconds(animation.currentTime || 0);
            },
            set: function set(newTime) {
              var resolved = this.resolved;
              if (!resolved) return;
              var animation = resolved.animation;
              animation.currentTime = secondsToMilliseconds(newTime);
            }
          }, {
            key: "speed",
            get: function get() {
              var resolved = this.resolved;
              if (!resolved) return 1;
              var animation = resolved.animation;
              return animation.playbackRate;
            },
            set: function set(newSpeed) {
              var resolved = this.resolved;
              if (!resolved) return;
              var animation = resolved.animation;
              animation.playbackRate = newSpeed;
            }
          }, {
            key: "state",
            get: function get() {
              var resolved = this.resolved;
              if (!resolved) return "idle";
              var animation = resolved.animation;
              return animation.playState;
            }
          }, {
            key: "startTime",
            get: function get() {
              var resolved = this.resolved;
              if (!resolved) return null;
              var animation = resolved.animation;
              // Coerce to number as TypeScript incorrectly types this
              // as CSSNumberish
              return animation.startTime;
            }
            /**
             * Replace the default DocumentTimeline with another AnimationTimeline.
             * Currently used for scroll animations.
             */
          }, {
            key: "attachTimeline",
            value: function attachTimeline(timeline) {
              if (!this._resolved) {
                this.pendingTimeline = timeline;
              } else {
                var resolved = this.resolved;
                if (!resolved) return noop$2;
                var animation = resolved.animation;
                _attachTimeline(animation, timeline);
              }
              return noop$2;
            }
          }, {
            key: "play",
            value: function play() {
              if (this.isStopped) return;
              var resolved = this.resolved;
              if (!resolved) return;
              var animation = resolved.animation;
              if (animation.playState === "finished") {
                this.updateFinishedPromise();
              }
              animation.play();
            }
          }, {
            key: "pause",
            value: function pause() {
              var resolved = this.resolved;
              if (!resolved) return;
              var animation = resolved.animation;
              animation.pause();
            }
          }, {
            key: "stop",
            value: function stop() {
              this.resolver.cancel();
              this.isStopped = true;
              if (this.state === "idle") return;
              this.resolveFinishedPromise();
              this.updateFinishedPromise();
              var resolved = this.resolved;
              if (!resolved) return;
              var animation = resolved.animation,
                keyframes = resolved.keyframes,
                duration = resolved.duration,
                type = resolved.type,
                ease = resolved.ease,
                times = resolved.times;
              if (animation.playState === "idle" || animation.playState === "finished") {
                return;
              }
              /**
               * WAAPI doesn't natively have any interruption capabilities.
               *
               * Rather than read commited styles back out of the DOM, we can
               * create a renderless JS animation and sample it twice to calculate
               * its current value, "previous" value, and therefore allow
               * Motion to calculate velocity for any subsequent animation.
               */
              if (this.time) {
                var _this$options7 = this.options,
                  _motionValue2 = _this$options7.motionValue,
                  onUpdate = _this$options7.onUpdate,
                  onComplete = _this$options7.onComplete,
                  element = _this$options7.element,
                  _options3 = _objectWithoutProperties2(_this$options7, _excluded11);
                var sampleAnimation = new MainThreadAnimation(_objectSpread3(_objectSpread3({}, _options3), {}, {
                  keyframes: keyframes,
                  duration: duration,
                  type: type,
                  ease: ease,
                  times: times,
                  isGenerator: true
                }));
                var sampleTime = secondsToMilliseconds(this.time);
                _motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
              }
              var onStop = this.options.onStop;
              onStop && onStop();
              this.cancel();
            }
          }, {
            key: "complete",
            value: function complete() {
              var resolved = this.resolved;
              if (!resolved) return;
              resolved.animation.finish();
            }
          }, {
            key: "cancel",
            value: function cancel() {
              var resolved = this.resolved;
              if (!resolved) return;
              resolved.animation.cancel();
            }
          }], [{
            key: "supports",
            value: function supports(options) {
              var motionValue = options.motionValue,
                name = options.name,
                repeatDelay = options.repeatDelay,
                repeatType = options.repeatType,
                damping = options.damping,
                type = options.type;
              if (!motionValue || !motionValue.owner || !(motionValue.owner.current instanceof HTMLElement)) {
                return false;
              }
              var _motionValue$owner$ge = motionValue.owner.getProps(),
                onUpdate = _motionValue$owner$ge.onUpdate,
                transformTemplate = _motionValue$owner$ge.transformTemplate;
              return supportsWaapi() && name && acceleratedValues.has(name) &&
              /**
               * If we're outputting values to onUpdate then we can't use WAAPI as there's
               * no way to read the value from WAAPI every frame.
               */
              !onUpdate && !transformTemplate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
            }
          }]);
        }(BaseAnimation);
        var underDampedSpring = {
          type: "spring",
          stiffness: 500,
          damping: 25,
          restSpeed: 10
        };
        var criticallyDampedSpring = function criticallyDampedSpring(target) {
          return {
            type: "spring",
            stiffness: 550,
            damping: target === 0 ? 2 * Math.sqrt(550) : 30,
            restSpeed: 10
          };
        };
        var keyframesTransition = {
          type: "keyframes",
          duration: 0.8
        };
        /**
         * Default easing curve is a slightly shallower version of
         * the default browser easing curve.
         */
        var ease = {
          type: "keyframes",
          ease: [0.25, 0.1, 0.35, 1],
          duration: 0.3
        };
        var getDefaultTransition = function getDefaultTransition(valueKey, _ref106) {
          var keyframes = _ref106.keyframes;
          if (keyframes.length > 2) {
            return keyframesTransition;
          } else if (transformProps.has(valueKey)) {
            return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;
          }
          return ease;
        };

        /**
         * Decide whether a transition is defined on a given Transition.
         * This filters out orchestration options and returns true
         * if any options are left.
         */
        function isTransitionDefined(_ref107) {
          var when = _ref107.when,
            _delay = _ref107.delay,
            delayChildren = _ref107.delayChildren,
            staggerChildren = _ref107.staggerChildren,
            staggerDirection = _ref107.staggerDirection,
            repeat = _ref107.repeat,
            repeatType = _ref107.repeatType,
            repeatDelay = _ref107.repeatDelay,
            from = _ref107.from,
            elapsed = _ref107.elapsed,
            transition = _objectWithoutProperties2(_ref107, _excluded12);
          return !!Object.keys(transition).length;
        }
        var animateMotionValue = function animateMotionValue(name, value, target) {
          var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var element = arguments.length > 4 ? arguments[4] : undefined;
          var isHandoff = arguments.length > 5 ? arguments[5] : undefined;
          return function (_onComplete) {
            var valueTransition = getValueTransition(transition, name) || {};
            /**
             * Most transition values are currently completely overwritten by value-specific
             * transitions. In the future it'd be nicer to blend these transitions. But for now
             * delay actually does inherit from the root transition if not value-specific.
             */
            var delay = valueTransition.delay || transition.delay || 0;
            /**
             * Elapsed isn't a public transition option but can be passed through from
             * optimized appear effects in milliseconds.
             */
            var _transition$elapsed = transition.elapsed,
              elapsed = _transition$elapsed === void 0 ? 0 : _transition$elapsed;
            elapsed = elapsed - secondsToMilliseconds(delay);
            var options = _objectSpread3(_objectSpread3({
              keyframes: Array.isArray(target) ? target : [null, target],
              ease: "easeOut",
              velocity: value.getVelocity()
            }, valueTransition), {}, {
              delay: -elapsed,
              onUpdate: function onUpdate(v) {
                value.set(v);
                valueTransition.onUpdate && valueTransition.onUpdate(v);
              },
              onComplete: function onComplete() {
                _onComplete();
                valueTransition.onComplete && valueTransition.onComplete();
              },
              name: name,
              motionValue: value,
              element: isHandoff ? undefined : element
            });
            /**
             * If there's no transition defined for this value, we can generate
             * unqiue transition settings for this value.
             */
            if (!isTransitionDefined(valueTransition)) {
              options = _objectSpread3(_objectSpread3({}, options), getDefaultTransition(name, options));
            }
            /**
             * Both WAAPI and our internal animation functions use durations
             * as defined by milliseconds, while our external API defines them
             * as seconds.
             */
            if (options.duration) {
              options.duration = secondsToMilliseconds(options.duration);
            }
            if (options.repeatDelay) {
              options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
            }
            if (options.from !== undefined) {
              options.keyframes[0] = options.from;
            }
            var shouldSkip = false;
            if (options.type === false || options.duration === 0 && !options.repeatDelay) {
              options.duration = 0;
              if (options.delay === 0) {
                shouldSkip = true;
              }
            }
            /**
             * If we can or must skip creating the animation, and apply only
             * the final keyframe, do so. We also check once keyframes are resolved but
             * this early check prevents the need to create an animation at all.
             */
            if (shouldSkip && !isHandoff && value.get() !== undefined) {
              var finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
              if (finalKeyframe !== undefined) {
                frame.update(function () {
                  options.onUpdate(finalKeyframe);
                  options.onComplete();
                });
                // We still want to return some animation controls here rather
                // than returning undefined
                return new GroupPlaybackControls([]);
              }
            }
            /**
             * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via
             * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
             * optimised animation.
             */
            if (!isHandoff && AcceleratedAnimation.supports(options)) {
              return new AcceleratedAnimation(options);
            } else {
              return new MainThreadAnimation(options);
            }
          };
        };

        /**
         * Decide whether we should block this animation. Previously, we achieved this
         * just by checking whether the key was listed in protectedKeys, but this
         * posed problems if an animation was triggered by afterChildren and protectedKeys
         * had been set to true in the meantime.
         */
        function shouldBlockAnimation(_ref108, key) {
          var protectedKeys = _ref108.protectedKeys,
            needsAnimating = _ref108.needsAnimating;
          var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
          needsAnimating[key] = false;
          return shouldBlock;
        }
        function animateTarget(visualElement, targetAndTransition) {
          var _ref109 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref109$delay = _ref109.delay,
            delay = _ref109$delay === void 0 ? 0 : _ref109$delay,
            transitionOverride = _ref109.transitionOverride,
            type = _ref109.type;
          var _a;
          var _targetAndTransition$ = targetAndTransition.transition,
            transition = _targetAndTransition$ === void 0 ? visualElement.getDefaultTransition() : _targetAndTransition$,
            transitionEnd = targetAndTransition.transitionEnd,
            target = _objectWithoutProperties2(targetAndTransition, _excluded13);
          if (transitionOverride) transition = transitionOverride;
          var animations = [];
          var animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
          for (var _key52 in target) {
            var value = visualElement.getValue(_key52, (_a = visualElement.latestValues[_key52]) !== null && _a !== void 0 ? _a : null);
            var valueTarget = target[_key52];
            if (valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, _key52)) {
              continue;
            }
            var valueTransition = _objectSpread3({
              delay: delay
            }, getValueTransition(transition || {}, _key52));
            /**
             * If this is the first time a value is being animated, check
             * to see if we're handling off from an existing animation.
             */
            var isHandoff = false;
            if (window.MotionHandoffAnimation) {
              var appearId = getOptimisedAppearId(visualElement);
              if (appearId) {
                var startTime = window.MotionHandoffAnimation(appearId, _key52, frame);
                if (startTime !== null) {
                  valueTransition.startTime = startTime;
                  isHandoff = true;
                }
              }
            }
            addValueToWillChange(visualElement, _key52);
            value.start(animateMotionValue(_key52, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(_key52) ? {
              type: false
            } : valueTransition, visualElement, isHandoff));
            var animation = value.animation;
            if (animation) {
              animations.push(animation);
            }
          }
          if (transitionEnd) {
            Promise.all(animations).then(function () {
              frame.update(function () {
                transitionEnd && setTarget(visualElement, transitionEnd);
              });
            });
          }
          return animations;
        }
        function animateVariant(visualElement, variant) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _a;
          var resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);
          var _ref110 = resolved || {},
            _ref110$transition = _ref110.transition,
            transition = _ref110$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref110$transition;
          if (options.transitionOverride) {
            transition = options.transitionOverride;
          }
          /**
           * If we have a variant, create a callback that runs it as an animation.
           * Otherwise, we resolve a Promise immediately for a composable no-op.
           */
          var getAnimation = resolved ? function () {
            return Promise.all(animateTarget(visualElement, resolved, options));
          } : function () {
            return Promise.resolve();
          };
          /**
           * If we have children, create a callback that runs all their animations.
           * Otherwise, we resolve a Promise immediately for a composable no-op.
           */
          var getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {
            var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var _transition2 = transition,
              _transition2$delayChi = _transition2.delayChildren,
              delayChildren = _transition2$delayChi === void 0 ? 0 : _transition2$delayChi,
              staggerChildren = _transition2.staggerChildren,
              staggerDirection = _transition2.staggerDirection;
            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
          } : function () {
            return Promise.resolve();
          };
          /**
           * If the transition explicitly defines a "when" option, we need to resolve either
           * this animation or all children animations before playing the other.
           */
          var _transition3 = transition,
            when = _transition3.when;
          if (when) {
            var _ref111 = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],
              _ref112 = _slicedToArray(_ref111, 2),
              first = _ref112[0],
              last = _ref112[1];
            return first().then(function () {
              return last();
            });
          } else {
            return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
          }
        }
        function animateChildren(visualElement, variant) {
          var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
          var options = arguments.length > 5 ? arguments[5] : undefined;
          var animations = [];
          var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
          var generateStaggerDuration = staggerDirection === 1 ? function () {
            var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return i * staggerChildren;
          } : function () {
            var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return maxStaggerDuration - i * staggerChildren;
          };
          Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {
            child.notify("AnimationStart", variant);
            animations.push(animateVariant(child, variant, _objectSpread3(_objectSpread3({}, options), {}, {
              delay: delayChildren + generateStaggerDuration(i)
            })).then(function () {
              return child.notify("AnimationComplete", variant);
            }));
          });
          return Promise.all(animations);
        }
        function sortByTreeOrder(a, b) {
          return a.sortNodePosition(b);
        }
        function animateVisualElement(visualElement, definition) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          visualElement.notify("AnimationStart", definition);
          var animation;
          if (Array.isArray(definition)) {
            var _animations = definition.map(function (variant) {
              return animateVariant(visualElement, variant, options);
            });
            animation = Promise.all(_animations);
          } else if (typeof definition === "string") {
            animation = animateVariant(visualElement, definition, options);
          } else {
            var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
            animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
          }
          return animation.then(function () {
            visualElement.notify("AnimationComplete", definition);
          });
        }
        var numVariantProps = variantProps.length;
        function getVariantContext(visualElement) {
          if (!visualElement) return undefined;
          if (!visualElement.isControllingVariants) {
            var _context3 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
            if (visualElement.props.initial !== undefined) {
              _context3.initial = visualElement.props.initial;
            }
            return _context3;
          }
          var context = {};
          for (var i = 0; i < numVariantProps; i++) {
            var name = variantProps[i];
            var prop = visualElement.props[name];
            if (isVariantLabel(prop) || prop === false) {
              context[name] = prop;
            }
          }
          return context;
        }
        var reversePriorityOrder = [].concat(variantPriorityOrder).reverse();
        var numAnimationTypes = variantPriorityOrder.length;
        function animateList(visualElement) {
          return function (animations) {
            return Promise.all(animations.map(function (_ref113) {
              var animation = _ref113.animation,
                options = _ref113.options;
              return animateVisualElement(visualElement, animation, options);
            }));
          };
        }
        function createAnimationState(visualElement) {
          var animate = animateList(visualElement);
          var state = createState();
          var isInitialRender = true;
          /**
           * This function will be used to reduce the animation definitions for
           * each active animation type into an object of resolved values for it.
           */
          var buildResolvedTypeValues = function buildResolvedTypeValues(type) {
            return function (acc, definition) {
              var _a;
              var resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);
              if (resolved) {
                var _transition4 = resolved.transition,
                  transitionEnd = resolved.transitionEnd,
                  target = _objectWithoutProperties2(resolved, _excluded14);
                acc = _objectSpread3(_objectSpread3(_objectSpread3({}, acc), target), transitionEnd);
              }
              return acc;
            };
          };
          /**
           * This just allows us to inject mocked animation functions
           * @internal
           */
          function setAnimateFunction(makeAnimator) {
            animate = makeAnimator(visualElement);
          }
          /**
           * When we receive new props, we need to:
           * 1. Create a list of protected keys for each type. This is a directory of
           *    value keys that are currently being "handled" by types of a higher priority
           *    so that whenever an animation is played of a given type, these values are
           *    protected from being animated.
           * 2. Determine if an animation type needs animating.
           * 3. Determine if any values have been removed from a type and figure out
           *    what to animate those to.
           */
          function animateChanges(changedActiveType) {
            var props = visualElement.props;
            var context = getVariantContext(visualElement.parent) || {};
            /**
             * A list of animations that we'll build into as we iterate through the animation
             * types. This will get executed at the end of the function.
             */
            var animations = [];
            /**
             * Keep track of which values have been removed. Then, as we hit lower priority
             * animation types, we can check if they contain removed values and animate to that.
             */
            var removedKeys = new Set();
            /**
             * A dictionary of all encountered keys. This is an object to let us build into and
             * copy it without iteration. Each time we hit an animation type we set its protected
             * keys - the keys its not allowed to animate - to the latest version of this object.
             */
            var encounteredKeys = {};
            /**
             * If a variant has been removed at a given index, and this component is controlling
             * variant animations, we want to ensure lower-priority variants are forced to animate.
             */
            var removedVariantIndex = Infinity;
            /**
             * Iterate through all animation types in reverse priority order. For each, we want to
             * detect which values it's handling and whether or not they've changed (and therefore
             * need to be animated). If any values have been removed, we want to detect those in
             * lower priority props and flag for animation.
             */
            var _loop7 = function _loop7() {
              var type = reversePriorityOrder[i];
              var typeState = state[type];
              var prop = props[type] !== undefined ? props[type] : context[type];
              var propIsVariant = isVariantLabel(prop);
              /**
               * If this type has *just* changed isActive status, set activeDelta
               * to that status. Otherwise set to null.
               */
              var activeDelta = type === changedActiveType ? typeState.isActive : null;
              if (activeDelta === false) removedVariantIndex = i;
              /**
               * If this prop is an inherited variant, rather than been set directly on the
               * component itself, we want to make sure we allow the parent to trigger animations.
               *
               * TODO: Can probably change this to a !isControllingVariants check
               */
              var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
              /**
               *
               */
              if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
                isInherited = false;
              }
              /**
               * Set all encountered keys so far as the protected keys for this type. This will
               * be any key that has been animated or otherwise handled by active, higher-priortiy types.
               */
              typeState.protectedKeys = _objectSpread3({}, encounteredKeys);
              // Check if we can skip analysing this prop early
              if (
              // If it isn't active and hasn't *just* been set as inactive
              !typeState.isActive && activeDelta === null ||
              // If we didn't and don't have any defined prop for this animation type
              !prop && !typeState.prevProp ||
              // Or if the prop doesn't define an animation
              isAnimationControls(prop) || typeof prop === "boolean") {
                return 1; // continue
              }
              /**
               * As we go look through the values defined on this type, if we detect
               * a changed value or a value that was removed in a higher priority, we set
               * this to true and add this prop to the animation list.
               */
              var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
              var shouldAnimateType = variantDidChange ||
              // If we're making this variant active, we want to always make it active
              type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
              // If we removed a higher-priority variant (i is in reverse order)
              i > removedVariantIndex && propIsVariant;
              var handledRemovedValues = false;
              /**
               * As animations can be set as variant lists, variants or target objects, we
               * coerce everything to an array if it isn't one already
               */
              var definitionList = Array.isArray(prop) ? prop : [prop];
              /**
               * Build an object of all the resolved values. We'll use this in the subsequent
               * animateChanges calls to determine whether a value has changed.
               */
              var resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
              if (activeDelta === false) resolvedValues = {};
              /**
               * Now we need to loop through all the keys in the prev prop and this prop,
               * and decide:
               * 1. If the value has changed, and needs animating
               * 2. If it has been removed, and needs adding to the removedKeys set
               * 3. If it has been removed in a higher priority type and needs animating
               * 4. If it hasn't been removed in a higher priority but hasn't changed, and
               *    needs adding to the type's protectedKeys list.
               */
              var _typeState$prevResolv = typeState.prevResolvedValues,
                prevResolvedValues = _typeState$prevResolv === void 0 ? {} : _typeState$prevResolv;
              var allKeys = _objectSpread3(_objectSpread3({}, prevResolvedValues), resolvedValues);
              var markToAnimate = function markToAnimate(key) {
                shouldAnimateType = true;
                if (removedKeys.has(key)) {
                  handledRemovedValues = true;
                  removedKeys.delete(key);
                }
                typeState.needsAnimating[key] = true;
                var motionValue = visualElement.getValue(key);
                if (motionValue) motionValue.liveStyle = false;
              };
              for (var _key53 in allKeys) {
                var _next2 = resolvedValues[_key53];
                var _prev = prevResolvedValues[_key53];
                // If we've already handled this we can just skip ahead
                if (encounteredKeys.hasOwnProperty(_key53)) continue;
                /**
                 * If the value has changed, we probably want to animate it.
                 */
                var valueHasChanged = false;
                if (isKeyframesTarget(_next2) && isKeyframesTarget(_prev)) {
                  valueHasChanged = !shallowCompare(_next2, _prev);
                } else {
                  valueHasChanged = _next2 !== _prev;
                }
                if (valueHasChanged) {
                  if (_next2 !== undefined && _next2 !== null) {
                    // If next is defined and doesn't equal prev, it needs animating
                    markToAnimate(_key53);
                  } else {
                    // If it's undefined, it's been removed.
                    removedKeys.add(_key53);
                  }
                } else if (_next2 !== undefined && removedKeys.has(_key53)) {
                  /**
                   * If next hasn't changed and it isn't undefined, we want to check if it's
                   * been removed by a higher priority
                   */
                  markToAnimate(_key53);
                } else {
                  /**
                   * If it hasn't changed, we add it to the list of protected values
                   * to ensure it doesn't get animated.
                   */
                  typeState.protectedKeys[_key53] = true;
                }
              }
              /**
               * Update the typeState so next time animateChanges is called we can compare the
               * latest prop and resolvedValues to these.
               */
              typeState.prevProp = prop;
              typeState.prevResolvedValues = resolvedValues;
              /**
               *
               */
              if (typeState.isActive) {
                encounteredKeys = _objectSpread3(_objectSpread3({}, encounteredKeys), resolvedValues);
              }
              if (isInitialRender && visualElement.blockInitialAnimation) {
                shouldAnimateType = false;
              }
              /**
               * If this is an inherited prop we want to skip this animation
               * unless the inherited variants haven't changed on this render.
               */
              var willAnimateViaParent = isInherited && variantDidChange;
              var needsAnimating = !willAnimateViaParent || handledRemovedValues;
              if (shouldAnimateType && needsAnimating) {
                animations.push.apply(animations, _toConsumableArray(definitionList.map(function (animation) {
                  return {
                    animation: animation,
                    options: {
                      type: type
                    }
                  };
                })));
              }
            };
            for (var i = 0; i < numAnimationTypes; i++) {
              if (_loop7()) continue;
            }
            /**
             * If there are some removed value that haven't been dealt with,
             * we need to create a new animation that falls back either to the value
             * defined in the style prop, or the last read value.
             */
            if (removedKeys.size) {
              var fallbackAnimation = {};
              removedKeys.forEach(function (key) {
                var fallbackTarget = visualElement.getBaseTarget(key);
                var motionValue = visualElement.getValue(key);
                if (motionValue) motionValue.liveStyle = true;
                // @ts-expect-error - @mattgperry to figure if we should do something here
                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
              });
              animations.push({
                animation: fallbackAnimation
              });
            }
            var shouldAnimate = Boolean(animations.length);
            if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
              shouldAnimate = false;
            }
            isInitialRender = false;
            return shouldAnimate ? animate(animations) : Promise.resolve();
          }
          /**
           * Change whether a certain animation type is active.
           */
          function setActive(type, isActive) {
            var _a;
            // If the active state hasn't changed, we can safely do nothing here
            if (state[type].isActive === isActive) return Promise.resolve();
            // Propagate active change to children
            (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
              var _a;
              return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);
            });
            state[type].isActive = isActive;
            var animations = animateChanges(type);
            for (var _key54 in state) {
              state[_key54].protectedKeys = {};
            }
            return animations;
          }
          return {
            animateChanges: animateChanges,
            setActive: setActive,
            setAnimateFunction: setAnimateFunction,
            getState: function getState() {
              return state;
            },
            reset: function reset() {
              state = createState();
              isInitialRender = true;
            }
          };
        }
        function checkVariantsDidChange(prev, next) {
          if (typeof next === "string") {
            return next !== prev;
          } else if (Array.isArray(next)) {
            return !shallowCompare(next, prev);
          }
          return false;
        }
        function createTypeState() {
          var isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          return {
            isActive: isActive,
            protectedKeys: {},
            needsAnimating: {},
            prevResolvedValues: {}
          };
        }
        function createState() {
          return {
            animate: createTypeState(true),
            whileInView: createTypeState(),
            whileHover: createTypeState(),
            whileTap: createTypeState(),
            whileDrag: createTypeState(),
            whileFocus: createTypeState(),
            exit: createTypeState()
          };
        }
        var Feature = /*#__PURE__*/function () {
          function Feature(node) {
            _classCallCheck(this, Feature);
            this.isMounted = false;
            this.node = node;
          }
          return _createClass(Feature, [{
            key: "update",
            value: function update() {}
          }]);
        }();
        var AnimationFeature = /*#__PURE__*/function (_Feature) {
          /**
           * We dynamically generate the AnimationState manager as it contains a reference
           * to the underlying animation library. We only want to load that if we load this,
           * so people can optionally code split it out using the `m` component.
           */
          function AnimationFeature(node) {
            var _this25;
            _classCallCheck(this, AnimationFeature);
            _this25 = _callSuper(this, AnimationFeature, [node]);
            node.animationState || (node.animationState = createAnimationState(node));
            return _this25;
          }
          _inherits(AnimationFeature, _Feature);
          return _createClass(AnimationFeature, [{
            key: "updateAnimationControlsSubscription",
            value: function updateAnimationControlsSubscription() {
              var _this$node$getProps = this.node.getProps(),
                animate = _this$node$getProps.animate;
              if (isAnimationControls(animate)) {
                this.unmountControls = animate.subscribe(this.node);
              }
            }
            /**
             * Subscribe any provided AnimationControls to the component's VisualElement
             */
          }, {
            key: "mount",
            value: function mount() {
              this.updateAnimationControlsSubscription();
            }
          }, {
            key: "update",
            value: function update() {
              var _this$node$getProps2 = this.node.getProps(),
                animate = _this$node$getProps2.animate;
              var _ref114 = this.node.prevProps || {},
                prevAnimate = _ref114.animate;
              if (animate !== prevAnimate) {
                this.updateAnimationControlsSubscription();
              }
            }
          }, {
            key: "unmount",
            value: function unmount() {
              var _a;
              this.node.animationState.reset();
              (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
            }
          }]);
        }(Feature);
        var id$1 = 0;
        var ExitAnimationFeature = /*#__PURE__*/function (_Feature2) {
          function ExitAnimationFeature() {
            var _this26;
            _classCallCheck(this, ExitAnimationFeature);
            _this26 = _callSuper(this, ExitAnimationFeature, arguments);
            _this26.id = id$1++;
            return _this26;
          }
          _inherits(ExitAnimationFeature, _Feature2);
          return _createClass(ExitAnimationFeature, [{
            key: "update",
            value: function update() {
              var _this27 = this;
              if (!this.node.presenceContext) return;
              var _this$node$presenceCo = this.node.presenceContext,
                isPresent = _this$node$presenceCo.isPresent,
                onExitComplete = _this$node$presenceCo.onExitComplete;
              var _ref115 = this.node.prevPresenceContext || {},
                prevIsPresent = _ref115.isPresent;
              if (!this.node.animationState || isPresent === prevIsPresent) {
                return;
              }
              var exitAnimation = this.node.animationState.setActive("exit", !isPresent);
              if (onExitComplete && !isPresent) {
                exitAnimation.then(function () {
                  return onExitComplete(_this27.id);
                });
              }
            }
          }, {
            key: "mount",
            value: function mount() {
              var _ref116 = this.node.presenceContext || {},
                register = _ref116.register;
              if (register) {
                this.unmount = register(this.id);
              }
            }
          }, {
            key: "unmount",
            value: function unmount() {}
          }]);
        }(Feature);
        var animations = {
          animation: {
            Feature: AnimationFeature
          },
          exit: {
            Feature: ExitAnimationFeature
          }
        };
        function addDomEvent(target, eventName, handler) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
            passive: true
          };
          target.addEventListener(eventName, handler, options);
          return function () {
            return target.removeEventListener(eventName, handler);
          };
        }
        function extractEventInfo(event) {
          return {
            point: {
              x: event.pageX,
              y: event.pageY
            }
          };
        }
        var addPointerInfo = function addPointerInfo(handler) {
          return function (event) {
            return isPrimaryPointer(event) && handler(event, extractEventInfo(event));
          };
        };
        function addPointerEvent(target, eventName, handler, options) {
          return addDomEvent(target, eventName, addPointerInfo(handler), options);
        }
        var distance = function distance(a, b) {
          return Math.abs(a - b);
        };
        function distance2D(a, b) {
          // Multi-dimensional
          var xDelta = distance(a.x, b.x);
          var yDelta = distance(a.y, b.y);
          return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2));
        }

        /**
         * @internal
         */
        var PanSession = /*#__PURE__*/function () {
          function PanSession(event, handlers) {
            var _this28 = this;
            var _ref117 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              transformPagePoint = _ref117.transformPagePoint,
              contextWindow = _ref117.contextWindow,
              _ref117$dragSnapToOri = _ref117.dragSnapToOrigin,
              dragSnapToOrigin = _ref117$dragSnapToOri === void 0 ? false : _ref117$dragSnapToOri;
            _classCallCheck(this, PanSession);
            /**
             * @internal
             */
            this.startEvent = null;
            /**
             * @internal
             */
            this.lastMoveEvent = null;
            /**
             * @internal
             */
            this.lastMoveEventInfo = null;
            /**
             * @internal
             */
            this.handlers = {};
            /**
             * @internal
             */
            this.contextWindow = window;
            this.updatePoint = function () {
              if (!(_this28.lastMoveEvent && _this28.lastMoveEventInfo)) return;
              var info = getPanInfo(_this28.lastMoveEventInfo, _this28.history);
              var isPanStarted = _this28.startEvent !== null;
              // Only start panning if the offset is larger than 3 pixels. If we make it
              // any larger than this we'll want to reset the pointer history
              // on the first update to avoid visual snapping to the cursoe.
              var isDistancePastThreshold = distance2D(info.offset, {
                x: 0,
                y: 0
              }) >= 3;
              if (!isPanStarted && !isDistancePastThreshold) return;
              var point = info.point;
              var timestamp = frameData.timestamp;
              _this28.history.push(_objectSpread3(_objectSpread3({}, point), {}, {
                timestamp: timestamp
              }));
              var _this28$handlers = _this28.handlers,
                onStart = _this28$handlers.onStart,
                onMove = _this28$handlers.onMove;
              if (!isPanStarted) {
                onStart && onStart(_this28.lastMoveEvent, info);
                _this28.startEvent = _this28.lastMoveEvent;
              }
              onMove && onMove(_this28.lastMoveEvent, info);
            };
            this.handlePointerMove = function (event, info) {
              _this28.lastMoveEvent = event;
              _this28.lastMoveEventInfo = transformPoint(info, _this28.transformPagePoint);
              // Throttle mouse move event to once per frame
              frame.update(_this28.updatePoint, true);
            };
            this.handlePointerUp = function (event, info) {
              _this28.end();
              var _this28$handlers2 = _this28.handlers,
                onEnd = _this28$handlers2.onEnd,
                onSessionEnd = _this28$handlers2.onSessionEnd,
                resumeAnimation = _this28$handlers2.resumeAnimation;
              if (_this28.dragSnapToOrigin) resumeAnimation && resumeAnimation();
              if (!(_this28.lastMoveEvent && _this28.lastMoveEventInfo)) return;
              var panInfo = getPanInfo(event.type === "pointercancel" ? _this28.lastMoveEventInfo : transformPoint(info, _this28.transformPagePoint), _this28.history);
              if (_this28.startEvent && onEnd) {
                onEnd(event, panInfo);
              }
              onSessionEnd && onSessionEnd(event, panInfo);
            };
            // If we have more than one touch, don't start detecting this gesture
            if (!isPrimaryPointer(event)) return;
            this.dragSnapToOrigin = dragSnapToOrigin;
            this.handlers = handlers;
            this.transformPagePoint = transformPagePoint;
            this.contextWindow = contextWindow || window;
            var info = extractEventInfo(event);
            var initialInfo = transformPoint(info, this.transformPagePoint);
            var point = initialInfo.point;
            var timestamp = frameData.timestamp;
            this.history = [_objectSpread3(_objectSpread3({}, point), {}, {
              timestamp: timestamp
            })];
            var onSessionStart = handlers.onSessionStart;
            onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
            this.removeListeners = pipe$1(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
          }
          return _createClass(PanSession, [{
            key: "updateHandlers",
            value: function updateHandlers(handlers) {
              this.handlers = handlers;
            }
          }, {
            key: "end",
            value: function end() {
              this.removeListeners && this.removeListeners();
              cancelFrame(this.updatePoint);
            }
          }]);
        }();
        function transformPoint(info, transformPagePoint) {
          return transformPagePoint ? {
            point: transformPagePoint(info.point)
          } : info;
        }
        function subtractPoint(a, b) {
          return {
            x: a.x - b.x,
            y: a.y - b.y
          };
        }
        function getPanInfo(_ref118, history) {
          var point = _ref118.point;
          return {
            point: point,
            delta: subtractPoint(point, lastDevicePoint(history)),
            offset: subtractPoint(point, startDevicePoint(history)),
            velocity: getVelocity(history, 0.1)
          };
        }
        function startDevicePoint(history) {
          return history[0];
        }
        function lastDevicePoint(history) {
          return history[history.length - 1];
        }
        function getVelocity(history, timeDelta) {
          if (history.length < 2) {
            return {
              x: 0,
              y: 0
            };
          }
          var i = history.length - 1;
          var timestampedPoint = null;
          var lastPoint = lastDevicePoint(history);
          while (i >= 0) {
            timestampedPoint = history[i];
            if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
              break;
            }
            i--;
          }
          if (!timestampedPoint) {
            return {
              x: 0,
              y: 0
            };
          }
          var time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
          if (time === 0) {
            return {
              x: 0,
              y: 0
            };
          }
          var currentVelocity = {
            x: (lastPoint.x - timestampedPoint.x) / time,
            y: (lastPoint.y - timestampedPoint.y) / time
          };
          if (currentVelocity.x === Infinity) {
            currentVelocity.x = 0;
          }
          if (currentVelocity.y === Infinity) {
            currentVelocity.y = 0;
          }
          return currentVelocity;
        }
        var SCALE_PRECISION = 0.0001;
        var SCALE_MIN = 1 - SCALE_PRECISION;
        var SCALE_MAX = 1 + SCALE_PRECISION;
        var TRANSLATE_PRECISION = 0.01;
        var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
        var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
        function calcLength(axis) {
          return axis.max - axis.min;
        }
        function isNear(value, target, maxDistance) {
          return Math.abs(value - target) <= maxDistance;
        }
        function calcAxisDelta(delta, source, target) {
          var origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
          delta.origin = origin;
          delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
          delta.scale = calcLength(target) / calcLength(source);
          delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
          if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
            delta.scale = 1.0;
          }
          if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
            delta.translate = 0.0;
          }
        }
        function calcBoxDelta(delta, source, target, origin) {
          calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);
          calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);
        }
        function calcRelativeAxis(target, relative, parent) {
          target.min = parent.min + relative.min;
          target.max = target.min + calcLength(relative);
        }
        function calcRelativeBox(target, relative, parent) {
          calcRelativeAxis(target.x, relative.x, parent.x);
          calcRelativeAxis(target.y, relative.y, parent.y);
        }
        function calcRelativeAxisPosition(target, layout, parent) {
          target.min = layout.min - parent.min;
          target.max = target.min + calcLength(layout);
        }
        function calcRelativePosition(target, layout, parent) {
          calcRelativeAxisPosition(target.x, layout.x, parent.x);
          calcRelativeAxisPosition(target.y, layout.y, parent.y);
        }

        /**
         * Apply constraints to a point. These constraints are both physical along an
         * axis, and an elastic factor that determines how much to constrain the point
         * by if it does lie outside the defined parameters.
         */
        function applyConstraints(point, _ref119, elastic) {
          var min = _ref119.min,
            max = _ref119.max;
          if (min !== undefined && point < min) {
            // If we have a min point defined, and this is outside of that, constrain
            point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);
          } else if (max !== undefined && point > max) {
            // If we have a max point defined, and this is outside of that, constrain
            point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);
          }
          return point;
        }
        /**
         * Calculate constraints in terms of the viewport when defined relatively to the
         * measured axis. This is measured from the nearest edge, so a max constraint of 200
         * on an axis with a max value of 300 would return a constraint of 500 - axis length
         */
        function calcRelativeAxisConstraints(axis, min, max) {
          return {
            min: min !== undefined ? axis.min + min : undefined,
            max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined
          };
        }
        /**
         * Calculate constraints in terms of the viewport when
         * defined relatively to the measured bounding box.
         */
        function calcRelativeConstraints(layoutBox, _ref120) {
          var top = _ref120.top,
            left = _ref120.left,
            bottom = _ref120.bottom,
            right = _ref120.right;
          return {
            x: calcRelativeAxisConstraints(layoutBox.x, left, right),
            y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
          };
        }
        /**
         * Calculate viewport constraints when defined as another viewport-relative axis
         */
        function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
          var min = constraintsAxis.min - layoutAxis.min;
          var max = constraintsAxis.max - layoutAxis.max;
          // If the constraints axis is actually smaller than the layout axis then we can
          // flip the constraints
          if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
            var _ref121 = [max, min];
            min = _ref121[0];
            max = _ref121[1];
          }
          return {
            min: min,
            max: max
          };
        }
        /**
         * Calculate viewport constraints when defined as another viewport-relative box
         */
        function calcViewportConstraints(layoutBox, constraintsBox) {
          return {
            x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
            y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
          };
        }
        /**
         * Calculate a transform origin relative to the source axis, between 0-1, that results
         * in an asthetically pleasing scale/transform needed to project from source to target.
         */
        function calcOrigin(source, target) {
          var origin = 0.5;
          var sourceLength = calcLength(source);
          var targetLength = calcLength(target);
          if (targetLength > sourceLength) {
            origin = progress(target.min, target.max - sourceLength, source.min);
          } else if (sourceLength > targetLength) {
            origin = progress(source.min, source.max - targetLength, target.min);
          }
          return clamp(0, 1, origin);
        }
        /**
         * Rebase the calculated viewport constraints relative to the layout.min point.
         */
        function rebaseAxisConstraints(layout, constraints) {
          var relativeConstraints = {};
          if (constraints.min !== undefined) {
            relativeConstraints.min = constraints.min - layout.min;
          }
          if (constraints.max !== undefined) {
            relativeConstraints.max = constraints.max - layout.min;
          }
          return relativeConstraints;
        }
        var defaultElastic = 0.35;
        /**
         * Accepts a dragElastic prop and returns resolved elastic values for each axis.
         */
        function resolveDragElastic() {
          var dragElastic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElastic;
          if (dragElastic === false) {
            dragElastic = 0;
          } else if (dragElastic === true) {
            dragElastic = defaultElastic;
          }
          return {
            x: resolveAxisElastic(dragElastic, "left", "right"),
            y: resolveAxisElastic(dragElastic, "top", "bottom")
          };
        }
        function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
          return {
            min: resolvePointElastic(dragElastic, minLabel),
            max: resolvePointElastic(dragElastic, maxLabel)
          };
        }
        function resolvePointElastic(dragElastic, label) {
          return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
        }
        var createAxisDelta = function createAxisDelta() {
          return {
            translate: 0,
            scale: 1,
            origin: 0,
            originPoint: 0
          };
        };
        var createDelta = function createDelta() {
          return {
            x: createAxisDelta(),
            y: createAxisDelta()
          };
        };
        var createAxis = function createAxis() {
          return {
            min: 0,
            max: 0
          };
        };
        var createBox = function createBox() {
          return {
            x: createAxis(),
            y: createAxis()
          };
        };
        function eachAxis(callback) {
          return [callback("x"), callback("y")];
        }

        /**
         * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
         * it's easier to consider each axis individually. This function returns a bounding box
         * as a map of single-axis min/max values.
         */
        function convertBoundingBoxToBox(_ref122) {
          var top = _ref122.top,
            left = _ref122.left,
            right = _ref122.right,
            bottom = _ref122.bottom;
          return {
            x: {
              min: left,
              max: right
            },
            y: {
              min: top,
              max: bottom
            }
          };
        }
        function convertBoxToBoundingBox(_ref123) {
          var x = _ref123.x,
            y = _ref123.y;
          return {
            top: y.min,
            right: x.max,
            bottom: y.max,
            left: x.min
          };
        }
        /**
         * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
         * provided by Framer to allow measured points to be corrected for device scaling. This is used
         * when measuring DOM elements and DOM event points.
         */
        function transformBoxPoints(point, transformPoint) {
          if (!transformPoint) return point;
          var topLeft = transformPoint({
            x: point.left,
            y: point.top
          });
          var bottomRight = transformPoint({
            x: point.right,
            y: point.bottom
          });
          return {
            top: topLeft.y,
            left: topLeft.x,
            bottom: bottomRight.y,
            right: bottomRight.x
          };
        }
        function isIdentityScale(scale) {
          return scale === undefined || scale === 1;
        }
        function hasScale(_ref124) {
          var scale = _ref124.scale,
            scaleX = _ref124.scaleX,
            scaleY = _ref124.scaleY;
          return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
        }
        function hasTransform(values) {
          return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
        }
        function has2DTranslate(values) {
          return is2DTranslate(values.x) || is2DTranslate(values.y);
        }
        function is2DTranslate(value) {
          return value && value !== "0%";
        }

        /**
         * Scales a point based on a factor and an originPoint
         */
        function scalePoint(point, scale, originPoint) {
          var distanceFromOrigin = point - originPoint;
          var scaled = scale * distanceFromOrigin;
          return originPoint + scaled;
        }
        /**
         * Applies a translate/scale delta to a point
         */
        function applyPointDelta(point, translate, scale, originPoint, boxScale) {
          if (boxScale !== undefined) {
            point = scalePoint(point, boxScale, originPoint);
          }
          return scalePoint(point, scale, originPoint) + translate;
        }
        /**
         * Applies a translate/scale delta to an axis
         */
        function applyAxisDelta(axis) {
          var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var originPoint = arguments.length > 3 ? arguments[3] : undefined;
          var boxScale = arguments.length > 4 ? arguments[4] : undefined;
          axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
          axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
        }
        /**
         * Applies a translate/scale delta to a box
         */
        function applyBoxDelta(box, _ref125) {
          var x = _ref125.x,
            y = _ref125.y;
          applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
          applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
        }
        var TREE_SCALE_SNAP_MIN = 0.999999999999;
        var TREE_SCALE_SNAP_MAX = 1.0000000000001;
        /**
         * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
         * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
         *
         * This is the final nested loop within updateLayoutDelta for future refactoring
         */
        function applyTreeDeltas(box, treeScale, treePath) {
          var isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var treeLength = treePath.length;
          if (!treeLength) return;
          // Reset the treeScale
          treeScale.x = treeScale.y = 1;
          var node;
          var delta;
          for (var i = 0; i < treeLength; i++) {
            node = treePath[i];
            delta = node.projectionDelta;
            /**
             * TODO: Prefer to remove this, but currently we have motion components with
             * display: contents in Framer.
             */
            var visualElement = node.options.visualElement;
            if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
              continue;
            }
            if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
              transformBox(box, {
                x: -node.scroll.offset.x,
                y: -node.scroll.offset.y
              });
            }
            if (delta) {
              // Incoporate each ancestor's scale into a culmulative treeScale for this component
              treeScale.x *= delta.x.scale;
              treeScale.y *= delta.y.scale;
              // Apply each ancestor's calculated delta into this component's recorded layout box
              applyBoxDelta(box, delta);
            }
            if (isSharedTransition && hasTransform(node.latestValues)) {
              transformBox(box, node.latestValues);
            }
          }
          /**
           * Snap tree scale back to 1 if it's within a non-perceivable threshold.
           * This will help reduce useless scales getting rendered.
           */
          if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
            treeScale.x = 1.0;
          }
          if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
            treeScale.y = 1.0;
          }
        }
        function translateAxis(axis, distance) {
          axis.min = axis.min + distance;
          axis.max = axis.max + distance;
        }
        /**
         * Apply a transform to an axis from the latest resolved motion values.
         * This function basically acts as a bridge between a flat motion value map
         * and applyAxisDelta
         */
        function transformAxis(axis, axisTranslate, axisScale, boxScale) {
          var axisOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
          var originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
          // Apply the axis delta to the final axis
          applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
        }
        /**
         * Apply a transform to a box from the latest resolved motion values.
         */
        function transformBox(box, transform) {
          transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
          transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
        }
        function measureViewportBox(instance, transformPoint) {
          return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
        }
        function measurePageBox(element, rootProjectionNode, transformPagePoint) {
          var viewportBox = measureViewportBox(element, transformPagePoint);
          var scroll = rootProjectionNode.scroll;
          if (scroll) {
            translateAxis(viewportBox.x, scroll.offset.x);
            translateAxis(viewportBox.y, scroll.offset.y);
          }
          return viewportBox;
        }

        // Fixes https://github.com/motiondivision/motion/issues/2270
        var getContextWindow = function getContextWindow(_ref126) {
          var current = _ref126.current;
          return current ? current.ownerDocument.defaultView : null;
        };
        var elementDragControls = new WeakMap();
        /**
         *
         */
        // let latestPointerEvent: PointerEvent
        var VisualElementDragControls = /*#__PURE__*/function () {
          function VisualElementDragControls(visualElement) {
            _classCallCheck(this, VisualElementDragControls);
            this.openDragLock = null;
            this.isDragging = false;
            this.currentDirection = null;
            this.originPoint = {
              x: 0,
              y: 0
            };
            /**
             * The permitted boundaries of travel, in pixels.
             */
            this.constraints = false;
            this.hasMutatedConstraints = false;
            /**
             * The per-axis resolved elastic values.
             */
            this.elastic = createBox();
            this.visualElement = visualElement;
          }
          return _createClass(VisualElementDragControls, [{
            key: "start",
            value: function start(originEvent) {
              var _this29 = this;
              var _ref127 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                _ref127$snapToCursor = _ref127.snapToCursor,
                snapToCursor = _ref127$snapToCursor === void 0 ? false : _ref127$snapToCursor;
              /**
               * Don't start dragging if this component is exiting
               */
              var presenceContext = this.visualElement.presenceContext;
              if (presenceContext && presenceContext.isPresent === false) return;
              var onSessionStart = function onSessionStart(event) {
                var _this29$getProps = _this29.getProps(),
                  dragSnapToOrigin = _this29$getProps.dragSnapToOrigin;
                // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch
                // the component.
                dragSnapToOrigin ? _this29.pauseAnimation() : _this29.stopAnimation();
                if (snapToCursor) {
                  _this29.snapToCursor(extractEventInfo(event).point);
                }
              };
              var onStart = function onStart(event, info) {
                // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
                var _this29$getProps2 = _this29.getProps(),
                  drag = _this29$getProps2.drag,
                  dragPropagation = _this29$getProps2.dragPropagation,
                  onDragStart = _this29$getProps2.onDragStart;
                if (drag && !dragPropagation) {
                  if (_this29.openDragLock) _this29.openDragLock();
                  _this29.openDragLock = setDragLock(drag);
                  // If we don 't have the lock, don't start dragging
                  if (!_this29.openDragLock) return;
                }
                _this29.isDragging = true;
                _this29.currentDirection = null;
                _this29.resolveConstraints();
                if (_this29.visualElement.projection) {
                  _this29.visualElement.projection.isAnimationBlocked = true;
                  _this29.visualElement.projection.target = undefined;
                }
                /**
                 * Record gesture origin
                 */
                eachAxis(function (axis) {
                  var current = _this29.getAxisMotionValue(axis).get() || 0;
                  /**
                   * If the MotionValue is a percentage value convert to px
                   */
                  if (percent.test(current)) {
                    var projection = _this29.visualElement.projection;
                    if (projection && projection.layout) {
                      var measuredAxis = projection.layout.layoutBox[axis];
                      if (measuredAxis) {
                        var _length = calcLength(measuredAxis);
                        current = _length * (parseFloat(current) / 100);
                      }
                    }
                  }
                  _this29.originPoint[axis] = current;
                });
                // Fire onDragStart event
                if (onDragStart) {
                  frame.postRender(function () {
                    return onDragStart(event, info);
                  });
                }
                addValueToWillChange(_this29.visualElement, "transform");
                var animationState = _this29.visualElement.animationState;
                animationState && animationState.setActive("whileDrag", true);
              };
              var onMove = function onMove(event, info) {
                // latestPointerEvent = event
                var _this29$getProps3 = _this29.getProps(),
                  dragPropagation = _this29$getProps3.dragPropagation,
                  dragDirectionLock = _this29$getProps3.dragDirectionLock,
                  onDirectionLock = _this29$getProps3.onDirectionLock,
                  onDrag = _this29$getProps3.onDrag;
                // If we didn't successfully receive the gesture lock, early return.
                if (!dragPropagation && !_this29.openDragLock) return;
                var offset = info.offset;
                // Attempt to detect drag direction if directionLock is true
                if (dragDirectionLock && _this29.currentDirection === null) {
                  _this29.currentDirection = getCurrentDirection(offset);
                  // If we've successfully set a direction, notify listener
                  if (_this29.currentDirection !== null) {
                    onDirectionLock && onDirectionLock(_this29.currentDirection);
                  }
                  return;
                }
                // Update each point with the latest position
                _this29.updateAxis("x", info.point, offset);
                _this29.updateAxis("y", info.point, offset);
                /**
                 * Ideally we would leave the renderer to fire naturally at the end of
                 * this frame but if the element is about to change layout as the result
                 * of a re-render we want to ensure the browser can read the latest
                 * bounding box to ensure the pointer and element don't fall out of sync.
                 */
                _this29.visualElement.render();
                /**
                 * This must fire after the render call as it might trigger a state
                 * change which itself might trigger a layout update.
                 */
                onDrag && onDrag(event, info);
              };
              var onSessionEnd = function onSessionEnd(event, info) {
                return _this29.stop(event, info);
              };
              var resumeAnimation = function resumeAnimation() {
                return eachAxis(function (axis) {
                  var _a;
                  return _this29.getAnimationState(axis) === "paused" && ((_a = _this29.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
                });
              };
              var _this$getProps = this.getProps(),
                dragSnapToOrigin = _this$getProps.dragSnapToOrigin;
              this.panSession = new PanSession(originEvent, {
                onSessionStart: onSessionStart,
                onStart: onStart,
                onMove: onMove,
                onSessionEnd: onSessionEnd,
                resumeAnimation: resumeAnimation
              }, {
                transformPagePoint: this.visualElement.getTransformPagePoint(),
                dragSnapToOrigin: dragSnapToOrigin,
                contextWindow: getContextWindow(this.visualElement)
              });
            }
          }, {
            key: "stop",
            value: function stop(event, info) {
              var isDragging = this.isDragging;
              this.cancel();
              if (!isDragging) return;
              var velocity = info.velocity;
              this.startAnimation(velocity);
              var _this$getProps2 = this.getProps(),
                onDragEnd = _this$getProps2.onDragEnd;
              if (onDragEnd) {
                frame.postRender(function () {
                  return onDragEnd(event, info);
                });
              }
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this.isDragging = false;
              var _this$visualElement = this.visualElement,
                projection = _this$visualElement.projection,
                animationState = _this$visualElement.animationState;
              if (projection) {
                projection.isAnimationBlocked = false;
              }
              this.panSession && this.panSession.end();
              this.panSession = undefined;
              var _this$getProps3 = this.getProps(),
                dragPropagation = _this$getProps3.dragPropagation;
              if (!dragPropagation && this.openDragLock) {
                this.openDragLock();
                this.openDragLock = null;
              }
              animationState && animationState.setActive("whileDrag", false);
            }
          }, {
            key: "updateAxis",
            value: function updateAxis(axis, _point, offset) {
              var _this$getProps4 = this.getProps(),
                drag = _this$getProps4.drag;
              // If we're not dragging this axis, do an early return.
              if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
              var axisValue = this.getAxisMotionValue(axis);
              var next = this.originPoint[axis] + offset[axis];
              // Apply constraints
              if (this.constraints && this.constraints[axis]) {
                next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
              }
              axisValue.set(next);
            }
          }, {
            key: "resolveConstraints",
            value: function resolveConstraints() {
              var _this30 = this;
              var _a;
              var _this$getProps5 = this.getProps(),
                dragConstraints = _this$getProps5.dragConstraints,
                dragElastic = _this$getProps5.dragElastic;
              var layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
              var prevConstraints = this.constraints;
              if (dragConstraints && isRefObject(dragConstraints)) {
                if (!this.constraints) {
                  this.constraints = this.resolveRefConstraints();
                }
              } else {
                if (dragConstraints && layout) {
                  this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
                } else {
                  this.constraints = false;
                }
              }
              this.elastic = resolveDragElastic(dragElastic);
              /**
               * If we're outputting to external MotionValues, we want to rebase the measured constraints
               * from viewport-relative to component-relative.
               */
              if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
                eachAxis(function (axis) {
                  if (_this30.constraints !== false && _this30.getAxisMotionValue(axis)) {
                    _this30.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], _this30.constraints[axis]);
                  }
                });
              }
            }
          }, {
            key: "resolveRefConstraints",
            value: function resolveRefConstraints() {
              var _this$getProps6 = this.getProps(),
                constraints = _this$getProps6.dragConstraints,
                onMeasureDragConstraints = _this$getProps6.onMeasureDragConstraints;
              if (!constraints || !isRefObject(constraints)) return false;
              var constraintsElement = constraints.current;
              var projection = this.visualElement.projection;
              // TODO
              if (!projection || !projection.layout) return false;
              var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
              var measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
              /**
               * If there's an onMeasureDragConstraints listener we call it and
               * if different constraints are returned, set constraints to that
               */
              if (onMeasureDragConstraints) {
                var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
                this.hasMutatedConstraints = !!userConstraints;
                if (userConstraints) {
                  measuredConstraints = convertBoundingBoxToBox(userConstraints);
                }
              }
              return measuredConstraints;
            }
          }, {
            key: "startAnimation",
            value: function startAnimation(velocity) {
              var _this31 = this;
              var _this$getProps7 = this.getProps(),
                drag = _this$getProps7.drag,
                dragMomentum = _this$getProps7.dragMomentum,
                dragElastic = _this$getProps7.dragElastic,
                dragTransition = _this$getProps7.dragTransition,
                dragSnapToOrigin = _this$getProps7.dragSnapToOrigin,
                onDragTransitionEnd = _this$getProps7.onDragTransitionEnd;
              var constraints = this.constraints || {};
              var momentumAnimations = eachAxis(function (axis) {
                if (!shouldDrag(axis, drag, _this31.currentDirection)) {
                  return;
                }
                var transition = constraints && constraints[axis] || {};
                if (dragSnapToOrigin) transition = {
                  min: 0,
                  max: 0
                };
                /**
                 * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
                 * of spring animations so we should look into adding a disable spring option to `inertia`.
                 * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
                 * using the value of `dragElastic`.
                 */
                var bounceStiffness = dragElastic ? 200 : 1000000;
                var bounceDamping = dragElastic ? 40 : 10000000;
                var inertia = _objectSpread3(_objectSpread3({
                  type: "inertia",
                  velocity: dragMomentum ? velocity[axis] : 0,
                  bounceStiffness: bounceStiffness,
                  bounceDamping: bounceDamping,
                  timeConstant: 750,
                  restDelta: 1,
                  restSpeed: 10
                }, dragTransition), transition);
                // If we're not animating on an externally-provided `MotionValue` we can use the
                // component's animation controls which will handle interactions with whileHover (etc),
                // otherwise we just have to animate the `MotionValue` itself.
                return _this31.startAxisValueAnimation(axis, inertia);
              });
              // Run all animations and then resolve the new drag constraints.
              return Promise.all(momentumAnimations).then(onDragTransitionEnd);
            }
          }, {
            key: "startAxisValueAnimation",
            value: function startAxisValueAnimation(axis, transition) {
              var axisValue = this.getAxisMotionValue(axis);
              addValueToWillChange(this.visualElement, axis);
              return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
            }
          }, {
            key: "stopAnimation",
            value: function stopAnimation() {
              var _this32 = this;
              eachAxis(function (axis) {
                return _this32.getAxisMotionValue(axis).stop();
              });
            }
          }, {
            key: "pauseAnimation",
            value: function pauseAnimation() {
              var _this33 = this;
              eachAxis(function (axis) {
                var _a;
                return (_a = _this33.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
              });
            }
          }, {
            key: "getAnimationState",
            value: function getAnimationState(axis) {
              var _a;
              return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
            }
            /**
             * Drag works differently depending on which props are provided.
             *
             * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
             * - Otherwise, we apply the delta to the x/y motion values.
             */
          }, {
            key: "getAxisMotionValue",
            value: function getAxisMotionValue(axis) {
              var dragKey = "_drag".concat(axis.toUpperCase());
              var props = this.visualElement.getProps();
              var externalMotionValue = props[dragKey];
              return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);
            }
          }, {
            key: "snapToCursor",
            value: function snapToCursor(point) {
              var _this34 = this;
              eachAxis(function (axis) {
                var _this34$getProps = _this34.getProps(),
                  drag = _this34$getProps.drag;
                // If we're not dragging this axis, do an early return.
                if (!shouldDrag(axis, drag, _this34.currentDirection)) return;
                var projection = _this34.visualElement.projection;
                var axisValue = _this34.getAxisMotionValue(axis);
                if (projection && projection.layout) {
                  var _projection$layout$la = projection.layout.layoutBox[axis],
                    _min2 = _projection$layout$la.min,
                    _max2 = _projection$layout$la.max;
                  axisValue.set(point[axis] - mixNumber$1(_min2, _max2, 0.5));
                }
              });
            }
            /**
             * When the viewport resizes we want to check if the measured constraints
             * have changed and, if so, reposition the element within those new constraints
             * relative to where it was before the resize.
             */
          }, {
            key: "scalePositionWithinConstraints",
            value: function scalePositionWithinConstraints() {
              var _this35 = this;
              if (!this.visualElement.current) return;
              var _this$getProps8 = this.getProps(),
                drag = _this$getProps8.drag,
                dragConstraints = _this$getProps8.dragConstraints;
              var projection = this.visualElement.projection;
              if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
              /**
               * Stop current animations as there can be visual glitching if we try to do
               * this mid-animation
               */
              this.stopAnimation();
              /**
               * Record the relative position of the dragged element relative to the
               * constraints box and save as a progress value.
               */
              var boxProgress = {
                x: 0,
                y: 0
              };
              eachAxis(function (axis) {
                var axisValue = _this35.getAxisMotionValue(axis);
                if (axisValue && _this35.constraints !== false) {
                  var latest = axisValue.get();
                  boxProgress[axis] = calcOrigin({
                    min: latest,
                    max: latest
                  }, _this35.constraints[axis]);
                }
              });
              /**
               * Update the layout of this element and resolve the latest drag constraints
               */
              var _this$visualElement$g = this.visualElement.getProps(),
                transformTemplate = _this$visualElement$g.transformTemplate;
              this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
              projection.root && projection.root.updateScroll();
              projection.updateLayout();
              this.resolveConstraints();
              /**
               * For each axis, calculate the current progress of the layout axis
               * within the new constraints.
               */
              eachAxis(function (axis) {
                if (!shouldDrag(axis, drag, null)) return;
                /**
                 * Calculate a new transform based on the previous box progress
                 */
                var axisValue = _this35.getAxisMotionValue(axis);
                var _this35$constraints$a = _this35.constraints[axis],
                  min = _this35$constraints$a.min,
                  max = _this35$constraints$a.max;
                axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
              });
            }
          }, {
            key: "addListeners",
            value: function addListeners() {
              var _this36 = this;
              if (!this.visualElement.current) return;
              elementDragControls.set(this.visualElement, this);
              var element = this.visualElement.current;
              /**
               * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
               */
              var stopPointerListener = addPointerEvent(element, "pointerdown", function (event) {
                var _this36$getProps = _this36.getProps(),
                  drag = _this36$getProps.drag,
                  _this36$getProps$drag = _this36$getProps.dragListener,
                  dragListener = _this36$getProps$drag === void 0 ? true : _this36$getProps$drag;
                drag && dragListener && _this36.start(event);
              });
              var measureDragConstraints = function measureDragConstraints() {
                var _this36$getProps2 = _this36.getProps(),
                  dragConstraints = _this36$getProps2.dragConstraints;
                if (isRefObject(dragConstraints) && dragConstraints.current) {
                  _this36.constraints = _this36.resolveRefConstraints();
                }
              };
              var projection = this.visualElement.projection;
              var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
              if (projection && !projection.layout) {
                projection.root && projection.root.updateScroll();
                projection.updateLayout();
              }
              frame.read(measureDragConstraints);
              /**
               * Attach a window resize listener to scale the draggable target within its defined
               * constraints as the window resizes.
               */
              var stopResizeListener = addDomEvent(window, "resize", function () {
                return _this36.scalePositionWithinConstraints();
              });
              /**
               * If the element's layout changes, calculate the delta and apply that to
               * the drag gesture's origin point.
               */
              var stopLayoutUpdateListener = projection.addEventListener("didUpdate", function (_ref128) {
                var delta = _ref128.delta,
                  hasLayoutChanged = _ref128.hasLayoutChanged;
                if (_this36.isDragging && hasLayoutChanged) {
                  eachAxis(function (axis) {
                    var motionValue = _this36.getAxisMotionValue(axis);
                    if (!motionValue) return;
                    _this36.originPoint[axis] += delta[axis].translate;
                    motionValue.set(motionValue.get() + delta[axis].translate);
                  });
                  _this36.visualElement.render();
                }
              });
              return function () {
                stopResizeListener();
                stopPointerListener();
                stopMeasureLayoutListener();
                stopLayoutUpdateListener && stopLayoutUpdateListener();
              };
            }
          }, {
            key: "getProps",
            value: function getProps() {
              var props = this.visualElement.getProps();
              var _props$drag = props.drag,
                drag = _props$drag === void 0 ? false : _props$drag,
                _props$dragDirectionL = props.dragDirectionLock,
                dragDirectionLock = _props$dragDirectionL === void 0 ? false : _props$dragDirectionL,
                _props$dragPropagatio = props.dragPropagation,
                dragPropagation = _props$dragPropagatio === void 0 ? false : _props$dragPropagatio,
                _props$dragConstraint = props.dragConstraints,
                dragConstraints = _props$dragConstraint === void 0 ? false : _props$dragConstraint,
                _props$dragElastic = props.dragElastic,
                dragElastic = _props$dragElastic === void 0 ? defaultElastic : _props$dragElastic,
                _props$dragMomentum = props.dragMomentum,
                dragMomentum = _props$dragMomentum === void 0 ? true : _props$dragMomentum;
              return _objectSpread3(_objectSpread3({}, props), {}, {
                drag: drag,
                dragDirectionLock: dragDirectionLock,
                dragPropagation: dragPropagation,
                dragConstraints: dragConstraints,
                dragElastic: dragElastic,
                dragMomentum: dragMomentum
              });
            }
          }]);
        }();
        function shouldDrag(direction, drag, currentDirection) {
          return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
        }
        /**
         * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
         * than the provided threshold, return `null`.
         *
         * @param offset - The x/y offset from origin.
         * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
         */
        function getCurrentDirection(offset) {
          var lockThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
          var direction = null;
          if (Math.abs(offset.y) > lockThreshold) {
            direction = "y";
          } else if (Math.abs(offset.x) > lockThreshold) {
            direction = "x";
          }
          return direction;
        }
        var DragGesture = /*#__PURE__*/function (_Feature3) {
          function DragGesture(node) {
            var _this37;
            _classCallCheck(this, DragGesture);
            _this37 = _callSuper(this, DragGesture, [node]);
            _this37.removeGroupControls = noop$2;
            _this37.removeListeners = noop$2;
            _this37.controls = new VisualElementDragControls(node);
            return _this37;
          }
          _inherits(DragGesture, _Feature3);
          return _createClass(DragGesture, [{
            key: "mount",
            value: function mount() {
              // If we've been provided a DragControls for manual control over the drag gesture,
              // subscribe this component to it on mount.
              var _this$node$getProps3 = this.node.getProps(),
                dragControls = _this$node$getProps3.dragControls;
              if (dragControls) {
                this.removeGroupControls = dragControls.subscribe(this.controls);
              }
              this.removeListeners = this.controls.addListeners() || noop$2;
            }
          }, {
            key: "unmount",
            value: function unmount() {
              this.removeGroupControls();
              this.removeListeners();
            }
          }]);
        }(Feature);
        var asyncHandler = function asyncHandler(handler) {
          return function (event, info) {
            if (handler) {
              frame.postRender(function () {
                return handler(event, info);
              });
            }
          };
        };
        var PanGesture = /*#__PURE__*/function (_Feature4) {
          function PanGesture() {
            var _this38;
            _classCallCheck(this, PanGesture);
            _this38 = _callSuper(this, PanGesture, arguments);
            _this38.removePointerDownListener = noop$2;
            return _this38;
          }
          _inherits(PanGesture, _Feature4);
          return _createClass(PanGesture, [{
            key: "onPointerDown",
            value: function onPointerDown(pointerDownEvent) {
              this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
                transformPagePoint: this.node.getTransformPagePoint(),
                contextWindow: getContextWindow(this.node)
              });
            }
          }, {
            key: "createPanHandlers",
            value: function createPanHandlers() {
              var _this39 = this;
              var _this$node$getProps4 = this.node.getProps(),
                onPanSessionStart = _this$node$getProps4.onPanSessionStart,
                onPanStart = _this$node$getProps4.onPanStart,
                onPan = _this$node$getProps4.onPan,
                onPanEnd = _this$node$getProps4.onPanEnd;
              return {
                onSessionStart: asyncHandler(onPanSessionStart),
                onStart: asyncHandler(onPanStart),
                onMove: onPan,
                onEnd: function onEnd(event, info) {
                  delete _this39.session;
                  if (onPanEnd) {
                    frame.postRender(function () {
                      return onPanEnd(event, info);
                    });
                  }
                }
              };
            }
          }, {
            key: "mount",
            value: function mount() {
              var _this40 = this;
              this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", function (event) {
                return _this40.onPointerDown(event);
              });
            }
          }, {
            key: "update",
            value: function update() {
              this.session && this.session.updateHandlers(this.createPanHandlers());
            }
          }, {
            key: "unmount",
            value: function unmount() {
              this.removePointerDownListener();
              this.session && this.session.end();
            }
          }]);
        }(Feature);
        /**
         * This should only ever be modified on the client otherwise it'll
         * persist through server requests. If we need instanced states we
         * could lazy-init via root.
         */
        var globalProjectionState = {
          /**
           * Global flag as to whether the tree has animated since the last time
           * we resized the window
           */
          hasAnimatedSinceResize: true,
          /**
           * We set this to true once, on the first update. Any nodes added to the tree beyond that
           * update will be given a `data-projection-id` attribute.
           */
          hasEverUpdated: false
        };
        function pixelsToPercent(pixels, axis) {
          if (axis.max === axis.min) return 0;
          return pixels / (axis.max - axis.min) * 100;
        }
        /**
         * We always correct borderRadius as a percentage rather than pixels to reduce paints.
         * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
         * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
         * borderRadius in both states. If we animate between the two in pixels that will trigger
         * a paint each time. If we animate between the two in percentage we'll avoid a paint.
         */
        var correctBorderRadius = {
          correct: function correct(latest, node) {
            if (!node.target) return latest;
            /**
             * If latest is a string, if it's a percentage we can return immediately as it's
             * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
             */
            if (typeof latest === "string") {
              if (px.test(latest)) {
                latest = parseFloat(latest);
              } else {
                return latest;
              }
            }
            /**
             * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
             * pixel value as a percentage of each axis
             */
            var x = pixelsToPercent(latest, node.target.x);
            var y = pixelsToPercent(latest, node.target.y);
            return "".concat(x, "% ").concat(y, "%");
          }
        };
        var correctBoxShadow = {
          correct: function correct(latest, _ref129) {
            var treeScale = _ref129.treeScale,
              projectionDelta = _ref129.projectionDelta;
            var original = latest;
            var shadow = complex.parse(latest);
            // TODO: Doesn't support multiple shadows
            if (shadow.length > 5) return original;
            var template = complex.createTransformer(latest);
            var offset = typeof shadow[0] !== "number" ? 1 : 0;
            // Calculate the overall context scale
            var xScale = projectionDelta.x.scale * treeScale.x;
            var yScale = projectionDelta.y.scale * treeScale.y;
            shadow[0 + offset] /= xScale;
            shadow[1 + offset] /= yScale;
            /**
             * Ideally we'd correct x and y scales individually, but because blur and
             * spread apply to both we have to take a scale average and apply that instead.
             * We could potentially improve the outcome of this by incorporating the ratio between
             * the two scales.
             */
            var averageScale = mixNumber$1(xScale, yScale, 0.5);
            // Blur
            if (typeof shadow[2 + offset] === "number") shadow[2 + offset] /= averageScale;
            // Spread
            if (typeof shadow[3 + offset] === "number") shadow[3 + offset] /= averageScale;
            return template(shadow);
          }
        };
        var MeasureLayoutWithContext = /*#__PURE__*/function (_reactExports$Compone3) {
          function MeasureLayoutWithContext() {
            _classCallCheck(this, MeasureLayoutWithContext);
            return _callSuper(this, MeasureLayoutWithContext, arguments);
          }
          _inherits(MeasureLayoutWithContext, _reactExports$Compone3);
          return _createClass(MeasureLayoutWithContext, [{
            key: "componentDidMount",
            value:
            /**
             * This only mounts projection nodes for components that
             * need measuring, we might want to do it for all components
             * in order to incorporate transforms
             */
            function componentDidMount() {
              var _this41 = this;
              var _this$props = this.props,
                visualElement = _this$props.visualElement,
                layoutGroup = _this$props.layoutGroup,
                switchLayoutGroup = _this$props.switchLayoutGroup,
                layoutId = _this$props.layoutId;
              var projection = visualElement.projection;
              addScaleCorrector(defaultScaleCorrectors);
              if (projection) {
                if (layoutGroup.group) layoutGroup.group.add(projection);
                if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
                  switchLayoutGroup.register(projection);
                }
                projection.root.didUpdate();
                projection.addEventListener("animationComplete", function () {
                  _this41.safeToRemove();
                });
                projection.setOptions(_objectSpread3(_objectSpread3({}, projection.options), {}, {
                  onExitComplete: function onExitComplete() {
                    return _this41.safeToRemove();
                  }
                }));
              }
              globalProjectionState.hasEverUpdated = true;
            }
          }, {
            key: "getSnapshotBeforeUpdate",
            value: function getSnapshotBeforeUpdate(prevProps) {
              var _this42 = this;
              var _this$props2 = this.props,
                layoutDependency = _this$props2.layoutDependency,
                visualElement = _this$props2.visualElement,
                drag = _this$props2.drag,
                isPresent = _this$props2.isPresent;
              var projection = visualElement.projection;
              if (!projection) return null;
              /**
               * TODO: We use this data in relegate to determine whether to
               * promote a previous element. There's no guarantee its presence data
               * will have updated by this point - if a bug like this arises it will
               * have to be that we markForRelegation and then find a new lead some other way,
               * perhaps in didUpdate
               */
              projection.isPresent = isPresent;
              if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {
                projection.willUpdate();
              } else {
                this.safeToRemove();
              }
              if (prevProps.isPresent !== isPresent) {
                if (isPresent) {
                  projection.promote();
                } else if (!projection.relegate()) {
                  /**
                   * If there's another stack member taking over from this one,
                   * it's in charge of the exit animation and therefore should
                   * be in charge of the safe to remove. Otherwise we call it here.
                   */
                  frame.postRender(function () {
                    var stack = projection.getStack();
                    if (!stack || !stack.members.length) {
                      _this42.safeToRemove();
                    }
                  });
                }
              }
              return null;
            }
          }, {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
              var _this43 = this;
              var projection = this.props.visualElement.projection;
              if (projection) {
                projection.root.didUpdate();
                microtask.postRender(function () {
                  if (!projection.currentAnimation && projection.isLead()) {
                    _this43.safeToRemove();
                  }
                });
              }
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              var _this$props3 = this.props,
                visualElement = _this$props3.visualElement,
                layoutGroup = _this$props3.layoutGroup,
                promoteContext = _this$props3.switchLayoutGroup;
              var projection = visualElement.projection;
              if (projection) {
                projection.scheduleCheckAfterUnmount();
                if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
                if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
              }
            }
          }, {
            key: "safeToRemove",
            value: function safeToRemove() {
              var safeToRemove = this.props.safeToRemove;
              safeToRemove && safeToRemove();
            }
          }, {
            key: "render",
            value: function render() {
              return null;
            }
          }]);
        }(reactExports.Component);
        function MeasureLayout(props) {
          var _usePresence3 = usePresence(),
            _usePresence4 = _slicedToArray(_usePresence3, 2),
            isPresent = _usePresence4[0],
            safeToRemove = _usePresence4[1];
          var layoutGroup = reactExports.useContext(LayoutGroupContext);
          return jsxRuntimeExports.jsx(MeasureLayoutWithContext, _objectSpread3(_objectSpread3({}, props), {}, {
            layoutGroup: layoutGroup,
            switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
            isPresent: isPresent,
            safeToRemove: safeToRemove
          }));
        }
        var defaultScaleCorrectors = {
          borderRadius: _objectSpread3(_objectSpread3({}, correctBorderRadius), {}, {
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
          }),
          borderTopLeftRadius: correctBorderRadius,
          borderTopRightRadius: correctBorderRadius,
          borderBottomLeftRadius: correctBorderRadius,
          borderBottomRightRadius: correctBorderRadius,
          boxShadow: correctBoxShadow
        };
        function animateSingleValue(value, keyframes, options) {
          var motionValue$1 = isMotionValue(value) ? value : motionValue(value);
          motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
          return motionValue$1.animation;
        }
        function isSVGElement(element) {
          return element instanceof SVGElement && element.tagName !== "svg";
        }
        var compareByDepth = function compareByDepth(a, b) {
          return a.depth - b.depth;
        };
        var FlatTree = /*#__PURE__*/function () {
          function FlatTree() {
            _classCallCheck(this, FlatTree);
            this.children = [];
            this.isDirty = false;
          }
          return _createClass(FlatTree, [{
            key: "add",
            value: function add(child) {
              addUniqueItem(this.children, child);
              this.isDirty = true;
            }
          }, {
            key: "remove",
            value: function remove(child) {
              removeItem(this.children, child);
              this.isDirty = true;
            }
          }, {
            key: "forEach",
            value: function forEach(callback) {
              this.isDirty && this.children.sort(compareByDepth);
              this.isDirty = false;
              this.children.forEach(callback);
            }
          }]);
        }();
        /**
         * Timeout defined in ms
         */
        function delay(callback, timeout) {
          var start = time.now();
          var _checkElapsed = function checkElapsed(_ref130) {
            var timestamp = _ref130.timestamp;
            var elapsed = timestamp - start;
            if (elapsed >= timeout) {
              cancelFrame(_checkElapsed);
              callback(elapsed - timeout);
            }
          };
          frame.read(_checkElapsed, true);
          return function () {
            return cancelFrame(_checkElapsed);
          };
        }
        var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
        var numBorders = borders.length;
        var asNumber = function asNumber(value) {
          return typeof value === "string" ? parseFloat(value) : value;
        };
        var isPx = function isPx(value) {
          return typeof value === "number" || px.test(value);
        };
        function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
          if (shouldCrossfadeOpacity) {
            target.opacity = mixNumber$1(0,
            // TODO Reinstate this if only child
            lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));
            target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));
          } else if (isOnlyMember) {
            target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);
          }
          /**
           * Mix border radius
           */
          for (var i = 0; i < numBorders; i++) {
            var borderLabel = "border".concat(borders[i], "Radius");
            var followRadius = getRadius(follow, borderLabel);
            var leadRadius = getRadius(lead, borderLabel);
            if (followRadius === undefined && leadRadius === undefined) continue;
            followRadius || (followRadius = 0);
            leadRadius || (leadRadius = 0);
            var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
            if (canMix) {
              target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);
              if (percent.test(leadRadius) || percent.test(followRadius)) {
                target[borderLabel] += "%";
              }
            } else {
              target[borderLabel] = leadRadius;
            }
          }
          /**
           * Mix rotation
           */
          if (follow.rotate || lead.rotate) {
            target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);
          }
        }
        function getRadius(values, radiusName) {
          return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;
        }
        // /**
        //  * We only want to mix the background color if there's a follow element
        //  * that we're not crossfading opacity between. For instance with switch
        //  * AnimateSharedLayout animations, this helps the illusion of a continuous
        //  * element being animated but also cuts down on the number of paints triggered
        //  * for elements where opacity is doing that work for us.
        //  */
        // if (
        //     !hasFollowElement &&
        //     latestLeadValues.backgroundColor &&
        //     latestFollowValues.backgroundColor
        // ) {
        //     /**
        //      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
        //      * We could probably create a mixer that runs at the start of the animation but
        //      * the idea behind the crossfader is that it runs dynamically between two potentially
        //      * changing targets (ie opacity or borderRadius may be animating independently via variants)
        //      */
        //     leadState.backgroundColor = followState.backgroundColor = mixColor(
        //         latestFollowValues.backgroundColor as string,
        //         latestLeadValues.backgroundColor as string
        //     )(p)
        // }
        var easeCrossfadeIn = /*@__PURE__*/compress(0, 0.5, circOut);
        var easeCrossfadeOut = /*@__PURE__*/compress(0.5, 0.95, noop$2);
        function compress(min, max, easing) {
          return function (p) {
            // Could replace ifs with clamp
            if (p < min) return 0;
            if (p > max) return 1;
            return easing(progress(min, max, p));
          };
        }

        /**
         * Reset an axis to the provided origin box.
         *
         * This is a mutative operation.
         */
        function copyAxisInto(axis, originAxis) {
          axis.min = originAxis.min;
          axis.max = originAxis.max;
        }
        /**
         * Reset a box to the provided origin box.
         *
         * This is a mutative operation.
         */
        function copyBoxInto(box, originBox) {
          copyAxisInto(box.x, originBox.x);
          copyAxisInto(box.y, originBox.y);
        }
        /**
         * Reset a delta to the provided origin box.
         *
         * This is a mutative operation.
         */
        function copyAxisDeltaInto(delta, originDelta) {
          delta.translate = originDelta.translate;
          delta.scale = originDelta.scale;
          delta.originPoint = originDelta.originPoint;
          delta.origin = originDelta.origin;
        }

        /**
         * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
         */
        function removePointDelta(point, translate, scale, originPoint, boxScale) {
          point -= translate;
          point = scalePoint(point, 1 / scale, originPoint);
          if (boxScale !== undefined) {
            point = scalePoint(point, 1 / boxScale, originPoint);
          }
          return point;
        }
        /**
         * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
         */
        function removeAxisDelta(axis) {
          var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
          var boxScale = arguments.length > 4 ? arguments[4] : undefined;
          var originAxis = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : axis;
          var sourceAxis = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : axis;
          if (percent.test(translate)) {
            translate = parseFloat(translate);
            var relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
            translate = relativeProgress - sourceAxis.min;
          }
          if (typeof translate !== "number") return;
          var originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
          if (axis === originAxis) originPoint -= translate;
          axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
          axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
        }
        /**
         * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
         * and acts as a bridge between motion values and removeAxisDelta
         */
        function removeAxisTransforms(axis, transforms, _ref131, origin, sourceAxis) {
          var _ref132 = _slicedToArray(_ref131, 3),
            key = _ref132[0],
            scaleKey = _ref132[1],
            originKey = _ref132[2];
          removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
        }
        /**
         * The names of the motion values we want to apply as translation, scale and origin.
         */
        var xKeys = ["x", "scaleX", "originX"];
        var yKeys = ["y", "scaleY", "originY"];
        /**
         * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
         * and acts as a bridge between motion values and removeAxisDelta
         */
        function removeBoxTransforms(box, transforms, originBox, sourceBox) {
          removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);
          removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);
        }
        function isAxisDeltaZero(delta) {
          return delta.translate === 0 && delta.scale === 1;
        }
        function isDeltaZero(delta) {
          return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
        }
        function axisEquals(a, b) {
          return a.min === b.min && a.max === b.max;
        }
        function boxEquals(a, b) {
          return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
        }
        function axisEqualsRounded(a, b) {
          return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
        }
        function boxEqualsRounded(a, b) {
          return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
        }
        function aspectRatio(box) {
          return calcLength(box.x) / calcLength(box.y);
        }
        function axisDeltaEquals(a, b) {
          return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
        }
        var NodeStack = /*#__PURE__*/function () {
          function NodeStack() {
            _classCallCheck(this, NodeStack);
            this.members = [];
          }
          return _createClass(NodeStack, [{
            key: "add",
            value: function add(node) {
              addUniqueItem(this.members, node);
              node.scheduleRender();
            }
          }, {
            key: "remove",
            value: function remove(node) {
              removeItem(this.members, node);
              if (node === this.prevLead) {
                this.prevLead = undefined;
              }
              if (node === this.lead) {
                var prevLead = this.members[this.members.length - 1];
                if (prevLead) {
                  this.promote(prevLead);
                }
              }
            }
          }, {
            key: "relegate",
            value: function relegate(node) {
              var indexOfNode = this.members.findIndex(function (member) {
                return node === member;
              });
              if (indexOfNode === 0) return false;
              /**
               * Find the next projection node that is present
               */
              var prevLead;
              for (var i = indexOfNode; i >= 0; i--) {
                var member = this.members[i];
                if (member.isPresent !== false) {
                  prevLead = member;
                  break;
                }
              }
              if (prevLead) {
                this.promote(prevLead);
                return true;
              } else {
                return false;
              }
            }
          }, {
            key: "promote",
            value: function promote(node, preserveFollowOpacity) {
              var prevLead = this.lead;
              if (node === prevLead) return;
              this.prevLead = prevLead;
              this.lead = node;
              node.show();
              if (prevLead) {
                prevLead.instance && prevLead.scheduleRender();
                node.scheduleRender();
                node.resumeFrom = prevLead;
                if (preserveFollowOpacity) {
                  node.resumeFrom.preserveOpacity = true;
                }
                if (prevLead.snapshot) {
                  node.snapshot = prevLead.snapshot;
                  node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
                }
                if (node.root && node.root.isUpdating) {
                  node.isLayoutDirty = true;
                }
                var crossfade = node.options.crossfade;
                if (crossfade === false) {
                  prevLead.hide();
                }
                /**
                 * TODO:
                 *   - Test border radius when previous node was deleted
                 *   - boxShadow mixing
                 *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
                 *   - Shared between element A in transformed container and element B (transform stays the same or changes)
                 *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
                 * ---
                 *   - Crossfade opacity of root nodes
                 *   - layoutId changes after animation
                 *   - layoutId changes mid animation
                 */
              }
            }
          }, {
            key: "exitAnimationComplete",
            value: function exitAnimationComplete() {
              this.members.forEach(function (node) {
                var options = node.options,
                  resumingFrom = node.resumingFrom;
                options.onExitComplete && options.onExitComplete();
                if (resumingFrom) {
                  resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
                }
              });
            }
          }, {
            key: "scheduleRender",
            value: function scheduleRender() {
              this.members.forEach(function (node) {
                node.instance && node.scheduleRender(false);
              });
            }
            /**
             * Clear any leads that have been removed this render to prevent them from being
             * used in future animations and to prevent memory leaks
             */
          }, {
            key: "removeLeadSnapshot",
            value: function removeLeadSnapshot() {
              if (this.lead && this.lead.snapshot) {
                this.lead.snapshot = undefined;
              }
            }
          }]);
        }();
        function buildProjectionTransform(delta, treeScale, latestTransform) {
          var transform = "";
          /**
           * The translations we use to calculate are always relative to the viewport coordinate space.
           * But when we apply scales, we also scale the coordinate space of an element and its children.
           * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
           * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
           */
          var xTranslate = delta.x.translate / treeScale.x;
          var yTranslate = delta.y.translate / treeScale.y;
          var zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
          if (xTranslate || yTranslate || zTranslate) {
            transform = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, ").concat(zTranslate, "px) ");
          }
          /**
           * Apply scale correction for the tree transform.
           * This will apply scale to the screen-orientated axes.
           */
          if (treeScale.x !== 1 || treeScale.y !== 1) {
            transform += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
          }
          if (latestTransform) {
            var transformPerspective = latestTransform.transformPerspective,
              rotate = latestTransform.rotate,
              rotateX = latestTransform.rotateX,
              rotateY = latestTransform.rotateY,
              skewX = latestTransform.skewX,
              skewY = latestTransform.skewY;
            if (transformPerspective) transform = "perspective(".concat(transformPerspective, "px) ").concat(transform);
            if (rotate) transform += "rotate(".concat(rotate, "deg) ");
            if (rotateX) transform += "rotateX(".concat(rotateX, "deg) ");
            if (rotateY) transform += "rotateY(".concat(rotateY, "deg) ");
            if (skewX) transform += "skewX(".concat(skewX, "deg) ");
            if (skewY) transform += "skewY(".concat(skewY, "deg) ");
          }
          /**
           * Apply scale to match the size of the element to the size we want it.
           * This will apply scale to the element-orientated axes.
           */
          var elementScaleX = delta.x.scale * treeScale.x;
          var elementScaleY = delta.y.scale * treeScale.y;
          if (elementScaleX !== 1 || elementScaleY !== 1) {
            transform += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
          }
          return transform || "none";
        }
        var metrics = {
          type: "projectionFrame",
          totalNodes: 0,
          resolvedTargetDeltas: 0,
          recalculatedProjection: 0
        };
        var isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;
        var transformAxes = ["", "X", "Y", "Z"];
        var hiddenVisibility = {
          visibility: "hidden"
        };
        /**
         * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
         * which has a noticeable difference in spring animations
         */
        var animationTarget = 1000;
        var id = 0;
        function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
          var latestValues = visualElement.latestValues;
          // Record the distorting transform and then temporarily set it to 0
          if (latestValues[key]) {
            values[key] = latestValues[key];
            visualElement.setStaticValue(key, 0);
            if (sharedAnimationValues) {
              sharedAnimationValues[key] = 0;
            }
          }
        }
        function cancelTreeOptimisedTransformAnimations(projectionNode) {
          projectionNode.hasCheckedOptimisedAppear = true;
          if (projectionNode.root === projectionNode) return;
          var visualElement = projectionNode.options.visualElement;
          if (!visualElement) return;
          var appearId = getOptimisedAppearId(visualElement);
          if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
            var _projectionNode$optio = projectionNode.options,
              _layout = _projectionNode$optio.layout,
              layoutId = _projectionNode$optio.layoutId;
            window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(_layout || layoutId));
          }
          var parent = projectionNode.parent;
          if (parent && !parent.hasCheckedOptimisedAppear) {
            cancelTreeOptimisedTransformAnimations(parent);
          }
        }
        function createProjectionNode(_ref133) {
          var attachResizeListener = _ref133.attachResizeListener,
            defaultParent = _ref133.defaultParent,
            measureScroll = _ref133.measureScroll,
            checkIsScrollRoot = _ref133.checkIsScrollRoot,
            _resetTransform = _ref133.resetTransform;
          return /*#__PURE__*/function () {
            function ProjectionNode() {
              var _this44 = this;
              var latestValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
              _classCallCheck(this, ProjectionNode);
              /**
               * A unique ID generated for every projection node.
               */
              this.id = id++;
              /**
               * An id that represents a unique session instigated by startUpdate.
               */
              this.animationId = 0;
              /**
               * A Set containing all this component's children. This is used to iterate
               * through the children.
               *
               * TODO: This could be faster to iterate as a flat array stored on the root node.
               */
              this.children = new Set();
              /**
               * Options for the node. We use this to configure what kind of layout animations
               * we should perform (if any).
               */
              this.options = {};
              /**
               * We use this to detect when its safe to shut down part of a projection tree.
               * We have to keep projecting children for scale correction and relative projection
               * until all their parents stop performing layout animations.
               */
              this.isTreeAnimating = false;
              this.isAnimationBlocked = false;
              /**
               * Flag to true if we think this layout has been changed. We can't always know this,
               * currently we set it to true every time a component renders, or if it has a layoutDependency
               * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
               * and if one node is dirtied, they all are.
               */
              this.isLayoutDirty = false;
              /**
               * Flag to true if we think the projection calculations for this node needs
               * recalculating as a result of an updated transform or layout animation.
               */
              this.isProjectionDirty = false;
              /**
               * Flag to true if the layout *or* transform has changed. This then gets propagated
               * throughout the projection tree, forcing any element below to recalculate on the next frame.
               */
              this.isSharedProjectionDirty = false;
              /**
               * Flag transform dirty. This gets propagated throughout the whole tree but is only
               * respected by shared nodes.
               */
              this.isTransformDirty = false;
              /**
               * Block layout updates for instant layout transitions throughout the tree.
               */
              this.updateManuallyBlocked = false;
              this.updateBlockedByResize = false;
              /**
               * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
               * call.
               */
              this.isUpdating = false;
              /**
               * If this is an SVG element we currently disable projection transforms
               */
              this.isSVG = false;
              /**
               * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
               * its projection styles.
               */
              this.needsReset = false;
              /**
               * Flags whether this node should have its transform reset prior to measuring.
               */
              this.shouldResetTransform = false;
              /**
               * Store whether this node has been checked for optimised appear animations. As
               * effects fire bottom-up, and we want to look up the tree for appear animations,
               * this makes sure we only check each path once, stopping at nodes that
               * have already been checked.
               */
              this.hasCheckedOptimisedAppear = false;
              /**
               * An object representing the calculated contextual/accumulated/tree scale.
               * This will be used to scale calculcated projection transforms, as these are
               * calculated in screen-space but need to be scaled for elements to layoutly
               * make it to their calculated destinations.
               *
               * TODO: Lazy-init
               */
              this.treeScale = {
                x: 1,
                y: 1
              };
              /**
               *
               */
              this.eventHandlers = new Map();
              this.hasTreeAnimated = false;
              // Note: Currently only running on root node
              this.updateScheduled = false;
              this.scheduleUpdate = function () {
                return _this44.update();
              };
              this.projectionUpdateScheduled = false;
              this.checkUpdateFailed = function () {
                if (_this44.isUpdating) {
                  _this44.isUpdating = false;
                  _this44.clearAllSnapshots();
                }
              };
              /**
               * This is a multi-step process as shared nodes might be of different depths. Nodes
               * are sorted by depth order, so we need to resolve the entire tree before moving to
               * the next step.
               */
              this.updateProjection = function () {
                _this44.projectionUpdateScheduled = false;
                /**
                 * Reset debug counts. Manually resetting rather than creating a new
                 * object each frame.
                 */
                if (isDebug) {
                  metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
                }
                _this44.nodes.forEach(propagateDirtyNodes);
                _this44.nodes.forEach(resolveTargetDelta);
                _this44.nodes.forEach(calcProjection);
                _this44.nodes.forEach(cleanDirtyNodes);
                if (isDebug) {
                  window.MotionDebug.record(metrics);
                }
              };
              /**
               * Frame calculations
               */
              this.resolvedRelativeTargetAt = 0.0;
              this.hasProjected = false;
              this.isVisible = true;
              this.animationProgress = 0;
              /**
               * Shared layout
               */
              // TODO Only running on root node
              this.sharedNodes = new Map();
              this.latestValues = latestValues;
              this.root = parent ? parent.root || parent : this;
              this.path = parent ? [].concat(_toConsumableArray(parent.path), [parent]) : [];
              this.parent = parent;
              this.depth = parent ? parent.depth + 1 : 0;
              for (var i = 0; i < this.path.length; i++) {
                this.path[i].shouldResetTransform = true;
              }
              if (this.root === this) this.nodes = new FlatTree();
            }
            return _createClass(ProjectionNode, [{
              key: "addEventListener",
              value: function addEventListener(name, handler) {
                if (!this.eventHandlers.has(name)) {
                  this.eventHandlers.set(name, new SubscriptionManager());
                }
                return this.eventHandlers.get(name).add(handler);
              }
            }, {
              key: "notifyListeners",
              value: function notifyListeners(name) {
                var subscriptionManager = this.eventHandlers.get(name);
                for (var _len33 = arguments.length, args = new Array(_len33 > 1 ? _len33 - 1 : 0), _key55 = 1; _key55 < _len33; _key55++) {
                  args[_key55 - 1] = arguments[_key55];
                }
                subscriptionManager && subscriptionManager.notify.apply(subscriptionManager, args);
              }
            }, {
              key: "hasListeners",
              value: function hasListeners(name) {
                return this.eventHandlers.has(name);
              }
              /**
               * Lifecycles
               */
            }, {
              key: "mount",
              value: function mount(instance) {
                var _this45 = this;
                var isLayoutDirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root.hasTreeAnimated;
                if (this.instance) return;
                this.isSVG = isSVGElement(instance);
                this.instance = instance;
                var _this$options8 = this.options,
                  layoutId = _this$options8.layoutId,
                  layout = _this$options8.layout,
                  visualElement = _this$options8.visualElement;
                if (visualElement && !visualElement.current) {
                  visualElement.mount(instance);
                }
                this.root.nodes.add(this);
                this.parent && this.parent.children.add(this);
                if (isLayoutDirty && (layout || layoutId)) {
                  this.isLayoutDirty = true;
                }
                if (attachResizeListener) {
                  var cancelDelay;
                  var resizeUnblockUpdate = function resizeUnblockUpdate() {
                    return _this45.root.updateBlockedByResize = false;
                  };
                  attachResizeListener(instance, function () {
                    _this45.root.updateBlockedByResize = true;
                    cancelDelay && cancelDelay();
                    cancelDelay = delay(resizeUnblockUpdate, 250);
                    if (globalProjectionState.hasAnimatedSinceResize) {
                      globalProjectionState.hasAnimatedSinceResize = false;
                      _this45.nodes.forEach(finishAnimation);
                    }
                  });
                }
                if (layoutId) {
                  this.root.registerSharedNode(layoutId, this);
                }
                // Only register the handler if it requires layout animation
                if (this.options.animate !== false && visualElement && (layoutId || layout)) {
                  this.addEventListener("didUpdate", function (_ref134) {
                    var delta = _ref134.delta,
                      hasLayoutChanged = _ref134.hasLayoutChanged,
                      hasRelativeTargetChanged = _ref134.hasRelativeTargetChanged,
                      newLayout = _ref134.layout;
                    if (_this45.isTreeAnimationBlocked()) {
                      _this45.target = undefined;
                      _this45.relativeTarget = undefined;
                      return;
                    }
                    // TODO: Check here if an animation exists
                    var layoutTransition = _this45.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
                    var _visualElement$getPro = visualElement.getProps(),
                      onLayoutAnimationStart = _visualElement$getPro.onLayoutAnimationStart,
                      onLayoutAnimationComplete = _visualElement$getPro.onLayoutAnimationComplete;
                    /**
                     * The target layout of the element might stay the same,
                     * but its position relative to its parent has changed.
                     */
                    var targetChanged = !_this45.targetLayout || !boxEqualsRounded(_this45.targetLayout, newLayout) || hasRelativeTargetChanged;
                    /**
                     * If the layout hasn't seemed to have changed, it might be that the
                     * element is visually in the same place in the document but its position
                     * relative to its parent has indeed changed. So here we check for that.
                     */
                    var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
                    if (_this45.options.layoutRoot || _this45.resumeFrom && _this45.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this45.currentAnimation)) {
                      if (_this45.resumeFrom) {
                        _this45.resumingFrom = _this45.resumeFrom;
                        _this45.resumingFrom.resumingFrom = undefined;
                      }
                      _this45.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                      var animationOptions = _objectSpread3(_objectSpread3({}, getValueTransition(layoutTransition, "layout")), {}, {
                        onPlay: onLayoutAnimationStart,
                        onComplete: onLayoutAnimationComplete
                      });
                      if (visualElement.shouldReduceMotion || _this45.options.layoutRoot) {
                        animationOptions.delay = 0;
                        animationOptions.type = false;
                      }
                      _this45.startAnimation(animationOptions);
                    } else {
                      /**
                       * If the layout hasn't changed and we have an animation that hasn't started yet,
                       * finish it immediately. Otherwise it will be animating from a location
                       * that was probably never commited to screen and look like a jumpy box.
                       */
                      if (!hasLayoutChanged) {
                        finishAnimation(_this45);
                      }
                      if (_this45.isLead() && _this45.options.onExitComplete) {
                        _this45.options.onExitComplete();
                      }
                    }
                    _this45.targetLayout = newLayout;
                  });
                }
              }
            }, {
              key: "unmount",
              value: function unmount() {
                this.options.layoutId && this.willUpdate();
                this.root.nodes.remove(this);
                var stack = this.getStack();
                stack && stack.remove(this);
                this.parent && this.parent.children.delete(this);
                this.instance = undefined;
                cancelFrame(this.updateProjection);
              }
              // only on the root
            }, {
              key: "blockUpdate",
              value: function blockUpdate() {
                this.updateManuallyBlocked = true;
              }
            }, {
              key: "unblockUpdate",
              value: function unblockUpdate() {
                this.updateManuallyBlocked = false;
              }
            }, {
              key: "isUpdateBlocked",
              value: function isUpdateBlocked() {
                return this.updateManuallyBlocked || this.updateBlockedByResize;
              }
            }, {
              key: "isTreeAnimationBlocked",
              value: function isTreeAnimationBlocked() {
                return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
              }
              // Note: currently only running on root node
            }, {
              key: "startUpdate",
              value: function startUpdate() {
                if (this.isUpdateBlocked()) return;
                this.isUpdating = true;
                this.nodes && this.nodes.forEach(resetSkewAndRotation);
                this.animationId++;
              }
            }, {
              key: "getTransformTemplate",
              value: function getTransformTemplate() {
                var visualElement = this.options.visualElement;
                return visualElement && visualElement.getProps().transformTemplate;
              }
            }, {
              key: "willUpdate",
              value: function willUpdate() {
                var shouldNotifyListeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                this.root.hasTreeAnimated = true;
                if (this.root.isUpdateBlocked()) {
                  this.options.onExitComplete && this.options.onExitComplete();
                  return;
                }
                /**
                 * If we're running optimised appear animations then these must be
                 * cancelled before measuring the DOM. This is so we can measure
                 * the true layout of the element rather than the WAAPI animation
                 * which will be unaffected by the resetSkewAndRotate step.
                 *
                 * Note: This is a DOM write. Worst case scenario is this is sandwiched
                 * between other snapshot reads which will cause unnecessary style recalculations.
                 * This has to happen here though, as we don't yet know which nodes will need
                 * snapshots in startUpdate(), but we only want to cancel optimised animations
                 * if a layout animation measurement is actually going to be affected by them.
                 */
                if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
                  cancelTreeOptimisedTransformAnimations(this);
                }
                !this.root.isUpdating && this.root.startUpdate();
                if (this.isLayoutDirty) return;
                this.isLayoutDirty = true;
                for (var i = 0; i < this.path.length; i++) {
                  var _node2 = this.path[i];
                  _node2.shouldResetTransform = true;
                  _node2.updateScroll("snapshot");
                  if (_node2.options.layoutRoot) {
                    _node2.willUpdate(false);
                  }
                }
                var _this$options9 = this.options,
                  layoutId = _this$options9.layoutId,
                  layout = _this$options9.layout;
                if (layoutId === undefined && !layout) return;
                var transformTemplate = this.getTransformTemplate();
                this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : undefined;
                this.updateSnapshot();
                shouldNotifyListeners && this.notifyListeners("willUpdate");
              }
            }, {
              key: "update",
              value: function update() {
                this.updateScheduled = false;
                var updateWasBlocked = this.isUpdateBlocked();
                // When doing an instant transition, we skip the layout update,
                // but should still clean up the measurements so that the next
                // snapshot could be taken correctly.
                if (updateWasBlocked) {
                  this.unblockUpdate();
                  this.clearAllSnapshots();
                  this.nodes.forEach(clearMeasurements);
                  return;
                }
                if (!this.isUpdating) {
                  this.nodes.forEach(clearIsLayoutDirty);
                }
                this.isUpdating = false;
                /**
                 * Write
                 */
                this.nodes.forEach(resetTransformStyle);
                /**
                 * Read ==================
                 */
                // Update layout measurements of updated children
                this.nodes.forEach(updateLayout);
                /**
                 * Write
                 */
                // Notify listeners that the layout is updated
                this.nodes.forEach(notifyLayoutUpdate);
                this.clearAllSnapshots();
                /**
                 * Manually flush any pending updates. Ideally
                 * we could leave this to the following requestAnimationFrame but this seems
                 * to leave a flash of incorrectly styled content.
                 */
                var now = time.now();
                frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
                frameData.timestamp = now;
                frameData.isProcessing = true;
                frameSteps.update.process(frameData);
                frameSteps.preRender.process(frameData);
                frameSteps.render.process(frameData);
                frameData.isProcessing = false;
              }
            }, {
              key: "didUpdate",
              value: function didUpdate() {
                if (!this.updateScheduled) {
                  this.updateScheduled = true;
                  microtask.read(this.scheduleUpdate);
                }
              }
            }, {
              key: "clearAllSnapshots",
              value: function clearAllSnapshots() {
                this.nodes.forEach(clearSnapshot);
                this.sharedNodes.forEach(removeLeadSnapshots);
              }
            }, {
              key: "scheduleUpdateProjection",
              value: function scheduleUpdateProjection() {
                if (!this.projectionUpdateScheduled) {
                  this.projectionUpdateScheduled = true;
                  frame.preRender(this.updateProjection, false, true);
                }
              }
            }, {
              key: "scheduleCheckAfterUnmount",
              value: function scheduleCheckAfterUnmount() {
                var _this46 = this;
                /**
                 * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
                 * we manually call didUpdate to give a chance to the siblings to animate.
                 * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
                 */
                frame.postRender(function () {
                  if (_this46.isLayoutDirty) {
                    _this46.root.didUpdate();
                  } else {
                    _this46.root.checkUpdateFailed();
                  }
                });
              }
              /**
               * Update measurements
               */
            }, {
              key: "updateSnapshot",
              value: function updateSnapshot() {
                if (this.snapshot || !this.instance) return;
                this.snapshot = this.measure();
              }
            }, {
              key: "updateLayout",
              value: function updateLayout() {
                if (!this.instance) return;
                // TODO: Incorporate into a forwarded scroll offset
                this.updateScroll();
                if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
                  return;
                }
                /**
                 * When a node is mounted, it simply resumes from the prevLead's
                 * snapshot instead of taking a new one, but the ancestors scroll
                 * might have updated while the prevLead is unmounted. We need to
                 * update the scroll again to make sure the layout we measure is
                 * up to date.
                 */
                if (this.resumeFrom && !this.resumeFrom.instance) {
                  for (var i = 0; i < this.path.length; i++) {
                    var _node3 = this.path[i];
                    _node3.updateScroll();
                  }
                }
                var prevLayout = this.layout;
                this.layout = this.measure(false);
                this.layoutCorrected = createBox();
                this.isLayoutDirty = false;
                this.projectionDelta = undefined;
                this.notifyListeners("measure", this.layout.layoutBox);
                var visualElement = this.options.visualElement;
                visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);
              }
            }, {
              key: "updateScroll",
              value: function updateScroll() {
                var phase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "measure";
                var needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
                if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
                  needsMeasurement = false;
                }
                if (needsMeasurement) {
                  var isRoot = checkIsScrollRoot(this.instance);
                  this.scroll = {
                    animationId: this.root.animationId,
                    phase: phase,
                    isRoot: isRoot,
                    offset: measureScroll(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot
                  };
                }
              }
            }, {
              key: "resetTransform",
              value: function resetTransform() {
                if (!_resetTransform) return;
                var isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
                var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
                var transformTemplate = this.getTransformTemplate();
                var transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : undefined;
                var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
                if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
                  _resetTransform(this.instance, transformTemplateValue);
                  this.shouldResetTransform = false;
                  this.scheduleRender();
                }
              }
            }, {
              key: "measure",
              value: function measure() {
                var removeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var pageBox = this.measurePageBox();
                var layoutBox = this.removeElementScroll(pageBox);
                /**
                 * Measurements taken during the pre-render stage
                 * still have transforms applied so we remove them
                 * via calculation.
                 */
                if (removeTransform) {
                  layoutBox = this.removeTransform(layoutBox);
                }
                roundBox(layoutBox);
                return {
                  animationId: this.root.animationId,
                  measuredBox: pageBox,
                  layoutBox: layoutBox,
                  latestValues: {},
                  source: this.id
                };
              }
            }, {
              key: "measurePageBox",
              value: function measurePageBox() {
                var _a;
                var visualElement = this.options.visualElement;
                if (!visualElement) return createBox();
                var box = visualElement.measureViewportBox();
                var wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
                if (!wasInScrollRoot) {
                  // Remove viewport scroll to give page-relative coordinates
                  var _scroll = this.root.scroll;
                  if (_scroll) {
                    translateAxis(box.x, _scroll.offset.x);
                    translateAxis(box.y, _scroll.offset.y);
                  }
                }
                return box;
              }
            }, {
              key: "removeElementScroll",
              value: function removeElementScroll(box) {
                var _a;
                var boxWithoutScroll = createBox();
                copyBoxInto(boxWithoutScroll, box);
                if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
                  return boxWithoutScroll;
                }
                /**
                 * Performance TODO: Keep a cumulative scroll offset down the tree
                 * rather than loop back up the path.
                 */
                for (var i = 0; i < this.path.length; i++) {
                  var _node4 = this.path[i];
                  var _scroll2 = _node4.scroll,
                    _options4 = _node4.options;
                  if (_node4 !== this.root && _scroll2 && _options4.layoutScroll) {
                    /**
                     * If this is a new scroll root, we want to remove all previous scrolls
                     * from the viewport box.
                     */
                    if (_scroll2.wasRoot) {
                      copyBoxInto(boxWithoutScroll, box);
                    }
                    translateAxis(boxWithoutScroll.x, _scroll2.offset.x);
                    translateAxis(boxWithoutScroll.y, _scroll2.offset.y);
                  }
                }
                return boxWithoutScroll;
              }
            }, {
              key: "applyTransform",
              value: function applyTransform(box) {
                var transformOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var withTransforms = createBox();
                copyBoxInto(withTransforms, box);
                for (var i = 0; i < this.path.length; i++) {
                  var _node5 = this.path[i];
                  if (!transformOnly && _node5.options.layoutScroll && _node5.scroll && _node5 !== _node5.root) {
                    transformBox(withTransforms, {
                      x: -_node5.scroll.offset.x,
                      y: -_node5.scroll.offset.y
                    });
                  }
                  if (!hasTransform(_node5.latestValues)) continue;
                  transformBox(withTransforms, _node5.latestValues);
                }
                if (hasTransform(this.latestValues)) {
                  transformBox(withTransforms, this.latestValues);
                }
                return withTransforms;
              }
            }, {
              key: "removeTransform",
              value: function removeTransform(box) {
                var boxWithoutTransform = createBox();
                copyBoxInto(boxWithoutTransform, box);
                for (var i = 0; i < this.path.length; i++) {
                  var _node6 = this.path[i];
                  if (!_node6.instance) continue;
                  if (!hasTransform(_node6.latestValues)) continue;
                  hasScale(_node6.latestValues) && _node6.updateSnapshot();
                  var sourceBox = createBox();
                  var nodeBox = _node6.measurePageBox();
                  copyBoxInto(sourceBox, nodeBox);
                  removeBoxTransforms(boxWithoutTransform, _node6.latestValues, _node6.snapshot ? _node6.snapshot.layoutBox : undefined, sourceBox);
                }
                if (hasTransform(this.latestValues)) {
                  removeBoxTransforms(boxWithoutTransform, this.latestValues);
                }
                return boxWithoutTransform;
              }
            }, {
              key: "setTargetDelta",
              value: function setTargetDelta(delta) {
                this.targetDelta = delta;
                this.root.scheduleUpdateProjection();
                this.isProjectionDirty = true;
              }
            }, {
              key: "setOptions",
              value: function setOptions(options) {
                this.options = _objectSpread3(_objectSpread3(_objectSpread3({}, this.options), options), {}, {
                  crossfade: options.crossfade !== undefined ? options.crossfade : true
                });
              }
            }, {
              key: "clearMeasurements",
              value: function clearMeasurements() {
                this.scroll = undefined;
                this.layout = undefined;
                this.snapshot = undefined;
                this.prevTransformTemplateValue = undefined;
                this.targetDelta = undefined;
                this.target = undefined;
                this.isLayoutDirty = false;
              }
            }, {
              key: "forceRelativeParentToResolveTarget",
              value: function forceRelativeParentToResolveTarget() {
                if (!this.relativeParent) return;
                /**
                 * If the parent target isn't up-to-date, force it to update.
                 * This is an unfortunate de-optimisation as it means any updating relative
                 * projection will cause all the relative parents to recalculate back
                 * up the tree.
                 */
                if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
                  this.relativeParent.resolveTargetDelta(true);
                }
              }
            }, {
              key: "resolveTargetDelta",
              value: function resolveTargetDelta() {
                var forceRecalculation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                var _a;
                /**
                 * Once the dirty status of nodes has been spread through the tree, we also
                 * need to check if we have a shared node of a different depth that has itself
                 * been dirtied.
                 */
                var lead = this.getLead();
                this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
                this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
                this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
                var isShared = Boolean(this.resumingFrom) || this !== lead;
                /**
                 * We don't use transform for this step of processing so we don't
                 * need to check whether any nodes have changed transform.
                 */
                var canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
                if (canSkip) return;
                var _this$options0 = this.options,
                  layout = _this$options0.layout,
                  layoutId = _this$options0.layoutId;
                /**
                 * If we have no layout, we can't perform projection, so early return
                 */
                if (!this.layout || !(layout || layoutId)) return;
                this.resolvedRelativeTargetAt = frameData.timestamp;
                /**
                 * If we don't have a targetDelta but do have a layout, we can attempt to resolve
                 * a relativeParent. This will allow a component to perform scale correction
                 * even if no animation has started.
                 */
                if (!this.targetDelta && !this.relativeTarget) {
                  var relativeParent = this.getClosestProjectingParent();
                  if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
                    this.relativeParent = relativeParent;
                    this.forceRelativeParentToResolveTarget();
                    this.relativeTarget = createBox();
                    this.relativeTargetOrigin = createBox();
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                  } else {
                    this.relativeParent = this.relativeTarget = undefined;
                  }
                }
                /**
                 * If we have no relative target or no target delta our target isn't valid
                 * for this frame.
                 */
                if (!this.relativeTarget && !this.targetDelta) return;
                /**
                 * Lazy-init target data structure
                 */
                if (!this.target) {
                  this.target = createBox();
                  this.targetWithTransforms = createBox();
                }
                /**
                 * If we've got a relative box for this component, resolve it into a target relative to the parent.
                 */
                if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
                  this.forceRelativeParentToResolveTarget();
                  calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
                  /**
                   * If we've only got a targetDelta, resolve it into a target
                   */
                } else if (this.targetDelta) {
                  if (Boolean(this.resumingFrom)) {
                    // TODO: This is creating a new object every frame
                    this.target = this.applyTransform(this.layout.layoutBox);
                  } else {
                    copyBoxInto(this.target, this.layout.layoutBox);
                  }
                  applyBoxDelta(this.target, this.targetDelta);
                } else {
                  /**
                   * If no target, use own layout as target
                   */
                  copyBoxInto(this.target, this.layout.layoutBox);
                }
                /**
                 * If we've been told to attempt to resolve a relative target, do so.
                 */
                if (this.attemptToResolveRelativeTarget) {
                  this.attemptToResolveRelativeTarget = false;
                  var _relativeParent = this.getClosestProjectingParent();
                  if (_relativeParent && Boolean(_relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !_relativeParent.options.layoutScroll && _relativeParent.target && this.animationProgress !== 1) {
                    this.relativeParent = _relativeParent;
                    this.forceRelativeParentToResolveTarget();
                    this.relativeTarget = createBox();
                    this.relativeTargetOrigin = createBox();
                    calcRelativePosition(this.relativeTargetOrigin, this.target, _relativeParent.target);
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                  } else {
                    this.relativeParent = this.relativeTarget = undefined;
                  }
                }
                /**
                 * Increase debug counter for resolved target deltas
                 */
                if (isDebug) {
                  metrics.resolvedTargetDeltas++;
                }
              }
            }, {
              key: "getClosestProjectingParent",
              value: function getClosestProjectingParent() {
                if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
                  return undefined;
                }
                if (this.parent.isProjecting()) {
                  return this.parent;
                } else {
                  return this.parent.getClosestProjectingParent();
                }
              }
            }, {
              key: "isProjecting",
              value: function isProjecting() {
                return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
              }
            }, {
              key: "calcProjection",
              value: function calcProjection() {
                var _a;
                var lead = this.getLead();
                var isShared = Boolean(this.resumingFrom) || this !== lead;
                var canSkip = true;
                /**
                 * If this is a normal layout animation and neither this node nor its nearest projecting
                 * is dirty then we can't skip.
                 */
                if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
                  canSkip = false;
                }
                /**
                 * If this is a shared layout animation and this node's shared projection is dirty then
                 * we can't skip.
                 */
                if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
                  canSkip = false;
                }
                /**
                 * If we have resolved the target this frame we must recalculate the
                 * projection to ensure it visually represents the internal calculations.
                 */
                if (this.resolvedRelativeTargetAt === frameData.timestamp) {
                  canSkip = false;
                }
                if (canSkip) return;
                var _this$options1 = this.options,
                  layout = _this$options1.layout,
                  layoutId = _this$options1.layoutId;
                /**
                 * If this section of the tree isn't animating we can
                 * delete our target sources for the following frame.
                 */
                this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
                if (!this.isTreeAnimating) {
                  this.targetDelta = this.relativeTarget = undefined;
                }
                if (!this.layout || !(layout || layoutId)) return;
                /**
                 * Reset the corrected box with the latest values from box, as we're then going
                 * to perform mutative operations on it.
                 */
                copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
                /**
                 * Record previous tree scales before updating.
                 */
                var prevTreeScaleX = this.treeScale.x;
                var prevTreeScaleY = this.treeScale.y;
                /**
                 * Apply all the parent deltas to this box to produce the corrected box. This
                 * is the layout box, as it will appear on screen as a result of the transforms of its parents.
                 */
                applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
                /**
                 * If this layer needs to perform scale correction but doesn't have a target,
                 * use the layout as the target.
                 */
                if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
                  lead.target = lead.layout.layoutBox;
                  lead.targetWithTransforms = createBox();
                }
                var target = lead.target;
                if (!target) {
                  /**
                   * If we don't have a target to project into, but we were previously
                   * projecting, we want to remove the stored transform and schedule
                   * a render to ensure the elements reflect the removed transform.
                   */
                  if (this.prevProjectionDelta) {
                    this.createProjectionDeltas();
                    this.scheduleRender();
                  }
                  return;
                }
                if (!this.projectionDelta || !this.prevProjectionDelta) {
                  this.createProjectionDeltas();
                } else {
                  copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
                  copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
                }
                /**
                 * Update the delta between the corrected box and the target box before user-set transforms were applied.
                 * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
                 * for our layout reprojection, but still allow them to be scaled correctly by the user.
                 * It might be that to simplify this we may want to accept that user-set scale is also corrected
                 * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
                 * to allow people to choose whether these styles are corrected based on just the
                 * layout reprojection or the final bounding box.
                 */
                calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
                if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
                  this.hasProjected = true;
                  this.scheduleRender();
                  this.notifyListeners("projectionUpdate", target);
                }
                /**
                 * Increase debug counter for recalculated projections
                 */
                if (isDebug) {
                  metrics.recalculatedProjection++;
                }
              }
            }, {
              key: "hide",
              value: function hide() {
                this.isVisible = false;
                // TODO: Schedule render
              }
            }, {
              key: "show",
              value: function show() {
                this.isVisible = true;
                // TODO: Schedule render
              }
            }, {
              key: "scheduleRender",
              value: function scheduleRender() {
                var notifyAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var _a;
                (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
                if (notifyAll) {
                  var stack = this.getStack();
                  stack && stack.scheduleRender();
                }
                if (this.resumingFrom && !this.resumingFrom.instance) {
                  this.resumingFrom = undefined;
                }
              }
            }, {
              key: "createProjectionDeltas",
              value: function createProjectionDeltas() {
                this.prevProjectionDelta = createDelta();
                this.projectionDelta = createDelta();
                this.projectionDeltaWithTransform = createDelta();
              }
            }, {
              key: "setAnimationOrigin",
              value: function setAnimationOrigin(delta) {
                var _this47 = this;
                var hasOnlyRelativeTargetChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var snapshot = this.snapshot;
                var snapshotLatestValues = snapshot ? snapshot.latestValues : {};
                var mixedValues = _objectSpread3({}, this.latestValues);
                var targetDelta = createDelta();
                if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
                  this.relativeTarget = this.relativeTargetOrigin = undefined;
                }
                this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
                var relativeLayout = createBox();
                var snapshotSource = snapshot ? snapshot.source : undefined;
                var layoutSource = this.layout ? this.layout.source : undefined;
                var isSharedLayoutAnimation = snapshotSource !== layoutSource;
                var stack = this.getStack();
                var isOnlyMember = !stack || stack.members.length <= 1;
                var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
                this.animationProgress = 0;
                var prevRelativeTarget;
                this.mixTargetDelta = function (latest) {
                  var progress = latest / 1000;
                  mixAxisDelta(targetDelta.x, delta.x, progress);
                  mixAxisDelta(targetDelta.y, delta.y, progress);
                  _this47.setTargetDelta(targetDelta);
                  if (_this47.relativeTarget && _this47.relativeTargetOrigin && _this47.layout && _this47.relativeParent && _this47.relativeParent.layout) {
                    calcRelativePosition(relativeLayout, _this47.layout.layoutBox, _this47.relativeParent.layout.layoutBox);
                    mixBox(_this47.relativeTarget, _this47.relativeTargetOrigin, relativeLayout, progress);
                    /**
                     * If this is an unchanged relative target we can consider the
                     * projection not dirty.
                     */
                    if (prevRelativeTarget && boxEquals(_this47.relativeTarget, prevRelativeTarget)) {
                      _this47.isProjectionDirty = false;
                    }
                    if (!prevRelativeTarget) prevRelativeTarget = createBox();
                    copyBoxInto(prevRelativeTarget, _this47.relativeTarget);
                  }
                  if (isSharedLayoutAnimation) {
                    _this47.animationValues = mixedValues;
                    mixValues(mixedValues, snapshotLatestValues, _this47.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
                  }
                  _this47.root.scheduleUpdateProjection();
                  _this47.scheduleRender();
                  _this47.animationProgress = progress;
                };
                this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
              }
            }, {
              key: "startAnimation",
              value: function startAnimation(options) {
                var _this48 = this;
                this.notifyListeners("animationStart");
                this.currentAnimation && this.currentAnimation.stop();
                if (this.resumingFrom && this.resumingFrom.currentAnimation) {
                  this.resumingFrom.currentAnimation.stop();
                }
                if (this.pendingAnimation) {
                  cancelFrame(this.pendingAnimation);
                  this.pendingAnimation = undefined;
                }
                /**
                 * Start the animation in the next frame to have a frame with progress 0,
                 * where the target is the same as when the animation started, so we can
                 * calculate the relative positions correctly for instant transitions.
                 */
                this.pendingAnimation = frame.update(function () {
                  globalProjectionState.hasAnimatedSinceResize = true;
                  _this48.currentAnimation = animateSingleValue(0, animationTarget, _objectSpread3(_objectSpread3({}, options), {}, {
                    onUpdate: function onUpdate(latest) {
                      _this48.mixTargetDelta(latest);
                      options.onUpdate && options.onUpdate(latest);
                    },
                    onComplete: function onComplete() {
                      options.onComplete && options.onComplete();
                      _this48.completeAnimation();
                    }
                  }));
                  if (_this48.resumingFrom) {
                    _this48.resumingFrom.currentAnimation = _this48.currentAnimation;
                  }
                  _this48.pendingAnimation = undefined;
                });
              }
            }, {
              key: "completeAnimation",
              value: function completeAnimation() {
                if (this.resumingFrom) {
                  this.resumingFrom.currentAnimation = undefined;
                  this.resumingFrom.preserveOpacity = undefined;
                }
                var stack = this.getStack();
                stack && stack.exitAnimationComplete();
                this.resumingFrom = this.currentAnimation = this.animationValues = undefined;
                this.notifyListeners("animationComplete");
              }
            }, {
              key: "finishAnimation",
              value: function finishAnimation() {
                if (this.currentAnimation) {
                  this.mixTargetDelta && this.mixTargetDelta(animationTarget);
                  this.currentAnimation.stop();
                }
                this.completeAnimation();
              }
            }, {
              key: "applyTransformsToTarget",
              value: function applyTransformsToTarget() {
                var lead = this.getLead();
                var targetWithTransforms = lead.targetWithTransforms,
                  target = lead.target,
                  layout = lead.layout,
                  latestValues = lead.latestValues;
                if (!targetWithTransforms || !target || !layout) return;
                /**
                 * If we're only animating position, and this element isn't the lead element,
                 * then instead of projecting into the lead box we instead want to calculate
                 * a new target that aligns the two boxes but maintains the layout shape.
                 */
                if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
                  target = this.target || createBox();
                  var xLength = calcLength(this.layout.layoutBox.x);
                  target.x.min = lead.target.x.min;
                  target.x.max = target.x.min + xLength;
                  var yLength = calcLength(this.layout.layoutBox.y);
                  target.y.min = lead.target.y.min;
                  target.y.max = target.y.min + yLength;
                }
                copyBoxInto(targetWithTransforms, target);
                /**
                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
                 * This is the final box that we will then project into by calculating a transform delta and
                 * applying it to the corrected box.
                 */
                transformBox(targetWithTransforms, latestValues);
                /**
                 * Update the delta between the corrected box and the final target box, after
                 * user-set transforms are applied to it. This will be used by the renderer to
                 * create a transform style that will reproject the element from its layout layout
                 * into the desired bounding box.
                 */
                calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
              }
            }, {
              key: "registerSharedNode",
              value: function registerSharedNode(layoutId, node) {
                if (!this.sharedNodes.has(layoutId)) {
                  this.sharedNodes.set(layoutId, new NodeStack());
                }
                var stack = this.sharedNodes.get(layoutId);
                stack.add(node);
                var config = node.options.initialPromotionConfig;
                node.promote({
                  transition: config ? config.transition : undefined,
                  preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : undefined
                });
              }
            }, {
              key: "isLead",
              value: function isLead() {
                var stack = this.getStack();
                return stack ? stack.lead === this : true;
              }
            }, {
              key: "getLead",
              value: function getLead() {
                var _a;
                var layoutId = this.options.layoutId;
                return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
              }
            }, {
              key: "getPrevLead",
              value: function getPrevLead() {
                var _a;
                var layoutId = this.options.layoutId;
                return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;
              }
            }, {
              key: "getStack",
              value: function getStack() {
                var layoutId = this.options.layoutId;
                if (layoutId) return this.root.sharedNodes.get(layoutId);
              }
            }, {
              key: "promote",
              value: function promote() {
                var _ref135 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  needsReset = _ref135.needsReset,
                  transition = _ref135.transition,
                  preserveFollowOpacity = _ref135.preserveFollowOpacity;
                var stack = this.getStack();
                if (stack) stack.promote(this, preserveFollowOpacity);
                if (needsReset) {
                  this.projectionDelta = undefined;
                  this.needsReset = true;
                }
                if (transition) this.setOptions({
                  transition: transition
                });
              }
            }, {
              key: "relegate",
              value: function relegate() {
                var stack = this.getStack();
                if (stack) {
                  return stack.relegate(this);
                } else {
                  return false;
                }
              }
            }, {
              key: "resetSkewAndRotation",
              value: function resetSkewAndRotation() {
                var visualElement = this.options.visualElement;
                if (!visualElement) return;
                // If there's no detected skew or rotation values, we can early return without a forced render.
                var hasDistortingTransform = false;
                /**
                 * An unrolled check for rotation values. Most elements don't have any rotation and
                 * skipping the nested loop and new object creation is 50% faster.
                 */
                var latestValues = visualElement.latestValues;
                if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
                  hasDistortingTransform = true;
                }
                // If there's no distorting values, we don't need to do any more.
                if (!hasDistortingTransform) return;
                var resetValues = {};
                if (latestValues.z) {
                  resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
                }
                // Check the skew and rotate value of all axes and reset to 0
                for (var i = 0; i < transformAxes.length; i++) {
                  resetDistortingTransform("rotate".concat(transformAxes[i]), visualElement, resetValues, this.animationValues);
                  resetDistortingTransform("skew".concat(transformAxes[i]), visualElement, resetValues, this.animationValues);
                }
                // Force a render of this element to apply the transform with all skews and rotations
                // set to 0.
                visualElement.render();
                // Put back all the values we reset
                for (var _key56 in resetValues) {
                  visualElement.setStaticValue(_key56, resetValues[_key56]);
                  if (this.animationValues) {
                    this.animationValues[_key56] = resetValues[_key56];
                  }
                }
                // Schedule a render for the next frame. This ensures we won't visually
                // see the element with the reset rotate value applied.
                visualElement.scheduleRender();
              }
            }, {
              key: "getProjectionStyles",
              value: function getProjectionStyles(styleProp) {
                var _a, _b;
                if (!this.instance || this.isSVG) return undefined;
                if (!this.isVisible) {
                  return hiddenVisibility;
                }
                var styles = {
                  visibility: ""
                };
                var transformTemplate = this.getTransformTemplate();
                if (this.needsReset) {
                  this.needsReset = false;
                  styles.opacity = "";
                  styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
                  styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
                  return styles;
                }
                var lead = this.getLead();
                if (!this.projectionDelta || !this.layout || !lead.target) {
                  var emptyStyles = {};
                  if (this.options.layoutId) {
                    emptyStyles.opacity = this.latestValues.opacity !== undefined ? this.latestValues.opacity : 1;
                    emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
                  }
                  if (this.hasProjected && !hasTransform(this.latestValues)) {
                    emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
                    this.hasProjected = false;
                  }
                  return emptyStyles;
                }
                var valuesToRender = lead.animationValues || lead.latestValues;
                this.applyTransformsToTarget();
                styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
                if (transformTemplate) {
                  styles.transform = transformTemplate(valuesToRender, styles.transform);
                }
                var _this$projectionDelta = this.projectionDelta,
                  x = _this$projectionDelta.x,
                  y = _this$projectionDelta.y;
                styles.transformOrigin = "".concat(x.origin * 100, "% ").concat(y.origin * 100, "% 0");
                if (lead.animationValues) {
                  /**
                   * If the lead component is animating, assign this either the entering/leaving
                   * opacity
                   */
                  styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
                } else {
                  /**
                   * Or we're not animating at all, set the lead component to its layout
                   * opacity and other components to hidden.
                   */
                  styles.opacity = lead === this ? valuesToRender.opacity !== undefined ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== undefined ? valuesToRender.opacityExit : 0;
                }
                /**
                 * Apply scale correction
                 */
                for (var _key57 in scaleCorrectors) {
                  if (valuesToRender[_key57] === undefined) continue;
                  var _scaleCorrectors$_key = scaleCorrectors[_key57],
                    correct = _scaleCorrectors$_key.correct,
                    applyTo = _scaleCorrectors$_key.applyTo;
                  /**
                   * Only apply scale correction to the value if we have an
                   * active projection transform. Otherwise these values become
                   * vulnerable to distortion if the element changes size without
                   * a corresponding layout animation.
                   */
                  var corrected = styles.transform === "none" ? valuesToRender[_key57] : correct(valuesToRender[_key57], lead);
                  if (applyTo) {
                    var num = applyTo.length;
                    for (var i = 0; i < num; i++) {
                      styles[applyTo[i]] = corrected;
                    }
                  } else {
                    styles[_key57] = corrected;
                  }
                }
                /**
                 * Disable pointer events on follow components. This is to ensure
                 * that if a follow component covers a lead component it doesn't block
                 * pointer events on the lead.
                 */
                if (this.options.layoutId) {
                  styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
                }
                return styles;
              }
            }, {
              key: "clearSnapshot",
              value: function clearSnapshot() {
                this.resumeFrom = this.snapshot = undefined;
              }
              // Only run on root
            }, {
              key: "resetTree",
              value: function resetTree() {
                this.root.nodes.forEach(function (node) {
                  var _a;
                  return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
                });
                this.root.nodes.forEach(clearMeasurements);
                this.root.sharedNodes.clear();
              }
            }]);
          }();
        }
        function updateLayout(node) {
          node.updateLayout();
        }
        function notifyLayoutUpdate(node) {
          var _a;
          var snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
          if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
            var _node$layout = node.layout,
              _layout2 = _node$layout.layoutBox,
              measuredLayout = _node$layout.measuredBox;
            var animationType = node.options.animationType;
            var isShared = snapshot.source !== node.layout.source;
            // TODO Maybe we want to also resize the layout snapshot so we don't trigger
            // animations for instance if layout="size" and an element has only changed position
            if (animationType === "size") {
              eachAxis(function (axis) {
                var axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
                var length = calcLength(axisSnapshot);
                axisSnapshot.min = _layout2[axis].min;
                axisSnapshot.max = axisSnapshot.min + length;
              });
            } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, _layout2)) {
              eachAxis(function (axis) {
                var axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
                var length = calcLength(_layout2[axis]);
                axisSnapshot.max = axisSnapshot.min + length;
                /**
                 * Ensure relative target gets resized and rerendererd
                 */
                if (node.relativeTarget && !node.currentAnimation) {
                  node.isProjectionDirty = true;
                  node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
                }
              });
            }
            var layoutDelta = createDelta();
            calcBoxDelta(layoutDelta, _layout2, snapshot.layoutBox);
            var visualDelta = createDelta();
            if (isShared) {
              calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
            } else {
              calcBoxDelta(visualDelta, _layout2, snapshot.layoutBox);
            }
            var hasLayoutChanged = !isDeltaZero(layoutDelta);
            var hasRelativeTargetChanged = false;
            if (!node.resumeFrom) {
              var relativeParent = node.getClosestProjectingParent();
              /**
               * If the relativeParent is itself resuming from a different element then
               * the relative snapshot is not relavent
               */
              if (relativeParent && !relativeParent.resumeFrom) {
                var parentSnapshot = relativeParent.snapshot,
                  parentLayout = relativeParent.layout;
                if (parentSnapshot && parentLayout) {
                  var relativeSnapshot = createBox();
                  calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
                  var relativeLayout = createBox();
                  calcRelativePosition(relativeLayout, _layout2, parentLayout.layoutBox);
                  if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
                    hasRelativeTargetChanged = true;
                  }
                  if (relativeParent.options.layoutRoot) {
                    node.relativeTarget = relativeLayout;
                    node.relativeTargetOrigin = relativeSnapshot;
                    node.relativeParent = relativeParent;
                  }
                }
              }
            }
            node.notifyListeners("didUpdate", {
              layout: _layout2,
              snapshot: snapshot,
              delta: visualDelta,
              layoutDelta: layoutDelta,
              hasLayoutChanged: hasLayoutChanged,
              hasRelativeTargetChanged: hasRelativeTargetChanged
            });
          } else if (node.isLead()) {
            var onExitComplete = node.options.onExitComplete;
            onExitComplete && onExitComplete();
          }
          /**
           * Clearing transition
           * TODO: Investigate why this transition is being passed in as {type: false } from Framer
           * and why we need it at all
           */
          node.options.transition = undefined;
        }
        function propagateDirtyNodes(node) {
          /**
           * Increase debug counter for nodes encountered this frame
           */
          if (isDebug) {
            metrics.totalNodes++;
          }
          if (!node.parent) return;
          /**
           * If this node isn't projecting, propagate isProjectionDirty. It will have
           * no performance impact but it will allow the next child that *is* projecting
           * but *isn't* dirty to just check its parent to see if *any* ancestor needs
           * correcting.
           */
          if (!node.isProjecting()) {
            node.isProjectionDirty = node.parent.isProjectionDirty;
          }
          /**
           * Propagate isSharedProjectionDirty and isTransformDirty
           * throughout the whole tree. A future revision can take another look at
           * this but for safety we still recalcualte shared nodes.
           */
          node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
          node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
        }
        function cleanDirtyNodes(node) {
          node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
        }
        function clearSnapshot(node) {
          node.clearSnapshot();
        }
        function clearMeasurements(node) {
          node.clearMeasurements();
        }
        function clearIsLayoutDirty(node) {
          node.isLayoutDirty = false;
        }
        function resetTransformStyle(node) {
          var visualElement = node.options.visualElement;
          if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
            visualElement.notify("BeforeLayoutMeasure");
          }
          node.resetTransform();
        }
        function finishAnimation(node) {
          node.finishAnimation();
          node.targetDelta = node.relativeTarget = node.target = undefined;
          node.isProjectionDirty = true;
        }
        function resolveTargetDelta(node) {
          node.resolveTargetDelta();
        }
        function calcProjection(node) {
          node.calcProjection();
        }
        function resetSkewAndRotation(node) {
          node.resetSkewAndRotation();
        }
        function removeLeadSnapshots(stack) {
          stack.removeLeadSnapshot();
        }
        function mixAxisDelta(output, delta, p) {
          output.translate = mixNumber$1(delta.translate, 0, p);
          output.scale = mixNumber$1(delta.scale, 1, p);
          output.origin = delta.origin;
          output.originPoint = delta.originPoint;
        }
        function mixAxis(output, from, to, p) {
          output.min = mixNumber$1(from.min, to.min, p);
          output.max = mixNumber$1(from.max, to.max, p);
        }
        function mixBox(output, from, to, p) {
          mixAxis(output.x, from.x, to.x, p);
          mixAxis(output.y, from.y, to.y, p);
        }
        function hasOpacityCrossfade(node) {
          return node.animationValues && node.animationValues.opacityExit !== undefined;
        }
        var defaultLayoutTransition = {
          duration: 0.45,
          ease: [0.4, 0, 0.1, 1]
        };
        var userAgentContains = function userAgentContains(string) {
          return typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
        };
        /**
         * Measured bounding boxes must be rounded in Safari and
         * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements
         * can appear to jump.
         */
        var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$2;
        function roundAxis(axis) {
          // Round to the nearest .5 pixels to support subpixel layouts
          axis.min = roundPoint(axis.min);
          axis.max = roundPoint(axis.max);
        }
        function roundBox(box) {
          roundAxis(box.x);
          roundAxis(box.y);
        }
        function shouldAnimatePositionOnly(animationType, snapshot, layout) {
          return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);
        }
        function checkNodeWasScrollRoot(node) {
          var _a;
          return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
        }
        var DocumentProjectionNode = createProjectionNode({
          attachResizeListener: function attachResizeListener(ref, notify) {
            return addDomEvent(ref, "resize", notify);
          },
          measureScroll: function measureScroll() {
            return {
              x: document.documentElement.scrollLeft || document.body.scrollLeft,
              y: document.documentElement.scrollTop || document.body.scrollTop
            };
          },
          checkIsScrollRoot: function checkIsScrollRoot() {
            return true;
          }
        });
        var rootProjectionNode = {
          current: undefined
        };
        var HTMLProjectionNode = createProjectionNode({
          measureScroll: function measureScroll(instance) {
            return {
              x: instance.scrollLeft,
              y: instance.scrollTop
            };
          },
          defaultParent: function defaultParent() {
            if (!rootProjectionNode.current) {
              var documentNode = new DocumentProjectionNode({});
              documentNode.mount(window);
              documentNode.setOptions({
                layoutScroll: true
              });
              rootProjectionNode.current = documentNode;
            }
            return rootProjectionNode.current;
          },
          resetTransform: function resetTransform(instance, value) {
            instance.style.transform = value !== undefined ? value : "none";
          },
          checkIsScrollRoot: function checkIsScrollRoot(instance) {
            return Boolean(window.getComputedStyle(instance).position === "fixed");
          }
        });
        var drag = {
          pan: {
            Feature: PanGesture
          },
          drag: {
            Feature: DragGesture,
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout: MeasureLayout
          }
        };
        function handleHoverEvent(node, event, lifecycle) {
          var props = node.props;
          if (node.animationState && props.whileHover) {
            node.animationState.setActive("whileHover", lifecycle === "Start");
          }
          var eventName = "onHover" + lifecycle;
          var callback = props[eventName];
          if (callback) {
            frame.postRender(function () {
              return callback(event, extractEventInfo(event));
            });
          }
        }
        var HoverGesture = /*#__PURE__*/function (_Feature5) {
          function HoverGesture() {
            _classCallCheck(this, HoverGesture);
            return _callSuper(this, HoverGesture, arguments);
          }
          _inherits(HoverGesture, _Feature5);
          return _createClass(HoverGesture, [{
            key: "mount",
            value: function mount() {
              var _this49 = this;
              var current = this.node.current;
              if (!current) return;
              this.unmount = hover(current, function (startEvent) {
                handleHoverEvent(_this49.node, startEvent, "Start");
                return function (endEvent) {
                  return handleHoverEvent(_this49.node, endEvent, "End");
                };
              });
            }
          }, {
            key: "unmount",
            value: function unmount() {}
          }]);
        }(Feature);
        var FocusGesture = /*#__PURE__*/function (_Feature6) {
          function FocusGesture() {
            var _this50;
            _classCallCheck(this, FocusGesture);
            _this50 = _callSuper(this, FocusGesture, arguments);
            _this50.isActive = false;
            return _this50;
          }
          _inherits(FocusGesture, _Feature6);
          return _createClass(FocusGesture, [{
            key: "onFocus",
            value: function onFocus() {
              var isFocusVisible = false;
              /**
               * If this element doesn't match focus-visible then don't
               * apply whileHover. But, if matches throws that focus-visible
               * is not a valid selector then in that browser outline styles will be applied
               * to the element by default and we want to match that behaviour with whileFocus.
               */
              try {
                isFocusVisible = this.node.current.matches(":focus-visible");
              } catch (e) {
                isFocusVisible = true;
              }
              if (!isFocusVisible || !this.node.animationState) return;
              this.node.animationState.setActive("whileFocus", true);
              this.isActive = true;
            }
          }, {
            key: "onBlur",
            value: function onBlur() {
              if (!this.isActive || !this.node.animationState) return;
              this.node.animationState.setActive("whileFocus", false);
              this.isActive = false;
            }
          }, {
            key: "mount",
            value: function mount() {
              var _this51 = this;
              this.unmount = pipe$1(addDomEvent(this.node.current, "focus", function () {
                return _this51.onFocus();
              }), addDomEvent(this.node.current, "blur", function () {
                return _this51.onBlur();
              }));
            }
          }, {
            key: "unmount",
            value: function unmount() {}
          }]);
        }(Feature);
        function handlePressEvent(node, event, lifecycle) {
          var props = node.props;
          if (node.animationState && props.whileTap) {
            node.animationState.setActive("whileTap", lifecycle === "Start");
          }
          var eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
          var callback = props[eventName];
          if (callback) {
            frame.postRender(function () {
              return callback(event, extractEventInfo(event));
            });
          }
        }
        var PressGesture = /*#__PURE__*/function (_Feature7) {
          function PressGesture() {
            _classCallCheck(this, PressGesture);
            return _callSuper(this, PressGesture, arguments);
          }
          _inherits(PressGesture, _Feature7);
          return _createClass(PressGesture, [{
            key: "mount",
            value: function mount() {
              var _this52 = this;
              var current = this.node.current;
              if (!current) return;
              this.unmount = press(current, function (startEvent) {
                handlePressEvent(_this52.node, startEvent, "Start");
                return function (endEvent, _ref136) {
                  var success = _ref136.success;
                  return handlePressEvent(_this52.node, endEvent, success ? "End" : "Cancel");
                };
              }, {
                useGlobalTarget: this.node.props.globalTapTarget
              });
            }
          }, {
            key: "unmount",
            value: function unmount() {}
          }]);
        }(Feature);
        /**
         * Map an IntersectionHandler callback to an element. We only ever make one handler for one
         * element, so even though these handlers might all be triggered by different
         * observers, we can keep them in the same map.
         */
        var observerCallbacks = new WeakMap();
        /**
         * Multiple observers can be created for multiple element/document roots. Each with
         * different settings. So here we store dictionaries of observers to each root,
         * using serialised settings (threshold/margin) as lookup keys.
         */
        var observers = new WeakMap();
        var fireObserverCallback = function fireObserverCallback(entry) {
          var callback = observerCallbacks.get(entry.target);
          callback && callback(entry);
        };
        var fireAllObserverCallbacks = function fireAllObserverCallbacks(entries) {
          entries.forEach(fireObserverCallback);
        };
        function initIntersectionObserver(_ref137) {
          var root = _ref137.root,
            options = _objectWithoutProperties2(_ref137, _excluded15);
          var lookupRoot = root || document;
          /**
           * If we don't have an observer lookup map for this root, create one.
           */
          if (!observers.has(lookupRoot)) {
            observers.set(lookupRoot, {});
          }
          var rootObservers = observers.get(lookupRoot);
          var key = JSON.stringify(options);
          /**
           * If we don't have an observer for this combination of root and settings,
           * create one.
           */
          if (!rootObservers[key]) {
            rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, _objectSpread3({
              root: root
            }, options));
          }
          return rootObservers[key];
        }
        function observeIntersection(element, options, callback) {
          var rootInteresectionObserver = initIntersectionObserver(options);
          observerCallbacks.set(element, callback);
          rootInteresectionObserver.observe(element);
          return function () {
            observerCallbacks.delete(element);
            rootInteresectionObserver.unobserve(element);
          };
        }
        var thresholdNames = {
          some: 0,
          all: 1
        };
        var InViewFeature = /*#__PURE__*/function (_Feature8) {
          function InViewFeature() {
            var _this53;
            _classCallCheck(this, InViewFeature);
            _this53 = _callSuper(this, InViewFeature, arguments);
            _this53.hasEnteredView = false;
            _this53.isInView = false;
            return _this53;
          }
          _inherits(InViewFeature, _Feature8);
          return _createClass(InViewFeature, [{
            key: "startObserver",
            value: function startObserver() {
              var _this54 = this;
              this.unmount();
              var _this$node$getProps5 = this.node.getProps(),
                _this$node$getProps5$ = _this$node$getProps5.viewport,
                viewport = _this$node$getProps5$ === void 0 ? {} : _this$node$getProps5$;
              var root = viewport.root,
                rootMargin = viewport.margin,
                _viewport$amount = viewport.amount,
                amount = _viewport$amount === void 0 ? "some" : _viewport$amount,
                once = viewport.once;
              var options = {
                root: root ? root.current : undefined,
                rootMargin: rootMargin,
                threshold: typeof amount === "number" ? amount : thresholdNames[amount]
              };
              var onIntersectionUpdate = function onIntersectionUpdate(entry) {
                var isIntersecting = entry.isIntersecting;
                /**
                 * If there's been no change in the viewport state, early return.
                 */
                if (_this54.isInView === isIntersecting) return;
                _this54.isInView = isIntersecting;
                /**
                 * Handle hasEnteredView. If this is only meant to run once, and
                 * element isn't visible, early return. Otherwise set hasEnteredView to true.
                 */
                if (once && !isIntersecting && _this54.hasEnteredView) {
                  return;
                } else if (isIntersecting) {
                  _this54.hasEnteredView = true;
                }
                if (_this54.node.animationState) {
                  _this54.node.animationState.setActive("whileInView", isIntersecting);
                }
                /**
                 * Use the latest committed props rather than the ones in scope
                 * when this observer is created
                 */
                var _this54$node$getProps = _this54.node.getProps(),
                  onViewportEnter = _this54$node$getProps.onViewportEnter,
                  onViewportLeave = _this54$node$getProps.onViewportLeave;
                var callback = isIntersecting ? onViewportEnter : onViewportLeave;
                callback && callback(entry);
              };
              return observeIntersection(this.node.current, options, onIntersectionUpdate);
            }
          }, {
            key: "mount",
            value: function mount() {
              this.startObserver();
            }
          }, {
            key: "update",
            value: function update() {
              if (typeof IntersectionObserver === "undefined") return;
              var _this$node = this.node,
                props = _this$node.props,
                prevProps = _this$node.prevProps;
              var hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
              if (hasOptionsChanged) {
                this.startObserver();
              }
            }
          }, {
            key: "unmount",
            value: function unmount() {}
          }]);
        }(Feature);
        function hasViewportOptionChanged(_ref138) {
          var _ref138$viewport = _ref138.viewport,
            viewport = _ref138$viewport === void 0 ? {} : _ref138$viewport;
          var _ref139 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref139$viewport = _ref139.viewport,
            prevViewport = _ref139$viewport === void 0 ? {} : _ref139$viewport;
          return function (name) {
            return viewport[name] !== prevViewport[name];
          };
        }
        var gestureAnimations = {
          inView: {
            Feature: InViewFeature
          },
          tap: {
            Feature: PressGesture
          },
          focus: {
            Feature: FocusGesture
          },
          hover: {
            Feature: HoverGesture
          }
        };
        var layout = {
          layout: {
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout: MeasureLayout
          }
        };

        // Does this device prefer reduced motion? Returns `null` server-side.
        var prefersReducedMotion = {
          current: null
        };
        var hasReducedMotionListener = {
          current: false
        };
        function initPrefersReducedMotion() {
          hasReducedMotionListener.current = true;
          if (!isBrowser$1) return;
          if (window.matchMedia) {
            var motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
            var setReducedMotionPreferences = function setReducedMotionPreferences() {
              return prefersReducedMotion.current = motionMediaQuery.matches;
            };
            motionMediaQuery.addListener(setReducedMotionPreferences);
            setReducedMotionPreferences();
          } else {
            prefersReducedMotion.current = false;
          }
        }

        /**
         * A list of all ValueTypes
         */
        var valueTypes = [].concat(dimensionValueTypes, [color, complex]);
        /**
         * Tests a value against the list of ValueTypes
         */
        var findValueType = function findValueType(v) {
          return valueTypes.find(testValueType(v));
        };
        var visualElementStore = new WeakMap();
        function updateMotionValuesFromProps(element, next, prev) {
          for (var _key58 in next) {
            var nextValue = next[_key58];
            var prevValue = prev[_key58];
            if (isMotionValue(nextValue)) {
              element.addValue(_key58, nextValue);
            } else if (isMotionValue(prevValue)) {
              element.addValue(_key58, motionValue(nextValue, {
                owner: element
              }));
            } else if (prevValue !== nextValue) {
              if (element.hasValue(_key58)) {
                var existingValue = element.getValue(_key58);
                if (existingValue.liveStyle === true) {
                  existingValue.jump(nextValue);
                } else if (!existingValue.hasAnimated) {
                  existingValue.set(nextValue);
                }
              } else {
                var latestValue = element.getStaticValue(_key58);
                element.addValue(_key58, motionValue(latestValue !== void 0 ? latestValue : nextValue, {
                  owner: element
                }));
              }
            }
          }
          for (var _key59 in prev) {
            if (next[_key59] === void 0) element.removeValue(_key59);
          }
          return next;
        }
        var propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
        var VisualElement = /*#__PURE__*/function () {
          function VisualElement(_ref140) {
            var _this55 = this;
            var parent = _ref140.parent,
              props = _ref140.props,
              presenceContext = _ref140.presenceContext,
              reducedMotionConfig = _ref140.reducedMotionConfig,
              blockInitialAnimation = _ref140.blockInitialAnimation,
              visualState = _ref140.visualState;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, VisualElement);
            this.current = null;
            this.children = /* @__PURE__ */new Set();
            this.isVariantNode = false;
            this.isControllingVariants = false;
            this.shouldReduceMotion = null;
            this.values = /* @__PURE__ */new Map();
            this.KeyframeResolver = KeyframeResolver;
            this.features = {};
            this.valueSubscriptions = /* @__PURE__ */new Map();
            this.prevMotionValues = {};
            this.events = {};
            this.propEventSubscriptions = {};
            this.notifyUpdate = function () {
              return _this55.notify("Update", _this55.latestValues);
            };
            this.render = function () {
              if (!_this55.current) return;
              _this55.triggerBuild();
              _this55.renderInstance(_this55.current, _this55.renderState, _this55.props.style, _this55.projection);
            };
            this.renderScheduledAt = 0;
            this.scheduleRender = function () {
              var now = time.now();
              if (_this55.renderScheduledAt < now) {
                _this55.renderScheduledAt = now;
                frame.render(_this55.render, false, true);
              }
            };
            var latestValues = visualState.latestValues,
              renderState = visualState.renderState,
              onUpdate = visualState.onUpdate;
            this.onUpdate = onUpdate;
            this.latestValues = latestValues;
            this.baseTarget = _objectSpread3({}, latestValues);
            this.initialValues = props.initial ? _objectSpread3({}, latestValues) : {};
            this.renderState = renderState;
            this.parent = parent;
            this.props = props;
            this.presenceContext = presenceContext;
            this.depth = parent ? parent.depth + 1 : 0;
            this.reducedMotionConfig = reducedMotionConfig;
            this.options = options;
            this.blockInitialAnimation = Boolean(blockInitialAnimation);
            this.isControllingVariants = isControllingVariants(props);
            this.isVariantNode = isVariantNode(props);
            if (this.isVariantNode) {
              this.variantChildren = /* @__PURE__ */new Set();
            }
            this.manuallyAnimateOnMount = Boolean(parent && parent.current);
            var _this$scrapeMotionVal = this.scrapeMotionValuesFromProps(props, {}, this),
              willChange = _this$scrapeMotionVal.willChange,
              initialMotionValues = _objectWithoutProperties2(_this$scrapeMotionVal, _excluded16);
            for (var _key60 in initialMotionValues) {
              var value = initialMotionValues[_key60];
              if (latestValues[_key60] !== void 0 && isMotionValue(value)) {
                value.set(latestValues[_key60], false);
              }
            }
          }
          return _createClass(VisualElement, [{
            key: "scrapeMotionValuesFromProps",
            value:
            /**
             * This method takes React props and returns found MotionValues. For example, HTML
             * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
             *
             * This isn't an abstract method as it needs calling in the constructor, but it is
             * intended to be one.
             */
            function scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
              return {};
            }
          }, {
            key: "mount",
            value: function mount(instance) {
              var _this56 = this;
              this.current = instance;
              visualElementStore.set(instance, this);
              if (this.projection && !this.projection.instance) {
                this.projection.mount(instance);
              }
              if (this.parent && this.isVariantNode && !this.isControllingVariants) {
                this.removeFromVariantTree = this.parent.addVariantChild(this);
              }
              this.values.forEach(function (value, key) {
                return _this56.bindToMotionValue(key, value);
              });
              if (!hasReducedMotionListener.current) {
                initPrefersReducedMotion();
              }
              this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
              if (this.parent) this.parent.children.add(this);
              this.update(this.props, this.presenceContext);
            }
          }, {
            key: "unmount",
            value: function unmount() {
              visualElementStore.delete(this.current);
              this.projection && this.projection.unmount();
              cancelFrame(this.notifyUpdate);
              cancelFrame(this.render);
              this.valueSubscriptions.forEach(function (remove) {
                return remove();
              });
              this.valueSubscriptions.clear();
              this.removeFromVariantTree && this.removeFromVariantTree();
              this.parent && this.parent.children.delete(this);
              for (var _key61 in this.events) {
                this.events[_key61].clear();
              }
              for (var _key62 in this.features) {
                var feature = this.features[_key62];
                if (feature) {
                  feature.unmount();
                  feature.isMounted = false;
                }
              }
              this.current = null;
            }
          }, {
            key: "bindToMotionValue",
            value: function bindToMotionValue(key, value) {
              var _this57 = this;
              if (this.valueSubscriptions.has(key)) {
                this.valueSubscriptions.get(key)();
              }
              var valueIsTransform = transformProps.has(key);
              var removeOnChange = value.on("change", function (latestValue) {
                _this57.latestValues[key] = latestValue;
                _this57.props.onUpdate && frame.preRender(_this57.notifyUpdate);
                if (valueIsTransform && _this57.projection) {
                  _this57.projection.isTransformDirty = true;
                }
              });
              var removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
              var removeSyncCheck;
              if (window.MotionCheckAppearSync) {
                removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
              }
              this.valueSubscriptions.set(key, function () {
                removeOnChange();
                removeOnRenderRequest();
                if (removeSyncCheck) removeSyncCheck();
                if (value.owner) value.stop();
              });
            }
          }, {
            key: "sortNodePosition",
            value: function sortNodePosition(other) {
              if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
                return 0;
              }
              return this.sortInstanceNodePosition(this.current, other.current);
            }
          }, {
            key: "updateFeatures",
            value: function updateFeatures() {
              var key = "animation";
              for (key in featureDefinitions) {
                var featureDefinition = featureDefinitions[key];
                if (!featureDefinition) continue;
                var isEnabled = featureDefinition.isEnabled,
                  FeatureConstructor = featureDefinition.Feature;
                if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
                  this.features[key] = new FeatureConstructor(this);
                }
                if (this.features[key]) {
                  var feature = this.features[key];
                  if (feature.isMounted) {
                    feature.update();
                  } else {
                    feature.mount();
                    feature.isMounted = true;
                  }
                }
              }
            }
          }, {
            key: "triggerBuild",
            value: function triggerBuild() {
              this.build(this.renderState, this.latestValues, this.props);
            }
            /**
             * Measure the current viewport box with or without transforms.
             * Only measures axis-aligned boxes, rotate and skew must be manually
             * removed with a re-render to work.
             */
          }, {
            key: "measureViewportBox",
            value: function measureViewportBox() {
              return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
            }
          }, {
            key: "getStaticValue",
            value: function getStaticValue(key) {
              return this.latestValues[key];
            }
          }, {
            key: "setStaticValue",
            value: function setStaticValue(key, value) {
              this.latestValues[key] = value;
            }
            /**
             * Update the provided props. Ensure any newly-added motion values are
             * added to our map, old ones removed, and listeners updated.
             */
          }, {
            key: "update",
            value: function update(props, presenceContext) {
              if (props.transformTemplate || this.props.transformTemplate) {
                this.scheduleRender();
              }
              this.prevProps = this.props;
              this.props = props;
              this.prevPresenceContext = this.presenceContext;
              this.presenceContext = presenceContext;
              for (var i = 0; i < propEventHandlers.length; i++) {
                var _key63 = propEventHandlers[i];
                if (this.propEventSubscriptions[_key63]) {
                  this.propEventSubscriptions[_key63]();
                  delete this.propEventSubscriptions[_key63];
                }
                var listenerName = "on" + _key63;
                var listener = props[listenerName];
                if (listener) {
                  this.propEventSubscriptions[_key63] = this.on(_key63, listener);
                }
              }
              this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
              if (this.handleChildMotionValue) {
                this.handleChildMotionValue();
              }
              this.onUpdate && this.onUpdate(this);
            }
          }, {
            key: "getProps",
            value: function getProps() {
              return this.props;
            }
            /**
             * Returns the variant definition with a given name.
             */
          }, {
            key: "getVariant",
            value: function getVariant(name) {
              return this.props.variants ? this.props.variants[name] : void 0;
            }
            /**
             * Returns the defined default transition on this component.
             */
          }, {
            key: "getDefaultTransition",
            value: function getDefaultTransition() {
              return this.props.transition;
            }
          }, {
            key: "getTransformPagePoint",
            value: function getTransformPagePoint() {
              return this.props.transformPagePoint;
            }
          }, {
            key: "getClosestVariantNode",
            value: function getClosestVariantNode() {
              return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
            }
            /**
             * Add a child visual element to our set of children.
             */
          }, {
            key: "addVariantChild",
            value: function addVariantChild(child) {
              var closestVariantNode = this.getClosestVariantNode();
              if (closestVariantNode) {
                closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
                return function () {
                  return closestVariantNode.variantChildren.delete(child);
                };
              }
            }
            /**
             * Add a motion value and bind it to this visual element.
             */
          }, {
            key: "addValue",
            value: function addValue(key, value) {
              var existingValue = this.values.get(key);
              if (value !== existingValue) {
                if (existingValue) this.removeValue(key);
                this.bindToMotionValue(key, value);
                this.values.set(key, value);
                this.latestValues[key] = value.get();
              }
            }
            /**
             * Remove a motion value and unbind any active subscriptions.
             */
          }, {
            key: "removeValue",
            value: function removeValue(key) {
              this.values.delete(key);
              var unsubscribe = this.valueSubscriptions.get(key);
              if (unsubscribe) {
                unsubscribe();
                this.valueSubscriptions.delete(key);
              }
              delete this.latestValues[key];
              this.removeValueFromRenderState(key, this.renderState);
            }
            /**
             * Check whether we have a motion value for this key
             */
          }, {
            key: "hasValue",
            value: function hasValue(key) {
              return this.values.has(key);
            }
          }, {
            key: "getValue",
            value: function getValue(key, defaultValue) {
              if (this.props.values && this.props.values[key]) {
                return this.props.values[key];
              }
              var value = this.values.get(key);
              if (value === void 0 && defaultValue !== void 0) {
                value = motionValue(defaultValue === null ? void 0 : defaultValue, {
                  owner: this
                });
                this.addValue(key, value);
              }
              return value;
            }
            /**
             * If we're trying to animate to a previously unencountered value,
             * we need to check for it in our state and as a last resort read it
             * directly from the instance (which might have performance implications).
             */
          }, {
            key: "readValue",
            value: function readValue(key, target) {
              var _a;
              var value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
              if (value !== void 0 && value !== null) {
                if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
                  value = parseFloat(value);
                } else if (!findValueType(value) && complex.test(target)) {
                  value = getAnimatableNone(key, target);
                }
                this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
              }
              return isMotionValue(value) ? value.get() : value;
            }
            /**
             * Set the base target to later animate back to. This is currently
             * only hydrated on creation and when we first read a value.
             */
          }, {
            key: "setBaseTarget",
            value: function setBaseTarget(key, value) {
              this.baseTarget[key] = value;
            }
            /**
             * Find the base target for a value thats been removed from all animation
             * props.
             */
          }, {
            key: "getBaseTarget",
            value: function getBaseTarget(key) {
              var _a;
              var initial = this.props.initial;
              var valueFromInitial;
              if (typeof initial === "string" || _typeof2(initial) === "object") {
                var variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
                if (variant) {
                  valueFromInitial = variant[key];
                }
              }
              if (initial && valueFromInitial !== void 0) {
                return valueFromInitial;
              }
              var target = this.getBaseTargetFromProps(this.props, key);
              if (target !== void 0 && !isMotionValue(target)) return target;
              return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
            }
          }, {
            key: "on",
            value: function on(eventName, callback) {
              if (!this.events[eventName]) {
                this.events[eventName] = new SubscriptionManager();
              }
              return this.events[eventName].add(callback);
            }
          }, {
            key: "notify",
            value: function notify(eventName) {
              if (this.events[eventName]) {
                var _this$events$eventNam;
                for (var _len34 = arguments.length, args = new Array(_len34 > 1 ? _len34 - 1 : 0), _key64 = 1; _key64 < _len34; _key64++) {
                  args[_key64 - 1] = arguments[_key64];
                }
                (_this$events$eventNam = this.events[eventName]).notify.apply(_this$events$eventNam, args);
              }
            }
          }]);
        }();
        var DOMVisualElement = /*#__PURE__*/function (_VisualElement) {
          function DOMVisualElement() {
            var _this58;
            _classCallCheck(this, DOMVisualElement);
            _this58 = _callSuper(this, DOMVisualElement, arguments);
            _this58.KeyframeResolver = DOMKeyframesResolver;
            return _this58;
          }
          _inherits(DOMVisualElement, _VisualElement);
          return _createClass(DOMVisualElement, [{
            key: "sortInstanceNodePosition",
            value: function sortInstanceNodePosition(a, b) {
              /**
               * compareDocumentPosition returns a bitmask, by using the bitwise &
               * we're returning true if 2 in that bitmask is set to true. 2 is set
               * to true if b preceeds a.
               */
              return a.compareDocumentPosition(b) & 2 ? 1 : -1;
            }
          }, {
            key: "getBaseTargetFromProps",
            value: function getBaseTargetFromProps(props, key) {
              return props.style ? props.style[key] : undefined;
            }
          }, {
            key: "removeValueFromRenderState",
            value: function removeValueFromRenderState(key, _ref141) {
              var vars = _ref141.vars,
                style = _ref141.style;
              delete vars[key];
              delete style[key];
            }
          }, {
            key: "handleChildMotionValue",
            value: function handleChildMotionValue() {
              var _this59 = this;
              if (this.childSubscription) {
                this.childSubscription();
                delete this.childSubscription;
              }
              var children = this.props.children;
              if (isMotionValue(children)) {
                this.childSubscription = children.on("change", function (latest) {
                  if (_this59.current) {
                    _this59.current.textContent = "".concat(latest);
                  }
                });
              }
            }
          }]);
        }(VisualElement);
        function getComputedStyle$1(element) {
          return window.getComputedStyle(element);
        }
        var HTMLVisualElement = /*#__PURE__*/function (_DOMVisualElement) {
          function HTMLVisualElement() {
            var _this60;
            _classCallCheck(this, HTMLVisualElement);
            _this60 = _callSuper(this, HTMLVisualElement, arguments);
            _this60.type = "html";
            _this60.renderInstance = renderHTML;
            return _this60;
          }
          _inherits(HTMLVisualElement, _DOMVisualElement);
          return _createClass(HTMLVisualElement, [{
            key: "readValueFromInstance",
            value: function readValueFromInstance(instance, key) {
              if (transformProps.has(key)) {
                var defaultType = getDefaultValueType(key);
                return defaultType ? defaultType.default || 0 : 0;
              } else {
                var computedStyle = getComputedStyle$1(instance);
                var value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
                return typeof value === "string" ? value.trim() : value;
              }
            }
          }, {
            key: "measureInstanceViewportBox",
            value: function measureInstanceViewportBox(instance, _ref142) {
              var transformPagePoint = _ref142.transformPagePoint;
              return measureViewportBox(instance, transformPagePoint);
            }
          }, {
            key: "build",
            value: function build(renderState, latestValues, props) {
              buildHTMLStyles(renderState, latestValues, props.transformTemplate);
            }
          }, {
            key: "scrapeMotionValuesFromProps",
            value: function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
              return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
            }
          }]);
        }(DOMVisualElement);
        var SVGVisualElement = /*#__PURE__*/function (_DOMVisualElement2) {
          function SVGVisualElement() {
            var _this61;
            _classCallCheck(this, SVGVisualElement);
            _this61 = _callSuper(this, SVGVisualElement, arguments);
            _this61.type = "svg";
            _this61.isSVGTag = false;
            _this61.measureInstanceViewportBox = createBox;
            return _this61;
          }
          _inherits(SVGVisualElement, _DOMVisualElement2);
          return _createClass(SVGVisualElement, [{
            key: "getBaseTargetFromProps",
            value: function getBaseTargetFromProps(props, key) {
              return props[key];
            }
          }, {
            key: "readValueFromInstance",
            value: function readValueFromInstance(instance, key) {
              if (transformProps.has(key)) {
                var defaultType = getDefaultValueType(key);
                return defaultType ? defaultType.default || 0 : 0;
              }
              key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
              return instance.getAttribute(key);
            }
          }, {
            key: "scrapeMotionValuesFromProps",
            value: function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
              return _scrapeMotionValuesFromProps(props, prevProps, visualElement);
            }
          }, {
            key: "build",
            value: function build(renderState, latestValues, props) {
              buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
            }
          }, {
            key: "renderInstance",
            value: function renderInstance(instance, renderState, styleProp, projection) {
              renderSVG(instance, renderState, styleProp, projection);
            }
          }, {
            key: "mount",
            value: function mount(instance) {
              this.isSVGTag = isSVGTag(instance.tagName);
              _superPropGet(SVGVisualElement, "mount", this, 3)([instance]);
            }
          }]);
        }(DOMVisualElement);
        var createDomVisualElement = function createDomVisualElement(Component, options) {
          return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
            allowProjection: Component !== reactExports.Fragment
          });
        };
        var createMotionComponent = /*@__PURE__*/createMotionComponentFactory(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, animations), gestureAnimations), drag), layout), createDomVisualElement);
        var motion = exports("m", /*@__PURE__*/createDOMMotionComponentProxy(createMotionComponent));
        var findById = function findById(arr, id) {
          return arr.find(function (toast) {
            return toast.id === id;
          });
        };
        function findToast(toasts, id) {
          var position = getToastPosition(toasts, id);
          var index = position ? toasts[position].findIndex(function (toast) {
            return toast.id === id;
          }) : -1;
          return {
            position: position,
            index: index
          };
        }
        function getToastPosition(toasts, id) {
          for (var _i9 = 0, _Object$entries4 = Object.entries(toasts); _i9 < _Object$entries4.length; _i9++) {
            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i9], 2),
              _position = _Object$entries4$_i[0],
              values = _Object$entries4$_i[1];
            if (findById(values, id)) {
              return _position;
            }
          }
        }
        function getToastStyle(position) {
          var isRighty = position.includes("right");
          var isLefty = position.includes("left");
          var alignItems = "center";
          if (isRighty) alignItems = "flex-end";
          if (isLefty) alignItems = "flex-start";
          return {
            display: "flex",
            flexDirection: "column",
            alignItems: alignItems
          };
        }
        function getToastListStyle(position) {
          var isTopOrBottom = position === "top" || position === "bottom";
          var margin = isTopOrBottom ? "0 auto" : void 0;
          var top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
          var bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
          var right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
          var left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
          return {
            position: "fixed",
            zIndex: "var(--toast-z-index, 5500)",
            pointerEvents: "none",
            display: "flex",
            flexDirection: "column",
            margin: margin,
            top: top,
            bottom: bottom,
            right: right,
            left: left
          };
        }

        // eslint-disable-next-line no-undef
        var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

        var isPropValid = /* #__PURE__ */memoize(function (prop) {
          return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
          /* o */ && prop.charCodeAt(1) === 110
          /* n */ && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */);
        var testOmitPropsOnStringTag = isPropValid;
        var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
          return key !== 'theme';
        };
        var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
          return typeof tag === 'string' &&
          // 96 is one less than the char code
          // for "a" so this is checking that
          // it's a lowercase character
          tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
        };
        var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
          var shouldForwardProp;
          if (options) {
            var optionsShouldForwardProp = options.shouldForwardProp;
            shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
              return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
            } : optionsShouldForwardProp;
          }
          if (typeof shouldForwardProp !== 'function' && isReal) {
            shouldForwardProp = tag.__emotion_forwardProp;
          }
          return shouldForwardProp;
        };
        var Insertion = function Insertion(_ref) {
          var cache = _ref.cache,
            serialized = _ref.serialized,
            isStringTag = _ref.isStringTag;
          registerStyles(cache, serialized, isStringTag);
          useInsertionEffectAlwaysWithSyncFallback(function () {
            return insertStyles(cache, serialized, isStringTag);
          });
          return null;
        };
        var createStyled = function createStyled(tag, options) {
          var isReal = tag.__emotion_real === tag;
          var baseTag = isReal && tag.__emotion_base || tag;
          var identifierName;
          var targetClassName;
          if (options !== undefined) {
            identifierName = options.label;
            targetClassName = options.target;
          }
          var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
          var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
          var shouldUseAs = !defaultShouldForwardProp('as');
          return function () {
            // eslint-disable-next-line prefer-rest-params
            var args = arguments;
            var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
            if (identifierName !== undefined) {
              styles.push("label:" + identifierName + ";");
            }
            if (args[0] == null || args[0].raw === undefined) {
              // eslint-disable-next-line prefer-spread
              styles.push.apply(styles, args);
            } else {
              var templateStringsArr = args[0];
              styles.push(templateStringsArr[0]);
              var len = args.length;
              var i = 1;
              for (; i < len; i++) {
                styles.push(args[i], templateStringsArr[i]);
              }
            }
            var Styled = withEmotionCache(function (props, cache, ref) {
              var FinalTag = shouldUseAs && props.as || baseTag;
              var className = '';
              var classInterpolations = [];
              var mergedProps = props;
              if (props.theme == null) {
                mergedProps = {};
                for (var key in props) {
                  mergedProps[key] = props[key];
                }
                mergedProps.theme = reactExports.useContext(ThemeContext);
              }
              if (typeof props.className === 'string') {
                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
              } else if (props.className != null) {
                className = props.className + " ";
              }
              var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
              className += cache.key + "-" + serialized.name;
              if (targetClassName !== undefined) {
                className += " " + targetClassName;
              }
              var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
              var newProps = {};
              for (var _key in props) {
                if (shouldUseAs && _key === 'as') continue;
                if (finalShouldForwardProp(_key)) {
                  newProps[_key] = props[_key];
                }
              }
              newProps.className = className;
              if (ref) {
                newProps.ref = ref;
              }
              return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion, {
                cache: cache,
                serialized: serialized,
                isStringTag: typeof FinalTag === 'string'
              }), /*#__PURE__*/reactExports.createElement(FinalTag, newProps));
            });
            Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
            Styled.defaultProps = tag.defaultProps;
            Styled.__emotion_real = Styled;
            Styled.__emotion_base = baseTag;
            Styled.__emotion_styles = styles;
            Styled.__emotion_forwardProp = shouldForwardProp;
            Object.defineProperty(Styled, 'toString', {
              value: function value() {
                return "." + targetClassName;
              }
            });
            Styled.withComponent = function (nextTag, nextOptions) {
              var newStyled = createStyled(nextTag, _extends$1({}, options, nextOptions, {
                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
              }));
              return newStyled.apply(void 0, styles);
            };
            return Styled;
          };
        };
        var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',
        // SVG
        'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

        // bind it to avoid mutating the original function
        var styled$1 = createStyled.bind(null);
        tags.forEach(function (tagName) {
          styled$1[tagName] = styled$1(tagName);
        });
        var allPropNames = /* @__PURE__ */new Set([].concat(_toConsumableArray(propNames), ["textStyle", "layerStyle", "apply", "noOfLines", "focusBorderColor", "errorBorderColor", "as", "__css", "css", "sx"]));
        var validHTMLProps = /* @__PURE__ */new Set(["htmlWidth", "htmlHeight", "htmlSize", "htmlTranslate"]);
        function shouldForwardProp(prop) {
          return (validHTMLProps.has(prop) || !allPropNames.has(prop)) && prop[0] !== "_";
        }
        var emotion_styled = interopDefault(styled$1);
        var toCSSObject = function toCSSObject(_ref143) {
          var baseStyle = _ref143.baseStyle;
          return function (props) {
            var theme = props.theme,
              cssProp = props.css,
              __css = props.__css,
              sx = props.sx,
              restProps = _objectWithoutProperties2(props, _excluded17);
            var _splitProps = splitProps(restProps, isStyleProp),
              _splitProps2 = _slicedToArray(_splitProps, 1),
              styleProps = _splitProps2[0];
            var finalBaseStyle = runIfFn$1(baseStyle, props);
            var finalStyles = assignAfter({}, __css, finalBaseStyle, compact(styleProps), sx);
            var computedCSS = css$2(finalStyles)(props.theme);
            return cssProp ? [computedCSS, cssProp] : computedCSS;
          };
        };
        function styled(component, options) {
          var _ref144 = options !== null && options !== void 0 ? options : {},
            baseStyle = _ref144.baseStyle,
            styledOptions = _objectWithoutProperties2(_ref144, _excluded18);
          if (!styledOptions.shouldForwardProp) {
            styledOptions.shouldForwardProp = shouldForwardProp;
          }
          var styleObject = toCSSObject({
            baseStyle: baseStyle
          });
          var Component = emotion_styled(component, styledOptions)(styleObject);
          var chakraComponent = reactExports.forwardRef(function ChakraComponent2(props, ref) {
            var children = props.children,
              restProps = _objectWithoutProperties2(props, _excluded19);
            var _useColorMode3 = useColorMode(),
              colorMode = _useColorMode3.colorMode,
              forced = _useColorMode3.forced;
            var dataTheme = forced ? colorMode : void 0;
            return reactExports.createElement(Component, _objectSpread3({
              ref: ref,
              "data-theme": dataTheme
            }, restProps), children);
          });
          return chakraComponent;
        }
        function factory() {
          var cache = /* @__PURE__ */new Map();
          return new Proxy(styled, {
            /**
             * @example
             * const Div = chakra("div")
             * const WithChakra = chakra(AnotherComponent)
             */
            apply: function apply(target, thisArg, argArray) {
              return styled.apply(void 0, _toConsumableArray(argArray));
            },
            /**
             * @example
             * <chakra.div />
             */
            get: function get(_, element) {
              if (!cache.has(element)) {
                cache.set(element, styled(element));
              }
              return cache.get(element);
            }
          });
        }
        var chakra = exports("b", factory());
        var toastMotionVariants = {
          initial: function initial(props) {
            var position = props.position;
            var dir = ["top", "bottom"].includes(position) ? "y" : "x";
            var factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
            if (position === "bottom") factor = 1;
            return _defineProperty2({
              opacity: 0
            }, dir, factor * 24);
          },
          animate: {
            opacity: 1,
            y: 0,
            x: 0,
            scale: 1,
            transition: {
              duration: 0.4,
              ease: [0.4, 0, 0.2, 1]
            }
          },
          exit: {
            opacity: 0,
            scale: 0.85,
            transition: {
              duration: 0.2,
              ease: [0.4, 0, 1, 1]
            }
          }
        };
        var ToastComponent = reactExports.memo(function (props) {
          var id = props.id,
            message = props.message,
            onCloseComplete = props.onCloseComplete,
            onRequestRemove = props.onRequestRemove,
            _props$requestClose = props.requestClose,
            requestClose = _props$requestClose === void 0 ? false : _props$requestClose,
            _props$position = props.position,
            position = _props$position === void 0 ? "bottom" : _props$position,
            _props$duration = props.duration,
            duration = _props$duration === void 0 ? 5e3 : _props$duration,
            containerStyle = props.containerStyle,
            _props$motionVariants = props.motionVariants,
            motionVariants = _props$motionVariants === void 0 ? toastMotionVariants : _props$motionVariants,
            _props$toastSpacing = props.toastSpacing,
            toastSpacing = _props$toastSpacing === void 0 ? "0.5rem" : _props$toastSpacing;
          var _reactExports$useStat19 = reactExports.useState(duration),
            _reactExports$useStat20 = _slicedToArray(_reactExports$useStat19, 2),
            delay = _reactExports$useStat20[0],
            setDelay = _reactExports$useStat20[1];
          var isPresent = useIsPresent();
          useUpdateEffect(function () {
            if (!isPresent) {
              onCloseComplete === null || onCloseComplete === void 0 || onCloseComplete();
            }
          }, [isPresent]);
          useUpdateEffect(function () {
            setDelay(duration);
          }, [duration]);
          var onMouseEnter = function onMouseEnter() {
            return setDelay(null);
          };
          var onMouseLeave = function onMouseLeave() {
            return setDelay(duration);
          };
          var close = function close() {
            if (isPresent) onRequestRemove();
          };
          reactExports.useEffect(function () {
            if (isPresent && requestClose) {
              onRequestRemove();
            }
          }, [isPresent, requestClose, onRequestRemove]);
          useTimeout(close, delay);
          var containerStyles = reactExports.useMemo(function () {
            return _objectSpread3({
              pointerEvents: "auto",
              maxWidth: 560,
              minWidth: 300,
              margin: toastSpacing
            }, containerStyle);
          }, [containerStyle, toastSpacing]);
          var toastStyle = reactExports.useMemo(function () {
            return getToastStyle(position);
          }, [position]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(motion.div, {
            layout: true,
            className: "chakra-toast",
            variants: motionVariants,
            initial: "initial",
            animate: "animate",
            exit: "exit",
            onHoverStart: onMouseEnter,
            onHoverEnd: onMouseLeave,
            custom: {
              position: position
            },
            style: toastStyle,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, {
              role: "status",
              "aria-atomic": "true",
              className: "chakra-toast__inner",
              __css: containerStyles,
              children: runIfFn$1(message, {
                id: id,
                onClose: close
              })
            })
          });
        });
        ToastComponent.displayName = "ToastComponent";
        function forwardRef(component) {
          return reactExports.forwardRef(component);
        }

        /* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

        var hasElementType = typeof Element !== 'undefined';
        var hasMap = typeof Map === 'function';
        var hasSet = typeof Set === 'function';
        var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

        // Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

        function equal(a, b) {
          // START: fast-deep-equal es6/index.js 3.1.3
          if (a === b) return true;
          if (a && b && _typeof2(a) == 'object' && _typeof2(b) == 'object') {
            if (a.constructor !== b.constructor) return false;
            var length, i, keys;
            if (Array.isArray(a)) {
              length = a.length;
              if (length != b.length) return false;
              for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
              return true;
            }

            // START: Modifications:
            // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
            //    to co-exist with es5.
            // 2. Replace `for of` with es5 compliant iteration using `for`.
            //    Basically, take:
            //
            //    ```js
            //    for (i of a.entries())
            //      if (!b.has(i[0])) return false;
            //    ```
            //
            //    ... and convert to:
            //
            //    ```js
            //    it = a.entries();
            //    while (!(i = it.next()).done)
            //      if (!b.has(i.value[0])) return false;
            //    ```
            //
            //    **Note**: `i` access switches to `i.value`.
            var it;
            if (hasMap && a instanceof Map && b instanceof Map) {
              if (a.size !== b.size) return false;
              it = a.entries();
              while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
              it = a.entries();
              while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false;
              return true;
            }
            if (hasSet && a instanceof Set && b instanceof Set) {
              if (a.size !== b.size) return false;
              it = a.entries();
              while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
              return true;
            }
            // END: Modifications

            if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
              length = a.length;
              if (length != b.length) return false;
              for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
              return true;
            }
            if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
            // START: Modifications:
            // Apply guards for `Object.create(null)` handling. See:
            // - https://github.com/FormidableLabs/react-fast-compare/issues/64
            // - https://github.com/epoberezkin/fast-deep-equal/issues/49
            if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
            if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
            // END: Modifications

            keys = Object.keys(a);
            length = keys.length;
            if (length !== Object.keys(b).length) return false;
            for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
            // END: fast-deep-equal

            // START: react-fast-compare
            // custom handling for DOM elements
            if (hasElementType && a instanceof Element) return false;

            // custom handling for React/Preact
            for (i = length; i-- !== 0;) {
              if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
                // React-specific: avoid traversing React elements' _owner
                // Preact-specific: avoid traversing Preact elements' __v and __o
                //    __v = $_original / $_vnode
                //    __o = $_owner
                // These properties contain circular references and are not needed when
                // comparing the actual elements (and not their owners)
                // .$$typeof and ._store on just reasonable markers of elements

                continue;
              }

              // all other properties should be traversed as usual
              if (!equal(a[keys[i]], b[keys[i]])) return false;
            }
            // END: react-fast-compare

            // START: fast-deep-equal
            return true;
          }
          return a !== a && b !== b;
        }
        // end fast-deep-equal

        var reactFastCompare = function isEqual(a, b) {
          try {
            return equal(a, b);
          } catch (error) {
            if ((error.message || '').match(/stack|recursion/i)) {
              // warn on circular references, don't crash
              // browsers give this different errors name and messages:
              // chrome/safari: "RangeError", "Maximum call stack size exceeded"
              // firefox: "InternalError", too much recursion"
              // edge: "Error", "Out of stack space"
              console.warn('react-fast-compare cannot handle circular refs');
              return false;
            }
            // some other error. we should definitely know about these
            throw error;
          }
        };
        var isEqual = /*@__PURE__*/getDefaultExportFromCjs(reactFastCompare);
        function useTheme() {
          var theme = reactExports.useContext(ThemeContext);
          if (!theme) {
            throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
          }
          return theme;
        }
        function useChakra() {
          var colorModeResult = useColorMode();
          var theme = useTheme();
          return _objectSpread3(_objectSpread3({}, colorModeResult), {}, {
            theme: theme
          });
        }
        function getBreakpointValue(theme, value, fallback) {
          var _ref146, _getValue;
          if (value == null) return value;
          var getValue = function getValue(val) {
            var _theme$__breakpoints4;
            return (_theme$__breakpoints4 = theme.__breakpoints) === null || _theme$__breakpoints4 === void 0 || (_theme$__breakpoints4 = _theme$__breakpoints4.asArray) === null || _theme$__breakpoints4 === void 0 ? void 0 : _theme$__breakpoints4[val];
          };
          return (_ref146 = (_getValue = getValue(value)) !== null && _getValue !== void 0 ? _getValue : getValue(fallback)) !== null && _ref146 !== void 0 ? _ref146 : fallback;
        }
        function getTokenValue(theme, value, fallback) {
          var _ref147, _getValue2;
          if (value == null) return value;
          var getValue = function getValue(val) {
            var _theme$__cssMap3;
            return (_theme$__cssMap3 = theme.__cssMap) === null || _theme$__cssMap3 === void 0 || (_theme$__cssMap3 = _theme$__cssMap3[val]) === null || _theme$__cssMap3 === void 0 ? void 0 : _theme$__cssMap3.value;
          };
          return (_ref147 = (_getValue2 = getValue(value)) !== null && _getValue2 !== void 0 ? _getValue2 : getValue(fallback)) !== null && _ref147 !== void 0 ? _ref147 : fallback;
        }
        function useToken(scale, token, fallback) {
          var theme = useTheme();
          return getToken(scale, token, fallback)(theme);
        }
        function getToken(scale, token, fallback) {
          var _token = Array.isArray(token) ? token : [token];
          var _fallback = Array.isArray(fallback) ? fallback : [fallback];
          return function (theme) {
            var fallbackArr = _fallback.filter(Boolean);
            var result = _token.map(function (token2, index) {
              var _fallbackArr$index2;
              if (scale === "breakpoints") {
                var _fallbackArr$index;
                return getBreakpointValue(theme, token2, (_fallbackArr$index = fallbackArr[index]) !== null && _fallbackArr$index !== void 0 ? _fallbackArr$index : token2);
              }
              var path = "".concat(scale, ".").concat(token2);
              return getTokenValue(theme, path, (_fallbackArr$index2 = fallbackArr[index]) !== null && _fallbackArr$index2 !== void 0 ? _fallbackArr$index2 : token2);
            });
            return Array.isArray(token) ? result : result[0];
          };
        }
        function omitReactElements(props) {
          return Object.fromEntries(Object.entries(props).filter(function (_ref148) {
            var _ref149 = _slicedToArray(_ref148, 2),
              key = _ref149[0],
              value = _ref149[1];
            return value !== void 0 && key !== "children" && !reactExports.isValidElement(value);
          }));
        }
        function useStyleConfigImpl(themeKey) {
          var _styleConfig$defaultP;
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var styleConfigProp = props.styleConfig,
            rest = _objectWithoutProperties2(props, _excluded20);
          var _useChakra = useChakra(),
            theme = _useChakra.theme,
            colorMode = _useChakra.colorMode;
          var themeStyleConfig = themeKey ? memoizedGet$1(theme, "components.".concat(themeKey)) : void 0;
          var styleConfig = styleConfigProp || themeStyleConfig;
          var mergedProps = mergeWith({
            theme: theme,
            colorMode: colorMode
          }, (_styleConfig$defaultP = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.defaultProps) !== null && _styleConfig$defaultP !== void 0 ? _styleConfig$defaultP : {}, omitReactElements(rest), function (obj, src) {
            return !obj ? src : void 0;
          });
          var stylesRef = reactExports.useRef({});
          if (styleConfig) {
            var _getStyles = resolveStyleConfig(styleConfig);
            var _styles2 = _getStyles(mergedProps);
            var isStyleEqual = isEqual(stylesRef.current, _styles2);
            if (!isStyleEqual) {
              stylesRef.current = _styles2;
            }
          }
          return stylesRef.current;
        }
        function useStyleConfig(themeKey) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return useStyleConfigImpl(themeKey, props);
        }
        function useMultiStyleConfig(themeKey) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return useStyleConfigImpl(themeKey, props);
        }
        var fallbackIcon = {
          path: /* @__PURE__ */jsxRuntimeExports.jsxs("g", {
            stroke: "currentColor",
            strokeWidth: "1.5",
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("path", {
              strokeLinecap: "round",
              fill: "none",
              d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
            }), /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              strokeLinecap: "round",
              d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
            }), /* @__PURE__ */jsxRuntimeExports.jsx("circle", {
              fill: "none",
              strokeMiterlimit: "10",
              cx: "12",
              cy: "12",
              r: "11.25"
            })]
          }),
          viewBox: "0 0 24 24"
        };
        var Icon = exports("I", forwardRef(function (props, ref) {
          var element = props.as,
            viewBox = props.viewBox,
            _props$color = props.color,
            color = _props$color === void 0 ? "currentColor" : _props$color,
            _props$focusable = props.focusable,
            focusable = _props$focusable === void 0 ? false : _props$focusable,
            children = props.children,
            className = props.className,
            __css = props.__css,
            rest = _objectWithoutProperties2(props, _excluded21);
          var _className = cx("chakra-icon", className);
          var customStyles = useStyleConfig("Icon", props);
          var styles = _objectSpread3(_objectSpread3({
            w: "1em",
            h: "1em",
            display: "inline-block",
            lineHeight: "1em",
            flexShrink: 0,
            color: color
          }, __css), customStyles);
          var shared = {
            ref: ref,
            focusable: focusable,
            className: _className,
            __css: styles
          };
          var _viewBox = viewBox !== null && viewBox !== void 0 ? viewBox : fallbackIcon.viewBox;
          if (element && typeof element !== "string") {
            return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.svg, _objectSpread3(_objectSpread3({
              as: element
            }, shared), rest));
          }
          var _path = children !== null && children !== void 0 ? children : fallbackIcon.path;
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.svg, _objectSpread3(_objectSpread3(_objectSpread3({
            verticalAlign: "middle",
            viewBox: _viewBox
          }, shared), rest), {}, {
            children: _path
          }));
        }));
        Icon.displayName = "Icon";
        function CheckIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Icon, _objectSpread3(_objectSpread3({
            viewBox: "0 0 24 24"
          }, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
            })
          }));
        }
        function InfoIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Icon, _objectSpread3(_objectSpread3({
            viewBox: "0 0 24 24"
          }, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
            })
          }));
        }
        function WarningIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Icon, _objectSpread3(_objectSpread3({
            viewBox: "0 0 24 24"
          }, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
            })
          }));
        }
        var spin = keyframes$1({
          "0%": {
            transform: "rotate(0deg)"
          },
          "100%": {
            transform: "rotate(360deg)"
          }
        });
        var Spinner = forwardRef(function (props, ref) {
          var styles = useStyleConfig("Spinner", props);
          var _omitThemingProps = omitThemingProps(props),
            _omitThemingProps$lab = _omitThemingProps.label,
            label = _omitThemingProps$lab === void 0 ? "Loading..." : _omitThemingProps$lab,
            _omitThemingProps$thi = _omitThemingProps.thickness,
            thickness = _omitThemingProps$thi === void 0 ? "2px" : _omitThemingProps$thi,
            _omitThemingProps$spe = _omitThemingProps.speed,
            speed = _omitThemingProps$spe === void 0 ? "0.45s" : _omitThemingProps$spe,
            _omitThemingProps$emp = _omitThemingProps.emptyColor,
            emptyColor = _omitThemingProps$emp === void 0 ? "transparent" : _omitThemingProps$emp,
            className = _omitThemingProps.className,
            rest = _objectWithoutProperties2(_omitThemingProps, _excluded22);
          var _className = cx("chakra-spinner", className);
          var spinnerStyles = _objectSpread3({
            display: "inline-block",
            borderColor: "currentColor",
            borderStyle: "solid",
            borderRadius: "99999px",
            borderWidth: thickness,
            borderBottomColor: emptyColor,
            borderLeftColor: emptyColor,
            animation: "".concat(spin, " ").concat(speed, " linear infinite")
          }, styles);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            __css: spinnerStyles,
            className: _className
          }, rest), {}, {
            children: label && /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, {
              srOnly: true,
              children: label
            })
          }));
        });
        Spinner.displayName = "Spinner";
        var _createContext3 = createContext({
            name: "AlertContext",
            hookName: "useAlertContext",
            providerName: "<Alert />"
          }),
          _createContext4 = _slicedToArray(_createContext3, 2),
          AlertProvider = _createContext4[0],
          useAlertContext = _createContext4[1];
        var _createContext5 = createContext({
            name: "AlertStylesContext",
            hookName: "useAlertStyles",
            providerName: "<Alert />"
          }),
          _createContext6 = _slicedToArray(_createContext5, 2),
          AlertStylesProvider = _createContext6[0],
          useAlertStyles = _createContext6[1];
        var STATUSES = {
          info: {
            icon: InfoIcon,
            colorScheme: "blue"
          },
          warning: {
            icon: WarningIcon,
            colorScheme: "orange"
          },
          success: {
            icon: CheckIcon,
            colorScheme: "green"
          },
          error: {
            icon: WarningIcon,
            colorScheme: "red"
          },
          loading: {
            icon: Spinner,
            colorScheme: "blue"
          }
        };
        function getStatusColorScheme(status) {
          return STATUSES[status].colorScheme;
        }
        function getStatusIcon(status) {
          return STATUSES[status].icon;
        }
        var Alert = forwardRef(function Alert2(props, ref) {
          var _props$colorScheme;
          var _omitThemingProps2 = omitThemingProps(props),
            _omitThemingProps2$st = _omitThemingProps2.status,
            status = _omitThemingProps2$st === void 0 ? "info" : _omitThemingProps2$st,
            _omitThemingProps2$ad = _omitThemingProps2.addRole,
            addRole = _omitThemingProps2$ad === void 0 ? true : _omitThemingProps2$ad,
            rest = _objectWithoutProperties2(_omitThemingProps2, _excluded23);
          var colorScheme = (_props$colorScheme = props.colorScheme) !== null && _props$colorScheme !== void 0 ? _props$colorScheme : getStatusColorScheme(status);
          var styles = useMultiStyleConfig("Alert", _objectSpread3(_objectSpread3({}, props), {}, {
            colorScheme: colorScheme
          }));
          var alertStyles = defineStyle(_objectSpread3({
            width: "100%",
            display: "flex",
            alignItems: "center",
            position: "relative",
            overflow: "hidden"
          }, styles.container));
          return /* @__PURE__ */jsxRuntimeExports.jsx(AlertProvider, {
            value: {
              status: status
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx(AlertStylesProvider, {
              value: styles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
                "data-status": status,
                role: addRole ? "alert" : void 0,
                ref: ref
              }, rest), {}, {
                className: cx("chakra-alert", props.className),
                __css: alertStyles
              }))
            })
          });
        });
        Alert.displayName = "Alert";
        function AlertIcon(props) {
          var _useAlertContext = useAlertContext(),
            status = _useAlertContext.status;
          var BaseIcon = getStatusIcon(status);
          var styles = useAlertStyles();
          var css = status === "loading" ? styles.spinner : styles.icon;
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
            display: "inherit",
            "data-status": status
          }, props), {}, {
            className: cx("chakra-alert__icon", props.className),
            __css: css,
            children: props.children || /* @__PURE__ */jsxRuntimeExports.jsx(BaseIcon, {
              h: "100%",
              w: "100%"
            })
          }));
        }
        AlertIcon.displayName = "AlertIcon";
        var AlertTitle = forwardRef(function AlertTitle2(props, ref) {
          var styles = useAlertStyles();
          var _useAlertContext2 = useAlertContext(),
            status = _useAlertContext2.status;
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            "data-status": status
          }, props), {}, {
            className: cx("chakra-alert__title", props.className),
            __css: styles.title
          }));
        });
        AlertTitle.displayName = "AlertTitle";
        var AlertDescription = forwardRef(function AlertDescription2(props, ref) {
          var _useAlertContext3 = useAlertContext(),
            status = _useAlertContext3.status;
          var styles = useAlertStyles();
          var descriptionStyles = defineStyle(_objectSpread3({
            display: "inline"
          }, styles.description));
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            "data-status": status
          }, props), {}, {
            className: cx("chakra-alert__desc", props.className),
            __css: descriptionStyles
          }));
        });
        AlertDescription.displayName = "AlertDescription";
        function CloseIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Icon, _objectSpread3(_objectSpread3({
            focusable: "false",
            "aria-hidden": true
          }, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
            })
          }));
        }
        var CloseButton = forwardRef(function CloseButton2(props, ref) {
          var styles = useStyleConfig("CloseButton", props);
          var _omitThemingProps3 = omitThemingProps(props),
            children = _omitThemingProps3.children,
            isDisabled = _omitThemingProps3.isDisabled,
            __css = _omitThemingProps3.__css,
            rest = _objectWithoutProperties2(_omitThemingProps3, _excluded24);
          var baseStyle = {
            outline: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flexShrink: 0
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.button, _objectSpread3(_objectSpread3({
            type: "button",
            "aria-label": "Close",
            ref: ref,
            disabled: isDisabled,
            __css: _objectSpread3(_objectSpread3(_objectSpread3({}, baseStyle), styles), __css)
          }, rest), {}, {
            children: children || /* @__PURE__ */jsxRuntimeExports.jsx(CloseIcon, {
              width: "1em",
              height: "1em"
            })
          }));
        });
        CloseButton.displayName = "CloseButton";
        var Toast = function Toast(props) {
          var status = props.status,
            _props$variant = props.variant,
            variant = _props$variant === void 0 ? "solid" : _props$variant,
            id = props.id,
            title = props.title,
            isClosable = props.isClosable,
            onClose = props.onClose,
            description = props.description,
            colorScheme = props.colorScheme,
            icon = props.icon;
          var ids = id ? {
            root: "toast-".concat(id),
            title: "toast-".concat(id, "-title"),
            description: "toast-".concat(id, "-description")
          } : void 0;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
            addRole: false,
            status: status,
            variant: variant,
            id: ids === null || ids === void 0 ? void 0 : ids.root,
            alignItems: "start",
            borderRadius: "md",
            boxShadow: "lg",
            paddingEnd: 8,
            textAlign: "start",
            width: "auto",
            colorScheme: colorScheme,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(AlertIcon, {
              children: icon
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.div, {
              flex: "1",
              maxWidth: "100%",
              children: [title && /* @__PURE__ */jsxRuntimeExports.jsx(AlertTitle, {
                id: ids === null || ids === void 0 ? void 0 : ids.title,
                children: title
              }), description && /* @__PURE__ */jsxRuntimeExports.jsx(AlertDescription, {
                id: ids === null || ids === void 0 ? void 0 : ids.description,
                display: "block",
                children: description
              })]
            }), isClosable && /* @__PURE__ */jsxRuntimeExports.jsx(CloseButton, {
              size: "sm",
              onClick: onClose,
              position: "absolute",
              insetEnd: 1,
              top: 1
            })]
          });
        };
        function createRenderToast() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var render = options.render,
            _options$toastCompone = options.toastComponent,
            ToastComponent = _options$toastCompone === void 0 ? Toast : _options$toastCompone;
          var renderToast = function renderToast(props) {
            if (typeof render === "function") {
              return render(_objectSpread3(_objectSpread3({}, props), options));
            }
            return /* @__PURE__ */jsxRuntimeExports.jsx(ToastComponent, _objectSpread3(_objectSpread3({}, props), options));
          };
          return renderToast;
        }
        var initialState = {
          top: [],
          "top-left": [],
          "top-right": [],
          "bottom-left": [],
          bottom: [],
          "bottom-right": []
        };
        var toastStore = createStore(initialState);
        function createStore(initialState2) {
          var state = initialState2;
          var listeners = /* @__PURE__ */new Set();
          var setState = function setState(setStateFn) {
            state = setStateFn(state);
            listeners.forEach(function (l) {
              return l();
            });
          };
          return {
            getState: function getState() {
              return state;
            },
            subscribe: function subscribe(listener) {
              listeners.add(listener);
              return function () {
                setState(function () {
                  return initialState2;
                });
                listeners.delete(listener);
              };
            },
            /**
             * Delete a toast record at its position
             */
            removeToast: function removeToast(id, position) {
              setState(function (prevState) {
                return _objectSpread3(_objectSpread3({}, prevState), {}, _defineProperty2({}, position, prevState[position].filter(function (toast) {
                  return toast.id != id;
                })));
              });
            },
            notify: function notify(message, options) {
              var toast = createToast(message, options);
              var position = toast.position,
                id = toast.id;
              setState(function (prevToasts) {
                var _prevToasts$position, _prevToasts$position2;
                var isTop = position.includes("top");
                var toasts = isTop ? [toast].concat(_toConsumableArray((_prevToasts$position = prevToasts[position]) !== null && _prevToasts$position !== void 0 ? _prevToasts$position : [])) : [].concat(_toConsumableArray((_prevToasts$position2 = prevToasts[position]) !== null && _prevToasts$position2 !== void 0 ? _prevToasts$position2 : []), [toast]);
                return _objectSpread3(_objectSpread3({}, prevToasts), {}, _defineProperty2({}, position, toasts));
              });
              return id;
            },
            update: function update(id, options) {
              if (!id) return;
              setState(function (prevState) {
                var nextState = _objectSpread3({}, prevState);
                var _findToast = findToast(nextState, id),
                  position = _findToast.position,
                  index = _findToast.index;
                if (position && index !== -1) {
                  nextState[position][index] = _objectSpread3(_objectSpread3(_objectSpread3({}, nextState[position][index]), options), {}, {
                    message: createRenderToast(options)
                  });
                }
                return nextState;
              });
            },
            closeAll: function closeAll() {
              var _ref150 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                positions = _ref150.positions;
              setState(function (prev) {
                var allPositions = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
                var positionsToClose = positions !== null && positions !== void 0 ? positions : allPositions;
                return positionsToClose.reduce(function (acc, position) {
                  acc[position] = prev[position].map(function (toast) {
                    return _objectSpread3(_objectSpread3({}, toast), {}, {
                      requestClose: true
                    });
                  });
                  return acc;
                }, _objectSpread3({}, prev));
              });
            },
            close: function close(id) {
              setState(function (prevState) {
                var position = getToastPosition(prevState, id);
                if (!position) return prevState;
                return _objectSpread3(_objectSpread3({}, prevState), {}, _defineProperty2({}, position, prevState[position].map(function (toast) {
                  if (toast.id == id) {
                    return _objectSpread3(_objectSpread3({}, toast), {}, {
                      requestClose: true
                    });
                  }
                  return toast;
                })));
              });
            },
            isActive: function isActive(id) {
              return Boolean(findToast(toastStore.getState(), id).position);
            }
          };
        }
        var counter = 0;
        function createToast(message) {
          var _options$id, _options$position;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          counter += 1;
          var id = (_options$id = options.id) !== null && _options$id !== void 0 ? _options$id : counter;
          var position = (_options$position = options.position) !== null && _options$position !== void 0 ? _options$position : "bottom";
          return {
            id: id,
            message: message,
            position: position,
            duration: options.duration,
            onCloseComplete: options.onCloseComplete,
            onRequestRemove: function onRequestRemove() {
              return toastStore.removeToast(String(id), position);
            },
            status: options.status,
            requestClose: false,
            containerStyle: options.containerStyle
          };
        }
        var _createContext7 = createContext({
            strict: false,
            name: "PortalContext"
          }),
          _createContext8 = _slicedToArray(_createContext7, 2),
          PortalContextProvider = _createContext8[0],
          usePortalContext = _createContext8[1];
        var PORTAL_CLASSNAME = "chakra-portal";
        var PORTAL_SELECTOR = ".chakra-portal";
        var Container$1 = function Container$1(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: "chakra-portal-zIndex",
            style: {
              position: "absolute",
              zIndex: props.zIndex,
              top: 0,
              left: 0,
              right: 0
              // NB: Don't add `bottom: 0`, it makes the entire app unusable
              // @see https://github.com/chakra-ui/chakra-ui/issues/3201
            },
            children: props.children
          });
        };
        var DefaultPortal = function DefaultPortal(props) {
          var appendToParentPortal = props.appendToParentPortal,
            children = props.children;
          var _reactExports$useStat21 = reactExports.useState(null),
            _reactExports$useStat22 = _slicedToArray(_reactExports$useStat21, 2),
            tempNode = _reactExports$useStat22[0],
            setTempNode = _reactExports$useStat22[1];
          var portal = reactExports.useRef(null);
          var _reactExports$useStat23 = reactExports.useState({}),
            _reactExports$useStat24 = _slicedToArray(_reactExports$useStat23, 2),
            forceUpdate = _reactExports$useStat24[1];
          reactExports.useEffect(function () {
            return forceUpdate({});
          }, []);
          var parentPortal = usePortalContext();
          var manager = usePortalManager();
          useSafeLayoutEffect$2(function () {
            if (!tempNode) return;
            var doc = tempNode.ownerDocument;
            var host = appendToParentPortal ? parentPortal !== null && parentPortal !== void 0 ? parentPortal : doc.body : doc.body;
            if (!host) return;
            portal.current = doc.createElement("div");
            portal.current.className = PORTAL_CLASSNAME;
            host.appendChild(portal.current);
            forceUpdate({});
            var portalNode = portal.current;
            return function () {
              if (host.contains(portalNode)) {
                host.removeChild(portalNode);
              }
            };
          }, [tempNode]);
          var _children = manager !== null && manager !== void 0 && manager.zIndex ? /* @__PURE__ */jsxRuntimeExports.jsx(Container$1, {
            zIndex: manager === null || manager === void 0 ? void 0 : manager.zIndex,
            children: children
          }) : children;
          return portal.current ? reactDomExports.createPortal(/* @__PURE__ */jsxRuntimeExports.jsx(PortalContextProvider, {
            value: portal.current,
            children: _children
          }), portal.current) : /* @__PURE__ */jsxRuntimeExports.jsx("span", {
            ref: function ref(el) {
              if (el) setTempNode(el);
            }
          });
        };
        var ContainerPortal = function ContainerPortal(props) {
          var children = props.children,
            containerRef = props.containerRef,
            appendToParentPortal = props.appendToParentPortal;
          var containerEl = containerRef.current;
          var host = containerEl !== null && containerEl !== void 0 ? containerEl : typeof window !== "undefined" ? document.body : void 0;
          var portal = reactExports.useMemo(function () {
            var node = containerEl === null || containerEl === void 0 ? void 0 : containerEl.ownerDocument.createElement("div");
            if (node) node.className = PORTAL_CLASSNAME;
            return node;
          }, [containerEl]);
          var _reactExports$useStat25 = reactExports.useState({}),
            _reactExports$useStat26 = _slicedToArray(_reactExports$useStat25, 2),
            forceUpdate = _reactExports$useStat26[1];
          useSafeLayoutEffect$2(function () {
            return forceUpdate({});
          }, []);
          useSafeLayoutEffect$2(function () {
            if (!portal || !host) return;
            host.appendChild(portal);
            return function () {
              host.removeChild(portal);
            };
          }, [portal, host]);
          if (host && portal) {
            return reactDomExports.createPortal(/* @__PURE__ */jsxRuntimeExports.jsx(PortalContextProvider, {
              value: appendToParentPortal ? portal : null,
              children: children
            }), portal);
          }
          return null;
        };
        function Portal(props) {
          var portalProps = _objectSpread3({
            appendToParentPortal: true
          }, props);
          var containerRef = portalProps.containerRef,
            rest = _objectWithoutProperties2(portalProps, _excluded25);
          return containerRef ? /* @__PURE__ */jsxRuntimeExports.jsx(ContainerPortal, _objectSpread3({
            containerRef: containerRef
          }, rest)) : /* @__PURE__ */jsxRuntimeExports.jsx(DefaultPortal, _objectSpread3({}, rest));
        }
        Portal.className = PORTAL_CLASSNAME;
        Portal.selector = PORTAL_SELECTOR;
        Portal.displayName = "Portal";
        var _createContext9 = createContext({
            name: "ToastOptionsContext",
            strict: false
          }),
          _createContext0 = _slicedToArray(_createContext9, 2),
          ToastOptionProvider = _createContext0[0],
          useToastOptionContext = _createContext0[1];
        var ToastProvider = function ToastProvider(props) {
          var state = reactExports.useSyncExternalStore(toastStore.subscribe, toastStore.getState, toastStore.getState);
          var motionVariants = props.motionVariants,
            _props$component = props.component,
            Component = _props$component === void 0 ? ToastComponent : _props$component,
            portalProps = props.portalProps,
            animatePresenceProps = props.animatePresenceProps;
          var stateKeys = Object.keys(state);
          var toastList = stateKeys.map(function (position) {
            var toasts = state[position];
            return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              role: "region",
              "aria-live": "polite",
              "aria-label": "Notifications-".concat(position),
              id: "chakra-toast-manager-".concat(position),
              style: getToastListStyle(position),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(AnimatePresence, _objectSpread3(_objectSpread3({}, animatePresenceProps), {}, {
                initial: false,
                children: toasts.map(function (toast) {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(Component, _objectSpread3({
                    motionVariants: motionVariants
                  }, toast), toast.id);
                })
              }))
            }, position);
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(Portal, _objectSpread3(_objectSpread3({}, portalProps), {}, {
            children: toastList
          }));
        };
        var createProvider = function createProvider(providerTheme) {
          return function ChakraProvider(_ref151) {
            var children = _ref151.children,
              _ref151$theme = _ref151.theme,
              theme = _ref151$theme === void 0 ? providerTheme : _ref151$theme,
              toastOptions = _ref151.toastOptions,
              restProps = _objectWithoutProperties2(_ref151, _excluded26);
            return /* @__PURE__ */jsxRuntimeExports.jsxs(Provider, _objectSpread3(_objectSpread3({
              theme: theme
            }, restProps), {}, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(ToastOptionProvider, {
                value: toastOptions === null || toastOptions === void 0 ? void 0 : toastOptions.defaultOptions,
                children: children
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ToastProvider, _objectSpread3({}, toastOptions))]
            }));
          };
        };
        var ChakraProvider = createProvider(theme$1);
        function sortNodes(nodes) {
          return nodes.sort(function (a, b) {
            var compare = a.compareDocumentPosition(b);
            if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
              return -1;
            }
            if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
              return 1;
            }
            if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
              throw Error("Cannot sort the given nodes.");
            } else {
              return 0;
            }
          });
        }
        var isElement$1 = function isElement$1(el) {
          return _typeof2(el) == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
        };
        function getNextIndex(current, max, loop) {
          var next = current + 1;
          if (loop && next >= max) next = 0;
          return next;
        }
        function getPrevIndex(current, max, loop) {
          var next = current - 1;
          if (loop && next < 0) next = max;
          return next;
        }
        var useSafeLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
        var cast = function cast(value) {
          return value;
        };
        var __defProp$1 = Object.defineProperty;
        var __defNormalProp$1 = function __defNormalProp$1(obj, key, value) {
          return key in obj ? __defProp$1(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          }) : obj[key] = value;
        };
        var __publicField$1 = function __publicField$1(obj, key, value) {
          __defNormalProp$1(obj, _typeof2(key) !== "symbol" ? key + "" : key, value);
          return value;
        };
        var DescendantsManager = /*#__PURE__*/_createClass(function DescendantsManager() {
          var _this62 = this;
          _classCallCheck(this, DescendantsManager);
          __publicField$1(this, "descendants", /* @__PURE__ */new Map());
          __publicField$1(this, "register", function (nodeOrOptions) {
            if (nodeOrOptions == null) return;
            if (isElement$1(nodeOrOptions)) {
              return _this62.registerNode(nodeOrOptions);
            }
            return function (node) {
              _this62.registerNode(node, nodeOrOptions);
            };
          });
          __publicField$1(this, "unregister", function (node) {
            _this62.descendants.delete(node);
            var sorted = sortNodes(Array.from(_this62.descendants.keys()));
            _this62.assignIndex(sorted);
          });
          __publicField$1(this, "destroy", function () {
            _this62.descendants.clear();
          });
          __publicField$1(this, "assignIndex", function (descendants) {
            _this62.descendants.forEach(function (descendant) {
              var index = descendants.indexOf(descendant.node);
              descendant.index = index;
              descendant.node.dataset["index"] = descendant.index.toString();
            });
          });
          __publicField$1(this, "count", function () {
            return _this62.descendants.size;
          });
          __publicField$1(this, "enabledCount", function () {
            return _this62.enabledValues().length;
          });
          __publicField$1(this, "values", function () {
            var values = Array.from(_this62.descendants.values());
            return values.sort(function (a, b) {
              return a.index - b.index;
            });
          });
          __publicField$1(this, "enabledValues", function () {
            return _this62.values().filter(function (descendant) {
              return !descendant.disabled;
            });
          });
          __publicField$1(this, "item", function (index) {
            if (_this62.count() === 0) return void 0;
            return _this62.values()[index];
          });
          __publicField$1(this, "enabledItem", function (index) {
            if (_this62.enabledCount() === 0) return void 0;
            return _this62.enabledValues()[index];
          });
          __publicField$1(this, "first", function () {
            return _this62.item(0);
          });
          __publicField$1(this, "firstEnabled", function () {
            return _this62.enabledItem(0);
          });
          __publicField$1(this, "last", function () {
            return _this62.item(_this62.descendants.size - 1);
          });
          __publicField$1(this, "lastEnabled", function () {
            var lastIndex = _this62.enabledValues().length - 1;
            return _this62.enabledItem(lastIndex);
          });
          __publicField$1(this, "indexOf", function (node) {
            var _this62$descendants$g, _this62$descendants$g2;
            if (!node) return -1;
            return (_this62$descendants$g = (_this62$descendants$g2 = _this62.descendants.get(node)) === null || _this62$descendants$g2 === void 0 ? void 0 : _this62$descendants$g2.index) !== null && _this62$descendants$g !== void 0 ? _this62$descendants$g : -1;
          });
          __publicField$1(this, "enabledIndexOf", function (node) {
            if (node == null) return -1;
            return _this62.enabledValues().findIndex(function (i) {
              return i.node.isSameNode(node);
            });
          });
          __publicField$1(this, "next", function (index) {
            var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var next = getNextIndex(index, _this62.count(), loop);
            return _this62.item(next);
          });
          __publicField$1(this, "nextEnabled", function (index) {
            var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var item = _this62.item(index);
            if (!item) return;
            var enabledIndex = _this62.enabledIndexOf(item.node);
            var nextEnabledIndex = getNextIndex(enabledIndex, _this62.enabledCount(), loop);
            return _this62.enabledItem(nextEnabledIndex);
          });
          __publicField$1(this, "prev", function (index) {
            var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var prev = getPrevIndex(index, _this62.count() - 1, loop);
            return _this62.item(prev);
          });
          __publicField$1(this, "prevEnabled", function (index) {
            var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var item = _this62.item(index);
            if (!item) return;
            var enabledIndex = _this62.enabledIndexOf(item.node);
            var prevEnabledIndex = getPrevIndex(enabledIndex, _this62.enabledCount() - 1, loop);
            return _this62.enabledItem(prevEnabledIndex);
          });
          __publicField$1(this, "registerNode", function (node, options) {
            if (!node || _this62.descendants.has(node)) return;
            var keys = Array.from(_this62.descendants.keys()).concat(node);
            var sorted = sortNodes(keys);
            if (options !== null && options !== void 0 && options.disabled) {
              options.disabled = !!options.disabled;
            }
            var descendant = _objectSpread3({
              node: node,
              index: -1
            }, options);
            _this62.descendants.set(node, descendant);
            _this62.assignIndex(sorted);
          });
        });
        function createDescendantContext() {
          var _createContext1 = createContext({
              name: "DescendantsProvider",
              errorMessage: "useDescendantsContext must be used within DescendantsProvider"
            }),
            _createContext10 = _slicedToArray(_createContext1, 2),
            DescendantsContextProvider = _createContext10[0],
            useDescendantsContext = _createContext10[1];
          var useDescendant = function useDescendant(options) {
            var descendants = useDescendantsContext();
            var _reactExports$useStat27 = reactExports.useState(-1),
              _reactExports$useStat28 = _slicedToArray(_reactExports$useStat27, 2),
              index = _reactExports$useStat28[0],
              setIndex = _reactExports$useStat28[1];
            var ref = reactExports.useRef(null);
            useSafeLayoutEffect(function () {
              return function () {
                if (!ref.current) return;
                descendants.unregister(ref.current);
              };
            }, []);
            useSafeLayoutEffect(function () {
              if (!ref.current) return;
              var dataIndex = Number(ref.current.dataset["index"]);
              if (index != dataIndex && !Number.isNaN(dataIndex)) {
                setIndex(dataIndex);
              }
            });
            var refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
            return {
              descendants: descendants,
              index: index,
              enabledIndex: descendants.enabledIndexOf(ref.current),
              register: mergeRefs(refCallback, ref)
            };
          };
          var useDescendants = function useDescendants() {
            var descendants = reactExports.useRef(new DescendantsManager());
            useSafeLayoutEffect(function () {
              return function () {
                return descendants.current.destroy();
              };
            });
            return descendants.current;
          };
          return [
          // context provider
          DescendantsContextProvider,
          // call this when you need to read from context
          useDescendantsContext,
          // descendants state information, to be called and passed to `ContextProvider`
          useDescendants,
          // descendant index information
          useDescendant];
        }
        var TRANSITION_EASINGS = {
          easeIn: [0.4, 0, 1, 1],
          easeOut: [0, 0, 0.2, 1],
          easeInOut: [0.4, 0, 0.2, 1]
        };
        var TRANSITION_VARIANTS = {
          slideLeft: {
            position: {
              left: 0,
              top: 0,
              bottom: 0,
              width: "100%"
            },
            enter: {
              x: 0,
              y: 0
            },
            exit: {
              x: "-100%",
              y: 0
            }
          },
          slideRight: {
            position: {
              right: 0,
              top: 0,
              bottom: 0,
              width: "100%"
            },
            enter: {
              x: 0,
              y: 0
            },
            exit: {
              x: "100%",
              y: 0
            }
          },
          slideUp: {
            position: {
              top: 0,
              left: 0,
              right: 0,
              maxWidth: "100vw"
            },
            enter: {
              x: 0,
              y: 0
            },
            exit: {
              x: 0,
              y: "-100%"
            }
          },
          slideDown: {
            position: {
              bottom: 0,
              left: 0,
              right: 0,
              maxWidth: "100vw"
            },
            enter: {
              x: 0,
              y: 0
            },
            exit: {
              x: 0,
              y: "100%"
            }
          }
        };
        function getSlideTransition(options) {
          var _options$direction;
          var side = (_options$direction = options === null || options === void 0 ? void 0 : options.direction) !== null && _options$direction !== void 0 ? _options$direction : "right";
          switch (side) {
            case "right":
              return TRANSITION_VARIANTS.slideRight;
            case "left":
              return TRANSITION_VARIANTS.slideLeft;
            case "bottom":
              return TRANSITION_VARIANTS.slideDown;
            case "top":
              return TRANSITION_VARIANTS.slideUp;
            default:
              return TRANSITION_VARIANTS.slideRight;
          }
        }
        var TRANSITION_DEFAULTS = exports("T", {
          enter: {
            duration: 0.2,
            ease: TRANSITION_EASINGS.easeOut
          },
          exit: {
            duration: 0.1,
            ease: TRANSITION_EASINGS.easeIn
          }
        });
        var withDelay = exports("w", {
          enter: function enter(transition, delay) {
            return _objectSpread3(_objectSpread3({}, transition), {}, {
              delay: typeof delay === "number" ? delay : delay === null || delay === void 0 ? void 0 : delay["enter"]
            });
          },
          exit: function exit(transition, delay) {
            return _objectSpread3(_objectSpread3({}, transition), {}, {
              delay: typeof delay === "number" ? delay : delay === null || delay === void 0 ? void 0 : delay["exit"]
            });
          }
        });
        var _createContext11 = createContext({
            name: "AvatarStylesContext",
            hookName: "useAvatarStyles",
            providerName: "<Avatar/>"
          }),
          _createContext12 = _slicedToArray(_createContext11, 2),
          AvatarStylesProvider = _createContext12[0],
          useAvatarStyles = _createContext12[1];
        function initials(name) {
          var _names$;
          var names = name.trim().split(" ");
          var firstName = (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : "";
          var lastName = names.length > 1 ? names[names.length - 1] : "";
          return firstName && lastName ? "".concat(firstName.charAt(0)).concat(lastName.charAt(0)) : firstName.charAt(0);
        }
        function AvatarName(props) {
          var name = props.name,
            getInitials = props.getInitials,
            rest = _objectWithoutProperties2(props, _excluded27);
          var styles = useAvatarStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            role: "img",
            "aria-label": name
          }, rest), {}, {
            __css: styles.label,
            children: name ? getInitials === null || getInitials === void 0 ? void 0 : getInitials(name) : null
          }));
        }
        AvatarName.displayName = "AvatarName";
        var GenericAvatarIcon = function GenericAvatarIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.svg, _objectSpread3(_objectSpread3({
            viewBox: "0 0 128 128",
            color: "#fff",
            width: "100%",
            height: "100%",
            className: "chakra-avatar__svg"
          }, props), {}, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
            }), /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
            })]
          }));
        };
        function useImage(props) {
          var loading = props.loading,
            src = props.src,
            srcSet = props.srcSet,
            onLoad = props.onLoad,
            onError = props.onError,
            crossOrigin = props.crossOrigin,
            sizes = props.sizes,
            ignoreFallback = props.ignoreFallback;
          var _reactExports$useStat29 = reactExports.useState("pending"),
            _reactExports$useStat30 = _slicedToArray(_reactExports$useStat29, 2),
            status = _reactExports$useStat30[0],
            setStatus = _reactExports$useStat30[1];
          reactExports.useEffect(function () {
            setStatus(src ? "loading" : "pending");
          }, [src]);
          var imageRef = reactExports.useRef(null);
          var load = reactExports.useCallback(function () {
            if (!src) return;
            flush();
            var img = new Image();
            img.src = src;
            if (crossOrigin) img.crossOrigin = crossOrigin;
            if (srcSet) img.srcset = srcSet;
            if (sizes) img.sizes = sizes;
            if (loading) img.loading = loading;
            img.onload = function (event) {
              flush();
              setStatus("loaded");
              onLoad === null || onLoad === void 0 || onLoad(event);
            };
            img.onerror = function (error) {
              flush();
              setStatus("failed");
              onError === null || onError === void 0 || onError(error);
            };
            imageRef.current = img;
          }, [src, crossOrigin, srcSet, sizes, onLoad, onError, loading]);
          var flush = function flush() {
            if (imageRef.current) {
              imageRef.current.onload = null;
              imageRef.current.onerror = null;
              imageRef.current = null;
            }
          };
          useSafeLayoutEffect$2(function () {
            if (ignoreFallback) return void 0;
            if (status === "loading") {
              load();
            }
            return function () {
              flush();
            };
          }, [status, load, ignoreFallback]);
          return ignoreFallback ? "loaded" : status;
        }
        var shouldShowFallbackImage = exports("W", function (status, fallbackStrategy) {
          return status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
        });
        function AvatarImage(props) {
          var src = props.src,
            srcSet = props.srcSet,
            onError = props.onError,
            onLoad = props.onLoad,
            getInitials = props.getInitials,
            name = props.name,
            borderRadius = props.borderRadius,
            loading = props.loading,
            iconLabel = props.iconLabel,
            _props$icon = props.icon,
            icon = _props$icon === void 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(GenericAvatarIcon, {}) : _props$icon,
            ignoreFallback = props.ignoreFallback,
            referrerPolicy = props.referrerPolicy,
            crossOrigin = props.crossOrigin;
          var status = useImage({
            src: src,
            onError: onError,
            crossOrigin: crossOrigin,
            ignoreFallback: ignoreFallback
          });
          var hasLoaded = status === "loaded";
          var showFallback = !src || !hasLoaded;
          if (showFallback) {
            return name ? /* @__PURE__ */jsxRuntimeExports.jsx(AvatarName, {
              className: "chakra-avatar__initials",
              getInitials: getInitials,
              name: name
            }) : reactExports.cloneElement(icon, {
              role: "img",
              "aria-label": iconLabel
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.img, {
            src: src,
            srcSet: srcSet,
            alt: name !== null && name !== void 0 ? name : iconLabel,
            onLoad: onLoad,
            referrerPolicy: referrerPolicy,
            crossOrigin: crossOrigin !== null && crossOrigin !== void 0 ? crossOrigin : void 0,
            className: "chakra-avatar__img",
            loading: loading,
            __css: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              borderRadius: borderRadius
            }
          });
        }
        AvatarImage.displayName = "AvatarImage";
        var baseStyle = defineStyle({
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          textTransform: "uppercase",
          fontWeight: "medium",
          position: "relative",
          flexShrink: 0
        });
        var Avatar = forwardRef(function (props, ref) {
          var styles = useMultiStyleConfig("Avatar", props);
          var _reactExports$useStat31 = reactExports.useState(false),
            _reactExports$useStat32 = _slicedToArray(_reactExports$useStat31, 2),
            isLoaded = _reactExports$useStat32[0],
            setIsLoaded = _reactExports$useStat32[1];
          var _omitThemingProps4 = omitThemingProps(props),
            src = _omitThemingProps4.src,
            srcSet = _omitThemingProps4.srcSet,
            name = _omitThemingProps4.name,
            showBorder = _omitThemingProps4.showBorder,
            _omitThemingProps4$bo = _omitThemingProps4.borderRadius,
            borderRadius = _omitThemingProps4$bo === void 0 ? "full" : _omitThemingProps4$bo,
            onError = _omitThemingProps4.onError,
            onLoadProp = _omitThemingProps4.onLoad,
            _omitThemingProps4$ge = _omitThemingProps4.getInitials,
            getInitials = _omitThemingProps4$ge === void 0 ? initials : _omitThemingProps4$ge,
            _omitThemingProps4$ic = _omitThemingProps4.icon,
            icon = _omitThemingProps4$ic === void 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(GenericAvatarIcon, {}) : _omitThemingProps4$ic,
            _omitThemingProps4$ic2 = _omitThemingProps4.iconLabel,
            iconLabel = _omitThemingProps4$ic2 === void 0 ? " avatar" : _omitThemingProps4$ic2,
            loading = _omitThemingProps4.loading,
            children = _omitThemingProps4.children,
            borderColor = _omitThemingProps4.borderColor,
            ignoreFallback = _omitThemingProps4.ignoreFallback,
            crossOrigin = _omitThemingProps4.crossOrigin,
            referrerPolicy = _omitThemingProps4.referrerPolicy,
            rest = _objectWithoutProperties2(_omitThemingProps4, _excluded28);
          var avatarStyles = _objectSpread3(_objectSpread3({
            borderRadius: borderRadius,
            borderWidth: showBorder ? "2px" : void 0
          }, baseStyle), styles.container);
          if (borderColor) {
            avatarStyles.borderColor = borderColor;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
            ref: ref
          }, rest), {}, {
            className: cx("chakra-avatar", props.className),
            "data-loaded": dataAttr(isLoaded),
            __css: avatarStyles,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(AvatarStylesProvider, {
              value: styles,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(AvatarImage, {
                src: src,
                srcSet: srcSet,
                loading: loading,
                onLoad: callAllHandlers(onLoadProp, function () {
                  setIsLoaded(true);
                }),
                onError: onError,
                getInitials: getInitials,
                name: name,
                borderRadius: borderRadius,
                icon: icon,
                iconLabel: iconLabel,
                ignoreFallback: ignoreFallback,
                crossOrigin: crossOrigin,
                referrerPolicy: referrerPolicy
              }), children]
            })
          }));
        });
        Avatar.displayName = "Avatar";
        var Badge = exports("p", forwardRef(function Badge2(props, ref) {
          var styles = useStyleConfig("Badge", props);
          var _omitThemingProps5 = omitThemingProps(props),
            className = _omitThemingProps5.className,
            rest = _objectWithoutProperties2(_omitThemingProps5, _excluded29);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
            ref: ref,
            className: cx("chakra-badge", props.className)
          }, rest), {}, {
            __css: _objectSpread3({
              display: "inline-block",
              whiteSpace: "nowrap",
              verticalAlign: "middle"
            }, styles)
          }));
        }));
        Badge.displayName = "Badge";
        var Box = exports("B", chakra("div"));
        Box.displayName = "Box";
        var _createContext13 = createContext({
            name: "BreadcrumbStylesContext",
            errorMessage: "useBreadcrumbStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<Breadcrumb />\" "
          }),
          _createContext14 = _slicedToArray(_createContext13, 2),
          BreadcrumbStylesProvider = _createContext14[0],
          useBreadcrumbStyles = _createContext14[1];
        var Breadcrumb = forwardRef(function Breadcrumb2(props, ref) {
          var styles = useMultiStyleConfig("Breadcrumb", props);
          var ownProps = omitThemingProps(props);
          var children = ownProps.children,
            _ownProps$spacing = ownProps.spacing,
            spacing = _ownProps$spacing === void 0 ? "0.5rem" : _ownProps$spacing,
            _ownProps$separator = ownProps.separator,
            separator = _ownProps$separator === void 0 ? "/" : _ownProps$separator,
            className = ownProps.className,
            listProps = ownProps.listProps,
            rest = _objectWithoutProperties2(ownProps, _excluded30);
          var validChildren = getValidChildren(children);
          var count = validChildren.length;
          var clones = validChildren.map(function (child, index) {
            return reactExports.cloneElement(child, {
              separator: separator,
              spacing: spacing,
              isLastChild: count === index + 1
            });
          });
          var _className = cx("chakra-breadcrumb", className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.nav, _objectSpread3(_objectSpread3({
            ref: ref,
            "aria-label": "breadcrumb",
            className: _className,
            __css: styles.container
          }, rest), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbStylesProvider, {
              value: styles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.ol, _objectSpread3(_objectSpread3({
                className: "chakra-breadcrumb__list"
              }, listProps), {}, {
                __css: _objectSpread3({
                  display: "flex",
                  alignItems: "center"
                }, styles.list),
                children: clones
              }))
            })
          }));
        });
        Breadcrumb.displayName = "Breadcrumb";
        var BreadcrumbLink = forwardRef(function BreadcrumbLink2(props, ref) {
          var isCurrentPage = props.isCurrentPage,
            as = props.as,
            className = props.className,
            href = props.href,
            rest = _objectWithoutProperties2(props, _excluded31);
          var styles = useBreadcrumbStyles();
          var sharedProps = _objectSpread3({
            ref: ref,
            as: as,
            className: cx("chakra-breadcrumb__link", className)
          }, rest);
          if (isCurrentPage) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3({
              "aria-current": "page",
              __css: styles.link
            }, sharedProps));
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.a, _objectSpread3({
            __css: styles.link,
            href: href
          }, sharedProps));
        });
        BreadcrumbLink.displayName = "BreadcrumbLink";
        var BreadcrumbSeparator = forwardRef(function BreadcrumbSeparator2(props, ref) {
          var spacing = props.spacing,
            rest = _objectWithoutProperties2(props, _excluded32);
          var styles = useBreadcrumbStyles();
          var separatorStyles = defineStyle(_objectSpread3({
            mx: spacing
          }, styles.separator));
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
            ref: ref,
            role: "presentation"
          }, rest), {}, {
            __css: separatorStyles
          }));
        });
        BreadcrumbSeparator.displayName = "BreadcrumbSeparator";
        var BreadcrumbItem = forwardRef(function BreadcrumbItem2(props, ref) {
          var isCurrentPage = props.isCurrentPage,
            separator = props.separator,
            isLastChild = props.isLastChild,
            spacing = props.spacing,
            children = props.children,
            className = props.className,
            rest = _objectWithoutProperties2(props, _excluded33);
          var validChildren = getValidChildren(children);
          var clones = validChildren.map(function (child) {
            if (child.type === BreadcrumbLink) {
              return reactExports.cloneElement(child, {
                isCurrentPage: isCurrentPage
              });
            }
            if (child.type === BreadcrumbSeparator) {
              return reactExports.cloneElement(child, {
                spacing: spacing,
                children: child.props.children || separator
              });
            }
            return child;
          });
          var styles = useBreadcrumbStyles();
          var itemStyles = defineStyle(_objectSpread3({
            display: "inline-flex",
            alignItems: "center"
          }, styles.item));
          var _className = cx("chakra-breadcrumb__list-item", className);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.li, _objectSpread3(_objectSpread3({
            ref: ref,
            className: _className
          }, rest), {}, {
            __css: itemStyles,
            children: [clones, !isLastChild && /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbSeparator, {
              spacing: spacing,
              children: separator
            })]
          }));
        });
        BreadcrumbItem.displayName = "BreadcrumbItem";
        var _createContext15 = createContext({
            strict: false,
            name: "ButtonGroupContext"
          }),
          _createContext16 = _slicedToArray(_createContext15, 2),
          ButtonGroupProvider = _createContext16[0],
          useButtonGroup = _createContext16[1];
        function ButtonIcon(props) {
          var children = props.children,
            className = props.className,
            rest = _objectWithoutProperties2(props, _excluded34);
          var _children = reactExports.isValidElement(children) ? reactExports.cloneElement(children, {
            "aria-hidden": true,
            focusable: false
          }) : children;
          var _className = cx("chakra-button__icon", className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
            display: "inline-flex",
            alignSelf: "center",
            flexShrink: 0
          }, rest), {}, {
            className: _className,
            children: _children
          }));
        }
        ButtonIcon.displayName = "ButtonIcon";
        function ButtonSpinner(props) {
          var label = props.label,
            placement = props.placement,
            _props$spacing = props.spacing,
            spacing = _props$spacing === void 0 ? "0.5rem" : _props$spacing,
            _props$children = props.children,
            children = _props$children === void 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(Spinner, {
              color: "currentColor",
              width: "1em",
              height: "1em"
            }) : _props$children,
            className = props.className,
            __css = props.__css,
            rest = _objectWithoutProperties2(props, _excluded35);
          var _className = cx("chakra-button__spinner", className);
          var marginProp = placement === "start" ? "marginEnd" : "marginStart";
          var spinnerStyles = reactExports.useMemo(function () {
            return defineStyle(_objectSpread3(_defineProperty2(_defineProperty2(_defineProperty2({
              display: "flex",
              alignItems: "center",
              position: label ? "relative" : "absolute"
            }, marginProp, label ? spacing : 0), "fontSize", "1em"), "lineHeight", "normal"), __css));
          }, [__css, label, marginProp, spacing]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            className: _className
          }, rest), {}, {
            __css: spinnerStyles,
            children: children
          }));
        }
        ButtonSpinner.displayName = "ButtonSpinner";
        function useButtonType(value) {
          var _reactExports$useStat33 = reactExports.useState(!value),
            _reactExports$useStat34 = _slicedToArray(_reactExports$useStat33, 2),
            isButton = _reactExports$useStat34[0],
            setIsButton = _reactExports$useStat34[1];
          var refCallback = reactExports.useCallback(function (node) {
            if (!node) return;
            setIsButton(node.tagName === "BUTTON");
          }, []);
          var type = isButton ? "button" : void 0;
          return {
            ref: refCallback,
            type: type
          };
        }
        var Button = exports("C", forwardRef(function (props, ref) {
          var group = useButtonGroup();
          var styles = useStyleConfig("Button", _objectSpread3(_objectSpread3({}, group), props));
          var _omitThemingProps6 = omitThemingProps(props),
            _omitThemingProps6$is = _omitThemingProps6.isDisabled,
            isDisabled = _omitThemingProps6$is === void 0 ? group === null || group === void 0 ? void 0 : group.isDisabled : _omitThemingProps6$is,
            isLoading = _omitThemingProps6.isLoading,
            isActive = _omitThemingProps6.isActive,
            children = _omitThemingProps6.children,
            leftIcon = _omitThemingProps6.leftIcon,
            rightIcon = _omitThemingProps6.rightIcon,
            loadingText = _omitThemingProps6.loadingText,
            _omitThemingProps6$ic = _omitThemingProps6.iconSpacing,
            iconSpacing = _omitThemingProps6$ic === void 0 ? "0.5rem" : _omitThemingProps6$ic,
            type = _omitThemingProps6.type,
            spinner = _omitThemingProps6.spinner,
            _omitThemingProps6$sp = _omitThemingProps6.spinnerPlacement,
            spinnerPlacement = _omitThemingProps6$sp === void 0 ? "start" : _omitThemingProps6$sp,
            className = _omitThemingProps6.className,
            as = _omitThemingProps6.as,
            shouldWrapChildren = _omitThemingProps6.shouldWrapChildren,
            rest = _objectWithoutProperties2(_omitThemingProps6, _excluded36);
          var buttonStyles = reactExports.useMemo(function () {
            var _focus = _objectSpread3(_objectSpread3({}, styles === null || styles === void 0 ? void 0 : styles["_focus"]), {}, {
              zIndex: 1
            });
            return _objectSpread3(_objectSpread3({
              display: "inline-flex",
              appearance: "none",
              alignItems: "center",
              justifyContent: "center",
              userSelect: "none",
              position: "relative",
              whiteSpace: "nowrap",
              verticalAlign: "middle",
              outline: "none"
            }, styles), !!group && {
              _focus: _focus
            });
          }, [styles, group]);
          var _useButtonType = useButtonType(as),
            _ref = _useButtonType.ref,
            defaultType = _useButtonType.type;
          var contentProps = {
            rightIcon: rightIcon,
            leftIcon: leftIcon,
            iconSpacing: iconSpacing,
            children: children,
            shouldWrapChildren: shouldWrapChildren
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.button, _objectSpread3(_objectSpread3({
            disabled: isDisabled || isLoading,
            ref: useMergeRefs$1(ref, _ref),
            as: as,
            type: type !== null && type !== void 0 ? type : defaultType,
            "data-active": dataAttr(isActive),
            "data-loading": dataAttr(isLoading),
            __css: buttonStyles,
            className: cx("chakra-button", className)
          }, rest), {}, {
            children: [isLoading && spinnerPlacement === "start" && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonSpinner, {
              className: "chakra-button__spinner--start",
              label: loadingText,
              placement: "start",
              spacing: iconSpacing,
              children: spinner
            }), isLoading ? loadingText || /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, {
              opacity: 0,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ButtonContent, _objectSpread3({}, contentProps))
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(ButtonContent, _objectSpread3({}, contentProps)), isLoading && spinnerPlacement === "end" && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonSpinner, {
              className: "chakra-button__spinner--end",
              label: loadingText,
              placement: "end",
              spacing: iconSpacing,
              children: spinner
            })]
          }));
        }));
        Button.displayName = "Button";
        function ButtonContent(props) {
          var leftIcon = props.leftIcon,
            rightIcon = props.rightIcon,
            children = props.children,
            iconSpacing = props.iconSpacing,
            shouldWrapChildren = props.shouldWrapChildren;
          if (!shouldWrapChildren) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [leftIcon && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonIcon, {
                marginEnd: iconSpacing,
                children: leftIcon
              }), children, rightIcon && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonIcon, {
                marginStart: iconSpacing,
                children: rightIcon
              })]
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs("span", {
            style: {
              display: "contents"
            },
            children: [leftIcon && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonIcon, {
              marginEnd: iconSpacing,
              children: leftIcon
            }), children, rightIcon && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonIcon, {
              marginStart: iconSpacing,
              children: rightIcon
            })]
          });
        }
        var IconButton = exports("a4", forwardRef(function (props, ref) {
          var icon = props.icon,
            children = props.children,
            isRound = props.isRound,
            ariaLabel = props["aria-label"],
            rest = _objectWithoutProperties2(props, _excluded37);
          var element = icon || children;
          var _children = reactExports.isValidElement(element) ? reactExports.cloneElement(element, {
            "aria-hidden": true,
            focusable: false
          }) : null;
          return /* @__PURE__ */jsxRuntimeExports.jsx(Button, _objectSpread3(_objectSpread3({
            px: "0",
            py: "0",
            borderRadius: isRound ? "full" : void 0,
            ref: ref,
            "aria-label": ariaLabel
          }, rest), {}, {
            children: _children
          }));
        }));
        IconButton.displayName = "IconButton";
        var _createStylesContext = createStylesContext("Card"),
          _createStylesContext2 = _slicedToArray(_createStylesContext, 2),
          CardStylesProvider = _createStylesContext2[0],
          useCardStyles = _createStylesContext2[1];
        exports("E", useCardStyles);
        var Card = exports("K", forwardRef(function Card2(props, ref) {
          var _omitThemingProps7 = omitThemingProps(props),
            className = _omitThemingProps7.className,
            children = _omitThemingProps7.children,
            _omitThemingProps7$di = _omitThemingProps7.direction,
            direction = _omitThemingProps7$di === void 0 ? "column" : _omitThemingProps7$di,
            justify = _omitThemingProps7.justify,
            align = _omitThemingProps7.align,
            rest = _objectWithoutProperties2(_omitThemingProps7, _excluded38);
          var styles = useMultiStyleConfig("Card", props);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            className: cx("chakra-card", className),
            __css: _objectSpread3({
              display: "flex",
              flexDirection: direction,
              justifyContent: justify,
              alignItems: align,
              position: "relative",
              minWidth: 0,
              wordWrap: "break-word"
            }, styles.container)
          }, rest), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(CardStylesProvider, {
              value: styles,
              children: children
            })
          }));
        }));
        var CardBody = exports("N", forwardRef(function CardBody2(props, ref) {
          var className = props.className,
            rest = _objectWithoutProperties2(props, _excluded39);
          var styles = useCardStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3({
            ref: ref,
            className: cx("chakra-card__body", className),
            __css: styles.body
          }, rest));
        }));
        var Center = chakra("div", {
          baseStyle: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        });
        Center.displayName = "Center";
        var centerStyles = {
          horizontal: {
            insetStart: "50%",
            transform: "translateX(-50%)"
          },
          vertical: {
            top: "50%",
            transform: "translateY(-50%)"
          },
          both: {
            insetStart: "50%",
            top: "50%",
            transform: "translate(-50%, -50%)"
          }
        };
        forwardRef(function AbsoluteCenter2(props, ref) {
          var _props$axis = props.axis,
            axis = _props$axis === void 0 ? "both" : _props$axis,
            rest = _objectWithoutProperties2(props, _excluded40);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            __css: centerStyles[axis]
          }, rest), {}, {
            position: "absolute"
          }));
        });
        var _createContext17 = createContext({
            name: "FormControlStylesContext",
            errorMessage: "useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<FormControl />\" "
          }),
          _createContext18 = _slicedToArray(_createContext17, 2),
          FormControlStylesProvider = _createContext18[0],
          useFormControlStyles = _createContext18[1];
        var _createContext19 = createContext({
            strict: false,
            name: "FormControlContext"
          }),
          _createContext20 = _slicedToArray(_createContext19, 2),
          FormControlProvider = _createContext20[0],
          useFormControlContext = _createContext20[1];
        function useFormControlProvider(props) {
          var idProp = props.id,
            isRequired = props.isRequired,
            isInvalid = props.isInvalid,
            isDisabled = props.isDisabled,
            isReadOnly = props.isReadOnly,
            htmlProps = _objectWithoutProperties2(props, _excluded41);
          var uuid = reactExports.useId();
          var id = idProp || "field-".concat(uuid);
          var labelId = "".concat(id, "-label");
          var feedbackId = "".concat(id, "-feedback");
          var helpTextId = "".concat(id, "-helptext");
          var _reactExports$useStat35 = reactExports.useState(false),
            _reactExports$useStat36 = _slicedToArray(_reactExports$useStat35, 2),
            hasFeedbackText = _reactExports$useStat36[0],
            setHasFeedbackText = _reactExports$useStat36[1];
          var _reactExports$useStat37 = reactExports.useState(false),
            _reactExports$useStat38 = _slicedToArray(_reactExports$useStat37, 2),
            hasHelpText = _reactExports$useStat38[0],
            setHasHelpText = _reactExports$useStat38[1];
          var _reactExports$useStat39 = reactExports.useState(false),
            _reactExports$useStat40 = _slicedToArray(_reactExports$useStat39, 2),
            isFocused = _reactExports$useStat40[0],
            setFocus = _reactExports$useStat40[1];
          var getHelpTextProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({
              id: helpTextId
            }, props2), {}, {
              /**
               * Notify the field context when the help text is rendered on screen,
               * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
               */
              ref: mergeRefs(forwardedRef, function (node) {
                if (!node) return;
                setHasHelpText(true);
              })
            });
          }, [helpTextId]);
          var getLabelProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: forwardedRef,
              "data-focus": dataAttr(isFocused),
              "data-disabled": dataAttr(isDisabled),
              "data-invalid": dataAttr(isInvalid),
              "data-readonly": dataAttr(isReadOnly),
              id: props2.id !== void 0 ? props2.id : labelId,
              htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id
            });
          }, [id, isDisabled, isFocused, isInvalid, isReadOnly, labelId]);
          var getErrorMessageProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({
              id: feedbackId
            }, props2), {}, {
              /**
               * Notify the field context when the error message is rendered on screen,
               * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
               */
              ref: mergeRefs(forwardedRef, function (node) {
                if (!node) return;
                setHasFeedbackText(true);
              }),
              "aria-live": "polite"
            });
          }, [feedbackId]);
          var getRootProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3(_objectSpread3({}, props2), htmlProps), {}, {
              ref: forwardedRef,
              role: "group",
              "data-focus": dataAttr(isFocused),
              "data-disabled": dataAttr(isDisabled),
              "data-invalid": dataAttr(isInvalid),
              "data-readonly": dataAttr(isReadOnly)
            });
          }, [htmlProps, isDisabled, isFocused, isInvalid, isReadOnly]);
          var getRequiredIndicatorProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: forwardedRef,
              role: "presentation",
              "aria-hidden": true,
              children: props2.children || "*"
            });
          }, []);
          return {
            isRequired: !!isRequired,
            isInvalid: !!isInvalid,
            isReadOnly: !!isReadOnly,
            isDisabled: !!isDisabled,
            isFocused: !!isFocused,
            onFocus: function onFocus() {
              return setFocus(true);
            },
            onBlur: function onBlur() {
              return setFocus(false);
            },
            hasFeedbackText: hasFeedbackText,
            setHasFeedbackText: setHasFeedbackText,
            hasHelpText: hasHelpText,
            setHasHelpText: setHasHelpText,
            id: id,
            labelId: labelId,
            feedbackId: feedbackId,
            helpTextId: helpTextId,
            htmlProps: htmlProps,
            getHelpTextProps: getHelpTextProps,
            getErrorMessageProps: getErrorMessageProps,
            getRootProps: getRootProps,
            getLabelProps: getLabelProps,
            getRequiredIndicatorProps: getRequiredIndicatorProps
          };
        }
        var FormControl = forwardRef(function FormControl2(props, ref) {
          var styles = useMultiStyleConfig("Form", props);
          var ownProps = omitThemingProps(props);
          var _useFormControlProvid = useFormControlProvider(ownProps),
            getRootProps = _useFormControlProvid.getRootProps,
            _ = _useFormControlProvid.htmlProps,
            context = _objectWithoutProperties2(_useFormControlProvid, _excluded42);
          var className = cx("chakra-form-control", props.className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(FormControlProvider, {
            value: context,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(FormControlStylesProvider, {
              value: styles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, getRootProps({}, ref)), {}, {
                className: className,
                __css: styles["container"]
              }))
            })
          });
        });
        FormControl.displayName = "FormControl";
        var FormHelperText = forwardRef(function FormHelperText2(props, ref) {
          var field = useFormControlContext();
          var styles = useFormControlStyles();
          var className = cx("chakra-form__helper-text", props.className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, field === null || field === void 0 ? void 0 : field.getHelpTextProps(props, ref)), {}, {
            __css: styles.helperText,
            className: className
          }));
        });
        FormHelperText.displayName = "FormHelperText";
        function useFormControl(props) {
          var _useFormControlProps = useFormControlProps(props),
            isDisabled = _useFormControlProps.isDisabled,
            isInvalid = _useFormControlProps.isInvalid,
            isReadOnly = _useFormControlProps.isReadOnly,
            isRequired = _useFormControlProps.isRequired,
            rest = _objectWithoutProperties2(_useFormControlProps, _excluded43);
          return _objectSpread3(_objectSpread3({}, rest), {}, {
            disabled: isDisabled,
            readOnly: isReadOnly,
            required: isRequired,
            "aria-invalid": ariaAttr(isInvalid),
            "aria-required": ariaAttr(isRequired),
            "aria-readonly": ariaAttr(isReadOnly)
          });
        }
        function useFormControlProps(props) {
          var _ref152, _ref153, _ref154;
          var field = useFormControlContext();
          var id = props.id,
            disabled = props.disabled,
            readOnly = props.readOnly,
            required = props.required,
            isRequired = props.isRequired,
            isInvalid = props.isInvalid,
            isReadOnly = props.isReadOnly,
            isDisabled = props.isDisabled,
            onFocus = props.onFocus,
            onBlur = props.onBlur,
            rest = _objectWithoutProperties2(props, _excluded44);
          var labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
          if (field !== null && field !== void 0 && field.hasFeedbackText && field !== null && field !== void 0 && field.isInvalid) {
            labelIds.push(field.feedbackId);
          }
          if (field !== null && field !== void 0 && field.hasHelpText) {
            labelIds.push(field.helpTextId);
          }
          return _objectSpread3(_objectSpread3({}, rest), {}, {
            "aria-describedby": labelIds.join(" ") || void 0,
            id: id !== null && id !== void 0 ? id : field === null || field === void 0 ? void 0 : field.id,
            isDisabled: (_ref152 = disabled !== null && disabled !== void 0 ? disabled : isDisabled) !== null && _ref152 !== void 0 ? _ref152 : field === null || field === void 0 ? void 0 : field.isDisabled,
            isReadOnly: (_ref153 = readOnly !== null && readOnly !== void 0 ? readOnly : isReadOnly) !== null && _ref153 !== void 0 ? _ref153 : field === null || field === void 0 ? void 0 : field.isReadOnly,
            isRequired: (_ref154 = required !== null && required !== void 0 ? required : isRequired) !== null && _ref154 !== void 0 ? _ref154 : field === null || field === void 0 ? void 0 : field.isRequired,
            isInvalid: isInvalid !== null && isInvalid !== void 0 ? isInvalid : field === null || field === void 0 ? void 0 : field.isInvalid,
            onFocus: callAllHandlers(field === null || field === void 0 ? void 0 : field.onFocus, onFocus),
            onBlur: callAllHandlers(field === null || field === void 0 ? void 0 : field.onBlur, onBlur)
          });
        }
        var Container = forwardRef(function Container2(props, ref) {
          var _omitThemingProps8 = omitThemingProps(props),
            className = _omitThemingProps8.className,
            centerContent = _omitThemingProps8.centerContent,
            rest = _objectWithoutProperties2(_omitThemingProps8, _excluded45);
          var styles = useStyleConfig("Container", props);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            className: cx("chakra-container", className)
          }, rest), {}, {
            __css: _objectSpread3(_objectSpread3({}, styles), centerContent && {
              display: "flex",
              flexDirection: "column",
              alignItems: "center"
            })
          }));
        });
        Container.displayName = "Container";
        var Divider = forwardRef(function Divider2(props, ref) {
          var _useStyleConfig = useStyleConfig("Divider", props),
            borderLeftWidth = _useStyleConfig.borderLeftWidth,
            borderBottomWidth = _useStyleConfig.borderBottomWidth,
            borderTopWidth = _useStyleConfig.borderTopWidth,
            borderRightWidth = _useStyleConfig.borderRightWidth,
            borderWidth = _useStyleConfig.borderWidth,
            borderStyle = _useStyleConfig.borderStyle,
            borderColor = _useStyleConfig.borderColor,
            styles = _objectWithoutProperties2(_useStyleConfig, _excluded46);
          var _omitThemingProps9 = omitThemingProps(props),
            className = _omitThemingProps9.className,
            _omitThemingProps9$or = _omitThemingProps9.orientation,
            orientation = _omitThemingProps9$or === void 0 ? "horizontal" : _omitThemingProps9$or,
            __css = _omitThemingProps9.__css,
            rest = _objectWithoutProperties2(_omitThemingProps9, _excluded47);
          var dividerStyles = {
            vertical: {
              borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
              height: "100%"
            },
            horizontal: {
              borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
              width: "100%"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.hr, _objectSpread3(_objectSpread3({
            ref: ref,
            "aria-orientation": orientation
          }, rest), {}, {
            __css: _objectSpread3(_objectSpread3(_objectSpread3({}, styles), {}, {
              border: "0",
              borderColor: borderColor,
              borderStyle: borderStyle
            }, dividerStyles[orientation]), __css),
            className: cx("chakra-divider", className)
          }));
        });
        Divider.displayName = "Divider";
        function isFunction(value) {
          return typeof value === "function";
        }
        function pipe() {
          for (var _len35 = arguments.length, fns = new Array(_len35), _key65 = 0; _key65 < _len35; _key65++) {
            fns[_key65] = arguments[_key65];
          }
          return function (v) {
            return fns.reduce(function (a, b) {
              return b(a);
            }, v);
          };
        }
        var createExtendTheme = function createExtendTheme(theme2) {
          return function extendTheme2() {
            for (var _len36 = arguments.length, extensions = new Array(_len36), _key66 = 0; _key66 < _len36; _key66++) {
              extensions[_key66] = arguments[_key66];
            }
            var overrides = [].concat(extensions);
            var activeTheme = extensions[extensions.length - 1];
            if (isChakraTheme(activeTheme) &&
            // this ensures backward compatibility
            // previously only `extendTheme(override, activeTheme?)` was allowed
            overrides.length > 1) {
              overrides = overrides.slice(0, overrides.length - 1);
            } else {
              activeTheme = theme2;
            }
            return pipe.apply(void 0, _toConsumableArray(overrides.map(function (extension) {
              return function (prevTheme) {
                return isFunction(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension);
              };
            })))(activeTheme);
          };
        };
        var extendTheme = createExtendTheme(theme$1);
        function mergeThemeOverride() {
          for (var _len37 = arguments.length, overrides = new Array(_len37), _key67 = 0; _key67 < _len37; _key67++) {
            overrides[_key67] = arguments[_key67];
          }
          return mergeWith.apply(void 0, [{}].concat(overrides, [mergeThemeCustomizer]));
        }
        function mergeThemeCustomizer(source, override, key, object) {
          if ((isFunction(source) || isFunction(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
            return function () {
              var sourceValue = isFunction(source) ? source.apply(void 0, arguments) : source;
              var overrideValue = isFunction(override) ? override.apply(void 0, arguments) : override;
              return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer);
            };
          }
          if (isObject(source) && isArray(override)) {
            return override;
          }
          if (isArray(source) && isObject(override)) {
            return override;
          }
          return void 0;
        }
        var Flex = forwardRef(function Flex2(props, ref) {
          var direction = props.direction,
            align = props.align,
            justify = props.justify,
            wrap = props.wrap,
            basis = props.basis,
            grow = props.grow,
            shrink = props.shrink,
            rest = _objectWithoutProperties2(props, _excluded48);
          var styles = {
            display: "flex",
            flexDirection: direction,
            alignItems: align,
            justifyContent: justify,
            flexWrap: wrap,
            flexBasis: basis,
            flexGrow: grow,
            flexShrink: shrink
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3({
            ref: ref,
            __css: styles
          }, rest));
        });
        Flex.displayName = "Flex";
        function _objectWithoutPropertiesLoose$1(r, e) {
          if (null == r) return {};
          var t = {};
          for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
            if (-1 !== e.indexOf(n)) continue;
            t[n] = r[n];
          }
          return t;
        }

        /**
         * defines a focus group
         */
        var FOCUS_GROUP = 'data-focus-lock';
        /**
         * disables element discovery inside a group marked by key
         */
        var FOCUS_DISABLED = 'data-focus-lock-disabled';
        /**
         * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content
         */
        var FOCUS_ALLOW = 'data-no-focus-lock';
        /**
         * instructs autofocus engine to pick default autofocus inside a given node
         * can be set on the element or container
         */
        var FOCUS_AUTO = 'data-autofocus-inside';
        /**
         * instructs autofocus to ignore elements within a given node
         * can be set on the element or container
         */
        var FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';

        /**
         * Assigns a value for a given ref, no matter of the ref format
         * @param {RefObject} ref - a callback function or ref object
         * @param value - a new value
         *
         * @see https://github.com/theKashey/use-callback-ref#assignref
         * @example
         * const refObject = useRef();
         * const refFn = (ref) => {....}
         *
         * assignRef(refObject, "refValue");
         * assignRef(refFn, "refValue");
         */
        function assignRef(ref, value) {
          if (typeof ref === 'function') {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
          return ref;
        }

        /**
         * creates a MutableRef with ref change callback
         * @param initialValue - initial ref value
         * @param {Function} callback - a callback to run when value changes
         *
         * @example
         * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
         * ref.current = 1;
         * // prints 0 -> 1
         *
         * @see https://reactjs.org/docs/hooks-reference.html#useref
         * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
         * @returns {MutableRefObject}
         */
        function useCallbackRef(initialValue, callback) {
          var ref = reactExports.useState(function () {
            return {
              // value
              value: initialValue,
              // last callback
              callback: callback,
              // "memoized" public interface
              facade: {
                get current() {
                  return ref.value;
                },
                set current(value) {
                  var last = ref.value;
                  if (last !== value) {
                    ref.value = value;
                    ref.callback(value, last);
                  }
                }
              }
            };
          })[0];
          // update callback
          ref.callback = callback;
          return ref.facade;
        }
        var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
        var currentValues = new WeakMap();
        /**
         * Merges two or more refs together providing a single interface to set their value
         * @param {RefObject|Ref} refs
         * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
         *
         * @see {@link mergeRefs} a version without buit-in memoization
         * @see https://github.com/theKashey/use-callback-ref#usemergerefs
         * @example
         * const Component = React.forwardRef((props, ref) => {
         *   const ownRef = useRef();
         *   const domRef = useMergeRefs([ref, ownRef]); //  merge together
         *   return <div ref={domRef}>...</div>
         * }
         */
        function useMergeRefs(refs, defaultValue) {
          var callbackRef = useCallbackRef(null, function (newValue) {
            return refs.forEach(function (ref) {
              return assignRef(ref, newValue);
            });
          });
          // handle refs changes - added or removed
          useIsomorphicLayoutEffect(function () {
            var oldValue = currentValues.get(callbackRef);
            if (oldValue) {
              var prevRefs_1 = new Set(oldValue);
              var nextRefs_1 = new Set(refs);
              var current_1 = callbackRef.current;
              prevRefs_1.forEach(function (ref) {
                if (!nextRefs_1.has(ref)) {
                  assignRef(ref, null);
                }
              });
              nextRefs_1.forEach(function (ref) {
                if (!prevRefs_1.has(ref)) {
                  assignRef(ref, current_1);
                }
              });
            }
            currentValues.set(callbackRef, refs);
          }, [refs]);
          return callbackRef;
        }
        var hiddenGuard = {
          width: "1px",
          height: "0px",
          padding: 0,
          overflow: "hidden",
          position: "fixed",
          top: "1px",
          left: "1px"
        };

        /******************************************************************************
        Copyright (c) Microsoft Corporation.
         Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
         THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

        var _assign = function __assign() {
          _assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return _assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
          }
          return t;
        }
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function (resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };
        function ItoI(a) {
          return a;
        }
        function innerCreateMedium(defaults, middleware) {
          if (middleware === void 0) {
            middleware = ItoI;
          }
          var buffer = [];
          var assigned = false;
          var medium = {
            read: function read() {
              if (assigned) {
                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
              }
              if (buffer.length) {
                return buffer[buffer.length - 1];
              }
              return defaults;
            },
            useMedium: function useMedium(data) {
              var item = middleware(data, assigned);
              buffer.push(item);
              return function () {
                buffer = buffer.filter(function (x) {
                  return x !== item;
                });
              };
            },
            assignSyncMedium: function assignSyncMedium(cb) {
              assigned = true;
              while (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
              }
              buffer = {
                push: function push(x) {
                  return cb(x);
                },
                filter: function filter() {
                  return buffer;
                }
              };
            },
            assignMedium: function assignMedium(cb) {
              assigned = true;
              var pendingQueue = [];
              if (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
                pendingQueue = buffer;
              }
              var executeQueue = function executeQueue() {
                var cbs = pendingQueue;
                pendingQueue = [];
                cbs.forEach(cb);
              };
              var cycle = function cycle() {
                return Promise.resolve().then(executeQueue);
              };
              cycle();
              buffer = {
                push: function push(x) {
                  pendingQueue.push(x);
                  cycle();
                },
                filter: function filter(_filter) {
                  pendingQueue = pendingQueue.filter(_filter);
                  return buffer;
                }
              };
            }
          };
          return medium;
        }
        function createMedium(defaults, middleware) {
          if (middleware === void 0) {
            middleware = ItoI;
          }
          return innerCreateMedium(defaults, middleware);
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        function createSidecarMedium(options) {
          if (options === void 0) {
            options = {};
          }
          var medium = innerCreateMedium(null);
          medium.options = _assign({
            async: true,
            ssr: false
          }, options);
          return medium;
        }
        var SideCar$1 = function SideCar$1(_a) {
          var sideCar = _a.sideCar,
            rest = __rest(_a, ["sideCar"]);
          if (!sideCar) {
            throw new Error('Sidecar: please provide `sideCar` property to import the right car');
          }
          var Target = sideCar.read();
          if (!Target) {
            throw new Error('Sidecar medium not found');
          }
          return reactExports.createElement(Target, _assign({}, rest));
        };
        SideCar$1.isSideCarExport = true;
        function exportSidecar(medium, exported) {
          medium.useMedium(exported);
          return SideCar$1;
        }
        var mediumFocus = createMedium({}, function (_ref) {
          var target = _ref.target,
            currentTarget = _ref.currentTarget;
          return {
            target: target,
            currentTarget: currentTarget
          };
        });
        var mediumBlur = createMedium();
        var mediumEffect = createMedium();
        var mediumSidecar = createSidecarMedium({
          async: true,
          ssr: typeof document !== 'undefined'
        });
        var focusScope = /*#__PURE__*/reactExports.createContext(undefined);
        var emptyArray = [];
        var FocusLock$1 = /* @__PURE__ */reactExports.forwardRef(function FocusLockUI(props, parentRef) {
          var _extends2;
          var _useState = reactExports.useState(),
            realObserved = _useState[0],
            setObserved = _useState[1];
          var observed = reactExports.useRef();
          var isActive = reactExports.useRef(false);
          var originalFocusedElement = reactExports.useRef(null);
          var _useState2 = reactExports.useState({}),
            update = _useState2[1];
          var children = props.children,
            _props$disabled = props.disabled,
            disabled = _props$disabled === void 0 ? false : _props$disabled,
            _props$noFocusGuards = props.noFocusGuards,
            noFocusGuards = _props$noFocusGuards === void 0 ? false : _props$noFocusGuards,
            _props$persistentFocu = props.persistentFocus,
            persistentFocus = _props$persistentFocu === void 0 ? false : _props$persistentFocu,
            _props$crossFrame = props.crossFrame,
            crossFrame = _props$crossFrame === void 0 ? true : _props$crossFrame,
            _props$autoFocus = props.autoFocus,
            autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus;
          props.allowTextSelection;
          var group = props.group,
            className = props.className,
            whiteList = props.whiteList,
            hasPositiveIndices = props.hasPositiveIndices,
            _props$shards = props.shards,
            shards = _props$shards === void 0 ? emptyArray : _props$shards,
            _props$as = props.as,
            Container = _props$as === void 0 ? "div" : _props$as,
            _props$lockProps = props.lockProps,
            containerProps = _props$lockProps === void 0 ? {} : _props$lockProps,
            SideCar = props.sideCar,
            _props$returnFocus = props.returnFocus,
            shouldReturnFocus = _props$returnFocus === void 0 ? false : _props$returnFocus,
            focusOptions = props.focusOptions,
            onActivationCallback = props.onActivation,
            onDeactivationCallback = props.onDeactivation;
          var _useState3 = reactExports.useState({}),
            id = _useState3[0];
          var onActivation = reactExports.useCallback(function (_ref) {
            var captureFocusRestore = _ref.captureFocusRestore;
            if (!originalFocusedElement.current) {
              var _document;
              var activeElement = (_document = document) == null ? void 0 : _document.activeElement;
              originalFocusedElement.current = activeElement;
              if (activeElement !== document.body) {
                originalFocusedElement.current = captureFocusRestore(activeElement);
              }
            }
            if (observed.current && onActivationCallback) {
              onActivationCallback(observed.current);
            }
            isActive.current = true;
            update();
          }, [onActivationCallback]);
          var onDeactivation = reactExports.useCallback(function () {
            isActive.current = false;
            if (onDeactivationCallback) {
              onDeactivationCallback(observed.current);
            }
            update();
          }, [onDeactivationCallback]);
          var returnFocus = reactExports.useCallback(function (allowDefer) {
            var focusRestore = originalFocusedElement.current;
            if (focusRestore) {
              var returnFocusTo = (typeof focusRestore === "function" ? focusRestore() : focusRestore) || document.body;
              var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
              if (howToReturnFocus) {
                var returnFocusOptions = _typeof2(howToReturnFocus) === "object" ? howToReturnFocus : void 0;
                originalFocusedElement.current = null;
                if (allowDefer) {
                  Promise.resolve().then(function () {
                    return returnFocusTo.focus(returnFocusOptions);
                  });
                } else {
                  returnFocusTo.focus(returnFocusOptions);
                }
              }
            }
          }, [shouldReturnFocus]);
          var onFocus = reactExports.useCallback(function (event) {
            if (isActive.current) {
              mediumFocus.useMedium(event);
            }
          }, []);
          var onBlur = mediumBlur.useMedium;
          var setObserveNode = reactExports.useCallback(function (newObserved) {
            if (observed.current !== newObserved) {
              observed.current = newObserved;
              setObserved(newObserved);
            }
          }, []);
          var lockProps = _extends$1((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
          var hasLeadingGuards = noFocusGuards !== true;
          var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
          var mergedRef = useMergeRefs([parentRef, setObserveNode]);
          var focusScopeValue = reactExports.useMemo(function () {
            return {
              observed: observed,
              shards: shards,
              enabled: !disabled,
              get active() {
                return isActive.current;
              }
            };
          }, [disabled, isActive, shards, observed]);
          return /* @__PURE__ */React.createElement(reactExports.Fragment, null, hasLeadingGuards && [/* @__PURE__ */React.createElement("div", {
            key: "guard-first",
            "data-focus-guard": true,
            tabIndex: disabled ? -1 : 0,
            style: hiddenGuard
          }), hasPositiveIndices ? /* @__PURE__ */React.createElement("div", {
            key: "guard-nearest",
            "data-focus-guard": true,
            tabIndex: disabled ? -1 : 1,
            style: hiddenGuard
          }) : null], !disabled && /* @__PURE__ */React.createElement(SideCar, {
            id: id,
            sideCar: mediumSidecar,
            observed: realObserved,
            disabled: disabled,
            persistentFocus: persistentFocus,
            crossFrame: crossFrame,
            autoFocus: autoFocus,
            whiteList: whiteList,
            shards: shards,
            onActivation: onActivation,
            onDeactivation: onDeactivation,
            returnFocus: returnFocus,
            focusOptions: focusOptions,
            noFocusGuards: noFocusGuards
          }), /* @__PURE__ */React.createElement(Container, _extends$1({
            ref: mergedRef
          }, lockProps, {
            className: className,
            onBlur: onBlur,
            onFocus: onFocus
          }), /* @__PURE__ */React.createElement(focusScope.Provider, {
            value: focusScopeValue
          }, children)), hasTailingGuards && /* @__PURE__ */React.createElement("div", {
            "data-focus-guard": true,
            tabIndex: disabled ? -1 : 0,
            style: hiddenGuard
          }));
        });
        FocusLock$1.propTypes = {};
        function _setPrototypeOf(t, e) {
          return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
            return t.__proto__ = e, t;
          }, _setPrototypeOf(t, e);
        }
        function _inheritsLoose(t, o) {
          t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
        }
        function _typeof$2(o) {
          "@babel/helpers - typeof";

          return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
            return typeof o;
          } : function (o) {
            return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
          }, _typeof$2(o);
        }
        function toPrimitive$2(t, r) {
          if ("object" != _typeof$2(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != _typeof$2(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        function toPropertyKey$2(t) {
          var i = toPrimitive$2(t, "string");
          return "symbol" == _typeof$2(i) ? i : i + "";
        }
        function _defineProperty$3(e, r, t) {
          return (r = toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }
        function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
          function getDisplayName(WrappedComponent) {
            return WrappedComponent.displayName || WrappedComponent.name || "Component";
          }
          return function wrap(WrappedComponent) {
            var mountedInstances = [];
            var state;
            function emitChange() {
              state = reducePropsToState(mountedInstances.map(function (instance) {
                return instance.props;
              }));
              handleStateChangeOnClient(state);
            }
            var SideEffect = /* @__PURE__ */function (_PureComponent) {
              _inheritsLoose(SideEffect2, _PureComponent);
              function SideEffect2() {
                return _PureComponent.apply(this, arguments) || this;
              }
              SideEffect2.peek = function peek() {
                return state;
              };
              var _proto = SideEffect2.prototype;
              _proto.componentDidMount = function componentDidMount() {
                mountedInstances.push(this);
                emitChange();
              };
              _proto.componentDidUpdate = function componentDidUpdate() {
                emitChange();
              };
              _proto.componentWillUnmount = function componentWillUnmount() {
                var index = mountedInstances.indexOf(this);
                mountedInstances.splice(index, 1);
                emitChange();
              };
              _proto.render = function render() {
                return /* @__PURE__ */React.createElement(WrappedComponent, this.props);
              };
              return SideEffect2;
            }(reactExports.PureComponent);
            _defineProperty$3(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
            return SideEffect;
          };
        }

        /*
        IE11 support
         */
        var toArray$1 = function toArray$1(a) {
          var ret = Array(a.length);
          for (var i = 0; i < a.length; ++i) {
            ret[i] = a[i];
          }
          return ret;
        };
        var asArray = function asArray(a) {
          return Array.isArray(a) ? a : [a];
        };
        var getFirst = function getFirst(a) {
          return Array.isArray(a) ? a[0] : a;
        };
        var isElementHidden = function isElementHidden(node) {
          // we can measure only "elements"
          // consider others as "visible"
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return false;
          }
          var computedStyle = window.getComputedStyle(node, null);
          if (!computedStyle || !computedStyle.getPropertyValue) {
            return false;
          }
          return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
        };
        var getParentNode$1 = function getParentNode$1(node) {
          // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node
          return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ?
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          node.parentNode.host : node.parentNode;
        };
        var isTopNode = function isTopNode(node) {
          // @ts-ignore
          return node === document || node && node.nodeType === Node.DOCUMENT_NODE;
        };
        var isInert = function isInert(node) {
          return node.hasAttribute('inert');
        };
        /**
         * @see https://github.com/testing-library/jest-dom/blob/main/src/to-be-visible.js
         */
        var isVisibleUncached = function isVisibleUncached(node, checkParent) {
          return !node || isTopNode(node) || !isElementHidden(node) && !isInert(node) && checkParent(getParentNode$1(node));
        };
        var _isVisibleCached = function isVisibleCached(visibilityCache, node) {
          var cached = visibilityCache.get(node);
          if (cached !== undefined) {
            return cached;
          }
          var result = isVisibleUncached(node, _isVisibleCached.bind(undefined, visibilityCache));
          visibilityCache.set(node, result);
          return result;
        };
        var isAutoFocusAllowedUncached = function isAutoFocusAllowedUncached(node, checkParent) {
          return node && !isTopNode(node) ? isAutoFocusAllowed(node) ? checkParent(getParentNode$1(node)) : false : true;
        };
        var _isAutoFocusAllowedCached = function isAutoFocusAllowedCached(cache, node) {
          var cached = cache.get(node);
          if (cached !== undefined) {
            return cached;
          }
          var result = isAutoFocusAllowedUncached(node, _isAutoFocusAllowedCached.bind(undefined, cache));
          cache.set(node, result);
          return result;
        };
        var getDataset = function getDataset(node) {
          // @ts-ignore
          return node.dataset;
        };
        var isHTMLButtonElement = function isHTMLButtonElement(node) {
          return node.tagName === 'BUTTON';
        };
        var isHTMLInputElement = function isHTMLInputElement(node) {
          return node.tagName === 'INPUT';
        };
        var isRadioElement = function isRadioElement(node) {
          return isHTMLInputElement(node) && node.type === 'radio';
        };
        var notHiddenInput = function notHiddenInput(node) {
          return !((isHTMLInputElement(node) || isHTMLButtonElement(node)) && (node.type === 'hidden' || node.disabled));
        };
        var isAutoFocusAllowed = function isAutoFocusAllowed(node) {
          var attribute = node.getAttribute(FOCUS_NO_AUTOFOCUS);
          return ![true, 'true', ''].includes(attribute);
        };
        var isGuard = function isGuard(node) {
          var _a;
          return Boolean(node && ((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.focusGuard));
        };
        var isNotAGuard = function isNotAGuard(node) {
          return !isGuard(node);
        };
        var isDefined = function isDefined(x) {
          return Boolean(x);
        };
        var tabSort = function tabSort(a, b) {
          var aTab = Math.max(0, a.tabIndex);
          var bTab = Math.max(0, b.tabIndex);
          var tabDiff = aTab - bTab;
          var indexDiff = a.index - b.index;
          if (tabDiff) {
            if (!aTab) {
              return 1;
            }
            if (!bTab) {
              return -1;
            }
          }
          return tabDiff || indexDiff;
        };
        var getTabIndex = function getTabIndex(node) {
          if (node.tabIndex < 0) {
            // all "focusable" elements are already preselected
            // but some might have implicit negative tabIndex
            // return 0 for <audio without tabIndex attribute - it is "tabbable"
            if (!node.hasAttribute('tabindex')) {
              return 0;
            }
          }
          return node.tabIndex;
        };
        var orderByTabIndex = function orderByTabIndex(nodes, filterNegative, keepGuards) {
          return toArray$1(nodes).map(function (node, index) {
            var tabIndex = getTabIndex(node);
            return {
              node: node,
              index: index,
              tabIndex: keepGuards && tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : tabIndex
            };
          }).filter(function (data) {
            return !filterNegative || data.tabIndex >= 0;
          }).sort(tabSort);
        };

        /**
         * list of the object to be considered as focusable
         */
        var tabbables = ['button:enabled', 'select:enabled', 'textarea:enabled', 'input:enabled',
        // elements with explicit roles will also use explicit tabindex
        // '[role="button"]',
        'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[tabindex]', '[contenteditable]', '[autofocus]'];
        var queryTabbables = tabbables.join(',');
        var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
        var _getFocusablesWithShadowDom = function getFocusablesWithShadowDom(parent, withGuards) {
          return toArray$1((parent.shadowRoot || parent).children).reduce(function (acc, child) {
            return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], _getFocusablesWithShadowDom(child));
          }, []);
        };
        var getFocusablesWithIFrame = function getFocusablesWithIFrame(parent, withGuards) {
          var _a;
          // contentDocument of iframe will be null if current origin cannot access it
          if (parent instanceof HTMLIFrameElement && ((_a = parent.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
            return getFocusables([parent.contentDocument.body], withGuards);
          }
          return [parent];
        };
        var getFocusables = function getFocusables(parents, withGuards) {
          return parents.reduce(function (acc, parent) {
            var _a;
            var focusableWithShadowDom = _getFocusablesWithShadowDom(parent, withGuards);
            var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function (node) {
              return getFocusablesWithIFrame(node, withGuards);
            }));
            return acc.concat(
            // add all tabbables inside and within shadow DOMs in DOM order
            focusableWithIframes,
            // add if node is tabbable itself
            parent.parentNode ? toArray$1(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) {
              return node === parent;
            }) : []);
          }, []);
        };
        /**
         * return a list of focusable nodes within an area marked as "auto-focusable"
         * @param parent
         */
        var getParentAutofocusables = function getParentAutofocusables(parent) {
          var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
          return toArray$1(parentFocus).map(function (node) {
            return getFocusables([node]);
          }).reduce(function (acc, nodes) {
            return acc.concat(nodes);
          }, []);
        };

        /**
         * given list of focusable elements keeps the ones user can interact with
         * @param nodes
         * @param visibilityCache
         */
        var filterFocusable = function filterFocusable(nodes, visibilityCache) {
          return toArray$1(nodes).filter(function (node) {
            return _isVisibleCached(visibilityCache, node);
          }).filter(function (node) {
            return notHiddenInput(node);
          });
        };
        var filterAutoFocusable = function filterAutoFocusable(nodes, cache) {
          if (cache === void 0) {
            cache = new Map();
          }
          return toArray$1(nodes).filter(function (node) {
            return _isAutoFocusAllowedCached(cache, node);
          });
        };
        /**
         * !__WARNING__! Low level API.
         * @returns all tabbable nodes
         *
         * @see {@link getFocusableNodes} to get any focusable element
         *
         * @param topNodes - array of top level HTMLElements to search inside
         * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call
         */
        var getTabbableNodes = function getTabbableNodes(topNodes, visibilityCache, withGuards) {
          return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
        };
        /**
         * !__WARNING__! Low level API.
         *
         * @returns anything "focusable", not only tabbable. The difference is in `tabIndex=-1`
         * (without guards, as long as they are not expected to be ever focused)
         *
         * @see {@link getTabbableNodes} to get only tabble nodes element
         *
         * @param topNodes - array of top level HTMLElements to search inside
         * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call
         */
        var getFocusableNodes = function getFocusableNodes(topNodes, visibilityCache) {
          return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
        };
        /**
         * return list of nodes which are expected to be auto-focused
         * @param topNode
         * @param visibilityCache
         */
        var parentAutofocusables = function parentAutofocusables(topNode, visibilityCache) {
          return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
        };
        /*
         * Determines if element is contained in scope, including nested shadow DOMs
         */
        var _contains$ = function contains$1(scope, element) {
          if (scope.shadowRoot) {
            return _contains$(scope.shadowRoot, element);
          } else {
            if (Object.getPrototypeOf(scope).contains !== undefined && Object.getPrototypeOf(scope).contains.call(scope, element)) {
              return true;
            }
            return toArray$1(scope.children).some(function (child) {
              var _a;
              if (child instanceof HTMLIFrameElement) {
                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
                if (iframeBody) {
                  return _contains$(iframeBody, element);
                }
                return false;
              }
              return _contains$(child, element);
            });
          }
        };

        /**
         * in case of multiple nodes nested inside each other
         * keeps only top ones
         * this is O(nlogn)
         * @param nodes
         * @returns {*}
         */
        var filterNested = function filterNested(nodes) {
          var contained = new Set();
          var l = nodes.length;
          for (var i = 0; i < l; i += 1) {
            for (var j = i + 1; j < l; j += 1) {
              var position = nodes[i].compareDocumentPosition(nodes[j]);
              /* eslint-disable no-bitwise */
              if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
                contained.add(j);
              }
              if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
                contained.add(i);
              }
              /* eslint-enable */
            }
          }
          return nodes.filter(function (_, index) {
            return !contained.has(index);
          });
        };
        /**
         * finds top most parent for a node
         * @param node
         * @returns {*}
         */
        var _getTopParent = function getTopParent(node) {
          return node.parentNode ? _getTopParent(node.parentNode) : node;
        };
        /**
         * returns all "focus containers" inside a given node
         * @param node - node or nodes to look inside
         * @returns Element[]
         */
        var getAllAffectedNodes = function getAllAffectedNodes(node) {
          var nodes = asArray(node);
          return nodes.filter(Boolean).reduce(function (acc, currentNode) {
            var group = currentNode.getAttribute(FOCUS_GROUP);
            acc.push.apply(acc, group ? filterNested(toArray$1(_getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, "=\"").concat(group, "\"]:not([").concat(FOCUS_DISABLED, "=\"disabled\"])")))) : [currentNode]);
            return acc;
          }, []);
        };
        var safeProbe = function safeProbe(cb) {
          try {
            return cb();
          } catch (e) {
            return undefined;
          }
        };

        /**
         * returns active element from document or from nested shadowdoms
         */
        /**
         * returns current active element. If the active element is a "container" itself(shadowRoot or iframe) returns active element inside it
         * @param [inDocument]
         */
        var _getActiveElement = function getActiveElement(inDocument) {
          if (inDocument === void 0) {
            inDocument = document;
          }
          if (!inDocument || !inDocument.activeElement) {
            return undefined;
          }
          var activeElement = inDocument.activeElement;
          return activeElement.shadowRoot ? _getActiveElement(activeElement.shadowRoot) : activeElement instanceof HTMLIFrameElement && safeProbe(function () {
            return activeElement.contentWindow.document;
          }) ? _getActiveElement(activeElement.contentWindow.document) : activeElement;
        };
        var focusInFrame = function focusInFrame(frame, activeElement) {
          return frame === activeElement;
        };
        var focusInsideIframe = function focusInsideIframe(topNode, activeElement) {
          return Boolean(toArray$1(topNode.querySelectorAll('iframe')).some(function (node) {
            return focusInFrame(node, activeElement);
          }));
        };
        /**
         * @returns {Boolean} true, if the current focus is inside given node or nodes.
         * Supports nodes hidden inside shadowDom
         */
        var focusInside = function focusInside(topNode, activeElement) {
          // const activeElement = document && getActiveElement();
          if (activeElement === void 0) {
            activeElement = _getActiveElement(getFirst(topNode).ownerDocument);
          }
          if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
            return false;
          }
          return getAllAffectedNodes(topNode).some(function (node) {
            return _contains$(node, activeElement) || focusInsideIframe(node, activeElement);
          });
        };

        /**
         * checks if focus is hidden FROM the focus-lock
         * ie contained inside a node focus-lock shall ignore
         *
         * This is a utility function coupled with {@link FOCUS_ALLOW} constant
         *
         * @returns {boolean} focus is currently is in "allow" area
         */
        var focusIsHidden = function focusIsHidden(inDocument) {
          if (inDocument === void 0) {
            inDocument = document;
          }
          var activeElement = _getActiveElement(inDocument);
          if (!activeElement) {
            return false;
          }
          // this does not support setting FOCUS_ALLOW within shadow dom
          return toArray$1(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function (node) {
            return _contains$(node, activeElement);
          });
        };
        var findSelectedRadio = function findSelectedRadio(node, nodes) {
          return nodes.filter(isRadioElement).filter(function (el) {
            return el.name === node.name;
          }).filter(function (el) {
            return el.checked;
          })[0] || node;
        };
        var correctNode = function correctNode(node, nodes) {
          if (isRadioElement(node) && node.name) {
            return findSelectedRadio(node, nodes);
          }
          return node;
        };
        /**
         * giving a set of radio inputs keeps only selected (tabbable) ones
         * @param nodes
         */
        var correctNodes = function correctNodes(nodes) {
          // IE11 has no Set(array) constructor
          var resultSet = new Set();
          nodes.forEach(function (node) {
            return resultSet.add(correctNode(node, nodes));
          });
          // using filter to support IE11
          return nodes.filter(function (node) {
            return resultSet.has(node);
          });
        };
        var pickFirstFocus = function pickFirstFocus(nodes) {
          if (nodes[0] && nodes.length > 1) {
            return correctNode(nodes[0], nodes);
          }
          return nodes[0];
        };
        var pickFocusable = function pickFocusable(nodes, node) {
          return nodes.indexOf(correctNode(node, nodes));
        };
        var NEW_FOCUS = 'NEW_FOCUS';
        /**
         * Main solver for the "find next focus" question
         * @param innerNodes - used to control "return focus"
         * @param innerTabbables - used to control "autofocus"
         * @param outerNodes
         * @param activeElement
         * @param lastNode
         * @returns {number|string|undefined|*}
         */
        var newFocus = function newFocus(innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {
          var cnt = innerNodes.length;
          var firstFocus = innerNodes[0];
          var lastFocus = innerNodes[cnt - 1];
          var isOnGuard = isGuard(activeElement);
          // focus is inside
          if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
            return undefined;
          }
          var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;
          var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
          var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
          // no active focus (or focus is on the body)
          if (activeIndex === -1) {
            // known fallback
            if (lastNodeInside !== -1) {
              return lastNodeInside;
            }
            return NEW_FOCUS;
          }
          // new focus, nothing to calculate
          if (lastNodeInside === -1) {
            return NEW_FOCUS;
          }
          var indexDiff = activeIndex - lastIndex;
          var firstNodeIndex = outerNodes.indexOf(firstFocus);
          var lastNodeIndex = outerNodes.indexOf(lastFocus);
          var correctedNodes = correctNodes(outerNodes);
          var currentFocusableIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;
          var previousFocusableIndex = lastNode ? correctedNodes.indexOf(lastNode) : currentFocusableIndex;
          var tabbableNodes = correctedNodes.filter(function (node) {
            return node.tabIndex >= 0;
          });
          var currentTabbableIndex = activeElement !== undefined ? tabbableNodes.indexOf(activeElement) : -1;
          var previousTabbableIndex = lastNode ? tabbableNodes.indexOf(lastNode) : currentTabbableIndex;
          var focusIndexDiff = currentTabbableIndex >= 0 && previousTabbableIndex >= 0 ?
          // old/new are tabbables, measure distance in tabbable space
          previousTabbableIndex - currentTabbableIndex :
          // or else measure in focusable space
          previousFocusableIndex - currentFocusableIndex;
          // old focus
          if (!indexDiff && lastNodeInside >= 0) {
            return lastNodeInside;
          }
          // no tabbable elements, autofocus is not possible
          if (innerTabbables.length === 0) {
            // an edge case with no tabbable elements
            // return the last focusable one
            // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to
            return lastNodeInside;
          }
          var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);
          var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);
          // first element
          if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
            return returnLastNode;
          }
          // last element
          if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
            return returnFirstNode;
          }
          // jump out, but not on the guard
          if (indexDiff && Math.abs(focusIndexDiff) > 1) {
            return lastNodeInside;
          }
          // focus above lock
          if (activeIndex <= firstNodeIndex) {
            return returnLastNode;
          }
          // focus below lock
          if (activeIndex > lastNodeIndex) {
            return returnFirstNode;
          }
          // index is inside tab order, but outside Lock
          if (indexDiff) {
            if (Math.abs(indexDiff) > 1) {
              return lastNodeInside;
            }
            return (cnt + lastNodeInside + indexDiff) % cnt;
          }
          // do nothing
          return undefined;
        };
        var findAutoFocused = function findAutoFocused(autoFocusables) {
          return function (node) {
            var _a;
            var autofocus = (_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus;
            return (
              // @ts-expect-error
              node.autofocus ||
              //
              autofocus !== undefined && autofocus !== 'false' ||
              //
              autoFocusables.indexOf(node) >= 0
            );
          };
        };
        var pickAutofocus = function pickAutofocus(nodesIndexes, orderedNodes, groups) {
          var nodes = nodesIndexes.map(function (_a) {
            var node = _a.node;
            return node;
          });
          var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
          if (autoFocusable && autoFocusable.length) {
            return pickFirstFocus(autoFocusable);
          }
          return pickFirstFocus(filterAutoFocusable(orderedNodes));
        };
        var _getParents = function getParents(node, parents) {
          if (parents === void 0) {
            parents = [];
          }
          parents.push(node);
          if (node.parentNode) {
            _getParents(node.parentNode.host || node.parentNode, parents);
          }
          return parents;
        };
        /**
         * finds a parent for both nodeA and nodeB
         * @param nodeA
         * @param nodeB
         * @returns {boolean|*}
         */
        var getCommonParent = function getCommonParent(nodeA, nodeB) {
          var parentsA = _getParents(nodeA);
          var parentsB = _getParents(nodeB);
          // tslint:disable-next-line:prefer-for-of
          for (var i = 0; i < parentsA.length; i += 1) {
            var currentParent = parentsA[i];
            if (parentsB.indexOf(currentParent) >= 0) {
              return currentParent;
            }
          }
          return false;
        };
        var getTopCommonParent = function getTopCommonParent(baseActiveElement, leftEntry, rightEntries) {
          var activeElements = asArray(baseActiveElement);
          var leftEntries = asArray(leftEntry);
          var activeElement = activeElements[0];
          var topCommon = false;
          leftEntries.filter(Boolean).forEach(function (entry) {
            topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
            rightEntries.filter(Boolean).forEach(function (subEntry) {
              var common = getCommonParent(activeElement, subEntry);
              if (common) {
                if (!topCommon || _contains$(common, topCommon)) {
                  topCommon = common;
                } else {
                  topCommon = getCommonParent(common, topCommon);
                }
              }
            });
          });
          // TODO: add assert here?
          return topCommon;
        };
        /**
         * return list of nodes which are expected to be autofocused inside a given top nodes
         * @param entries
         * @param visibilityCache
         */
        var allParentAutofocusables = function allParentAutofocusables(entries, visibilityCache) {
          return entries.reduce(function (acc, node) {
            return acc.concat(parentAutofocusables(node, visibilityCache));
          }, []);
        };
        var reorderNodes = function reorderNodes(srcNodes, dstNodes) {
          var remap = new Map();
          // no Set(dstNodes) for IE11 :(
          dstNodes.forEach(function (entity) {
            return remap.set(entity.node, entity);
          });
          // remap to dstNodes
          return srcNodes.map(function (node) {
            return remap.get(node);
          }).filter(isDefined);
        };
        /**
         * contains the main logic of the `focus-lock` package.
         *
         * ! you probably dont need this function !
         *
         * given top node(s) and the last active element returns the element to be focused next
         * @returns element which should be focused to move focus inside
         * @param topNode
         * @param lastNode
         */
        var focusSolver = function focusSolver(topNode, lastNode) {
          var activeElement = _getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
          var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
          var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
          var visibilityCache = new Map();
          var anyFocusable = getFocusableNodes(entries, visibilityCache);
          var innerElements = anyFocusable.filter(function (_a) {
            var node = _a.node;
            return isNotAGuard(node);
          });
          if (!innerElements[0]) {
            return undefined;
          }
          var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function (_a) {
            var node = _a.node;
            return node;
          });
          var orderedInnerElements = reorderNodes(outerNodes, innerElements);
          // collect inner focusable and separately tabbables
          var innerFocusables = orderedInnerElements.map(function (_a) {
            var node = _a.node;
            return node;
          });
          var innerTabbable = orderedInnerElements.filter(function (_a) {
            var tabIndex = _a.tabIndex;
            return tabIndex >= 0;
          }).map(function (_a) {
            var node = _a.node;
            return node;
          });
          var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);
          if (newId === NEW_FOCUS) {
            var focusNode =
            // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
            pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) || pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache));
            if (focusNode) {
              return {
                node: focusNode
              };
            } else {
              console.warn('focus-lock: cannot find any node to move focus into');
              return undefined;
            }
          }
          if (newId === undefined) {
            return newId;
          }
          return orderedInnerElements[newId];
        };

        /**
         * traverses all related nodes (including groups) returning a list of all nodes(outer and internal) with meta information
         * This is low-level API!
         * @returns list of focusable elements inside a given top(!) node.
         * @see {@link getFocusableNodes} providing a simpler API
         */
        var expandFocusableNodes = function expandFocusableNodes(topNode) {
          var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
          var commonParent = getTopCommonParent(topNode, topNode, entries);
          var outerNodes = orderByTabIndex(getFocusables([commonParent], true), true, true);
          var innerElements = getFocusables(entries, false);
          return outerNodes.map(function (_a) {
            var node = _a.node,
              index = _a.index;
            return {
              node: node,
              index: index,
              lockItem: innerElements.indexOf(node) >= 0,
              guard: isGuard(node)
            };
          });
        };
        var focusOn = function focusOn(target, focusOptions) {
          if (!target) {
            // not clear how, but is possible https://github.com/theKashey/focus-lock/issues/53
            return;
          }
          if ('focus' in target) {
            target.focus(focusOptions);
          }
          if ('contentWindow' in target && target.contentWindow) {
            target.contentWindow.focus();
          }
        };
        var guardCount = 0;
        var lockDisabled = false;
        /**
         * The main functionality of the focus-lock package
         *
         * Contains focus at a given node.
         * The last focused element will help to determine which element(first or last) should be focused.
         * The found element will be focused.
         *
         * This is one time action (move), not a persistent focus-lock
         *
         * HTML markers (see {@link import('./constants').FOCUS_AUTO} constants) can control autofocus
         * @see {@link focusSolver} for the same functionality without autofocus
         */
        var moveFocusInside = function moveFocusInside(topNode, lastNode, options) {
          if (options === void 0) {
            options = {};
          }
          var focusable = focusSolver(topNode, lastNode);
          // global local side effect to countain recursive lock activation and resolve focus-fighting
          if (lockDisabled) {
            return;
          }
          if (focusable) {
            /** +FOCUS-FIGHTING prevention **/
            if (guardCount > 2) {
              // we have recursive entered back the lock activation
              console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
              lockDisabled = true;
              setTimeout(function () {
                lockDisabled = false;
              }, 1);
              return;
            }
            guardCount++;
            focusOn(focusable.node, options.focusOptions);
            guardCount--;
          }
        };
        function weakRef(value) {
          if (!value) return null;
          // #68 Safari 14.1 dont have it yet
          // FIXME: remove in 2025
          if (typeof WeakRef === 'undefined') {
            return function () {
              return value || null;
            };
          }
          var w = value ? new WeakRef(value) : null;
          return function () {
            return (w === null || w === void 0 ? void 0 : w.deref()) || null;
          };
        }
        var recordElementLocation = function recordElementLocation(element) {
          if (!element) {
            return null;
          }
          var stack = [];
          var currentElement = element;
          while (currentElement && currentElement !== document.body) {
            stack.push({
              current: weakRef(currentElement),
              parent: weakRef(currentElement.parentElement),
              left: weakRef(currentElement.previousElementSibling),
              right: weakRef(currentElement.nextElementSibling)
            });
            currentElement = currentElement.parentElement;
          }
          return {
            element: weakRef(element),
            stack: stack,
            ownerDocument: element.ownerDocument
          };
        };
        var restoreFocusTo = function restoreFocusTo(location) {
          var _a, _b, _c, _d, _e;
          if (!location) {
            return undefined;
          }
          var stack = location.stack,
            ownerDocument = location.ownerDocument;
          var visibilityCache = new Map();
          for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {
            var line = stack_1[_i];
            var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line);
            // is it still here?
            if (parent_1 && ownerDocument.contains(parent_1)) {
              var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);
              var savedCurrent = line.current();
              var current = parent_1.contains(savedCurrent) ? savedCurrent : undefined;
              var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);
              var focusables = getTabbableNodes([parent_1], visibilityCache);
              var aim =
              // that is element itself
              (_e = (_d = current !== null && current !== void 0 ? current :
              // or something in it's place
              left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d :
              // or somebody to the right, still close enough
              right) !== null && _e !== void 0 ? _e :
              // or somebody to the left, something?
              left;
              while (aim) {
                for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {
                  var focusable = focusables_1[_f];
                  if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {
                    return focusable.node;
                  }
                }
                aim = aim.nextElementSibling;
              }
              if (focusables.length) {
                // if parent contains a focusable - move there
                return focusables[0].node;
              }
            }
          }
          // nothing matched
          return undefined;
        };
        /**
         * Captures the current focused element to restore focus as close as possible in the future
         * Handles situations where the focused element is removed from the DOM or no longer focusable
         * moving focus to the closest focusable element
         * @param targetElement - element where focus should be restored
         * @returns a function returning a new element to focus
         */
        var captureFocusRestore = function captureFocusRestore(targetElement) {
          var location = recordElementLocation(targetElement);
          return function () {
            return restoreFocusTo(location);
          };
        };

        /**
         * for a given `element` in a given `scope` returns focusable siblings
         * @param element - base element
         * @param scope - common parent. Can be document, but better to narrow it down for performance reasons
         * @returns {prev,next} - references to a focusable element before and after
         * @returns undefined - if operation is not applicable
         */
        var getRelativeFocusable = function getRelativeFocusable(element, scope, useTabbables) {
          if (!element || !scope) {
            console.error('no element or scope given');
            return {};
          }
          var shards = asArray(scope);
          if (shards.every(function (shard) {
            return !_contains$(shard, element);
          })) {
            console.error('Active element is not contained in the scope');
            return {};
          }
          var focusables = useTabbables ? getTabbableNodes(shards, new Map()) : getFocusableNodes(shards, new Map());
          var current = focusables.findIndex(function (_a) {
            var node = _a.node;
            return node === element;
          });
          if (current === -1) {
            // an edge case, when anchor element is not found
            return undefined;
          }
          return {
            prev: focusables[current - 1],
            next: focusables[current + 1],
            first: focusables[0],
            last: focusables[focusables.length - 1]
          };
        };
        var getBoundary = function getBoundary(shards, useTabbables) {
          var set = useTabbables ? getTabbableNodes(asArray(shards), new Map()) : getFocusableNodes(asArray(shards), new Map());
          return {
            first: set[0],
            last: set[set.length - 1]
          };
        };
        var defaultOptions = function defaultOptions(options) {
          return Object.assign({
            scope: document.body,
            cycle: true,
            onlyTabbable: true
          }, options);
        };
        var moveFocus = function moveFocus(fromElement, options, cb) {
          if (options === void 0) {
            options = {};
          }
          var newOptions = defaultOptions(options);
          var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);
          if (!solution) {
            return;
          }
          var target = cb(solution, newOptions.cycle);
          if (target) {
            focusOn(target.node, newOptions.focusOptions);
          }
        };
        /**
         * focuses next element in the tab-order
         * @param fromElement - common parent to scope active element search or tab cycle order
         * @param {FocusNextOptions} [options] - focus options
         */
        var focusNextElement = function focusNextElement(fromElement, options) {
          if (options === void 0) {
            options = {};
          }
          moveFocus(fromElement, options, function (_a, cycle) {
            var next = _a.next,
              first = _a.first;
            return next || cycle && first;
          });
        };
        /**
         * focuses prev element in the tab order
         * @param fromElement - common parent to scope active element search or tab cycle order
         * @param {FocusNextOptions} [options] - focus options
         */
        var focusPrevElement = function focusPrevElement(fromElement, options) {
          if (options === void 0) {
            options = {};
          }
          moveFocus(fromElement, options, function (_a, cycle) {
            var prev = _a.prev,
              last = _a.last;
            return prev || cycle && last;
          });
        };
        var pickBoundary = function pickBoundary(scope, options, what) {
          var _a;
          var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);
          var node = boundary[what];
          if (node) {
            focusOn(node.node, options.focusOptions);
          }
        };
        /**
         * focuses first element in the tab-order
         * @param {FocusNextOptions} options - focus options
         */
        var focusFirstElement = function focusFirstElement(scope, options) {
          if (options === void 0) {
            options = {};
          }
          pickBoundary(scope, options, 'first');
        };
        /**
         * focuses last element in the tab order
         * @param {FocusNextOptions} options - focus options
         */
        var focusLastElement = function focusLastElement(scope, options) {
          if (options === void 0) {
            options = {};
          }
          pickBoundary(scope, options, 'last');
        };
        function deferAction(action) {
          setTimeout(action, 1);
        }
        var extractRef$1 = function extractRef(ref) {
          return ref && 'current' in ref ? ref.current : ref;
        };
        var focusOnBody = function focusOnBody2() {
          return document && document.activeElement === document.body;
        };
        var isFreeFocus = function isFreeFocus2() {
          return focusOnBody() || focusIsHidden();
        };
        var lastActiveTrap = null;
        var lastActiveFocus = null;
        var tryRestoreFocus = function tryRestoreFocus2() {
          return null;
        };
        var lastPortaledElement = null;
        var focusWasOutsideWindow = false;
        var windowFocused = false;
        var defaultWhitelist = function defaultWhitelist2() {
          return true;
        };
        var focusWhitelisted = function focusWhitelisted2(activeElement) {
          return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
        };
        var recordPortal = function recordPortal2(observerNode, portaledElement) {
          lastPortaledElement = {
            observerNode: observerNode,
            portaledElement: portaledElement
          };
        };
        var focusIsPortaledPair = function focusIsPortaledPair2(element) {
          return lastPortaledElement && lastPortaledElement.portaledElement === element;
        };
        function autoGuard(startIndex, end, step, allNodes) {
          var lastGuard = null;
          var i = startIndex;
          do {
            var item = allNodes[i];
            if (item.guard) {
              if (item.node.dataset.focusAutoGuard) {
                lastGuard = item;
              }
            } else if (item.lockItem) {
              if (i !== startIndex) {
                return;
              }
              lastGuard = null;
            } else {
              break;
            }
          } while ((i += step) !== end);
          if (lastGuard) {
            lastGuard.node.tabIndex = 0;
          }
        }
        var focusWasOutside = function focusWasOutside2(crossFrameOption) {
          if (crossFrameOption) {
            return Boolean(focusWasOutsideWindow);
          }
          return focusWasOutsideWindow === "meanwhile";
        };
        var checkInHost = function checkInHost2(check, el, boundary) {
          return el && (el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost2(check, el.parentNode, boundary));
        };
        var withinHost = function withinHost2(activeElement, workingArea) {
          return workingArea.some(function (area) {
            return checkInHost(activeElement, area, area);
          });
        };
        var getNodeFocusables = function getNodeFocusables2(nodes) {
          return getFocusableNodes(nodes, /* @__PURE__ */new Map());
        };
        var isNotFocusable = function isNotFocusable2(node) {
          return !getNodeFocusables([node.parentNode]).some(function (el) {
            return el.node === node;
          });
        };
        var activateTrap = function activateTrap2() {
          var result = false;
          if (lastActiveTrap) {
            var _lastActiveTrap = lastActiveTrap,
              observed = _lastActiveTrap.observed,
              persistentFocus = _lastActiveTrap.persistentFocus,
              autoFocus = _lastActiveTrap.autoFocus,
              shards = _lastActiveTrap.shards,
              crossFrame = _lastActiveTrap.crossFrame,
              focusOptions = _lastActiveTrap.focusOptions,
              noFocusGuards = _lastActiveTrap.noFocusGuards;
            var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
            if (focusOnBody() && lastActiveFocus && lastActiveFocus !== document.body) {
              if (!document.body.contains(lastActiveFocus) || isNotFocusable(lastActiveFocus)) {
                var newTarget = tryRestoreFocus();
                if (newTarget) {
                  newTarget.focus();
                }
              }
            }
            var activeElement = document && document.activeElement;
            if (workingNode) {
              var workingArea = [workingNode].concat(shards.map(extractRef$1).filter(Boolean));
              var shouldForceRestoreFocus = function shouldForceRestoreFocus2() {
                if (!focusWasOutside(crossFrame) || !noFocusGuards || !lastActiveFocus || windowFocused) {
                  return false;
                }
                var nodes = getNodeFocusables(workingArea);
                var lastIndex = nodes.findIndex(function (_ref) {
                  var node = _ref.node;
                  return node === lastActiveFocus;
                });
                return lastIndex === 0 || lastIndex === nodes.length - 1;
              };
              if (!activeElement || focusWhitelisted(activeElement)) {
                if (persistentFocus || shouldForceRestoreFocus() || !isFreeFocus() || !lastActiveFocus && autoFocus) {
                  if (workingNode && !(focusInside(workingArea) || activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement))) {
                    if (document && !lastActiveFocus && activeElement && !autoFocus) {
                      if (activeElement.blur) {
                        activeElement.blur();
                      }
                      document.body.focus();
                    } else {
                      result = moveFocusInside(workingArea, lastActiveFocus, {
                        focusOptions: focusOptions
                      });
                      lastPortaledElement = {};
                    }
                  }
                  lastActiveFocus = document && document.activeElement;
                  if (lastActiveFocus !== document.body) {
                    tryRestoreFocus = captureFocusRestore(lastActiveFocus);
                  }
                  focusWasOutsideWindow = false;
                }
              }
              if (document && activeElement !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
                var newActiveElement = document && document.activeElement;
                var allNodes = expandFocusableNodes(workingArea);
                var focusedIndex = allNodes.map(function (_ref2) {
                  var node = _ref2.node;
                  return node;
                }).indexOf(newActiveElement);
                if (focusedIndex > -1) {
                  allNodes.filter(function (_ref3) {
                    var guard = _ref3.guard,
                      node = _ref3.node;
                    return guard && node.dataset.focusAutoGuard;
                  }).forEach(function (_ref4) {
                    var node = _ref4.node;
                    return node.removeAttribute("tabIndex");
                  });
                  autoGuard(focusedIndex, allNodes.length, 1, allNodes);
                  autoGuard(focusedIndex, -1, -1, allNodes);
                }
              }
            }
          }
          return result;
        };
        var onTrap = function onTrap2(event) {
          if (activateTrap() && event) {
            event.stopPropagation();
            event.preventDefault();
          }
        };
        var onBlur = function onBlur2() {
          return deferAction(activateTrap);
        };
        var onFocus = function onFocus2(event) {
          var source = event.target;
          var currentNode = event.currentTarget;
          if (!currentNode.contains(source)) {
            recordPortal(currentNode, source);
          }
        };
        var FocusWatcher = function FocusWatcher2() {
          return null;
        };
        var onWindowFocus = function onWindowFocus2() {
          windowFocused = true;
        };
        var onWindowBlur = function onWindowBlur2() {
          windowFocused = false;
          focusWasOutsideWindow = "just";
          deferAction(function () {
            focusWasOutsideWindow = "meanwhile";
          });
        };
        var attachHandler = function attachHandler2() {
          document.addEventListener("focusin", onTrap);
          document.addEventListener("focusout", onBlur);
          window.addEventListener("focus", onWindowFocus);
          window.addEventListener("blur", onWindowBlur);
        };
        var detachHandler = function detachHandler2() {
          document.removeEventListener("focusin", onTrap);
          document.removeEventListener("focusout", onBlur);
          window.removeEventListener("focus", onWindowFocus);
          window.removeEventListener("blur", onWindowBlur);
        };
        function reducePropsToState(propsList) {
          return propsList.filter(function (_ref6) {
            var disabled = _ref6.disabled;
            return !disabled;
          });
        }
        var focusLockAPI = {
          moveFocusInside: moveFocusInside,
          focusInside: focusInside,
          focusNextElement: focusNextElement,
          focusPrevElement: focusPrevElement,
          focusFirstElement: focusFirstElement,
          focusLastElement: focusLastElement,
          captureFocusRestore: captureFocusRestore
        };
        function handleStateChangeOnClient(traps) {
          var trap = traps.slice(-1)[0];
          if (trap && !lastActiveTrap) {
            attachHandler();
          }
          var lastTrap = lastActiveTrap;
          var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
          lastActiveTrap = trap;
          if (lastTrap && !sameTrap) {
            lastTrap.onDeactivation();
            if (!traps.filter(function (_ref7) {
              var id = _ref7.id;
              return id === lastTrap.id;
            }).length) {
              lastTrap.returnFocus(!trap);
            }
          }
          if (trap) {
            lastActiveFocus = null;
            if (!sameTrap || lastTrap.observed !== trap.observed) {
              trap.onActivation(focusLockAPI);
            }
            activateTrap();
            deferAction(activateTrap);
          } else {
            detachHandler();
            lastActiveFocus = null;
          }
        }
        mediumFocus.assignSyncMedium(onFocus);
        mediumBlur.assignMedium(onBlur);
        mediumEffect.assignMedium(function (cb) {
          return cb(focusLockAPI);
        });
        var FocusTrap$1 = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
        var FocusLockCombination = /* @__PURE__ */reactExports.forwardRef(function FocusLockUICombination(props, ref) {
          return /* @__PURE__ */React.createElement(FocusLock$1, _extends$1({
            sideCar: FocusTrap$1,
            ref: ref
          }, props));
        });
        var _ref = FocusLock$1.propTypes || {};
        _ref.sideCar;
        _objectWithoutPropertiesLoose$1(_ref, ["sideCar"]);
        FocusLockCombination.propTypes = {};
        var FocusTrap = (_FocusLockCombination = FocusLockCombination.default) !== null && _FocusLockCombination !== void 0 ? _FocusLockCombination : FocusLockCombination;
        var FocusLock = function FocusLock(props) {
          var initialFocusRef = props.initialFocusRef,
            finalFocusRef = props.finalFocusRef,
            contentRef = props.contentRef,
            restoreFocus = props.restoreFocus,
            children = props.children,
            isDisabled = props.isDisabled,
            autoFocus = props.autoFocus,
            persistentFocus = props.persistentFocus,
            lockFocusAcrossFrames = props.lockFocusAcrossFrames;
          var onActivation = reactExports.useCallback(function () {
            if (initialFocusRef !== null && initialFocusRef !== void 0 && initialFocusRef.current) {
              initialFocusRef.current.focus();
            } else if (contentRef !== null && contentRef !== void 0 && contentRef.current) {
              var focusables = getAllFocusable(contentRef.current);
              if (focusables.length === 0) {
                requestAnimationFrame(function () {
                  var _contentRef$current;
                  (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
                });
              }
            }
          }, [initialFocusRef, contentRef]);
          var onDeactivation = reactExports.useCallback(function () {
            var _finalFocusRef$curren;
            finalFocusRef === null || finalFocusRef === void 0 || (_finalFocusRef$curren = finalFocusRef.current) === null || _finalFocusRef$curren === void 0 || _finalFocusRef$curren.focus();
          }, [finalFocusRef]);
          var returnFocus = restoreFocus && !finalFocusRef;
          return /* @__PURE__ */jsxRuntimeExports.jsx(FocusTrap, {
            crossFrame: lockFocusAcrossFrames,
            persistentFocus: persistentFocus,
            autoFocus: autoFocus,
            disabled: isDisabled,
            onActivation: onActivation,
            onDeactivation: onDeactivation,
            returnFocus: returnFocus,
            children: children
          });
        };
        FocusLock.displayName = "FocusLock";
        var FormLabel = forwardRef(function FormLabel2(passedProps, ref) {
          var _field$getLabelProps;
          var styles = useStyleConfig("FormLabel", passedProps);
          var props = omitThemingProps(passedProps);
          var className = props.className,
            children = props.children,
            _props$requiredIndica = props.requiredIndicator,
            requiredIndicator = _props$requiredIndica === void 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(RequiredIndicator, {}) : _props$requiredIndica,
            _props$optionalIndica = props.optionalIndicator,
            optionalIndicator = _props$optionalIndica === void 0 ? null : _props$optionalIndica,
            rest = _objectWithoutProperties2(props, _excluded49);
          var field = useFormControlContext();
          var ownProps = (_field$getLabelProps = field === null || field === void 0 ? void 0 : field.getLabelProps(rest, ref)) !== null && _field$getLabelProps !== void 0 ? _field$getLabelProps : _objectSpread3({
            ref: ref
          }, rest);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.label, _objectSpread3(_objectSpread3({}, ownProps), {}, {
            className: cx("chakra-form__label", props.className),
            __css: _objectSpread3({
              display: "block",
              textAlign: "start"
            }, styles),
            children: [children, field !== null && field !== void 0 && field.isRequired ? requiredIndicator : optionalIndicator]
          }));
        });
        FormLabel.displayName = "FormLabel";
        var RequiredIndicator = forwardRef(function RequiredIndicator2(props, ref) {
          var field = useFormControlContext();
          var styles = useFormControlStyles();
          if (!(field !== null && field !== void 0 && field.isRequired)) return null;
          var className = cx("chakra-form__required-indicator", props.className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({}, field === null || field === void 0 ? void 0 : field.getRequiredIndicatorProps(props, ref)), {}, {
            __css: styles.requiredIndicator,
            className: className
          }));
        });
        RequiredIndicator.displayName = "RequiredIndicator";
        var Grid = forwardRef(function Grid2(props, ref) {
          var templateAreas = props.templateAreas,
            gap = props.gap,
            rowGap = props.rowGap,
            columnGap = props.columnGap,
            column = props.column,
            row = props.row,
            autoFlow = props.autoFlow,
            autoRows = props.autoRows,
            templateRows = props.templateRows,
            autoColumns = props.autoColumns,
            templateColumns = props.templateColumns,
            rest = _objectWithoutProperties2(props, _excluded50);
          var styles = {
            display: "grid",
            gridTemplateAreas: templateAreas,
            gridGap: gap,
            gridRowGap: rowGap,
            gridColumnGap: columnGap,
            gridAutoColumns: autoColumns,
            gridColumn: column,
            gridRow: row,
            gridAutoFlow: autoFlow,
            gridAutoRows: autoRows,
            gridTemplateRows: templateRows,
            gridTemplateColumns: templateColumns
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3({
            ref: ref,
            __css: styles
          }, rest));
        });
        Grid.displayName = "Grid";
        var SimpleGrid = exports("J", forwardRef(function SimpleGrid2(props, ref) {
          var columns = props.columns,
            spacingX = props.spacingX,
            spacingY = props.spacingY,
            spacing = props.spacing,
            minChildWidth = props.minChildWidth,
            rest = _objectWithoutProperties2(props, _excluded51);
          var theme = useTheme();
          var templateColumns = minChildWidth ? widthToColumns(minChildWidth, theme) : countToColumns(columns);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Grid, _objectSpread3({
            ref: ref,
            gap: spacing,
            columnGap: spacingX,
            rowGap: spacingY,
            templateColumns: templateColumns
          }, rest));
        }));
        SimpleGrid.displayName = "SimpleGrid";
        function toPx(n) {
          return typeof n === "number" ? "".concat(n, "px") : n;
        }
        function widthToColumns(width, theme) {
          return mapResponsive(width, function (value) {
            var _value = getToken("sizes", value, toPx(value))(theme);
            return value === null ? null : "repeat(auto-fit, minmax(".concat(_value, ", 1fr))");
          });
        }
        function countToColumns(count) {
          return mapResponsive(count, function (value) {
            return value === null ? null : "repeat(".concat(value, ", minmax(0, 1fr))");
          });
        }
        var Input = forwardRef(function Input2(props, ref) {
          var htmlSize = props.htmlSize,
            rest = _objectWithoutProperties2(props, _excluded52);
          var styles = useMultiStyleConfig("Input", rest);
          var ownProps = omitThemingProps(rest);
          var input = useFormControl(ownProps);
          var _className = cx("chakra-input", props.className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.input, _objectSpread3(_objectSpread3({
            size: htmlSize
          }, input), {}, {
            __css: styles.field,
            ref: ref,
            className: _className
          }));
        });
        Input.displayName = "Input";
        Input.id = "Input";
        var _createContext21 = createContext({
            name: "InputGroupStylesContext",
            errorMessage: "useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<InputGroup />\" "
          }),
          _createContext22 = _slicedToArray(_createContext21, 2),
          InputGroupStylesProvider = _createContext22[0],
          useInputGroupStyles = _createContext22[1];
        var InputGroup = forwardRef(function InputGroup2(props, ref) {
          var styles = useMultiStyleConfig("Input", props);
          var _omitThemingProps0 = omitThemingProps(props),
            children = _omitThemingProps0.children,
            className = _omitThemingProps0.className,
            rest = _objectWithoutProperties2(_omitThemingProps0, _excluded53);
          var _className = cx("chakra-input__group", className);
          var groupStyles = {};
          var validChildren = getValidChildren(children);
          var input = styles.field;
          validChildren.forEach(function (child) {
            if (!styles) return;
            if (input && child.type.id === "InputLeftElement") {
              var _input$height;
              groupStyles.paddingStart = (_input$height = input.height) !== null && _input$height !== void 0 ? _input$height : input.h;
            }
            if (input && child.type.id === "InputRightElement") {
              var _input$height2;
              groupStyles.paddingEnd = (_input$height2 = input.height) !== null && _input$height2 !== void 0 ? _input$height2 : input.h;
            }
            if (child.type.id === "InputRightAddon") {
              groupStyles.borderEndRadius = 0;
            }
            if (child.type.id === "InputLeftAddon") {
              groupStyles.borderStartRadius = 0;
            }
          });
          var clones = validChildren.map(function (child) {
            var _child$props, _child$props2;
            var theming = compact({
              size: ((_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.size) || props.size,
              variant: ((_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : _child$props2.variant) || props.variant
            });
            return child.type.id !== "Input" ? reactExports.cloneElement(child, theming) : reactExports.cloneElement(child, Object.assign(theming, groupStyles, child.props));
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            className: _className,
            ref: ref,
            __css: _objectSpread3({
              width: "100%",
              display: "flex",
              position: "relative",
              // Parts of inputs override z-index to ensure that they stack correctly on each other
              // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
              isolation: "isolate"
            }, styles.group),
            "data-group": true
          }, rest), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(InputGroupStylesProvider, {
              value: styles,
              children: clones
            })
          }));
        });
        InputGroup.displayName = "InputGroup";
        var StyledInputElement = chakra("div", {
          baseStyle: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "absolute",
            top: "0",
            zIndex: 2
          }
        });
        var InputElement = forwardRef(function InputElement2(props, ref) {
          var _input$height3, _input$height4;
          var _props$placement = props.placement,
            placement = _props$placement === void 0 ? "left" : _props$placement,
            rest = _objectWithoutProperties2(props, _excluded54);
          var styles = useInputGroupStyles();
          var input = styles.field;
          var attr = placement === "left" ? "insetStart" : "insetEnd";
          var elementStyles = _objectSpread3(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, attr, "0"), "width", (_input$height3 = input === null || input === void 0 ? void 0 : input.height) !== null && _input$height3 !== void 0 ? _input$height3 : input === null || input === void 0 ? void 0 : input.h), "height", (_input$height4 = input === null || input === void 0 ? void 0 : input.height) !== null && _input$height4 !== void 0 ? _input$height4 : input === null || input === void 0 ? void 0 : input.h), "fontSize", input === null || input === void 0 ? void 0 : input.fontSize), styles.element);
          return /* @__PURE__ */jsxRuntimeExports.jsx(StyledInputElement, _objectSpread3({
            ref: ref,
            __css: elementStyles
          }, rest));
        });
        InputElement.id = "InputElement";
        InputElement.displayName = "InputElement";
        var InputLeftElement = forwardRef(function InputLeftElement2(props, ref) {
          var className = props.className,
            rest = _objectWithoutProperties2(props, _excluded55);
          var _className = cx("chakra-input__left-element", className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(InputElement, _objectSpread3({
            ref: ref,
            placement: "left",
            className: _className
          }, rest));
        });
        InputLeftElement.id = "InputLeftElement";
        InputLeftElement.displayName = "InputLeftElement";
        var InputRightElement = forwardRef(function InputRightElement2(props, ref) {
          var className = props.className,
            rest = _objectWithoutProperties2(props, _excluded56);
          var _className = cx("chakra-input__right-element", className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(InputElement, _objectSpread3({
            ref: ref,
            placement: "right",
            className: _className
          }, rest));
        });
        InputRightElement.id = "InputRightElement";
        InputRightElement.displayName = "InputRightElement";
        var Link = exports("a6", forwardRef(function Link2(props, ref) {
          var styles = useStyleConfig("Link", props);
          var _omitThemingProps1 = omitThemingProps(props),
            className = _omitThemingProps1.className,
            isExternal = _omitThemingProps1.isExternal,
            rest = _objectWithoutProperties2(_omitThemingProps1, _excluded57);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.a, _objectSpread3(_objectSpread3({
            target: isExternal ? "_blank" : void 0,
            rel: isExternal ? "noopener" : void 0,
            ref: ref,
            className: cx("chakra-link", className)
          }, rest), {}, {
            __css: styles
          }));
        }));
        Link.displayName = "Link";
        var top = 'top';
        var bottom = 'bottom';
        var right = 'right';
        var left = 'left';
        var auto = 'auto';
        var basePlacements = [top, bottom, right, left];
        var start = 'start';
        var end = 'end';
        var clippingParents = 'clippingParents';
        var viewport = 'viewport';
        var popper = 'popper';
        var reference = 'reference';
        var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
          return acc.concat([placement + "-" + start, placement + "-" + end]);
        }, []);
        var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
          return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
        }, []); // modifiers that need to read the DOM

        var beforeRead = 'beforeRead';
        var read = 'read';
        var afterRead = 'afterRead'; // pure-logic modifiers

        var beforeMain = 'beforeMain';
        var main = 'main';
        var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

        var beforeWrite = 'beforeWrite';
        var write = 'write';
        var afterWrite = 'afterWrite';
        var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
        function getNodeName(element) {
          return element ? (element.nodeName || '').toLowerCase() : null;
        }
        function getWindow(node) {
          if (node == null) {
            return window;
          }
          if (node.toString() !== '[object Window]') {
            var ownerDocument = node.ownerDocument;
            return ownerDocument ? ownerDocument.defaultView || window : window;
          }
          return node;
        }
        function isElement(node) {
          var OwnElement = getWindow(node).Element;
          return node instanceof OwnElement || node instanceof Element;
        }
        function isHTMLElement(node) {
          var OwnElement = getWindow(node).HTMLElement;
          return node instanceof OwnElement || node instanceof HTMLElement;
        }
        function isShadowRoot(node) {
          // IE 11 has no ShadowRoot
          if (typeof ShadowRoot === 'undefined') {
            return false;
          }
          var OwnElement = getWindow(node).ShadowRoot;
          return node instanceof OwnElement || node instanceof ShadowRoot;
        }

        // and applies them to the HTMLElements such as popper and arrow

        function applyStyles(_ref) {
          var state = _ref.state;
          Object.keys(state.elements).forEach(function (name) {
            var style = state.styles[name] || {};
            var attributes = state.attributes[name] || {};
            var element = state.elements[name]; // arrow is optional + virtual elements

            if (!isHTMLElement(element) || !getNodeName(element)) {
              return;
            } // Flow doesn't support to extend this property, but it's the most
            // effective way to apply styles to an HTMLElement
            // $FlowFixMe[cannot-write]

            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function (name) {
              var value = attributes[name];
              if (value === false) {
                element.removeAttribute(name);
              } else {
                element.setAttribute(name, value === true ? '' : value);
              }
            });
          });
        }
        function effect$2(_ref2) {
          var state = _ref2.state;
          var initialStyles = {
            popper: {
              position: state.options.strategy,
              left: '0',
              top: '0',
              margin: '0'
            },
            arrow: {
              position: 'absolute'
            },
            reference: {}
          };
          Object.assign(state.elements.popper.style, initialStyles.popper);
          state.styles = initialStyles;
          if (state.elements.arrow) {
            Object.assign(state.elements.arrow.style, initialStyles.arrow);
          }
          return function () {
            Object.keys(state.elements).forEach(function (name) {
              var element = state.elements[name];
              var attributes = state.attributes[name] || {};
              var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

              var style = styleProperties.reduce(function (style, property) {
                style[property] = '';
                return style;
              }, {}); // arrow is optional + virtual elements

              if (!isHTMLElement(element) || !getNodeName(element)) {
                return;
              }
              Object.assign(element.style, style);
              Object.keys(attributes).forEach(function (attribute) {
                element.removeAttribute(attribute);
              });
            });
          };
        } // eslint-disable-next-line import/no-unused-modules

        var applyStyles$1 = {
          name: 'applyStyles',
          enabled: true,
          phase: 'write',
          fn: applyStyles,
          effect: effect$2,
          requires: ['computeStyles']
        };
        function getBasePlacement(placement) {
          return placement.split('-')[0];
        }
        var max = Math.max;
        var min = Math.min;
        var round = Math.round;
        function getUAString() {
          var uaData = navigator.userAgentData;
          if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
            return uaData.brands.map(function (item) {
              return item.brand + "/" + item.version;
            }).join(' ');
          }
          return navigator.userAgent;
        }
        function isLayoutViewport() {
          return !/^((?!chrome|android).)*safari/i.test(getUAString());
        }
        function getBoundingClientRect(element, includeScale, isFixedStrategy) {
          if (includeScale === void 0) {
            includeScale = false;
          }
          if (isFixedStrategy === void 0) {
            isFixedStrategy = false;
          }
          var clientRect = element.getBoundingClientRect();
          var scaleX = 1;
          var scaleY = 1;
          if (includeScale && isHTMLElement(element)) {
            scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
            scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
          }
          var _ref = isElement(element) ? getWindow(element) : window,
            visualViewport = _ref.visualViewport;
          var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
          var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
          var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
          var width = clientRect.width / scaleX;
          var height = clientRect.height / scaleY;
          return {
            width: width,
            height: height,
            top: y,
            right: x + width,
            bottom: y + height,
            left: x,
            x: x,
            y: y
          };
        }

        // means it doesn't take into account transforms.

        function getLayoutRect(element) {
          var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
          // Fixes https://github.com/popperjs/popper-core/issues/1223

          var width = element.offsetWidth;
          var height = element.offsetHeight;
          if (Math.abs(clientRect.width - width) <= 1) {
            width = clientRect.width;
          }
          if (Math.abs(clientRect.height - height) <= 1) {
            height = clientRect.height;
          }
          return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: width,
            height: height
          };
        }
        function contains(parent, child) {
          var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

          if (parent.contains(child)) {
            return true;
          } // then fallback to custom implementation with Shadow DOM support
          else if (rootNode && isShadowRoot(rootNode)) {
            var next = child;
            do {
              if (next && parent.isSameNode(next)) {
                return true;
              } // $FlowFixMe[prop-missing]: need a better way to handle this...

              next = next.parentNode || next.host;
            } while (next);
          } // Give up, the result is false

          return false;
        }
        function getComputedStyle(element) {
          return getWindow(element).getComputedStyle(element);
        }
        function isTableElement(element) {
          return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
        }
        function getDocumentElement(element) {
          // $FlowFixMe[incompatible-return]: assume body is always available
          return ((isElement(element) ? element.ownerDocument :
          // $FlowFixMe[prop-missing]
          element.document) || window.document).documentElement;
        }
        function getParentNode(element) {
          if (getNodeName(element) === 'html') {
            return element;
          }
          return (
            // this is a quicker (but less type safe) way to save quite some bytes from the bundle
            // $FlowFixMe[incompatible-return]
            // $FlowFixMe[prop-missing]
            element.assignedSlot ||
            // step into the shadow DOM of the parent of a slotted node
            element.parentNode || (
            // DOM Element detected
            isShadowRoot(element) ? element.host : null) ||
            // ShadowRoot detected
            // $FlowFixMe[incompatible-call]: HTMLElement is a Node
            getDocumentElement(element) // fallback
          );
        }
        function getTrueOffsetParent(element) {
          if (!isHTMLElement(element) ||
          // https://github.com/popperjs/popper-core/issues/837
          getComputedStyle(element).position === 'fixed') {
            return null;
          }
          return element.offsetParent;
        } // `.offsetParent` reports `null` for fixed elements, while absolute elements
        // return the containing block

        function getContainingBlock(element) {
          var isFirefox = /firefox/i.test(getUAString());
          var isIE = /Trident/i.test(getUAString());
          if (isIE && isHTMLElement(element)) {
            // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
            var elementCss = getComputedStyle(element);
            if (elementCss.position === 'fixed') {
              return null;
            }
          }
          var currentNode = getParentNode(element);
          if (isShadowRoot(currentNode)) {
            currentNode = currentNode.host;
          }
          while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
            var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
            // create a containing block.
            // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

            if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
              return currentNode;
            } else {
              currentNode = currentNode.parentNode;
            }
          }
          return null;
        } // Gets the closest ancestor positioned element. Handles some edge cases,
        // such as table ancestors and cross browser bugs.

        function getOffsetParent(element) {
          var window = getWindow(element);
          var offsetParent = getTrueOffsetParent(element);
          while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
            offsetParent = getTrueOffsetParent(offsetParent);
          }
          if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
            return window;
          }
          return offsetParent || getContainingBlock(element) || window;
        }
        function getMainAxisFromPlacement(placement) {
          return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
        }
        function within(min$1, value, max$1) {
          return max(min$1, min(value, max$1));
        }
        function withinMaxClamp(min, value, max) {
          var v = within(min, value, max);
          return v > max ? max : v;
        }
        function getFreshSideObject() {
          return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
        }
        function mergePaddingObject(paddingObject) {
          return Object.assign({}, getFreshSideObject(), paddingObject);
        }
        function expandToHashMap(value, keys) {
          return keys.reduce(function (hashMap, key) {
            hashMap[key] = value;
            return hashMap;
          }, {});
        }
        var toPaddingObject = function toPaddingObject(padding, state) {
          padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
            placement: state.placement
          })) : padding;
          return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
        };
        function arrow(_ref) {
          var _state$modifiersData$;
          var state = _ref.state,
            name = _ref.name,
            options = _ref.options;
          var arrowElement = state.elements.arrow;
          var popperOffsets = state.modifiersData.popperOffsets;
          var basePlacement = getBasePlacement(state.placement);
          var axis = getMainAxisFromPlacement(basePlacement);
          var isVertical = [left, right].indexOf(basePlacement) >= 0;
          var len = isVertical ? 'height' : 'width';
          if (!arrowElement || !popperOffsets) {
            return;
          }
          var paddingObject = toPaddingObject(options.padding, state);
          var arrowRect = getLayoutRect(arrowElement);
          var minProp = axis === 'y' ? top : left;
          var maxProp = axis === 'y' ? bottom : right;
          var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
          var startDiff = popperOffsets[axis] - state.rects.reference[axis];
          var arrowOffsetParent = getOffsetParent(arrowElement);
          var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
          var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
          // outside of the popper bounds

          var min = paddingObject[minProp];
          var max = clientSize - arrowRect[len] - paddingObject[maxProp];
          var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
          var offset = within(min, center, max); // Prevents breaking syntax highlighting...

          var axisProp = axis;
          state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
        }
        function effect$1(_ref2) {
          var state = _ref2.state,
            options = _ref2.options;
          var _options$element = options.element,
            arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
          if (arrowElement == null) {
            return;
          } // CSS selector

          if (typeof arrowElement === 'string') {
            arrowElement = state.elements.popper.querySelector(arrowElement);
            if (!arrowElement) {
              return;
            }
          }
          if (!contains(state.elements.popper, arrowElement)) {
            return;
          }
          state.elements.arrow = arrowElement;
        } // eslint-disable-next-line import/no-unused-modules

        var arrow$1 = {
          name: 'arrow',
          enabled: true,
          phase: 'main',
          fn: arrow,
          effect: effect$1,
          requires: ['popperOffsets'],
          requiresIfExists: ['preventOverflow']
        };
        function getVariation(placement) {
          return placement.split('-')[1];
        }
        var unsetSides = {
          top: 'auto',
          right: 'auto',
          bottom: 'auto',
          left: 'auto'
        }; // Round the offsets to the nearest suitable subpixel based on the DPR.
        // Zooming can change the DPR, but it seems to report a value that will
        // cleanly divide the values into the appropriate subpixels.

        function roundOffsetsByDPR(_ref, win) {
          var x = _ref.x,
            y = _ref.y;
          var dpr = win.devicePixelRatio || 1;
          return {
            x: round(x * dpr) / dpr || 0,
            y: round(y * dpr) / dpr || 0
          };
        }
        function mapToStyles(_ref2) {
          var _Object$assign2;
          var popper = _ref2.popper,
            popperRect = _ref2.popperRect,
            placement = _ref2.placement,
            variation = _ref2.variation,
            offsets = _ref2.offsets,
            position = _ref2.position,
            gpuAcceleration = _ref2.gpuAcceleration,
            adaptive = _ref2.adaptive,
            roundOffsets = _ref2.roundOffsets,
            isFixed = _ref2.isFixed;
          var _offsets$x = offsets.x,
            x = _offsets$x === void 0 ? 0 : _offsets$x,
            _offsets$y = offsets.y,
            y = _offsets$y === void 0 ? 0 : _offsets$y;
          var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
            x: x,
            y: y
          }) : {
            x: x,
            y: y
          };
          x = _ref3.x;
          y = _ref3.y;
          var hasX = offsets.hasOwnProperty('x');
          var hasY = offsets.hasOwnProperty('y');
          var sideX = left;
          var sideY = top;
          var win = window;
          if (adaptive) {
            var offsetParent = getOffsetParent(popper);
            var heightProp = 'clientHeight';
            var widthProp = 'clientWidth';
            if (offsetParent === getWindow(popper)) {
              offsetParent = getDocumentElement(popper);
              if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
                heightProp = 'scrollHeight';
                widthProp = 'scrollWidth';
              }
            } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

            offsetParent = offsetParent;
            if (placement === top || (placement === left || placement === right) && variation === end) {
              sideY = bottom;
              var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
              // $FlowFixMe[prop-missing]
              offsetParent[heightProp];
              y -= offsetY - popperRect.height;
              y *= gpuAcceleration ? 1 : -1;
            }
            if (placement === left || (placement === top || placement === bottom) && variation === end) {
              sideX = right;
              var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
              // $FlowFixMe[prop-missing]
              offsetParent[widthProp];
              x -= offsetX - popperRect.width;
              x *= gpuAcceleration ? 1 : -1;
            }
          }
          var commonStyles = Object.assign({
            position: position
          }, adaptive && unsetSides);
          var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
            x: x,
            y: y
          }, getWindow(popper)) : {
            x: x,
            y: y
          };
          x = _ref4.x;
          y = _ref4.y;
          if (gpuAcceleration) {
            var _Object$assign;
            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
          }
          return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
        }
        function computeStyles(_ref5) {
          var state = _ref5.state,
            options = _ref5.options;
          var _options$gpuAccelerat = options.gpuAcceleration,
            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
            _options$adaptive = options.adaptive,
            adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
            _options$roundOffsets = options.roundOffsets,
            roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
          var commonStyles = {
            placement: getBasePlacement(state.placement),
            variation: getVariation(state.placement),
            popper: state.elements.popper,
            popperRect: state.rects.popper,
            gpuAcceleration: gpuAcceleration,
            isFixed: state.options.strategy === 'fixed'
          };
          if (state.modifiersData.popperOffsets != null) {
            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.popperOffsets,
              position: state.options.strategy,
              adaptive: adaptive,
              roundOffsets: roundOffsets
            })));
          }
          if (state.modifiersData.arrow != null) {
            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.arrow,
              position: 'absolute',
              adaptive: false,
              roundOffsets: roundOffsets
            })));
          }
          state.attributes.popper = Object.assign({}, state.attributes.popper, {
            'data-popper-placement': state.placement
          });
        } // eslint-disable-next-line import/no-unused-modules

        var computeStyles$1 = {
          name: 'computeStyles',
          enabled: true,
          phase: 'beforeWrite',
          fn: computeStyles,
          data: {}
        };
        var passive = {
          passive: true
        };
        function effect(_ref) {
          var state = _ref.state,
            instance = _ref.instance,
            options = _ref.options;
          var _options$scroll = options.scroll,
            scroll = _options$scroll === void 0 ? true : _options$scroll,
            _options$resize = options.resize,
            resize = _options$resize === void 0 ? true : _options$resize;
          var window = getWindow(state.elements.popper);
          var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
          if (scroll) {
            scrollParents.forEach(function (scrollParent) {
              scrollParent.addEventListener('scroll', instance.update, passive);
            });
          }
          if (resize) {
            window.addEventListener('resize', instance.update, passive);
          }
          return function () {
            if (scroll) {
              scrollParents.forEach(function (scrollParent) {
                scrollParent.removeEventListener('scroll', instance.update, passive);
              });
            }
            if (resize) {
              window.removeEventListener('resize', instance.update, passive);
            }
          };
        } // eslint-disable-next-line import/no-unused-modules

        var eventListeners = {
          name: 'eventListeners',
          enabled: true,
          phase: 'write',
          fn: function fn() {},
          effect: effect,
          data: {}
        };
        var hash$1 = {
          left: 'right',
          right: 'left',
          bottom: 'top',
          top: 'bottom'
        };
        function getOppositePlacement(placement) {
          return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash$1[matched];
          });
        }
        var hash = {
          start: 'end',
          end: 'start'
        };
        function getOppositeVariationPlacement(placement) {
          return placement.replace(/start|end/g, function (matched) {
            return hash[matched];
          });
        }
        function getWindowScroll(node) {
          var win = getWindow(node);
          var scrollLeft = win.pageXOffset;
          var scrollTop = win.pageYOffset;
          return {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop
          };
        }
        function getWindowScrollBarX(element) {
          // If <html> has a CSS width greater than the viewport, then this will be
          // incorrect for RTL.
          // Popper 1 is broken in this case and never had a bug report so let's assume
          // it's not an issue. I don't think anyone ever specifies width on <html>
          // anyway.
          // Browsers where the left scrollbar doesn't cause an issue report `0` for
          // this (e.g. Edge 2019, IE11, Safari)
          return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
        }
        function getViewportRect(element, strategy) {
          var win = getWindow(element);
          var html = getDocumentElement(element);
          var visualViewport = win.visualViewport;
          var width = html.clientWidth;
          var height = html.clientHeight;
          var x = 0;
          var y = 0;
          if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            var layoutViewport = isLayoutViewport();
            if (layoutViewport || !layoutViewport && strategy === 'fixed') {
              x = visualViewport.offsetLeft;
              y = visualViewport.offsetTop;
            }
          }
          return {
            width: width,
            height: height,
            x: x + getWindowScrollBarX(element),
            y: y
          };
        }

        // of the `<html>` and `<body>` rect bounds if horizontally scrollable

        function getDocumentRect(element) {
          var _element$ownerDocumen;
          var html = getDocumentElement(element);
          var winScroll = getWindowScroll(element);
          var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
          var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
          var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
          var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
          var y = -winScroll.scrollTop;
          if (getComputedStyle(body || html).direction === 'rtl') {
            x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
          }
          return {
            width: width,
            height: height,
            x: x,
            y: y
          };
        }
        function isScrollParent(element) {
          // Firefox wants us to check `-x` and `-y` variations as well
          var _getComputedStyle = getComputedStyle(element),
            overflow = _getComputedStyle.overflow,
            overflowX = _getComputedStyle.overflowX,
            overflowY = _getComputedStyle.overflowY;
          return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function getScrollParent(node) {
          if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
            // $FlowFixMe[incompatible-return]: assume body is always available
            return node.ownerDocument.body;
          }
          if (isHTMLElement(node) && isScrollParent(node)) {
            return node;
          }
          return getScrollParent(getParentNode(node));
        }

        /*
        given a DOM element, return the list of all scroll parents, up the list of ancesors
        until we get to the top window object. This list is what we attach scroll listeners
        to, because if any of these parent elements scroll, we'll need to re-calculate the
        reference element's position.
        */

        function listScrollParents(element, list) {
          var _element$ownerDocumen;
          if (list === void 0) {
            list = [];
          }
          var scrollParent = getScrollParent(element);
          var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
          var win = getWindow(scrollParent);
          var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
          var updatedList = list.concat(target);
          return isBody ? updatedList :
          // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
          updatedList.concat(listScrollParents(getParentNode(target)));
        }
        function rectToClientRect(rect) {
          return Object.assign({}, rect, {
            left: rect.x,
            top: rect.y,
            right: rect.x + rect.width,
            bottom: rect.y + rect.height
          });
        }
        function getInnerBoundingClientRect(element, strategy) {
          var rect = getBoundingClientRect(element, false, strategy === 'fixed');
          rect.top = rect.top + element.clientTop;
          rect.left = rect.left + element.clientLeft;
          rect.bottom = rect.top + element.clientHeight;
          rect.right = rect.left + element.clientWidth;
          rect.width = element.clientWidth;
          rect.height = element.clientHeight;
          rect.x = rect.left;
          rect.y = rect.top;
          return rect;
        }
        function getClientRectFromMixedType(element, clippingParent, strategy) {
          return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
        } // A "clipping parent" is an overflowable container with the characteristic of
        // clipping (or hiding) overflowing elements with a position different from
        // `initial`

        function getClippingParents(element) {
          var clippingParents = listScrollParents(getParentNode(element));
          var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
          var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
          if (!isElement(clipperElement)) {
            return [];
          } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

          return clippingParents.filter(function (clippingParent) {
            return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
          });
        } // Gets the maximum area that the element is visible in due to any number of
        // clipping parents

        function getClippingRect(element, boundary, rootBoundary, strategy) {
          var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
          var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
          var firstClippingParent = clippingParents[0];
          var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
            var rect = getClientRectFromMixedType(element, clippingParent, strategy);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
          }, getClientRectFromMixedType(element, firstClippingParent, strategy));
          clippingRect.width = clippingRect.right - clippingRect.left;
          clippingRect.height = clippingRect.bottom - clippingRect.top;
          clippingRect.x = clippingRect.left;
          clippingRect.y = clippingRect.top;
          return clippingRect;
        }
        function computeOffsets(_ref) {
          var reference = _ref.reference,
            element = _ref.element,
            placement = _ref.placement;
          var basePlacement = placement ? getBasePlacement(placement) : null;
          var variation = placement ? getVariation(placement) : null;
          var commonX = reference.x + reference.width / 2 - element.width / 2;
          var commonY = reference.y + reference.height / 2 - element.height / 2;
          var offsets;
          switch (basePlacement) {
            case top:
              offsets = {
                x: commonX,
                y: reference.y - element.height
              };
              break;
            case bottom:
              offsets = {
                x: commonX,
                y: reference.y + reference.height
              };
              break;
            case right:
              offsets = {
                x: reference.x + reference.width,
                y: commonY
              };
              break;
            case left:
              offsets = {
                x: reference.x - element.width,
                y: commonY
              };
              break;
            default:
              offsets = {
                x: reference.x,
                y: reference.y
              };
          }
          var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
          if (mainAxis != null) {
            var len = mainAxis === 'y' ? 'height' : 'width';
            switch (variation) {
              case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
              case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            }
          }
          return offsets;
        }
        function detectOverflow(state, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options,
            _options$placement = _options.placement,
            placement = _options$placement === void 0 ? state.placement : _options$placement,
            _options$strategy = _options.strategy,
            strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
            _options$boundary = _options.boundary,
            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
            _options$rootBoundary = _options.rootBoundary,
            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
            _options$elementConte = _options.elementContext,
            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
            _options$altBoundary = _options.altBoundary,
            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
            _options$padding = _options.padding,
            padding = _options$padding === void 0 ? 0 : _options$padding;
          var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
          var altContext = elementContext === popper ? reference : popper;
          var popperRect = state.rects.popper;
          var element = state.elements[altBoundary ? altContext : elementContext];
          var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
          var referenceClientRect = getBoundingClientRect(state.elements.reference);
          var popperOffsets = computeOffsets({
            reference: referenceClientRect,
            element: popperRect,
            placement: placement
          });
          var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
          var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
          // 0 or negative = within the clipping rect

          var overflowOffsets = {
            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
          };
          var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

          if (elementContext === popper && offsetData) {
            var offset = offsetData[placement];
            Object.keys(overflowOffsets).forEach(function (key) {
              var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
              var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
              overflowOffsets[key] += offset[axis] * multiply;
            });
          }
          return overflowOffsets;
        }
        function computeAutoPlacement(state, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options,
            placement = _options.placement,
            boundary = _options.boundary,
            rootBoundary = _options.rootBoundary,
            padding = _options.padding,
            flipVariations = _options.flipVariations,
            _options$allowedAutoP = _options.allowedAutoPlacements,
            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
          var variation = getVariation(placement);
          var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
            return getVariation(placement) === variation;
          }) : basePlacements;
          var allowedPlacements = placements$1.filter(function (placement) {
            return allowedAutoPlacements.indexOf(placement) >= 0;
          });
          if (allowedPlacements.length === 0) {
            allowedPlacements = placements$1;
          } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

          var overflows = allowedPlacements.reduce(function (acc, placement) {
            acc[placement] = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding
            })[getBasePlacement(placement)];
            return acc;
          }, {});
          return Object.keys(overflows).sort(function (a, b) {
            return overflows[a] - overflows[b];
          });
        }
        function getExpandedFallbackPlacements(placement) {
          if (getBasePlacement(placement) === auto) {
            return [];
          }
          var oppositePlacement = getOppositePlacement(placement);
          return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
        }
        function flip(_ref) {
          var state = _ref.state,
            options = _ref.options,
            name = _ref.name;
          if (state.modifiersData[name]._skip) {
            return;
          }
          var _options$mainAxis = options.mainAxis,
            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
            _options$altAxis = options.altAxis,
            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
            specifiedFallbackPlacements = options.fallbackPlacements,
            padding = options.padding,
            boundary = options.boundary,
            rootBoundary = options.rootBoundary,
            altBoundary = options.altBoundary,
            _options$flipVariatio = options.flipVariations,
            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
            allowedAutoPlacements = options.allowedAutoPlacements;
          var preferredPlacement = state.options.placement;
          var basePlacement = getBasePlacement(preferredPlacement);
          var isBasePlacement = basePlacement === preferredPlacement;
          var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
          var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
            return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding,
              flipVariations: flipVariations,
              allowedAutoPlacements: allowedAutoPlacements
            }) : placement);
          }, []);
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var checksMap = new Map();
          var makeFallbackChecks = true;
          var firstFittingPlacement = placements[0];
          for (var i = 0; i < placements.length; i++) {
            var placement = placements[i];
            var _basePlacement = getBasePlacement(placement);
            var isStartVariation = getVariation(placement) === start;
            var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
            var len = isVertical ? 'width' : 'height';
            var overflow = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              altBoundary: altBoundary,
              padding: padding
            });
            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
            if (referenceRect[len] > popperRect[len]) {
              mainVariationSide = getOppositePlacement(mainVariationSide);
            }
            var altVariationSide = getOppositePlacement(mainVariationSide);
            var checks = [];
            if (checkMainAxis) {
              checks.push(overflow[_basePlacement] <= 0);
            }
            if (checkAltAxis) {
              checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
            }
            if (checks.every(function (check) {
              return check;
            })) {
              firstFittingPlacement = placement;
              makeFallbackChecks = false;
              break;
            }
            checksMap.set(placement, checks);
          }
          if (makeFallbackChecks) {
            // `2` may be desired in some cases  research later
            var numberOfChecks = flipVariations ? 3 : 1;
            var _loop = function _loop(_i) {
              var fittingPlacement = placements.find(function (placement) {
                var checks = checksMap.get(placement);
                if (checks) {
                  return checks.slice(0, _i).every(function (check) {
                    return check;
                  });
                }
              });
              if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
              }
            };
            for (var _i = numberOfChecks; _i > 0; _i--) {
              var _ret = _loop(_i);
              if (_ret === "break") break;
            }
          }
          if (state.placement !== firstFittingPlacement) {
            state.modifiersData[name]._skip = true;
            state.placement = firstFittingPlacement;
            state.reset = true;
          }
        } // eslint-disable-next-line import/no-unused-modules

        var flip$1 = {
          name: 'flip',
          enabled: true,
          phase: 'main',
          fn: flip,
          requiresIfExists: ['offset'],
          data: {
            _skip: false
          }
        };
        function getSideOffsets(overflow, rect, preventedOffsets) {
          if (preventedOffsets === void 0) {
            preventedOffsets = {
              x: 0,
              y: 0
            };
          }
          return {
            top: overflow.top - rect.height - preventedOffsets.y,
            right: overflow.right - rect.width + preventedOffsets.x,
            bottom: overflow.bottom - rect.height + preventedOffsets.y,
            left: overflow.left - rect.width - preventedOffsets.x
          };
        }
        function isAnySideFullyClipped(overflow) {
          return [top, right, bottom, left].some(function (side) {
            return overflow[side] >= 0;
          });
        }
        function hide(_ref) {
          var state = _ref.state,
            name = _ref.name;
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var preventedOffsets = state.modifiersData.preventOverflow;
          var referenceOverflow = detectOverflow(state, {
            elementContext: 'reference'
          });
          var popperAltOverflow = detectOverflow(state, {
            altBoundary: true
          });
          var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
          var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
          var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
          var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
          state.modifiersData[name] = {
            referenceClippingOffsets: referenceClippingOffsets,
            popperEscapeOffsets: popperEscapeOffsets,
            isReferenceHidden: isReferenceHidden,
            hasPopperEscaped: hasPopperEscaped
          };
          state.attributes.popper = Object.assign({}, state.attributes.popper, {
            'data-popper-reference-hidden': isReferenceHidden,
            'data-popper-escaped': hasPopperEscaped
          });
        } // eslint-disable-next-line import/no-unused-modules

        var hide$1 = {
          name: 'hide',
          enabled: true,
          phase: 'main',
          requiresIfExists: ['preventOverflow'],
          fn: hide
        };
        function distanceAndSkiddingToXY(placement, rects, offset) {
          var basePlacement = getBasePlacement(placement);
          var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
          var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
              placement: placement
            })) : offset,
            skidding = _ref[0],
            distance = _ref[1];
          skidding = skidding || 0;
          distance = (distance || 0) * invertDistance;
          return [left, right].indexOf(basePlacement) >= 0 ? {
            x: distance,
            y: skidding
          } : {
            x: skidding,
            y: distance
          };
        }
        function offset(_ref2) {
          var state = _ref2.state,
            options = _ref2.options,
            name = _ref2.name;
          var _options$offset = options.offset,
            offset = _options$offset === void 0 ? [0, 0] : _options$offset;
          var data = placements.reduce(function (acc, placement) {
            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
            return acc;
          }, {});
          var _data$state$placement = data[state.placement],
            x = _data$state$placement.x,
            y = _data$state$placement.y;
          if (state.modifiersData.popperOffsets != null) {
            state.modifiersData.popperOffsets.x += x;
            state.modifiersData.popperOffsets.y += y;
          }
          state.modifiersData[name] = data;
        } // eslint-disable-next-line import/no-unused-modules

        var offset$1 = {
          name: 'offset',
          enabled: true,
          phase: 'main',
          requires: ['popperOffsets'],
          fn: offset
        };
        function popperOffsets(_ref) {
          var state = _ref.state,
            name = _ref.name;
          // Offsets are the actual position the popper needs to have to be
          // properly positioned near its reference element
          // This is the most basic placement, and will be adjusted by
          // the modifiers in the next step
          state.modifiersData[name] = computeOffsets({
            reference: state.rects.reference,
            element: state.rects.popper,
            placement: state.placement
          });
        } // eslint-disable-next-line import/no-unused-modules

        var popperOffsets$1 = {
          name: 'popperOffsets',
          enabled: true,
          phase: 'read',
          fn: popperOffsets,
          data: {}
        };
        function getAltAxis(axis) {
          return axis === 'x' ? 'y' : 'x';
        }
        function preventOverflow(_ref) {
          var state = _ref.state,
            options = _ref.options,
            name = _ref.name;
          var _options$mainAxis = options.mainAxis,
            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
            _options$altAxis = options.altAxis,
            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
            boundary = options.boundary,
            rootBoundary = options.rootBoundary,
            altBoundary = options.altBoundary,
            padding = options.padding,
            _options$tether = options.tether,
            tether = _options$tether === void 0 ? true : _options$tether,
            _options$tetherOffset = options.tetherOffset,
            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
          var overflow = detectOverflow(state, {
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            altBoundary: altBoundary
          });
          var basePlacement = getBasePlacement(state.placement);
          var variation = getVariation(state.placement);
          var isBasePlacement = !variation;
          var mainAxis = getMainAxisFromPlacement(basePlacement);
          var altAxis = getAltAxis(mainAxis);
          var popperOffsets = state.modifiersData.popperOffsets;
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
            placement: state.placement
          })) : tetherOffset;
          var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
            mainAxis: tetherOffsetValue,
            altAxis: tetherOffsetValue
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, tetherOffsetValue);
          var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
          var data = {
            x: 0,
            y: 0
          };
          if (!popperOffsets) {
            return;
          }
          if (checkMainAxis) {
            var _offsetModifierState$;
            var mainSide = mainAxis === 'y' ? top : left;
            var altSide = mainAxis === 'y' ? bottom : right;
            var len = mainAxis === 'y' ? 'height' : 'width';
            var offset = popperOffsets[mainAxis];
            var min$1 = offset + overflow[mainSide];
            var max$1 = offset - overflow[altSide];
            var additive = tether ? -popperRect[len] / 2 : 0;
            var minLen = variation === start ? referenceRect[len] : popperRect[len];
            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
            // outside the reference bounds

            var arrowElement = state.elements.arrow;
            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
              width: 0,
              height: 0
            };
            var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
            var arrowPaddingMin = arrowPaddingObject[mainSide];
            var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
            // to include its full size in the calculation. If the reference is small
            // and near the edge of a boundary, the popper can overflow even if the
            // reference is not overflowing as well (e.g. virtual elements with no
            // width or height)

            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
            var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
            var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
            var tetherMax = offset + maxOffset - offsetModifierValue;
            var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
            popperOffsets[mainAxis] = preventedOffset;
            data[mainAxis] = preventedOffset - offset;
          }
          if (checkAltAxis) {
            var _offsetModifierState$2;
            var _mainSide = mainAxis === 'x' ? top : left;
            var _altSide = mainAxis === 'x' ? bottom : right;
            var _offset = popperOffsets[altAxis];
            var _len = altAxis === 'y' ? 'height' : 'width';
            var _min = _offset + overflow[_mainSide];
            var _max = _offset - overflow[_altSide];
            var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
            popperOffsets[altAxis] = _preventedOffset;
            data[altAxis] = _preventedOffset - _offset;
          }
          state.modifiersData[name] = data;
        } // eslint-disable-next-line import/no-unused-modules

        var preventOverflow$1 = {
          name: 'preventOverflow',
          enabled: true,
          phase: 'main',
          fn: preventOverflow,
          requiresIfExists: ['offset']
        };
        function getHTMLElementScroll(element) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
          };
        }
        function getNodeScroll(node) {
          if (node === getWindow(node) || !isHTMLElement(node)) {
            return getWindowScroll(node);
          } else {
            return getHTMLElementScroll(node);
          }
        }
        function isElementScaled(element) {
          var rect = element.getBoundingClientRect();
          var scaleX = round(rect.width) / element.offsetWidth || 1;
          var scaleY = round(rect.height) / element.offsetHeight || 1;
          return scaleX !== 1 || scaleY !== 1;
        } // Returns the composite rect of an element relative to its offsetParent.
        // Composite means it takes into account transforms as well as layout.

        function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
          if (isFixed === void 0) {
            isFixed = false;
          }
          var isOffsetParentAnElement = isHTMLElement(offsetParent);
          var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
          var documentElement = getDocumentElement(offsetParent);
          var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
          var scroll = {
            scrollLeft: 0,
            scrollTop: 0
          };
          var offsets = {
            x: 0,
            y: 0
          };
          if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' ||
            // https://github.com/popperjs/popper-core/issues/1078
            isScrollParent(documentElement)) {
              scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement(offsetParent)) {
              offsets = getBoundingClientRect(offsetParent, true);
              offsets.x += offsetParent.clientLeft;
              offsets.y += offsetParent.clientTop;
            } else if (documentElement) {
              offsets.x = getWindowScrollBarX(documentElement);
            }
          }
          return {
            x: rect.left + scroll.scrollLeft - offsets.x,
            y: rect.top + scroll.scrollTop - offsets.y,
            width: rect.width,
            height: rect.height
          };
        }
        function order(modifiers) {
          var map = new Map();
          var visited = new Set();
          var result = [];
          modifiers.forEach(function (modifier) {
            map.set(modifier.name, modifier);
          }); // On visiting object, check for its dependencies and visit them recursively

          function sort(modifier) {
            visited.add(modifier.name);
            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
            requires.forEach(function (dep) {
              if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) {
                  sort(depModifier);
                }
              }
            });
            result.push(modifier);
          }
          modifiers.forEach(function (modifier) {
            if (!visited.has(modifier.name)) {
              // check for visited object
              sort(modifier);
            }
          });
          return result;
        }
        function orderModifiers(modifiers) {
          // order based on dependencies
          var orderedModifiers = order(modifiers); // order based on phase

          return modifierPhases.reduce(function (acc, phase) {
            return acc.concat(orderedModifiers.filter(function (modifier) {
              return modifier.phase === phase;
            }));
          }, []);
        }
        function debounce(fn) {
          var pending;
          return function () {
            if (!pending) {
              pending = new Promise(function (resolve) {
                Promise.resolve().then(function () {
                  pending = undefined;
                  resolve(fn());
                });
              });
            }
            return pending;
          };
        }
        function mergeByName(modifiers) {
          var merged = modifiers.reduce(function (merged, current) {
            var existing = merged[current.name];
            merged[current.name] = existing ? Object.assign({}, existing, current, {
              options: Object.assign({}, existing.options, current.options),
              data: Object.assign({}, existing.data, current.data)
            }) : current;
            return merged;
          }, {}); // IE11 does not support Object.values

          return Object.keys(merged).map(function (key) {
            return merged[key];
          });
        }
        var DEFAULT_OPTIONS$1 = {
          placement: 'bottom',
          modifiers: [],
          strategy: 'absolute'
        };
        function areValidElements() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return !args.some(function (element) {
            return !(element && typeof element.getBoundingClientRect === 'function');
          });
        }
        function popperGenerator(generatorOptions) {
          if (generatorOptions === void 0) {
            generatorOptions = {};
          }
          var _generatorOptions = generatorOptions,
            _generatorOptions$def = _generatorOptions.defaultModifiers,
            defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
            _generatorOptions$def2 = _generatorOptions.defaultOptions,
            defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
          return function createPopper(reference, popper, options) {
            if (options === void 0) {
              options = defaultOptions;
            }
            var state = {
              placement: 'bottom',
              orderedModifiers: [],
              options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
              modifiersData: {},
              elements: {
                reference: reference,
                popper: popper
              },
              attributes: {},
              styles: {}
            };
            var effectCleanupFns = [];
            var isDestroyed = false;
            var instance = {
              state: state,
              setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                  reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                  popper: listScrollParents(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties

                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

                state.orderedModifiers = orderedModifiers.filter(function (m) {
                  return m.enabled;
                });
                runModifierEffects();
                return instance.update();
              },
              // Sync update  it will always be executed, even if not necessary. This
              // is useful for low frequency updates where sync behavior simplifies the
              // logic.
              // For high frequency updates (e.g. `resize` and `scroll` events), always
              // prefer the async Popper#update method
              forceUpdate: function forceUpdate() {
                if (isDestroyed) {
                  return;
                }
                var _state$elements = state.elements,
                  reference = _state$elements.reference,
                  popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore

                if (!areValidElements(reference, popper)) {
                  return;
                } // Store the reference and popper rects to be read by modifiers

                state.rects = {
                  reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
                  popper: getLayoutRect(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect

                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`

                state.orderedModifiers.forEach(function (modifier) {
                  return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                for (var index = 0; index < state.orderedModifiers.length; index++) {
                  if (state.reset === true) {
                    state.reset = false;
                    index = -1;
                    continue;
                  }
                  var _state$orderedModifie = state.orderedModifiers[index],
                    fn = _state$orderedModifie.fn,
                    _state$orderedModifie2 = _state$orderedModifie.options,
                    _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                    name = _state$orderedModifie.name;
                  if (typeof fn === 'function') {
                    state = fn({
                      state: state,
                      options: _options,
                      name: name,
                      instance: instance
                    }) || state;
                  }
                }
              },
              // Async and optimistically optimized update  it will not be executed if
              // not necessary (debounced to run at most once-per-tick)
              update: debounce(function () {
                return new Promise(function (resolve) {
                  instance.forceUpdate();
                  resolve(state);
                });
              }),
              destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
              }
            };
            if (!areValidElements(reference, popper)) {
              return instance;
            }
            instance.setOptions(options).then(function (state) {
              if (!isDestroyed && options.onFirstUpdate) {
                options.onFirstUpdate(state);
              }
            }); // Modifiers have the ability to execute arbitrary code before the first
            // update cycle runs. They will be executed in the same order as the update
            // cycle. This is useful when a modifier adds some persistent data that
            // other modifiers need to use, but the modifier is run after the dependent
            // one.

            function runModifierEffects() {
              state.orderedModifiers.forEach(function (_ref) {
                var name = _ref.name,
                  _ref$options = _ref.options,
                  options = _ref$options === void 0 ? {} : _ref$options,
                  effect = _ref.effect;
                if (typeof effect === 'function') {
                  var cleanupFn = effect({
                    state: state,
                    name: name,
                    instance: instance,
                    options: options
                  });
                  var noopFn = function noopFn() {};
                  effectCleanupFns.push(cleanupFn || noopFn);
                }
              });
            }
            function cleanupModifierEffects() {
              effectCleanupFns.forEach(function (fn) {
                return fn();
              });
              effectCleanupFns = [];
            }
            return instance;
          };
        }
        var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
        var createPopper = /*#__PURE__*/popperGenerator({
          defaultModifiers: defaultModifiers
        }); // eslint-disable-next-line import/no-unused-modules

        var toVar = function toVar(value, fallback) {
          return {
            var: value,
            varRef: fallback ? "var(".concat(value, ", ").concat(fallback, ")") : "var(".concat(value, ")")
          };
        };
        var cssVars = {
          arrowShadowColor: toVar("--popper-arrow-shadow-color"),
          arrowSize: toVar("--popper-arrow-size", "8px"),
          arrowSizeHalf: toVar("--popper-arrow-size-half"),
          arrowBg: toVar("--popper-arrow-bg"),
          transformOrigin: toVar("--popper-transform-origin"),
          arrowOffset: toVar("--popper-arrow-offset")
        };
        function getBoxShadow(placement) {
          if (placement.includes("top")) return "1px 1px 0px 0 var(--popper-arrow-shadow-color)";
          if (placement.includes("bottom")) return "-1px -1px 0px 0 var(--popper-arrow-shadow-color)";
          if (placement.includes("right")) return "-1px 1px 0px 0 var(--popper-arrow-shadow-color)";
          if (placement.includes("left")) return "1px -1px 0px 0 var(--popper-arrow-shadow-color)";
        }
        var transforms = {
          top: "bottom center",
          "top-start": "bottom left",
          "top-end": "bottom right",
          bottom: "top center",
          "bottom-start": "top left",
          "bottom-end": "top right",
          left: "right center",
          "left-start": "right top",
          "left-end": "right bottom",
          right: "left center",
          "right-start": "left top",
          "right-end": "left bottom"
        };
        var toTransformOrigin = function toTransformOrigin(placement) {
          return transforms[placement];
        };
        var defaultEventListeners = {
          scroll: true,
          resize: true
        };
        function getEventListenerOptions(value) {
          var eventListeners;
          if (_typeof2(value) === "object") {
            eventListeners = {
              enabled: true,
              options: _objectSpread3(_objectSpread3({}, defaultEventListeners), value)
            };
          } else {
            eventListeners = {
              enabled: value,
              options: defaultEventListeners
            };
          }
          return eventListeners;
        }
        var matchWidth = {
          name: "matchWidth",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function fn(_ref155) {
            var state = _ref155.state;
            state.styles.popper.width = "".concat(state.rects.reference.width, "px");
          },
          effect: function effect(_ref156) {
            var state = _ref156.state;
            return function () {
              var reference = state.elements.reference;
              state.elements.popper.style.width = "".concat(reference.offsetWidth, "px");
            };
          }
        };
        var transformOrigin = {
          name: "transformOrigin",
          enabled: true,
          phase: "write",
          fn: function fn(_ref157) {
            var state = _ref157.state;
            setTransformOrigin(state);
          },
          effect: function effect(_ref158) {
            var state = _ref158.state;
            return function () {
              setTransformOrigin(state);
            };
          }
        };
        var setTransformOrigin = function setTransformOrigin(state) {
          state.elements.popper.style.setProperty(cssVars.transformOrigin.var, toTransformOrigin(state.placement));
        };
        var positionArrow = {
          name: "positionArrow",
          enabled: true,
          phase: "afterWrite",
          fn: function fn(_ref159) {
            var state = _ref159.state;
            setArrowStyles(state);
          }
        };
        var setArrowStyles = function setArrowStyles(state) {
          var _state$elements2;
          if (!state.placement) return;
          var overrides = getArrowStyle$1(state.placement);
          if ((_state$elements2 = state.elements) !== null && _state$elements2 !== void 0 && _state$elements2.arrow && overrides) {
            Object.assign(state.elements.arrow.style, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, overrides.property, overrides.value), "width", cssVars.arrowSize.varRef), "height", cssVars.arrowSize.varRef), "zIndex", -1));
            var _vars = _defineProperty2(_defineProperty2({}, cssVars.arrowSizeHalf.var, "calc(".concat(cssVars.arrowSize.varRef, " / 2 - 1px)")), cssVars.arrowOffset.var, "calc(".concat(cssVars.arrowSizeHalf.varRef, " * -1)"));
            for (var property in _vars) {
              state.elements.arrow.style.setProperty(property, _vars[property]);
            }
          }
        };
        var getArrowStyle$1 = function getArrowStyle$1(placement) {
          if (placement.startsWith("top")) {
            return {
              property: "bottom",
              value: cssVars.arrowOffset.varRef
            };
          }
          if (placement.startsWith("bottom")) {
            return {
              property: "top",
              value: cssVars.arrowOffset.varRef
            };
          }
          if (placement.startsWith("left")) {
            return {
              property: "right",
              value: cssVars.arrowOffset.varRef
            };
          }
          if (placement.startsWith("right")) {
            return {
              property: "left",
              value: cssVars.arrowOffset.varRef
            };
          }
        };
        var innerArrow = {
          name: "innerArrow",
          enabled: true,
          phase: "main",
          requires: ["arrow"],
          fn: function fn(_ref160) {
            var state = _ref160.state;
            setInnerArrowStyles(state);
          },
          effect: function effect(_ref161) {
            var state = _ref161.state;
            return function () {
              setInnerArrowStyles(state);
            };
          }
        };
        var setInnerArrowStyles = function setInnerArrowStyles(state) {
          if (!state.elements.arrow) return;
          var inner = state.elements.arrow.querySelector("[data-popper-arrow-inner]");
          if (!inner) return;
          var boxShadow = getBoxShadow(state.placement);
          if (boxShadow) {
            inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
          }
          Object.assign(inner.style, {
            transform: "rotate(45deg)",
            background: cssVars.arrowBg.varRef,
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            position: "absolute",
            zIndex: "inherit",
            boxShadow: "var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))"
          });
        };
        var logicals = {
          "start-start": {
            ltr: "left-start",
            rtl: "right-start"
          },
          "start-end": {
            ltr: "left-end",
            rtl: "right-end"
          },
          "end-start": {
            ltr: "right-start",
            rtl: "left-start"
          },
          "end-end": {
            ltr: "right-end",
            rtl: "left-end"
          },
          start: {
            ltr: "left",
            rtl: "right"
          },
          end: {
            ltr: "right",
            rtl: "left"
          }
        };
        var opposites = {
          "auto-start": "auto-end",
          "auto-end": "auto-start",
          "top-start": "top-end",
          "top-end": "top-start",
          "bottom-start": "bottom-end",
          "bottom-end": "bottom-start"
        };
        function getPopperPlacement(placement) {
          var _logicals$placement, _opposites$placement;
          var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ltr";
          var value = ((_logicals$placement = logicals[placement]) === null || _logicals$placement === void 0 ? void 0 : _logicals$placement[dir]) || placement;
          if (dir === "ltr") return value;
          return (_opposites$placement = opposites[placement]) !== null && _opposites$placement !== void 0 ? _opposites$placement : value;
        }
        function usePopper() {
          var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _props$enabled = props.enabled,
            enabled = _props$enabled === void 0 ? true : _props$enabled,
            modifiers = props.modifiers,
            _props$placement2 = props.placement,
            placementProp = _props$placement2 === void 0 ? "bottom" : _props$placement2,
            _props$strategy = props.strategy,
            strategy = _props$strategy === void 0 ? "absolute" : _props$strategy,
            _props$arrowPadding = props.arrowPadding,
            arrowPadding = _props$arrowPadding === void 0 ? 8 : _props$arrowPadding,
            _props$eventListeners = props.eventListeners,
            eventListeners = _props$eventListeners === void 0 ? true : _props$eventListeners,
            offset = props.offset,
            _props$gutter = props.gutter,
            gutter = _props$gutter === void 0 ? 8 : _props$gutter,
            _props$flip = props.flip,
            flip = _props$flip === void 0 ? true : _props$flip,
            _props$boundary = props.boundary,
            boundary = _props$boundary === void 0 ? "clippingParents" : _props$boundary,
            _props$preventOverflo = props.preventOverflow,
            preventOverflow = _props$preventOverflo === void 0 ? true : _props$preventOverflo,
            matchWidth$1 = props.matchWidth,
            _props$direction = props.direction,
            direction = _props$direction === void 0 ? "ltr" : _props$direction;
          var reference = reactExports.useRef(null);
          var popper = reactExports.useRef(null);
          var instance = reactExports.useRef(null);
          var placement = getPopperPlacement(placementProp, direction);
          var cleanup = reactExports.useRef(function () {});
          var setupPopper = reactExports.useCallback(function () {
            var _cleanup$current;
            if (!enabled || !reference.current || !popper.current) return;
            (_cleanup$current = cleanup.current) === null || _cleanup$current === void 0 || _cleanup$current.call(cleanup);
            instance.current = createPopper(reference.current, popper.current, {
              placement: placement,
              modifiers: [innerArrow, positionArrow, transformOrigin, _objectSpread3(_objectSpread3({}, matchWidth), {}, {
                enabled: !!matchWidth$1
              }), _objectSpread3({
                name: "eventListeners"
              }, getEventListenerOptions(eventListeners)), {
                name: "arrow",
                options: {
                  padding: arrowPadding
                }
              }, {
                name: "offset",
                options: {
                  offset: offset !== null && offset !== void 0 ? offset : [0, gutter]
                }
              }, {
                name: "flip",
                enabled: !!flip,
                options: {
                  padding: 8
                }
              }, {
                name: "preventOverflow",
                enabled: !!preventOverflow,
                options: {
                  boundary: boundary
                }
              }].concat(_toConsumableArray(modifiers !== null && modifiers !== void 0 ? modifiers : [])),
              strategy: strategy
            });
            instance.current.forceUpdate();
            cleanup.current = instance.current.destroy;
          }, [placement, enabled, modifiers, matchWidth$1, eventListeners, arrowPadding, offset, gutter, flip, preventOverflow, boundary, strategy]);
          reactExports.useEffect(function () {
            return function () {
              if (!reference.current && !popper.current) {
                var _instance$current;
                (_instance$current = instance.current) === null || _instance$current === void 0 || _instance$current.destroy();
                instance.current = null;
              }
            };
          }, []);
          var referenceRef = reactExports.useCallback(function (node) {
            reference.current = node;
            setupPopper();
          }, [setupPopper]);
          var getReferenceProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: mergeRefs(referenceRef, ref)
            });
          }, [referenceRef]);
          var popperRef = reactExports.useCallback(function (node) {
            popper.current = node;
            setupPopper();
          }, [setupPopper]);
          var getPopperProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: mergeRefs(popperRef, ref),
              style: _objectSpread3(_objectSpread3({}, props2.style), {}, {
                position: strategy,
                minWidth: matchWidth$1 ? void 0 : "max-content",
                inset: "0 auto auto 0"
              })
            });
          }, [strategy, popperRef, matchWidth$1]);
          var getArrowProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var size = props2.size,
              shadowColor = props2.shadowColor,
              bg = props2.bg,
              style = props2.style,
              rest = _objectWithoutProperties2(props2, _excluded58);
            return _objectSpread3(_objectSpread3({}, rest), {}, {
              ref: ref,
              "data-popper-arrow": "",
              style: getArrowStyle(props2)
            });
          }, []);
          var getArrowInnerProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: ref,
              "data-popper-arrow-inner": ""
            });
          }, []);
          return {
            update: function update() {
              var _instance$current2;
              (_instance$current2 = instance.current) === null || _instance$current2 === void 0 || _instance$current2.update();
            },
            forceUpdate: function forceUpdate() {
              var _instance$current3;
              (_instance$current3 = instance.current) === null || _instance$current3 === void 0 || _instance$current3.forceUpdate();
            },
            transformOrigin: cssVars.transformOrigin.varRef,
            referenceRef: referenceRef,
            popperRef: popperRef,
            getPopperProps: getPopperProps,
            getArrowProps: getArrowProps,
            getArrowInnerProps: getArrowInnerProps,
            getReferenceProps: getReferenceProps
          };
        }
        function getArrowStyle(props) {
          var size = props.size,
            shadowColor = props.shadowColor,
            bg = props.bg,
            style = props.style;
          var computedStyle = _objectSpread3(_objectSpread3({}, style), {}, {
            position: "absolute"
          });
          if (size) {
            computedStyle["--popper-arrow-size"] = size;
          }
          if (shadowColor) {
            computedStyle["--popper-arrow-shadow-color"] = shadowColor;
          }
          if (bg) {
            computedStyle["--popper-arrow-bg"] = bg;
          }
          return computedStyle;
        }
        function useEventListeners() {
          var listeners = reactExports.useRef(/* @__PURE__ */new Map());
          var currentListeners = listeners.current;
          var add = reactExports.useCallback(function (el, type, listener, options) {
            listeners.current.set(listener, {
              type: type,
              el: el,
              options: options
            });
            el.addEventListener(type, listener, options);
          }, []);
          var remove = reactExports.useCallback(function (el, type, listener, options) {
            el.removeEventListener(type, listener, options);
            listeners.current.delete(listener);
          }, []);
          reactExports.useEffect(function () {
            return function () {
              currentListeners.forEach(function (value, key) {
                remove(value.el, value.type, key, value.options);
              });
            };
          }, [remove, currentListeners]);
          return {
            add: add,
            remove: remove
          };
        }
        function isValidElement(event) {
          var _event$composedPath$, _event$composedPath;
          var target = (_event$composedPath$ = (_event$composedPath = event.composedPath) === null || _event$composedPath === void 0 || (_event$composedPath = _event$composedPath.call(event)) === null || _event$composedPath === void 0 ? void 0 : _event$composedPath[0]) !== null && _event$composedPath$ !== void 0 ? _event$composedPath$ : event.target;
          var tagName = target.tagName,
            isContentEditable = target.isContentEditable;
          return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable !== true;
        }
        function useClickable() {
          var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var htmlRef = props.ref,
            isDisabled = props.isDisabled,
            isFocusable = props.isFocusable,
            _props$clickOnEnter = props.clickOnEnter,
            clickOnEnter = _props$clickOnEnter === void 0 ? true : _props$clickOnEnter,
            _props$clickOnSpace = props.clickOnSpace,
            clickOnSpace = _props$clickOnSpace === void 0 ? true : _props$clickOnSpace,
            onMouseDown = props.onMouseDown,
            onMouseUp = props.onMouseUp,
            onClick = props.onClick,
            onKeyDown = props.onKeyDown,
            onKeyUp = props.onKeyUp,
            tabIndexProp = props.tabIndex,
            onMouseOver = props.onMouseOver,
            onMouseLeave = props.onMouseLeave,
            htmlProps = _objectWithoutProperties2(props, _excluded59);
          var _reactExports$useStat41 = reactExports.useState(true),
            _reactExports$useStat42 = _slicedToArray(_reactExports$useStat41, 2),
            isButton = _reactExports$useStat42[0],
            setIsButton = _reactExports$useStat42[1];
          var _reactExports$useStat43 = reactExports.useState(false),
            _reactExports$useStat44 = _slicedToArray(_reactExports$useStat43, 2),
            isPressed = _reactExports$useStat44[0],
            setIsPressed = _reactExports$useStat44[1];
          var listeners = useEventListeners();
          var refCallback = function refCallback(node) {
            if (!node) return;
            if (node.tagName !== "BUTTON") {
              setIsButton(false);
            }
          };
          var tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
          var trulyDisabled = isDisabled && !isFocusable;
          var handleClick = reactExports.useCallback(function (event) {
            if (isDisabled) {
              event.stopPropagation();
              event.preventDefault();
              return;
            }
            var self = event.currentTarget;
            self.focus();
            onClick === null || onClick === void 0 || onClick(event);
          }, [isDisabled, onClick]);
          var onDocumentKeyUp = reactExports.useCallback(function (e) {
            if (isPressed && isValidElement(e)) {
              e.preventDefault();
              e.stopPropagation();
              setIsPressed(false);
              listeners.remove(document, "keyup", onDocumentKeyUp, false);
            }
          }, [isPressed, listeners]);
          var handleKeyDown = reactExports.useCallback(function (event) {
            onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
            if (isDisabled || event.defaultPrevented || event.metaKey) {
              return;
            }
            if (!isValidElement(event.nativeEvent) || isButton) return;
            var shouldClickOnEnter = clickOnEnter && event.key === "Enter";
            var shouldClickOnSpace = clickOnSpace && event.key === " ";
            if (shouldClickOnSpace) {
              event.preventDefault();
              setIsPressed(true);
            }
            if (shouldClickOnEnter) {
              event.preventDefault();
              var _self = event.currentTarget;
              _self.click();
            }
            listeners.add(document, "keyup", onDocumentKeyUp, false);
          }, [isDisabled, isButton, onKeyDown, clickOnEnter, clickOnSpace, listeners, onDocumentKeyUp]);
          var handleKeyUp = reactExports.useCallback(function (event) {
            onKeyUp === null || onKeyUp === void 0 || onKeyUp(event);
            if (isDisabled || event.defaultPrevented || event.metaKey) return;
            if (!isValidElement(event.nativeEvent) || isButton) return;
            var shouldClickOnSpace = clickOnSpace && event.key === " ";
            if (shouldClickOnSpace) {
              event.preventDefault();
              setIsPressed(false);
              var _self2 = event.currentTarget;
              _self2.click();
            }
          }, [clickOnSpace, isButton, isDisabled, onKeyUp]);
          var onDocumentMouseUp = reactExports.useCallback(function (event) {
            if (event.button !== 0) return;
            setIsPressed(false);
            listeners.remove(document, "mouseup", onDocumentMouseUp, false);
          }, [listeners]);
          var handleMouseDown = reactExports.useCallback(function (event) {
            if (event.button !== 0) return;
            if (isDisabled) {
              event.stopPropagation();
              event.preventDefault();
              return;
            }
            if (!isButton) {
              setIsPressed(true);
            }
            var target = event.currentTarget;
            target.focus({
              preventScroll: true
            });
            listeners.add(document, "mouseup", onDocumentMouseUp, false);
            onMouseDown === null || onMouseDown === void 0 || onMouseDown(event);
          }, [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp]);
          var handleMouseUp = reactExports.useCallback(function (event) {
            if (event.button !== 0) return;
            if (!isButton) {
              setIsPressed(false);
            }
            onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
          }, [onMouseUp, isButton]);
          var handleMouseOver = reactExports.useCallback(function (event) {
            if (isDisabled) {
              event.preventDefault();
              return;
            }
            onMouseOver === null || onMouseOver === void 0 || onMouseOver(event);
          }, [isDisabled, onMouseOver]);
          var handleMouseLeave = reactExports.useCallback(function (event) {
            if (isPressed) {
              event.preventDefault();
              setIsPressed(false);
            }
            onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave(event);
          }, [isPressed, onMouseLeave]);
          var ref = mergeRefs(htmlRef, refCallback);
          if (isButton) {
            return _objectSpread3(_objectSpread3({}, htmlProps), {}, {
              ref: ref,
              type: "button",
              "aria-disabled": trulyDisabled ? void 0 : isDisabled,
              disabled: trulyDisabled,
              onClick: handleClick,
              onMouseDown: onMouseDown,
              onMouseUp: onMouseUp,
              onKeyUp: onKeyUp,
              onKeyDown: onKeyDown,
              onMouseOver: onMouseOver,
              onMouseLeave: onMouseLeave
            });
          }
          return _objectSpread3(_objectSpread3({}, htmlProps), {}, {
            ref: ref,
            role: "button",
            "data-active": dataAttr(isPressed),
            "aria-disabled": isDisabled ? "true" : void 0,
            tabIndex: trulyDisabled ? void 0 : tabIndex,
            onClick: handleClick,
            onMouseDown: handleMouseDown,
            onMouseUp: handleMouseUp,
            onKeyUp: handleKeyUp,
            onKeyDown: handleKeyDown,
            onMouseOver: handleMouseOver,
            onMouseLeave: handleMouseLeave
          });
        }
        var getDefaultParent = function getDefaultParent(originalTarget) {
          if (typeof document === 'undefined') {
            return null;
          }
          var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
          return sampleTarget.ownerDocument.body;
        };
        var counterMap = new WeakMap();
        var uncontrolledNodes = new WeakMap();
        var markerMap = {};
        var lockCount = 0;
        var _unwrapHost = function unwrapHost(node) {
          return node && (node.host || _unwrapHost(node.parentNode));
        };
        var correctTargets = function correctTargets(parent, targets) {
          return targets.map(function (target) {
            if (parent.contains(target)) {
              return target;
            }
            var correctedTarget = _unwrapHost(target);
            if (correctedTarget && parent.contains(correctedTarget)) {
              return correctedTarget;
            }
            console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
            return null;
          }).filter(function (x) {
            return Boolean(x);
          });
        };
        /**
         * Marks everything except given node(or nodes) as aria-hidden
         * @param {Element | Element[]} originalTarget - elements to keep on the page
         * @param [parentNode] - top element, defaults to document.body
         * @param {String} [markerName] - a special attribute to mark every node
         * @param {String} [controlAttribute] - html Attribute to control
         * @return {Undo} undo command
         */
        var applyAttributeToOthers = function applyAttributeToOthers(originalTarget, parentNode, markerName, controlAttribute) {
          var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
          if (!markerMap[markerName]) {
            markerMap[markerName] = new WeakMap();
          }
          var markerCounter = markerMap[markerName];
          var hiddenNodes = [];
          var elementsToKeep = new Set();
          var elementsToStop = new Set(targets);
          var _keep = function keep(el) {
            if (!el || elementsToKeep.has(el)) {
              return;
            }
            elementsToKeep.add(el);
            _keep(el.parentNode);
          };
          targets.forEach(_keep);
          var _deep = function deep(parent) {
            if (!parent || elementsToStop.has(parent)) {
              return;
            }
            Array.prototype.forEach.call(parent.children, function (node) {
              if (elementsToKeep.has(node)) {
                _deep(node);
              } else {
                try {
                  var attr = node.getAttribute(controlAttribute);
                  var alreadyHidden = attr !== null && attr !== 'false';
                  var counterValue = (counterMap.get(node) || 0) + 1;
                  var markerValue = (markerCounter.get(node) || 0) + 1;
                  counterMap.set(node, counterValue);
                  markerCounter.set(node, markerValue);
                  hiddenNodes.push(node);
                  if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                  }
                  if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                  }
                  if (!alreadyHidden) {
                    node.setAttribute(controlAttribute, 'true');
                  }
                } catch (e) {
                  console.error('aria-hidden: cannot operate on ', node, e);
                }
              }
            });
          };
          _deep(parentNode);
          elementsToKeep.clear();
          lockCount++;
          return function () {
            hiddenNodes.forEach(function (node) {
              var counterValue = counterMap.get(node) - 1;
              var markerValue = markerCounter.get(node) - 1;
              counterMap.set(node, counterValue);
              markerCounter.set(node, markerValue);
              if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                  node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
              }
              if (!markerValue) {
                node.removeAttribute(markerName);
              }
            });
            lockCount--;
            if (!lockCount) {
              // clear
              counterMap = new WeakMap();
              counterMap = new WeakMap();
              uncontrolledNodes = new WeakMap();
              markerMap = {};
            }
          };
        };
        /**
         * Marks everything except given node(or nodes) as aria-hidden
         * @param {Element | Element[]} originalTarget - elements to keep on the page
         * @param [parentNode] - top element, defaults to document.body
         * @param {String} [markerName] - a special attribute to mark every node
         * @return {Undo} undo command
         */
        var hideOthers = function hideOthers(originalTarget, parentNode, markerName) {
          if (markerName === void 0) {
            markerName = 'data-aria-hidden';
          }
          var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
          var activeParentNode = getDefaultParent(originalTarget);
          if (!activeParentNode) {
            return function () {
              return null;
            };
          }
          // we should not hide aria-live elements - https://github.com/theKashey/aria-hidden/issues/10
          // and script elements, as they have no impact on accessibility.
          targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live], script')));
          return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
        };
        var __defProp = Object.defineProperty;
        var __defNormalProp = function __defNormalProp(obj, key, value) {
          return key in obj ? __defProp(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          }) : obj[key] = value;
        };
        var __publicField = function __publicField(obj, key, value) {
          __defNormalProp(obj, key + "", value);
          return value;
        };
        var ModalManager = /*#__PURE__*/function () {
          function ModalManager() {
            _classCallCheck(this, ModalManager);
            __publicField(this, "modals");
            this.modals = /* @__PURE__ */new Set();
          }
          return _createClass(ModalManager, [{
            key: "add",
            value: function add(modal) {
              this.modals.add(modal);
              return this.modals.size;
            }
          }, {
            key: "remove",
            value: function remove(modal) {
              this.modals.delete(modal);
            }
          }, {
            key: "isTopModal",
            value: function isTopModal(modal) {
              if (!modal) return false;
              var topModal = Array.from(this.modals)[this.modals.size - 1];
              return modal === topModal;
            }
          }]);
        }();
        var modalManager = new ModalManager();
        function useModalManager(ref, isOpen) {
          var _reactExports$useStat45 = reactExports.useState(0),
            _reactExports$useStat46 = _slicedToArray(_reactExports$useStat45, 2),
            index = _reactExports$useStat46[0],
            setIndex = _reactExports$useStat46[1];
          reactExports.useEffect(function () {
            var node = ref.current;
            if (!node) return;
            if (isOpen) {
              var index2 = modalManager.add(node);
              setIndex(index2);
            }
            return function () {
              modalManager.remove(node);
              setIndex(0);
            };
          }, [isOpen, ref]);
          return index;
        }
        function useModal(props) {
          var isOpen = props.isOpen,
            onClose = props.onClose,
            id = props.id,
            _props$closeOnOverlay = props.closeOnOverlayClick,
            closeOnOverlayClick = _props$closeOnOverlay === void 0 ? true : _props$closeOnOverlay,
            _props$closeOnEsc = props.closeOnEsc,
            closeOnEsc = _props$closeOnEsc === void 0 ? true : _props$closeOnEsc,
            _props$useInert = props.useInert,
            useInert = _props$useInert === void 0 ? true : _props$useInert,
            onOverlayClickProp = props.onOverlayClick,
            onEsc = props.onEsc;
          var dialogRef = reactExports.useRef(null);
          var overlayRef = reactExports.useRef(null);
          var _useIds = useIds(id, "chakra-modal", "chakra-modal--header", "chakra-modal--body"),
            _useIds2 = _slicedToArray(_useIds, 3),
            dialogId = _useIds2[0],
            headerId = _useIds2[1],
            bodyId = _useIds2[2];
          useAriaHidden(dialogRef, isOpen && useInert);
          var index = useModalManager(dialogRef, isOpen);
          var mouseDownTarget = reactExports.useRef(null);
          var onMouseDown = reactExports.useCallback(function (event) {
            mouseDownTarget.current = event.target;
          }, []);
          var onKeyDown = reactExports.useCallback(function (event) {
            if (event.key === "Escape") {
              event.stopPropagation();
              if (closeOnEsc) {
                onClose === null || onClose === void 0 || onClose();
              }
              onEsc === null || onEsc === void 0 || onEsc();
            }
          }, [closeOnEsc, onClose, onEsc]);
          var _reactExports$useStat47 = reactExports.useState(false),
            _reactExports$useStat48 = _slicedToArray(_reactExports$useStat47, 2),
            headerMounted = _reactExports$useStat48[0],
            setHeaderMounted = _reactExports$useStat48[1];
          var _reactExports$useStat49 = reactExports.useState(false),
            _reactExports$useStat50 = _slicedToArray(_reactExports$useStat49, 2),
            bodyMounted = _reactExports$useStat50[0],
            setBodyMounted = _reactExports$useStat50[1];
          var getDialogProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({
              role: "dialog"
            }, props2), {}, {
              ref: mergeRefs(ref, dialogRef),
              id: dialogId,
              tabIndex: -1,
              "aria-modal": true,
              "aria-labelledby": headerMounted ? headerId : void 0,
              "aria-describedby": bodyMounted ? bodyId : void 0,
              onClick: callAllHandlers(props2.onClick, function (event) {
                return event.stopPropagation();
              })
            });
          }, [bodyId, bodyMounted, dialogId, headerId, headerMounted]);
          var onOverlayClick = reactExports.useCallback(function (event) {
            event.stopPropagation();
            if (mouseDownTarget.current !== event.target) return;
            if (!modalManager.isTopModal(dialogRef.current)) return;
            if (closeOnOverlayClick) {
              onClose === null || onClose === void 0 || onClose();
            }
            onOverlayClickProp === null || onOverlayClickProp === void 0 || onOverlayClickProp();
          }, [onClose, closeOnOverlayClick, onOverlayClickProp]);
          var getDialogContainerProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: mergeRefs(ref, overlayRef),
              onClick: callAllHandlers(props2.onClick, onOverlayClick),
              onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
              onMouseDown: callAllHandlers(props2.onMouseDown, onMouseDown)
            });
          }, [onKeyDown, onMouseDown, onOverlayClick]);
          return {
            isOpen: isOpen,
            onClose: onClose,
            headerId: headerId,
            bodyId: bodyId,
            setBodyMounted: setBodyMounted,
            setHeaderMounted: setHeaderMounted,
            dialogRef: dialogRef,
            overlayRef: overlayRef,
            getDialogProps: getDialogProps,
            getDialogContainerProps: getDialogContainerProps,
            index: index
          };
        }
        function useAriaHidden(ref, shouldHide) {
          var currentElement = ref.current;
          reactExports.useEffect(function () {
            if (!ref.current || !shouldHide) return void 0;
            return hideOthers(ref.current);
          }, [shouldHide, ref, currentElement]);
        }
        function useIds(idProp) {
          for (var _len38 = arguments.length, prefixes = new Array(_len38 > 1 ? _len38 - 1 : 0), _key68 = 1; _key68 < _len38; _key68++) {
            prefixes[_key68 - 1] = arguments[_key68];
          }
          var reactId = reactExports.useId();
          var id = idProp || reactId;
          return reactExports.useMemo(function () {
            return prefixes.map(function (prefix) {
              return "".concat(prefix, "-").concat(id);
            });
          }, [id, prefixes]);
        }
        var _createContext23 = createContext({
            name: "ModalStylesContext",
            errorMessage: "useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<Modal />\" "
          }),
          _createContext24 = _slicedToArray(_createContext23, 2),
          ModalStylesProvider = _createContext24[0],
          useModalStyles = _createContext24[1];
        exports("h", useModalStyles);
        var _createContext25 = createContext({
            strict: true,
            name: "ModalContext",
            errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
          }),
          _createContext26 = _slicedToArray(_createContext25, 2),
          ModalContextProvider = _createContext26[0],
          useModalContext = _createContext26[1];
        exports("e", useModalContext);
        var Modal = exports("q", function (props) {
          var _props$lockFocusAcros;
          var modalProps = _objectSpread3(_objectSpread3({
            scrollBehavior: "outside",
            autoFocus: true,
            trapFocus: true,
            returnFocusOnClose: true,
            blockScrollOnMount: true,
            allowPinchZoom: false,
            preserveScrollBarGap: true,
            motionPreset: "scale"
          }, props), {}, {
            lockFocusAcrossFrames: (_props$lockFocusAcros = props.lockFocusAcrossFrames) !== null && _props$lockFocusAcros !== void 0 ? _props$lockFocusAcros : true
          });
          var portalProps = modalProps.portalProps,
            children = modalProps.children,
            autoFocus = modalProps.autoFocus,
            trapFocus = modalProps.trapFocus,
            initialFocusRef = modalProps.initialFocusRef,
            finalFocusRef = modalProps.finalFocusRef,
            returnFocusOnClose = modalProps.returnFocusOnClose,
            blockScrollOnMount = modalProps.blockScrollOnMount,
            allowPinchZoom = modalProps.allowPinchZoom,
            preserveScrollBarGap = modalProps.preserveScrollBarGap,
            motionPreset = modalProps.motionPreset,
            lockFocusAcrossFrames = modalProps.lockFocusAcrossFrames,
            animatePresenceProps = modalProps.animatePresenceProps,
            onCloseComplete = modalProps.onCloseComplete;
          var styles = useMultiStyleConfig("Modal", modalProps);
          var modal = useModal(modalProps);
          var context = _objectSpread3(_objectSpread3({}, modal), {}, {
            autoFocus: autoFocus,
            trapFocus: trapFocus,
            initialFocusRef: initialFocusRef,
            finalFocusRef: finalFocusRef,
            returnFocusOnClose: returnFocusOnClose,
            blockScrollOnMount: blockScrollOnMount,
            allowPinchZoom: allowPinchZoom,
            preserveScrollBarGap: preserveScrollBarGap,
            motionPreset: motionPreset,
            lockFocusAcrossFrames: lockFocusAcrossFrames
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(ModalContextProvider, {
            value: context,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ModalStylesProvider, {
              value: styles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(AnimatePresence, _objectSpread3(_objectSpread3({}, animatePresenceProps), {}, {
                onExitComplete: onCloseComplete,
                children: context.isOpen && /* @__PURE__ */jsxRuntimeExports.jsx(Portal, _objectSpread3(_objectSpread3({}, portalProps), {}, {
                  children: children
                }))
              }))
            })
          });
        });
        Modal.displayName = "Modal";
        var zeroRightClassName = 'right-scroll-bar-position';
        var fullWidthClassName = 'width-before-scroll-bar';
        var noScrollbarsClassName = 'with-scroll-bars-hidden';
        /**
         * Name of a CSS variable containing the amount of "hidden" scrollbar
         * ! might be undefined ! use will fallback!
         */
        var removedBarSizeVariable = '--removed-body-scroll-bar-size';
        var effectCar = createSidecarMedium();
        var nothing = function nothing() {
          return;
        };
        /**
         * Removes scrollbar from the page and contain the scroll within the Lock
         */
        var RemoveScroll = reactExports.forwardRef(function (props, parentRef) {
          var ref = reactExports.useRef(null);
          var _a = reactExports.useState({
              onScrollCapture: nothing,
              onWheelCapture: nothing,
              onTouchMoveCapture: nothing
            }),
            callbacks = _a[0],
            setCallbacks = _a[1];
          var forwardProps = props.forwardProps,
            children = props.children,
            className = props.className,
            removeScrollBar = props.removeScrollBar,
            enabled = props.enabled,
            shards = props.shards,
            sideCar = props.sideCar,
            noRelative = props.noRelative,
            noIsolation = props.noIsolation,
            inert = props.inert,
            allowPinchZoom = props.allowPinchZoom,
            _b = props.as,
            Container = _b === void 0 ? 'div' : _b,
            gapMode = props.gapMode,
            rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
          var SideCar = sideCar;
          var containerRef = useMergeRefs([ref, parentRef]);
          var containerProps = _assign(_assign({}, rest), callbacks);
          return reactExports.createElement(reactExports.Fragment, null, enabled && reactExports.createElement(SideCar, {
            sideCar: effectCar,
            removeScrollBar: removeScrollBar,
            shards: shards,
            noRelative: noRelative,
            noIsolation: noIsolation,
            inert: inert,
            setCallbacks: setCallbacks,
            allowPinchZoom: !!allowPinchZoom,
            lockRef: ref,
            gapMode: gapMode
          }), forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), _assign(_assign({}, containerProps), {
            ref: containerRef
          })) : reactExports.createElement(Container, _assign({}, containerProps, {
            className: className,
            ref: containerRef
          }), children));
        });
        RemoveScroll.defaultProps = {
          enabled: true,
          removeScrollBar: true,
          inert: false
        };
        RemoveScroll.classNames = {
          fullWidth: fullWidthClassName,
          zeroRight: zeroRightClassName
        };
        var getNonce = function getNonce() {
          if (typeof __webpack_nonce__ !== 'undefined') {
            return __webpack_nonce__;
          }
          return undefined;
        };
        function makeStyleTag() {
          if (!document) return null;
          var tag = document.createElement('style');
          tag.type = 'text/css';
          var nonce = getNonce();
          if (nonce) {
            tag.setAttribute('nonce', nonce);
          }
          return tag;
        }
        function injectStyles(tag, css) {
          // @ts-ignore
          if (tag.styleSheet) {
            // @ts-ignore
            tag.styleSheet.cssText = css;
          } else {
            tag.appendChild(document.createTextNode(css));
          }
        }
        function insertStyleTag(tag) {
          var head = document.head || document.getElementsByTagName('head')[0];
          head.appendChild(tag);
        }
        var stylesheetSingleton = function stylesheetSingleton() {
          var counter = 0;
          var stylesheet = null;
          return {
            add: function add(style) {
              if (counter == 0) {
                if (stylesheet = makeStyleTag()) {
                  injectStyles(stylesheet, style);
                  insertStyleTag(stylesheet);
                }
              }
              counter++;
            },
            remove: function remove() {
              counter--;
              if (!counter && stylesheet) {
                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
                stylesheet = null;
              }
            }
          };
        };

        /**
         * creates a hook to control style singleton
         * @see {@link styleSingleton} for a safer component version
         * @example
         * ```tsx
         * const useStyle = styleHookSingleton();
         * ///
         * useStyle('body { overflow: hidden}');
         */
        var styleHookSingleton = function styleHookSingleton() {
          var sheet = stylesheetSingleton();
          return function (styles, isDynamic) {
            reactExports.useEffect(function () {
              sheet.add(styles);
              return function () {
                sheet.remove();
              };
            }, [styles && isDynamic]);
          };
        };

        /**
         * create a Component to add styles on demand
         * - styles are added when first instance is mounted
         * - styles are removed when the last instance is unmounted
         * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
         */
        var styleSingleton = function styleSingleton() {
          var useStyle = styleHookSingleton();
          var Sheet = function Sheet(_a) {
            var styles = _a.styles,
              dynamic = _a.dynamic;
            useStyle(styles, dynamic);
            return null;
          };
          return Sheet;
        };
        var zeroGap = {
          left: 0,
          top: 0,
          right: 0,
          gap: 0
        };
        var parse = function parse(x) {
          return parseInt(x || '', 10) || 0;
        };
        var getOffset = function getOffset(gapMode) {
          var cs = window.getComputedStyle(document.body);
          var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
          var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
          var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
          return [parse(left), parse(top), parse(right)];
        };
        var getGapWidth = function getGapWidth(gapMode) {
          if (gapMode === void 0) {
            gapMode = 'margin';
          }
          if (typeof window === 'undefined') {
            return zeroGap;
          }
          var offsets = getOffset(gapMode);
          var documentWidth = document.documentElement.clientWidth;
          var windowWidth = window.innerWidth;
          return {
            left: offsets[0],
            top: offsets[1],
            right: offsets[2],
            gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
          };
        };
        var Style = styleSingleton();
        var lockAttribute = 'data-scroll-locked';
        // important tip - once we measure scrollBar width and remove them
        // we could not repeat this operation
        // thus we are using style-singleton - only the first "yet correct" style will be applied.
        var getStyles = function getStyles(_a, allowRelative, gapMode, important) {
          var left = _a.left,
            top = _a.top,
            right = _a.right,
            gap = _a.gap;
          if (gapMode === void 0) {
            gapMode = 'margin';
          }
          return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([allowRelative && "position: relative ".concat(important, ";"), gapMode === 'margin' && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "), gapMode === 'padding' && "padding-right: ".concat(gap, "px ").concat(important, ";")].filter(Boolean).join(''), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
        };
        var getCurrentUseCounter = function getCurrentUseCounter() {
          var counter = parseInt(document.body.getAttribute(lockAttribute) || '0', 10);
          return isFinite(counter) ? counter : 0;
        };
        var useLockAttribute = function useLockAttribute() {
          reactExports.useEffect(function () {
            document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
            return function () {
              var newCounter = getCurrentUseCounter() - 1;
              if (newCounter <= 0) {
                document.body.removeAttribute(lockAttribute);
              } else {
                document.body.setAttribute(lockAttribute, newCounter.toString());
              }
            };
          }, []);
        };
        /**
         * Removes page scrollbar and blocks page scroll when mounted
         */
        var RemoveScrollBar = function RemoveScrollBar(_a) {
          var noRelative = _a.noRelative,
            noImportant = _a.noImportant,
            _b = _a.gapMode,
            gapMode = _b === void 0 ? 'margin' : _b;
          useLockAttribute();
          /*
           gap will be measured on every component mount
           however it will be used only by the "first" invocation
           due to singleton nature of <Style
           */
          var gap = reactExports.useMemo(function () {
            return getGapWidth(gapMode);
          }, [gapMode]);
          return reactExports.createElement(Style, {
            styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '')
          });
        };
        var passiveSupported = false;
        if (typeof window !== 'undefined') {
          try {
            var options = Object.defineProperty({}, 'passive', {
              get: function get() {
                passiveSupported = true;
                return true;
              }
            });
            // @ts-ignore
            window.addEventListener('test', options, options);
            // @ts-ignore
            window.removeEventListener('test', options, options);
          } catch (err) {
            passiveSupported = false;
          }
        }
        var nonPassive = passiveSupported ? {
          passive: false
        } : false;
        var alwaysContainsScroll = function alwaysContainsScroll(node) {
          // textarea will always _contain_ scroll inside self. It only can be hidden
          return node.tagName === 'TEXTAREA';
        };
        var elementCanBeScrolled = function elementCanBeScrolled(node, overflow) {
          if (!(node instanceof Element)) {
            return false;
          }
          var styles = window.getComputedStyle(node);
          return (
            // not-not-scrollable
            styles[overflow] !== 'hidden' &&
            // contains scroll inside self
            !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible')
          );
        };
        var elementCouldBeVScrolled = function elementCouldBeVScrolled(node) {
          return elementCanBeScrolled(node, 'overflowY');
        };
        var elementCouldBeHScrolled = function elementCouldBeHScrolled(node) {
          return elementCanBeScrolled(node, 'overflowX');
        };
        var locationCouldBeScrolled = function locationCouldBeScrolled(axis, node) {
          var ownerDocument = node.ownerDocument;
          var current = node;
          do {
            // Skip over shadow root
            if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
              current = current.host;
            }
            var isScrollable = elementCouldBeScrolled(axis, current);
            if (isScrollable) {
              var _a = getScrollVariables(axis, current),
                scrollHeight = _a[1],
                clientHeight = _a[2];
              if (scrollHeight > clientHeight) {
                return true;
              }
            }
            current = current.parentNode;
          } while (current && current !== ownerDocument.body);
          return false;
        };
        var getVScrollVariables = function getVScrollVariables(_a) {
          var scrollTop = _a.scrollTop,
            scrollHeight = _a.scrollHeight,
            clientHeight = _a.clientHeight;
          return [scrollTop, scrollHeight, clientHeight];
        };
        var getHScrollVariables = function getHScrollVariables(_a) {
          var scrollLeft = _a.scrollLeft,
            scrollWidth = _a.scrollWidth,
            clientWidth = _a.clientWidth;
          return [scrollLeft, scrollWidth, clientWidth];
        };
        var elementCouldBeScrolled = function elementCouldBeScrolled(axis, node) {
          return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
        };
        var getScrollVariables = function getScrollVariables(axis, node) {
          return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
        };
        var getDirectionFactor = function getDirectionFactor(axis, direction) {
          /**
           * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
           * and then increasingly negative as you scroll towards the end of the content.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
           */
          return axis === 'h' && direction === 'rtl' ? -1 : 1;
        };
        var handleScroll = function handleScroll(axis, endTarget, event, sourceDelta, noOverscroll) {
          var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
          var delta = directionFactor * sourceDelta;
          // find scrollable target
          var target = event.target;
          var targetInLock = endTarget.contains(target);
          var shouldCancelScroll = false;
          var isDeltaPositive = delta > 0;
          var availableScroll = 0;
          var availableScrollTop = 0;
          do {
            if (!target) {
              break;
            }
            var _a = getScrollVariables(axis, target),
              position = _a[0],
              scroll_1 = _a[1],
              capacity = _a[2];
            var elementScroll = scroll_1 - capacity - directionFactor * position;
            if (position || elementScroll) {
              if (elementCouldBeScrolled(axis, target)) {
                availableScroll += elementScroll;
                availableScrollTop += position;
              }
            }
            var parent_1 = target.parentNode;
            // we will "bubble" from ShadowDom in case we are, or just to the parent in normal case
            // this is the same logic used in focus-lock
            target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
          } while (
          // portaled content
          !targetInLock && target !== document.body ||
          // self content
          targetInLock && (endTarget.contains(target) || endTarget === target));
          // handle epsilon around 0 (non standard zoom levels)
          if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
            shouldCancelScroll = true;
          } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
            shouldCancelScroll = true;
          }
          return shouldCancelScroll;
        };
        var getTouchXY = function getTouchXY(event) {
          return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
        };
        var getDeltaXY = function getDeltaXY(event) {
          return [event.deltaX, event.deltaY];
        };
        var extractRef = function extractRef(ref) {
          return ref && 'current' in ref ? ref.current : ref;
        };
        var deltaCompare = function deltaCompare(x, y) {
          return x[0] === y[0] && x[1] === y[1];
        };
        var generateStyle = function generateStyle(id) {
          return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
        };
        var idCounter = 0;
        var lockStack = [];
        function RemoveScrollSideCar(props) {
          var shouldPreventQueue = reactExports.useRef([]);
          var touchStartRef = reactExports.useRef([0, 0]);
          var activeAxis = reactExports.useRef();
          var id = reactExports.useState(idCounter++)[0];
          var Style = reactExports.useState(styleSingleton)[0];
          var lastProps = reactExports.useRef(props);
          reactExports.useEffect(function () {
            lastProps.current = props;
          }, [props]);
          reactExports.useEffect(function () {
            if (props.inert) {
              document.body.classList.add("block-interactivity-".concat(id));
              var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
              allow_1.forEach(function (el) {
                return el.classList.add("allow-interactivity-".concat(id));
              });
              return function () {
                document.body.classList.remove("block-interactivity-".concat(id));
                allow_1.forEach(function (el) {
                  return el.classList.remove("allow-interactivity-".concat(id));
                });
              };
            }
            return;
          }, [props.inert, props.lockRef.current, props.shards]);
          var shouldCancelEvent = reactExports.useCallback(function (event, parent) {
            if ('touches' in event && event.touches.length === 2 || event.type === 'wheel' && event.ctrlKey) {
              return !lastProps.current.allowPinchZoom;
            }
            var touch = getTouchXY(event);
            var touchStart = touchStartRef.current;
            var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
            var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
            var currentAxis;
            var target = event.target;
            var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
            // allow horizontal touch move on Range inputs. They will not cause any scroll
            if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
              return false;
            }
            // allow drag selection (iOS); check if selection's anchorNode is the same as target or contains target
            var selection = window.getSelection();
            var anchorNode = selection && selection.anchorNode;
            var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
            if (isTouchingSelection) {
              return false;
            }
            var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
            if (!canBeScrolledInMainDirection) {
              return true;
            }
            if (canBeScrolledInMainDirection) {
              currentAxis = moveDirection;
            } else {
              currentAxis = moveDirection === 'v' ? 'h' : 'v';
              canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
              // other axis might be not scrollable
            }
            if (!canBeScrolledInMainDirection) {
              return false;
            }
            if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
              activeAxis.current = currentAxis;
            }
            if (!currentAxis) {
              return true;
            }
            var cancelingAxis = activeAxis.current || currentAxis;
            return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY);
          }, []);
          var shouldPrevent = reactExports.useCallback(function (_event) {
            var event = _event;
            if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
              // not the last active
              return;
            }
            var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
            var sourceEvent = shouldPreventQueue.current.filter(function (e) {
              return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
            })[0];
            // self event, and should be canceled
            if (sourceEvent && sourceEvent.should) {
              if (event.cancelable) {
                event.preventDefault();
              }
              return;
            }
            // outside or shard event
            if (!sourceEvent) {
              var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function (node) {
                return node.contains(event.target);
              });
              var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
              if (shouldStop) {
                if (event.cancelable) {
                  event.preventDefault();
                }
              }
            }
          }, []);
          var shouldCancel = reactExports.useCallback(function (name, delta, target, should) {
            var event = {
              name: name,
              delta: delta,
              target: target,
              should: should,
              shadowParent: getOutermostShadowParent(target)
            };
            shouldPreventQueue.current.push(event);
            setTimeout(function () {
              shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) {
                return e !== event;
              });
            }, 1);
          }, []);
          var scrollTouchStart = reactExports.useCallback(function (event) {
            touchStartRef.current = getTouchXY(event);
            activeAxis.current = undefined;
          }, []);
          var scrollWheel = reactExports.useCallback(function (event) {
            shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
          }, []);
          var scrollTouchMove = reactExports.useCallback(function (event) {
            shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
          }, []);
          reactExports.useEffect(function () {
            lockStack.push(Style);
            props.setCallbacks({
              onScrollCapture: scrollWheel,
              onWheelCapture: scrollWheel,
              onTouchMoveCapture: scrollTouchMove
            });
            document.addEventListener('wheel', shouldPrevent, nonPassive);
            document.addEventListener('touchmove', shouldPrevent, nonPassive);
            document.addEventListener('touchstart', scrollTouchStart, nonPassive);
            return function () {
              lockStack = lockStack.filter(function (inst) {
                return inst !== Style;
              });
              document.removeEventListener('wheel', shouldPrevent, nonPassive);
              document.removeEventListener('touchmove', shouldPrevent, nonPassive);
              document.removeEventListener('touchstart', scrollTouchStart, nonPassive);
            };
          }, []);
          var removeScrollBar = props.removeScrollBar,
            inert = props.inert;
          return reactExports.createElement(reactExports.Fragment, null, inert ? reactExports.createElement(Style, {
            styles: generateStyle(id)
          }) : null, removeScrollBar ? reactExports.createElement(RemoveScrollBar, {
            noRelative: props.noRelative,
            gapMode: props.gapMode
          }) : null);
        }
        function getOutermostShadowParent(node) {
          var shadowParent = null;
          while (node !== null) {
            if (node instanceof ShadowRoot) {
              shadowParent = node.host;
              node = node.host;
            }
            node = node.parentNode;
          }
          return shadowParent;
        }
        var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
        var ReactRemoveScroll = reactExports.forwardRef(function (props, ref) {
          return reactExports.createElement(RemoveScroll, _assign({}, props, {
            ref: ref,
            sideCar: SideCar
          }));
        });
        ReactRemoveScroll.classNames = RemoveScroll.classNames;
        function ModalFocusScope(props) {
          var _useModalContext = useModalContext(),
            autoFocus = _useModalContext.autoFocus,
            trapFocus = _useModalContext.trapFocus,
            dialogRef = _useModalContext.dialogRef,
            initialFocusRef = _useModalContext.initialFocusRef,
            blockScrollOnMount = _useModalContext.blockScrollOnMount,
            allowPinchZoom = _useModalContext.allowPinchZoom,
            finalFocusRef = _useModalContext.finalFocusRef,
            returnFocusOnClose = _useModalContext.returnFocusOnClose,
            preserveScrollBarGap = _useModalContext.preserveScrollBarGap,
            lockFocusAcrossFrames = _useModalContext.lockFocusAcrossFrames,
            isOpen = _useModalContext.isOpen;
          var _usePresence5 = usePresence(),
            _usePresence6 = _slicedToArray(_usePresence5, 2),
            isPresent = _usePresence6[0],
            safeToRemove = _usePresence6[1];
          reactExports.useEffect(function () {
            if (!isPresent && safeToRemove) {
              setTimeout(safeToRemove);
            }
          }, [isPresent, safeToRemove]);
          var index = useModalManager(dialogRef, isOpen);
          return /* @__PURE__ */jsxRuntimeExports.jsx(FocusLock, {
            autoFocus: autoFocus,
            isDisabled: !trapFocus,
            initialFocusRef: initialFocusRef,
            finalFocusRef: finalFocusRef,
            restoreFocus: returnFocusOnClose,
            contentRef: dialogRef,
            lockFocusAcrossFrames: lockFocusAcrossFrames,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ReactRemoveScroll, {
              removeScrollBar: !preserveScrollBarGap,
              allowPinchZoom: allowPinchZoom,
              enabled: index === 1 && blockScrollOnMount,
              forwardProps: true,
              children: props.children
            })
          });
        }
        var ModalBody = exports("x", forwardRef(function (props, ref) {
          var className = props.className,
            rest = _objectWithoutProperties2(props, _excluded60);
          var _useModalContext2 = useModalContext(),
            bodyId = _useModalContext2.bodyId,
            setBodyMounted = _useModalContext2.setBodyMounted;
          reactExports.useEffect(function () {
            setBodyMounted(true);
            return function () {
              return setBodyMounted(false);
            };
          }, [setBodyMounted]);
          var _className = cx("chakra-modal__body", className);
          var styles = useModalStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            className: _className,
            id: bodyId
          }, rest), {}, {
            __css: styles.body
          }));
        }));
        ModalBody.displayName = "ModalBody";
        var ModalCloseButton = exports("v", forwardRef(function (props, ref) {
          var onClick = props.onClick,
            className = props.className,
            rest = _objectWithoutProperties2(props, _excluded61);
          var _useModalContext3 = useModalContext(),
            onClose = _useModalContext3.onClose;
          var _className = cx("chakra-modal__close-btn", className);
          var styles = useModalStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(CloseButton, _objectSpread3({
            ref: ref,
            __css: styles.closeButton,
            className: _className,
            onClick: callAllHandlers(onClick, function (event) {
              event.stopPropagation();
              onClose();
            })
          }, rest));
        }));
        ModalCloseButton.displayName = "ModalCloseButton";
        var ModalHeader = exports("t", forwardRef(function (props, ref) {
          var className = props.className,
            rest = _objectWithoutProperties2(props, _excluded62);
          var _useModalContext4 = useModalContext(),
            headerId = _useModalContext4.headerId,
            setHeaderMounted = _useModalContext4.setHeaderMounted;
          reactExports.useEffect(function () {
            setHeaderMounted(true);
            return function () {
              return setHeaderMounted(false);
            };
          }, [setHeaderMounted]);
          var _className = cx("chakra-modal__header", className);
          var styles = useModalStyles();
          var headerStyles = defineStyle(_objectSpread3({
            flex: 0
          }, styles.header));
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.header, _objectSpread3(_objectSpread3({
            ref: ref,
            className: _className,
            id: headerId
          }, rest), {}, {
            __css: headerStyles
          }));
        }));
        ModalHeader.displayName = "ModalHeader";
        var variants$1 = {
          enter: function enter() {
            var _transition$enter;
            var _ref162 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              transition = _ref162.transition,
              transitionEnd = _ref162.transitionEnd,
              delay = _ref162.delay;
            return {
              opacity: 1,
              transition: (_transition$enter = transition === null || transition === void 0 ? void 0 : transition.enter) !== null && _transition$enter !== void 0 ? _transition$enter : withDelay.enter(TRANSITION_DEFAULTS.enter, delay),
              transitionEnd: transitionEnd === null || transitionEnd === void 0 ? void 0 : transitionEnd.enter
            };
          },
          exit: function exit() {
            var _transition$exit;
            var _ref163 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              transition = _ref163.transition,
              transitionEnd = _ref163.transitionEnd,
              delay = _ref163.delay;
            return {
              opacity: 0,
              transition: (_transition$exit = transition === null || transition === void 0 ? void 0 : transition.exit) !== null && _transition$exit !== void 0 ? _transition$exit : withDelay.exit(TRANSITION_DEFAULTS.exit, delay),
              transitionEnd: transitionEnd === null || transitionEnd === void 0 ? void 0 : transitionEnd.exit
            };
          }
        };
        var fadeConfig = {
          initial: "exit",
          animate: "enter",
          exit: "exit",
          variants: variants$1
        };
        var Fade = reactExports.forwardRef(function Fade2(props, ref) {
          var unmountOnExit = props.unmountOnExit,
            isOpen = props.in,
            className = props.className,
            transition = props.transition,
            transitionEnd = props.transitionEnd,
            delay = props.delay,
            animatePresenceProps = props.animatePresenceProps,
            rest = _objectWithoutProperties2(props, _excluded63);
          var animate = isOpen || unmountOnExit ? "enter" : "exit";
          var show = unmountOnExit ? isOpen && unmountOnExit : true;
          var custom = {
            transition: transition,
            transitionEnd: transitionEnd,
            delay: delay
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(AnimatePresence, _objectSpread3(_objectSpread3({}, animatePresenceProps), {}, {
            custom: custom,
            children: show && /* @__PURE__ */jsxRuntimeExports.jsx(motion.div, _objectSpread3(_objectSpread3({
              ref: ref,
              className: cx("chakra-fade", className),
              custom: custom
            }, fadeConfig), {}, {
              animate: animate
            }, rest))
          }));
        });
        Fade.displayName = "Fade";
        var MotionDiv$2 = chakra(motion.div);
        var ModalOverlay = exports("s", forwardRef(function (props, ref) {
          var className = props.className,
            transition = props.transition,
            _motionProps = props.motionProps,
            rest = _objectWithoutProperties2(props, _excluded64);
          var _className = cx("chakra-modal__overlay", className);
          var styles = useModalStyles();
          var overlayStyle = _objectSpread3({
            pos: "fixed",
            left: "0",
            top: "0",
            w: "100vw",
            h: "100vh"
          }, styles.overlay);
          var _useModalContext5 = useModalContext(),
            motionPreset = _useModalContext5.motionPreset;
          var defaultMotionProps = motionPreset === "none" ? {} : fadeConfig;
          var motionProps = _motionProps || defaultMotionProps;
          return /* @__PURE__ */jsxRuntimeExports.jsx(MotionDiv$2, _objectSpread3(_objectSpread3({}, motionProps), {}, {
            __css: overlayStyle,
            ref: ref,
            className: _className
          }, rest));
        }));
        ModalOverlay.displayName = "ModalOverlay";
        var _createContext27 = createContext(),
          _createContext28 = _slicedToArray(_createContext27, 2),
          DrawerContextProvider = _createContext28[0],
          useDrawerContext = _createContext28[1];
        var placementMap = {
          start: {
            ltr: "left",
            rtl: "right"
          },
          end: {
            ltr: "right",
            rtl: "left"
          }
        };
        function getDrawerPlacement(placement, dir) {
          var _placementMap$placeme, _placementMap$placeme2;
          if (!placement) return;
          return (_placementMap$placeme = (_placementMap$placeme2 = placementMap[placement]) === null || _placementMap$placeme2 === void 0 ? void 0 : _placementMap$placeme2[dir]) !== null && _placementMap$placeme !== void 0 ? _placementMap$placeme : placement;
        }
        function Drawer(props) {
          var _theme$components;
          var isOpen = props.isOpen,
            onClose = props.onClose,
            _props$placement3 = props.placement,
            placementProp = _props$placement3 === void 0 ? "right" : _props$placement3,
            children = props.children,
            rest = _objectWithoutProperties2(props, _excluded65);
          var theme = useTheme();
          var drawerStyleConfig = (_theme$components = theme.components) === null || _theme$components === void 0 ? void 0 : _theme$components.Drawer;
          var placement = getDrawerPlacement(placementProp, theme.direction);
          return /* @__PURE__ */jsxRuntimeExports.jsx(DrawerContextProvider, {
            value: {
              placement: placement
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Modal, _objectSpread3(_objectSpread3({
              isOpen: isOpen,
              onClose: onClose,
              styleConfig: drawerStyleConfig
            }, rest), {}, {
              children: children
            }))
          });
        }
        var defaultTransition = {
          exit: {
            duration: 0.15,
            ease: TRANSITION_EASINGS.easeInOut
          },
          enter: {
            type: "spring",
            damping: 25,
            stiffness: 180
          }
        };
        var variants = {
          exit: function exit(_ref164) {
            var _transition$exit2;
            var direction = _ref164.direction,
              transition = _ref164.transition,
              transitionEnd = _ref164.transitionEnd,
              delay = _ref164.delay;
            var _getSlideTransition = getSlideTransition({
                direction: direction
              }),
              exitStyles = _getSlideTransition.exit;
            return _objectSpread3(_objectSpread3({}, exitStyles), {}, {
              transition: (_transition$exit2 = transition === null || transition === void 0 ? void 0 : transition.exit) !== null && _transition$exit2 !== void 0 ? _transition$exit2 : withDelay.exit(defaultTransition.exit, delay),
              transitionEnd: transitionEnd === null || transitionEnd === void 0 ? void 0 : transitionEnd.exit
            });
          },
          enter: function enter(_ref165) {
            var _transition$enter2;
            var direction = _ref165.direction,
              transitionEnd = _ref165.transitionEnd,
              transition = _ref165.transition,
              delay = _ref165.delay;
            var _getSlideTransition2 = getSlideTransition({
                direction: direction
              }),
              enterStyles = _getSlideTransition2.enter;
            return _objectSpread3(_objectSpread3({}, enterStyles), {}, {
              transition: (_transition$enter2 = transition === null || transition === void 0 ? void 0 : transition.enter) !== null && _transition$enter2 !== void 0 ? _transition$enter2 : withDelay.enter(defaultTransition.enter, delay),
              transitionEnd: transitionEnd === null || transitionEnd === void 0 ? void 0 : transitionEnd.enter
            });
          }
        };
        var Slide = reactExports.forwardRef(function Slide2(props, ref) {
          var _props$direction2 = props.direction,
            direction = _props$direction2 === void 0 ? "right" : _props$direction2,
            style = props.style,
            unmountOnExit = props.unmountOnExit,
            isOpen = props.in,
            className = props.className,
            transition = props.transition,
            transitionEnd = props.transitionEnd,
            delay = props.delay,
            motionProps = props.motionProps,
            animatePresenceProps = props.animatePresenceProps,
            rest = _objectWithoutProperties2(props, _excluded66);
          var transitionStyles = getSlideTransition({
            direction: direction
          });
          var computedStyle = Object.assign({
            position: "fixed"
          }, transitionStyles.position, style);
          var show = unmountOnExit ? isOpen && unmountOnExit : true;
          var animate = isOpen || unmountOnExit ? "enter" : "exit";
          var custom = {
            transitionEnd: transitionEnd,
            transition: transition,
            direction: direction,
            delay: delay
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(AnimatePresence, _objectSpread3(_objectSpread3({}, animatePresenceProps), {}, {
            custom: custom,
            children: show && /* @__PURE__ */jsxRuntimeExports.jsx(motion.div, _objectSpread3(_objectSpread3({}, rest), {}, {
              ref: ref,
              initial: "exit",
              className: cx("chakra-slide", className),
              animate: animate,
              exit: "exit",
              custom: custom,
              variants: variants,
              style: computedStyle
            }, motionProps))
          }));
        });
        Slide.displayName = "Slide";
        var MotionDiv$1 = chakra(Slide);
        var DrawerContent = forwardRef(function (props, ref) {
          var className = props.className,
            children = props.children,
            motionProps = props.motionProps,
            rootProps = props.containerProps,
            rest = _objectWithoutProperties2(props, _excluded67);
          var _useModalContext6 = useModalContext(),
            getDialogProps = _useModalContext6.getDialogProps,
            getDialogContainerProps = _useModalContext6.getDialogContainerProps,
            isOpen = _useModalContext6.isOpen;
          var dialogProps = getDialogProps(rest, ref);
          var containerProps = getDialogContainerProps(rootProps);
          var _className = cx("chakra-modal__content", className);
          var styles = useModalStyles();
          var dialogStyles = _objectSpread3({
            display: "flex",
            flexDirection: "column",
            position: "relative",
            width: "100%",
            outline: 0
          }, styles.dialog);
          var dialogContainerStyles = _objectSpread3({
            display: "flex",
            width: "100vw",
            height: "$100vh",
            position: "fixed",
            left: 0,
            top: 0
          }, styles.dialogContainer);
          var _useDrawerContext = useDrawerContext(),
            placement = _useDrawerContext.placement;
          return /* @__PURE__ */jsxRuntimeExports.jsx(ModalFocusScope, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, containerProps), {}, {
              className: "chakra-modal__content-container",
              __css: dialogContainerStyles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(MotionDiv$1, _objectSpread3(_objectSpread3({
                motionProps: motionProps,
                direction: placement,
                in: isOpen,
                className: _className
              }, dialogProps), {}, {
                __css: dialogStyles,
                children: children
              }))
            }))
          });
        });
        DrawerContent.displayName = "DrawerContent";
        function getElementRef(el) {
          var _el$props;
          var version = reactExports.version;
          if (typeof version !== "string") return el === null || el === void 0 ? void 0 : el.ref;
          if (version.startsWith("18.")) return el === null || el === void 0 ? void 0 : el.ref;
          return el === null || el === void 0 || (_el$props = el.props) === null || _el$props === void 0 ? void 0 : _el$props.ref;
        }
        var SelectField = forwardRef(function SelectField2(props, ref) {
          var children = props.children,
            placeholder = props.placeholder,
            className = props.className,
            rest = _objectWithoutProperties2(props, _excluded68);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.select, _objectSpread3(_objectSpread3({}, rest), {}, {
            ref: ref,
            className: cx("chakra-select", className),
            children: [placeholder && /* @__PURE__ */jsxRuntimeExports.jsx("option", {
              value: "",
              children: placeholder
            }), children]
          }));
        });
        SelectField.displayName = "SelectField";
        var Select = exports("L", forwardRef(function (props, ref) {
          var _styles$field;
          var styles = useMultiStyleConfig("Select", props);
          var _omitThemingProps10 = omitThemingProps(props),
            rootProps = _omitThemingProps10.rootProps,
            placeholder = _omitThemingProps10.placeholder,
            icon = _omitThemingProps10.icon,
            color = _omitThemingProps10.color,
            height = _omitThemingProps10.height,
            h = _omitThemingProps10.h,
            minH = _omitThemingProps10.minH,
            minHeight = _omitThemingProps10.minHeight,
            iconColor = _omitThemingProps10.iconColor,
            iconSize = _omitThemingProps10.iconSize,
            rest = _objectWithoutProperties2(_omitThemingProps10, _excluded69);
          var _split = split(rest, layoutPropNames),
            _split2 = _slicedToArray(_split, 2),
            layoutProps = _split2[0],
            otherProps = _split2[1];
          var ownProps = useFormControl(otherProps);
          var rootStyles = {
            width: "100%",
            height: "fit-content",
            position: "relative",
            color: color
          };
          var fieldStyles = _objectSpread3(_objectSpread3({
            paddingEnd: "2rem"
          }, styles.field), {}, {
            _focus: _objectSpread3({
              zIndex: "unset"
            }, (_styles$field = styles.field) === null || _styles$field === void 0 ? void 0 : _styles$field["_focus"])
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(chakra.div, _objectSpread3(_objectSpread3(_objectSpread3({
            className: "chakra-select__wrapper",
            __css: rootStyles
          }, layoutProps), rootProps), {}, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(SelectField, _objectSpread3(_objectSpread3({
              ref: ref,
              height: h !== null && h !== void 0 ? h : height,
              minH: minH !== null && minH !== void 0 ? minH : minHeight,
              placeholder: placeholder
            }, ownProps), {}, {
              __css: fieldStyles,
              children: props.children
            })), /* @__PURE__ */jsxRuntimeExports.jsx(SelectIcon, _objectSpread3(_objectSpread3(_objectSpread3({
              "data-disabled": dataAttr(ownProps.disabled)
            }, (iconColor || color) && {
              color: iconColor || color
            }), {}, {
              __css: styles.icon
            }, iconSize && {
              fontSize: iconSize
            }), {}, {
              children: icon
            }))]
          }));
        }));
        Select.displayName = "Select";
        var DefaultIcon = function DefaultIcon(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx("svg", _objectSpread3(_objectSpread3({
            viewBox: "0 0 24 24"
          }, props), {}, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("path", {
              fill: "currentColor",
              d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
            })
          }));
        };
        var IconWrapper = chakra("div", {
          baseStyle: {
            position: "absolute",
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            pointerEvents: "none",
            top: "50%",
            transform: "translateY(-50%)"
          }
        });
        var SelectIcon = function SelectIcon(props) {
          var _props$children2 = props.children,
            children = _props$children2 === void 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(DefaultIcon, {}) : _props$children2,
            rest = _objectWithoutProperties2(props, _excluded70);
          var clone = reactExports.cloneElement(children, {
            role: "presentation",
            className: "chakra-select__icon",
            focusable: false,
            "aria-hidden": true,
            // force icon to adhere to `IconWrapper` styles
            style: {
              width: "1em",
              height: "1em",
              color: "currentColor"
            }
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(IconWrapper, _objectSpread3(_objectSpread3({}, rest), {}, {
            className: "chakra-select__icon-wrapper",
            children: reactExports.isValidElement(children) ? clone : null
          }));
        };
        SelectIcon.displayName = "SelectIcon";
        var StackItem = function StackItem(props) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            className: "chakra-stack__item"
          }, props), {}, {
            __css: _objectSpread3({
              display: "inline-block",
              flex: "0 0 auto",
              minWidth: 0
            }, props["__css"])
          }));
        };
        StackItem.displayName = "StackItem";
        function getDividerStyles(options) {
          var spacing = options.spacing,
            direction = options.direction;
          var dividerStyles = {
            column: {
              my: spacing,
              mx: 0,
              borderLeftWidth: 0,
              borderBottomWidth: "1px"
            },
            "column-reverse": {
              my: spacing,
              mx: 0,
              borderLeftWidth: 0,
              borderBottomWidth: "1px"
            },
            row: {
              mx: spacing,
              my: 0,
              borderLeftWidth: "1px",
              borderBottomWidth: 0
            },
            "row-reverse": {
              mx: spacing,
              my: 0,
              borderLeftWidth: "1px",
              borderBottomWidth: 0
            }
          };
          return {
            "&": mapResponsive(direction, function (value) {
              return dividerStyles[value];
            })
          };
        }
        var Stack = forwardRef(function (props, ref) {
          var isInline = props.isInline,
            directionProp = props.direction,
            align = props.align,
            justify = props.justify,
            _props$spacing2 = props.spacing,
            spacing = _props$spacing2 === void 0 ? "0.5rem" : _props$spacing2,
            wrap = props.wrap,
            children = props.children,
            divider = props.divider,
            className = props.className,
            shouldWrapChildren = props.shouldWrapChildren,
            rest = _objectWithoutProperties2(props, _excluded71);
          var direction = isInline ? "row" : directionProp !== null && directionProp !== void 0 ? directionProp : "column";
          var dividerStyle = reactExports.useMemo(function () {
            return getDividerStyles({
              spacing: spacing,
              direction: direction
            });
          }, [spacing, direction]);
          var hasDivider = !!divider;
          var shouldUseChildren = !shouldWrapChildren && !hasDivider;
          var clones = reactExports.useMemo(function () {
            var validChildren = getValidChildren(children);
            return shouldUseChildren ? validChildren : validChildren.map(function (child, index) {
              var key = typeof child.key !== "undefined" ? child.key : index;
              var isLast = index + 1 === validChildren.length;
              var wrappedChild = /* @__PURE__ */jsxRuntimeExports.jsx(StackItem, {
                children: child
              }, key);
              var _child = shouldWrapChildren ? wrappedChild : child;
              if (!hasDivider) return _child;
              var clonedDivider = reactExports.cloneElement(divider, {
                __css: dividerStyle
              });
              var _divider = isLast ? null : clonedDivider;
              return /* @__PURE__ */jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [_child, _divider]
              }, key);
            });
          }, [divider, dividerStyle, hasDivider, shouldUseChildren, shouldWrapChildren, children]);
          var _className = cx("chakra-stack", className);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            ref: ref,
            display: "flex",
            alignItems: align,
            justifyContent: justify,
            flexDirection: direction,
            flexWrap: wrap,
            gap: hasDivider ? void 0 : spacing,
            className: _className
          }, rest), {}, {
            children: clones
          }));
        });
        Stack.displayName = "Stack";
        var HStack = exports("n", forwardRef(function (props, ref) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Stack, _objectSpread3(_objectSpread3({
            align: "center"
          }, props), {}, {
            direction: "row",
            ref: ref
          }));
        }));
        HStack.displayName = "HStack";
        var VStack = exports("V", forwardRef(function (props, ref) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Stack, _objectSpread3(_objectSpread3({
            align: "center"
          }, props), {}, {
            direction: "column",
            ref: ref
          }));
        }));
        VStack.displayName = "VStack";
        var _createContext29 = createContext({
            name: "StatStylesContext",
            errorMessage: "useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<Stat />\" "
          }),
          _createContext30 = _slicedToArray(_createContext29, 2),
          StatStylesProvider = _createContext30[0],
          useStatStyles = _createContext30[1];
        var Stat = exports("S", forwardRef(function Stat2(props, ref) {
          var styles = useMultiStyleConfig("Stat", props);
          var statStyles = _objectSpread3({
            position: "relative",
            flex: "1 1 0%"
          }, styles.container);
          var _omitThemingProps11 = omitThemingProps(props),
            className = _omitThemingProps11.className,
            children = _omitThemingProps11.children,
            rest = _objectWithoutProperties2(_omitThemingProps11, _excluded72);
          return /* @__PURE__ */jsxRuntimeExports.jsx(StatStylesProvider, {
            value: styles,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
              ref: ref
            }, rest), {}, {
              className: cx("chakra-stat", className),
              __css: statStyles,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("dl", {
                children: children
              })
            }))
          });
        }));
        Stat.displayName = "Stat";
        var StatLabel = exports("y", forwardRef(function StatLabel2(props, ref) {
          var styles = useStatStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.dt, _objectSpread3(_objectSpread3({
            ref: ref
          }, props), {}, {
            className: cx("chakra-stat__label", props.className),
            __css: styles.label
          }));
        }));
        StatLabel.displayName = "StatLabel";
        var StatNumber = exports("z", forwardRef(function StatNumber2(props, ref) {
          var styles = useStatStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.dd, _objectSpread3(_objectSpread3({
            ref: ref
          }, props), {}, {
            className: cx("chakra-stat__number", props.className),
            __css: _objectSpread3(_objectSpread3({}, styles.number), {}, {
              fontFeatureSettings: "pnum",
              fontVariantNumeric: "proportional-nums"
            })
          }));
        }));
        StatNumber.displayName = "StatNumber";
        var _createDescendantCont = createDescendantContext(),
          _createDescendantCont2 = _slicedToArray(_createDescendantCont, 4),
          TabsDescendantsProvider = _createDescendantCont2[0],
          useTabsDescendantsContext = _createDescendantCont2[1],
          useTabsDescendants = _createDescendantCont2[2],
          useTabsDescendant = _createDescendantCont2[3];
        function useTabs(props) {
          var _props$id;
          var defaultIndex = props.defaultIndex,
            onChange = props.onChange,
            index = props.index,
            isManual = props.isManual,
            isLazy = props.isLazy,
            _props$lazyBehavior = props.lazyBehavior,
            lazyBehavior = _props$lazyBehavior === void 0 ? "unmount" : _props$lazyBehavior,
            _props$orientation = props.orientation,
            orientation = _props$orientation === void 0 ? "horizontal" : _props$orientation,
            _props$direction3 = props.direction,
            direction = _props$direction3 === void 0 ? "ltr" : _props$direction3,
            htmlProps = _objectWithoutProperties2(props, _excluded73);
          var _reactExports$useStat51 = reactExports.useState(defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0),
            _reactExports$useStat52 = _slicedToArray(_reactExports$useStat51, 2),
            focusedIndex = _reactExports$useStat52[0],
            setFocusedIndex = _reactExports$useStat52[1];
          var _useControllableState = useControllableState({
              defaultValue: defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0,
              value: index,
              onChange: onChange
            }),
            _useControllableState2 = _slicedToArray(_useControllableState, 2),
            selectedIndex = _useControllableState2[0],
            setSelectedIndex = _useControllableState2[1];
          reactExports.useEffect(function () {
            if (index != null) {
              setFocusedIndex(index);
            }
          }, [index]);
          var descendants = useTabsDescendants();
          var uuid = reactExports.useId();
          var uid = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : uuid;
          var id = "tabs-".concat(uid);
          return {
            id: id,
            selectedIndex: selectedIndex,
            focusedIndex: focusedIndex,
            setSelectedIndex: setSelectedIndex,
            setFocusedIndex: setFocusedIndex,
            isManual: isManual,
            isLazy: isLazy,
            lazyBehavior: lazyBehavior,
            orientation: orientation,
            descendants: descendants,
            direction: direction,
            htmlProps: htmlProps
          };
        }
        var _createContext31 = createContext({
            name: "TabsContext",
            errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
          }),
          _createContext32 = _slicedToArray(_createContext31, 2),
          TabsProvider = _createContext32[0],
          useTabsContext = _createContext32[1];
        function useTabList(props) {
          var _useTabsContext = useTabsContext(),
            focusedIndex = _useTabsContext.focusedIndex,
            orientation = _useTabsContext.orientation,
            direction = _useTabsContext.direction;
          var descendants = useTabsDescendantsContext();
          var onKeyDown = reactExports.useCallback(function (event) {
            var nextTab = function nextTab() {
              var _next$node;
              var next = descendants.nextEnabled(focusedIndex);
              if (next) (_next$node = next.node) === null || _next$node === void 0 || _next$node.focus();
            };
            var prevTab = function prevTab() {
              var _prev$node;
              var prev = descendants.prevEnabled(focusedIndex);
              if (prev) (_prev$node = prev.node) === null || _prev$node === void 0 || _prev$node.focus();
            };
            var firstTab = function firstTab() {
              var _first$node;
              var first = descendants.firstEnabled();
              if (first) (_first$node = first.node) === null || _first$node === void 0 || _first$node.focus();
            };
            var lastTab = function lastTab() {
              var _last$node;
              var last = descendants.lastEnabled();
              if (last) (_last$node = last.node) === null || _last$node === void 0 || _last$node.focus();
            };
            var isHorizontal = orientation === "horizontal";
            var isVertical = orientation === "vertical";
            var eventKey = event.key;
            var ArrowStart = direction === "ltr" ? "ArrowLeft" : "ArrowRight";
            var ArrowEnd = direction === "ltr" ? "ArrowRight" : "ArrowLeft";
            var keyMap = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, ArrowStart, function () {
              return isHorizontal && prevTab();
            }), ArrowEnd, function () {
              return isHorizontal && nextTab();
            }), "ArrowDown", function ArrowDown() {
              return isVertical && nextTab();
            }), "ArrowUp", function ArrowUp() {
              return isVertical && prevTab();
            }), "Home", firstTab), "End", lastTab);
            var action = keyMap[eventKey];
            if (action) {
              event.preventDefault();
              action(event);
            }
          }, [descendants, focusedIndex, orientation, direction]);
          return _objectSpread3(_objectSpread3({}, props), {}, {
            role: "tablist",
            "aria-orientation": orientation,
            onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
          });
        }
        function useTab(props) {
          var _props$isDisabled = props.isDisabled,
            isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,
            _props$isFocusable = props.isFocusable,
            isFocusable = _props$isFocusable === void 0 ? false : _props$isFocusable,
            htmlProps = _objectWithoutProperties2(props, _excluded74);
          var _useTabsContext2 = useTabsContext(),
            setSelectedIndex = _useTabsContext2.setSelectedIndex,
            isManual = _useTabsContext2.isManual,
            id = _useTabsContext2.id,
            setFocusedIndex = _useTabsContext2.setFocusedIndex,
            selectedIndex = _useTabsContext2.selectedIndex;
          var _useTabsDescendant = useTabsDescendant({
              disabled: isDisabled && !isFocusable
            }),
            index = _useTabsDescendant.index,
            register = _useTabsDescendant.register;
          var isSelected = index === selectedIndex;
          var onClick = function onClick() {
            setSelectedIndex(index);
          };
          var onFocus = function onFocus() {
            setFocusedIndex(index);
            var isDisabledButFocusable = isDisabled && isFocusable;
            var shouldSelect = !isManual && !isDisabledButFocusable;
            if (shouldSelect) {
              setSelectedIndex(index);
            }
          };
          var clickableProps = useClickable(_objectSpread3(_objectSpread3({}, htmlProps), {}, {
            ref: mergeRefs(register, props.ref),
            isDisabled: isDisabled,
            isFocusable: isFocusable,
            onClick: callAllHandlers(props.onClick, onClick)
          }));
          var type = "button";
          return _objectSpread3(_objectSpread3({}, clickableProps), {}, {
            id: makeTabId(id, index),
            role: "tab",
            tabIndex: isSelected ? 0 : -1,
            type: type,
            "aria-selected": isSelected,
            "aria-controls": makeTabPanelId(id, index),
            onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)
          });
        }
        var _createContext33 = createContext({}),
          _createContext34 = _slicedToArray(_createContext33, 2),
          TabPanelProvider = _createContext34[0],
          useTabPanelContext = _createContext34[1];
        function useTabPanels(props) {
          var context = useTabsContext();
          var id = context.id,
            selectedIndex = context.selectedIndex;
          var validChildren = getValidChildren(props.children);
          var children = validChildren.map(function (child, index) {
            var _child$key;
            return reactExports.createElement(TabPanelProvider, {
              key: (_child$key = child.key) !== null && _child$key !== void 0 ? _child$key : index,
              value: {
                isSelected: index === selectedIndex,
                id: makeTabPanelId(id, index),
                tabId: makeTabId(id, index),
                selectedIndex: selectedIndex
              }
            }, child);
          });
          return _objectSpread3(_objectSpread3({}, props), {}, {
            children: children
          });
        }
        function useTabPanel(props) {
          var children = props.children,
            htmlProps = _objectWithoutProperties2(props, _excluded75);
          var _useTabsContext3 = useTabsContext(),
            isLazy = _useTabsContext3.isLazy,
            lazyBehavior = _useTabsContext3.lazyBehavior;
          var _useTabPanelContext = useTabPanelContext(),
            isSelected = _useTabPanelContext.isSelected,
            id = _useTabPanelContext.id,
            tabId = _useTabPanelContext.tabId;
          var hasBeenSelected = reactExports.useRef(false);
          if (isSelected) {
            hasBeenSelected.current = true;
          }
          var shouldRenderChildren = lazyDisclosure({
            wasSelected: hasBeenSelected.current,
            isSelected: isSelected,
            enabled: isLazy,
            mode: lazyBehavior
          });
          return _objectSpread3(_objectSpread3({
            // Puts the tabpanel in the page `Tab` sequence.
            tabIndex: 0
          }, htmlProps), {}, {
            children: shouldRenderChildren ? children : null,
            role: "tabpanel",
            "aria-labelledby": tabId,
            hidden: !isSelected,
            id: id
          });
        }
        function makeTabId(id, index) {
          return "".concat(id, "--tab-").concat(index);
        }
        function makeTabPanelId(id, index) {
          return "".concat(id, "--tabpanel-").concat(index);
        }
        var _createContext35 = createContext({
            name: "TabsStylesContext",
            errorMessage: "useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<Tabs />\" "
          }),
          _createContext36 = _slicedToArray(_createContext35, 2),
          TabsStylesProvider = _createContext36[0],
          useTabsStyles = _createContext36[1];
        var Tabs = forwardRef(function Tabs2(props, ref) {
          var styles = useMultiStyleConfig("Tabs", props);
          var _omitThemingProps12 = omitThemingProps(props),
            children = _omitThemingProps12.children,
            className = _omitThemingProps12.className,
            rest = _objectWithoutProperties2(_omitThemingProps12, _excluded76);
          var _useTabs = useTabs(rest),
            htmlProps = _useTabs.htmlProps,
            descendants = _useTabs.descendants,
            ctx = _objectWithoutProperties2(_useTabs, _excluded77);
          var context = reactExports.useMemo(function () {
            return ctx;
          }, [ctx]);
          var _ = htmlProps.isFitted,
            rootProps = _objectWithoutProperties2(htmlProps, _excluded78);
          var tabsStyles = _objectSpread3({
            position: "relative"
          }, styles.root);
          return /* @__PURE__ */jsxRuntimeExports.jsx(TabsDescendantsProvider, {
            value: descendants,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TabsProvider, {
              value: context,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TabsStylesProvider, {
                value: styles,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
                  className: cx("chakra-tabs", className),
                  ref: ref
                }, rootProps), {}, {
                  __css: tabsStyles,
                  children: children
                }))
              })
            })
          });
        });
        Tabs.displayName = "Tabs";
        var Tab = forwardRef(function Tab2(props, ref) {
          var styles = useTabsStyles();
          var tabProps = useTab(_objectSpread3(_objectSpread3({}, props), {}, {
            ref: ref
          }));
          var tabStyles = defineStyle(_objectSpread3({
            outline: "0",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }, styles.tab));
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.button, _objectSpread3(_objectSpread3({}, tabProps), {}, {
            className: cx("chakra-tabs__tab", props.className),
            __css: tabStyles
          }));
        });
        Tab.displayName = "Tab";
        var TabList = forwardRef(function TabList2(props, ref) {
          var tablistProps = useTabList(_objectSpread3(_objectSpread3({}, props), {}, {
            ref: ref
          }));
          var styles = useTabsStyles();
          var tablistStyles = defineStyle(_objectSpread3({
            display: "flex"
          }, styles.tablist));
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, tablistProps), {}, {
            className: cx("chakra-tabs__tablist", props.className),
            __css: tablistStyles
          }));
        });
        TabList.displayName = "TabList";
        var TabPanel = forwardRef(function TabPanel2(props, ref) {
          var panelProps = useTabPanel(_objectSpread3(_objectSpread3({}, props), {}, {
            ref: ref
          }));
          var styles = useTabsStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({
            outline: "0"
          }, panelProps), {}, {
            className: cx("chakra-tabs__tab-panel", props.className),
            __css: styles.tabpanel
          }));
        });
        TabPanel.displayName = "TabPanel";
        var TabPanels = forwardRef(function TabPanels2(props, ref) {
          var panelsProps = useTabPanels(props);
          var styles = useTabsStyles();
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, panelsProps), {}, {
            width: "100%",
            ref: ref,
            className: cx("chakra-tabs__tab-panels", props.className),
            __css: styles.tabpanels
          }));
        });
        TabPanels.displayName = "TabPanels";
        var omitted = ["h", "minH", "height", "minHeight"];
        var Textarea = forwardRef(function (props, ref) {
          var styles = useStyleConfig("Textarea", props);
          var _omitThemingProps13 = omitThemingProps(props),
            className = _omitThemingProps13.className,
            rows = _omitThemingProps13.rows,
            rest = _objectWithoutProperties2(_omitThemingProps13, _excluded79);
          var textareaProps = useFormControl(rest);
          var textareaStyles = rows ? omit(styles, omitted) : styles;
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.textarea, _objectSpread3(_objectSpread3({
            ref: ref,
            rows: rows
          }, textareaProps), {}, {
            className: cx("chakra-textarea", className),
            __css: textareaStyles
          }));
        });
        Textarea.displayName = "Textarea";
        function getToastPlacement(position, dir) {
          var _logical$dir;
          var computedPosition = position !== null && position !== void 0 ? position : "bottom";
          var logicals = {
            "top-start": {
              ltr: "top-left",
              rtl: "top-right"
            },
            "top-end": {
              ltr: "top-right",
              rtl: "top-left"
            },
            "bottom-start": {
              ltr: "bottom-left",
              rtl: "bottom-right"
            },
            "bottom-end": {
              ltr: "bottom-right",
              rtl: "bottom-left"
            }
          };
          var logical = logicals[computedPosition];
          return (_logical$dir = logical === null || logical === void 0 ? void 0 : logical[dir]) !== null && _logical$dir !== void 0 ? _logical$dir : computedPosition;
        }
        function createToastFn(dir, defaultOptions) {
          var normalizeToastOptions = function normalizeToastOptions(options) {
            var _options$position2;
            return _objectSpread3(_objectSpread3(_objectSpread3({}, defaultOptions), options), {}, {
              position: getToastPlacement((_options$position2 = options === null || options === void 0 ? void 0 : options.position) !== null && _options$position2 !== void 0 ? _options$position2 : defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.position, dir)
            });
          };
          var toast = function toast(options) {
            var normalizedToastOptions = normalizeToastOptions(options);
            var Message = createRenderToast(normalizedToastOptions);
            return toastStore.notify(Message, normalizedToastOptions);
          };
          toast.update = function (id, options) {
            toastStore.update(id, normalizeToastOptions(options));
          };
          toast.promise = function (promise, options) {
            var id = toast(_objectSpread3(_objectSpread3({}, options.loading), {}, {
              status: "loading",
              duration: null
            }));
            promise.then(function (data) {
              return toast.update(id, _objectSpread3({
                status: "success",
                duration: 5e3
              }, runIfFn$1(options.success, data)));
            }).catch(function (error) {
              return toast.update(id, _objectSpread3({
                status: "error",
                duration: 5e3
              }, runIfFn$1(options.error, error)));
            });
          };
          toast.closeAll = toastStore.closeAll;
          toast.close = toastStore.close;
          toast.isActive = toastStore.isActive;
          return toast;
        }
        function useToast(options) {
          var _useChakra2 = useChakra(),
            theme = _useChakra2.theme;
          var defaultOptions = useToastOptionContext();
          return reactExports.useMemo(function () {
            return createToastFn(theme.direction, _objectSpread3(_objectSpread3({}, defaultOptions), options));
          }, [options, theme.direction, defaultOptions]);
        }
        var scale = {
          exit: {
            scale: 0.85,
            opacity: 0,
            transition: {
              opacity: {
                duration: 0.15,
                easings: "easeInOut"
              },
              scale: {
                duration: 0.2,
                easings: "easeInOut"
              }
            }
          },
          enter: {
            scale: 1,
            opacity: 1,
            transition: {
              opacity: {
                easings: "easeOut",
                duration: 0.2
              },
              scale: {
                duration: 0.2,
                ease: [0.175, 0.885, 0.4, 1.1]
              }
            }
          }
        };
        var getDoc = function getDoc(ref) {
          var _ref$current3;
          return ((_ref$current3 = ref.current) === null || _ref$current3 === void 0 ? void 0 : _ref$current3.ownerDocument) || document;
        };
        var getWin = function getWin(ref) {
          var _ref$current4;
          return ((_ref$current4 = ref.current) === null || _ref$current4 === void 0 || (_ref$current4 = _ref$current4.ownerDocument) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.defaultView) || window;
        };
        function useTooltip() {
          var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _props$openDelay = props.openDelay,
            openDelay = _props$openDelay === void 0 ? 0 : _props$openDelay,
            _props$closeDelay = props.closeDelay,
            closeDelay = _props$closeDelay === void 0 ? 0 : _props$closeDelay,
            _props$closeOnClick = props.closeOnClick,
            closeOnClick = _props$closeOnClick === void 0 ? true : _props$closeOnClick,
            closeOnMouseDown = props.closeOnMouseDown,
            closeOnScroll = props.closeOnScroll,
            _props$closeOnPointer = props.closeOnPointerDown,
            closeOnPointerDown = _props$closeOnPointer === void 0 ? closeOnMouseDown : _props$closeOnPointer,
            _props$closeOnEsc2 = props.closeOnEsc,
            closeOnEsc = _props$closeOnEsc2 === void 0 ? true : _props$closeOnEsc2,
            onOpenProp = props.onOpen,
            onCloseProp = props.onClose,
            placement = props.placement,
            id = props.id,
            isOpenProp = props.isOpen,
            defaultIsOpen = props.defaultIsOpen,
            _props$arrowSize = props.arrowSize,
            arrowSize = _props$arrowSize === void 0 ? 10 : _props$arrowSize,
            arrowShadowColor = props.arrowShadowColor,
            arrowPadding = props.arrowPadding,
            modifiers = props.modifiers,
            isDisabled = props.isDisabled,
            gutter = props.gutter,
            offset = props.offset,
            direction = props.direction,
            htmlProps = _objectWithoutProperties2(props, _excluded80);
          var _useDisclosure = useDisclosure({
              isOpen: isOpenProp,
              defaultIsOpen: defaultIsOpen,
              onOpen: onOpenProp,
              onClose: onCloseProp
            }),
            isOpen = _useDisclosure.isOpen,
            onOpen = _useDisclosure.onOpen,
            onClose = _useDisclosure.onClose;
          var _usePopper = usePopper({
              enabled: isOpen,
              placement: placement,
              arrowPadding: arrowPadding,
              modifiers: modifiers,
              gutter: gutter,
              offset: offset,
              direction: direction
            }),
            referenceRef = _usePopper.referenceRef,
            getPopperProps = _usePopper.getPopperProps,
            getArrowInnerProps = _usePopper.getArrowInnerProps,
            getArrowProps = _usePopper.getArrowProps;
          var uuid = reactExports.useId();
          var uid = id !== null && id !== void 0 ? id : uuid;
          var tooltipId = "tooltip-".concat(uid);
          var ref = reactExports.useRef(null);
          var enterTimeout = reactExports.useRef(void 0);
          var clearEnterTimeout = reactExports.useCallback(function () {
            if (enterTimeout.current) {
              clearTimeout(enterTimeout.current);
              enterTimeout.current = void 0;
            }
          }, []);
          var exitTimeout = reactExports.useRef(void 0);
          var clearExitTimeout = reactExports.useCallback(function () {
            if (exitTimeout.current) {
              clearTimeout(exitTimeout.current);
              exitTimeout.current = void 0;
            }
          }, []);
          var closeNow = reactExports.useCallback(function () {
            clearExitTimeout();
            onClose();
          }, [onClose, clearExitTimeout]);
          var dispatchCloseEvent = useCloseEvent(ref, closeNow);
          var openWithDelay = reactExports.useCallback(function () {
            if (!isDisabled && !enterTimeout.current) {
              if (isOpen) dispatchCloseEvent();
              var win = getWin(ref);
              enterTimeout.current = win.setTimeout(onOpen, openDelay);
            }
          }, [dispatchCloseEvent, isDisabled, isOpen, onOpen, openDelay]);
          var closeWithDelay = reactExports.useCallback(function () {
            clearEnterTimeout();
            var win = getWin(ref);
            exitTimeout.current = win.setTimeout(closeNow, closeDelay);
          }, [closeDelay, closeNow, clearEnterTimeout]);
          var onClick = reactExports.useCallback(function () {
            if (isOpen && closeOnClick) {
              closeWithDelay();
            }
          }, [closeOnClick, closeWithDelay, isOpen]);
          var onPointerDown = reactExports.useCallback(function () {
            if (isOpen && closeOnPointerDown) {
              closeWithDelay();
            }
          }, [closeOnPointerDown, closeWithDelay, isOpen]);
          var onKeyDown = reactExports.useCallback(function (event) {
            if (isOpen && event.key === "Escape") {
              closeWithDelay();
            }
          }, [isOpen, closeWithDelay]);
          useEventListener(function () {
            return getDoc(ref);
          }, "keydown", closeOnEsc ? onKeyDown : void 0);
          useEventListener(function () {
            if (!closeOnScroll) return null;
            var node = ref.current;
            if (!node) return null;
            var scrollParent = getScrollParent$1(node);
            return scrollParent.localName === "body" ? getWin(ref) : scrollParent;
          }, "scroll", function () {
            if (isOpen && closeOnScroll) {
              closeNow();
            }
          }, {
            passive: true,
            capture: true
          });
          reactExports.useEffect(function () {
            if (!isDisabled) return;
            clearEnterTimeout();
            if (isOpen) onClose();
          }, [isDisabled, isOpen, onClose, clearEnterTimeout]);
          reactExports.useEffect(function () {
            return function () {
              clearEnterTimeout();
              clearExitTimeout();
            };
          }, [clearEnterTimeout, clearExitTimeout]);
          useEventListener(function () {
            return ref.current;
          }, "pointerleave", closeWithDelay);
          var getTriggerProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var triggerProps = _objectSpread3(_objectSpread3({}, props2), {}, {
              ref: mergeRefs(ref, _ref, referenceRef),
              onPointerEnter: callAllHandlers(props2.onPointerEnter, function (e) {
                if (e.pointerType === "touch") return;
                openWithDelay();
              }),
              onClick: callAllHandlers(props2.onClick, onClick),
              onPointerDown: callAllHandlers(props2.onPointerDown, onPointerDown),
              onFocus: callAllHandlers(props2.onFocus, openWithDelay),
              onBlur: callAllHandlers(props2.onBlur, closeWithDelay),
              "aria-describedby": isOpen ? tooltipId : void 0
            });
            return triggerProps;
          }, [openWithDelay, closeWithDelay, onPointerDown, isOpen, tooltipId, onClick, referenceRef]);
          var getTooltipPositionerProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var forwardedRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return getPopperProps(_objectSpread3(_objectSpread3({}, props2), {}, {
              style: _objectSpread3(_objectSpread3({}, props2.style), {}, _defineProperty2(_defineProperty2({}, cssVars.arrowSize.var, arrowSize ? "".concat(arrowSize, "px") : void 0), cssVars.arrowShadowColor.var, arrowShadowColor))
            }), forwardedRef);
          }, [getPopperProps, arrowSize, arrowShadowColor]);
          var getTooltipProps = reactExports.useCallback(function () {
            var props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var styles = _objectSpread3(_objectSpread3({}, props2.style), {}, {
              position: "relative",
              transformOrigin: cssVars.transformOrigin.varRef
            });
            return _objectSpread3(_objectSpread3(_objectSpread3({
              ref: ref2
            }, htmlProps), props2), {}, {
              id: tooltipId,
              role: "tooltip",
              style: styles
            });
          }, [htmlProps, tooltipId]);
          return {
            isOpen: isOpen,
            show: openWithDelay,
            hide: closeWithDelay,
            getTriggerProps: getTriggerProps,
            getTooltipProps: getTooltipProps,
            getTooltipPositionerProps: getTooltipPositionerProps,
            getArrowProps: getArrowProps,
            getArrowInnerProps: getArrowInnerProps
          };
        }
        var closeEventName = "chakra-ui:close-tooltip";
        function useCloseEvent(ref, close) {
          reactExports.useEffect(function () {
            var doc = getDoc(ref);
            doc.addEventListener(closeEventName, close);
            return function () {
              return doc.removeEventListener(closeEventName, close);
            };
          }, [close, ref]);
          return function () {
            var doc = getDoc(ref);
            var win = getWin(ref);
            doc.dispatchEvent(new win.CustomEvent(closeEventName));
          };
        }
        var MotionDiv = chakra(motion.div);
        var Tooltip = forwardRef(function (props, ref) {
          var _ref166, _ref167;
          var styles = useStyleConfig("Tooltip", props);
          var ownProps = omitThemingProps(props);
          var theme = useTheme();
          var children = ownProps.children,
            label = ownProps.label,
            shouldWrapChildren = ownProps.shouldWrapChildren,
            ariaLabel = ownProps["aria-label"],
            hasArrow = ownProps.hasArrow,
            bg = ownProps.bg,
            portalProps = ownProps.portalProps,
            background = ownProps.background,
            backgroundColor = ownProps.backgroundColor,
            bgColor = ownProps.bgColor,
            motionProps = ownProps.motionProps,
            animatePresenceProps = ownProps.animatePresenceProps,
            rest = _objectWithoutProperties2(ownProps, _excluded81);
          var userDefinedBg = (_ref166 = (_ref167 = background !== null && background !== void 0 ? background : backgroundColor) !== null && _ref167 !== void 0 ? _ref167 : bg) !== null && _ref166 !== void 0 ? _ref166 : bgColor;
          if (userDefinedBg) {
            styles.bg = userDefinedBg;
            var bgVar = getCSSVar(theme, "colors", userDefinedBg);
            styles[cssVars.arrowBg.var] = bgVar;
          }
          var tooltip = useTooltip(_objectSpread3(_objectSpread3({}, rest), {}, {
            direction: theme.direction
          }));
          var shouldWrap = !reactExports.isValidElement(children) || shouldWrapChildren;
          var trigger;
          if (shouldWrap) {
            trigger = /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
              display: "inline-block",
              tabIndex: 0
            }, tooltip.getTriggerProps()), {}, {
              children: children
            }));
          } else {
            var child = reactExports.Children.only(children);
            trigger = reactExports.cloneElement(child, tooltip.getTriggerProps(child.props, getElementRef(child)));
          }
          var hasAriaLabel = !!ariaLabel;
          var _tooltipProps = tooltip.getTooltipProps({}, ref);
          var tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
          var srOnlyProps = pick(_tooltipProps, ["role", "id"]);
          if (!label) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: children
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [trigger, /* @__PURE__ */jsxRuntimeExports.jsx(AnimatePresence, _objectSpread3(_objectSpread3({}, animatePresenceProps), {}, {
              children: tooltip.isOpen && /* @__PURE__ */jsxRuntimeExports.jsx(Portal, _objectSpread3(_objectSpread3({}, portalProps), {}, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, _objectSpread3(_objectSpread3({}, tooltip.getTooltipPositionerProps()), {}, {
                  __css: {
                    zIndex: styles.zIndex,
                    pointerEvents: "none"
                  },
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(MotionDiv, _objectSpread3(_objectSpread3(_objectSpread3({
                    variants: scale,
                    initial: "exit",
                    animate: "enter",
                    exit: "exit"
                  }, motionProps), tooltipProps), {}, {
                    __css: styles,
                    children: [label, hasAriaLabel && /* @__PURE__ */jsxRuntimeExports.jsx(chakra.span, _objectSpread3(_objectSpread3({
                      srOnly: true
                    }, srOnlyProps), {}, {
                      children: ariaLabel
                    })), hasArrow && /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, {
                      "data-popper-arrow": true,
                      className: "chakra-tooltip__arrow-wrapper",
                      children: /* @__PURE__ */jsxRuntimeExports.jsx(chakra.div, {
                        "data-popper-arrow-inner": true,
                        className: "chakra-tooltip__arrow",
                        __css: {
                          bg: styles.bg
                        }
                      })
                    })]
                  }))
                }))
              }))
            }))]
          });
        });
        Tooltip.displayName = "Tooltip";
        var Heading = exports("H", forwardRef(function Heading2(props, ref) {
          var styles = useStyleConfig("Heading", props);
          var _omitThemingProps14 = omitThemingProps(props),
            className = _omitThemingProps14.className,
            rest = _objectWithoutProperties2(_omitThemingProps14, _excluded82);
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.h2, _objectSpread3(_objectSpread3({
            ref: ref,
            className: cx("chakra-heading", props.className)
          }, rest), {}, {
            __css: styles
          }));
        }));
        Heading.displayName = "Heading";
        var Text = exports("l", forwardRef(function Text2(props, ref) {
          var styles = useStyleConfig("Text", props);
          var _omitThemingProps15 = omitThemingProps(props),
            className = _omitThemingProps15.className,
            align = _omitThemingProps15.align,
            decoration = _omitThemingProps15.decoration,
            casing = _omitThemingProps15.casing,
            rest = _objectWithoutProperties2(_omitThemingProps15, _excluded83);
          var aliasedProps = compact({
            textAlign: props.align,
            textDecoration: props.decoration,
            textTransform: props.casing
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(chakra.p, _objectSpread3(_objectSpread3(_objectSpread3({
            ref: ref,
            className: cx("chakra-text", props.className)
          }, aliasedProps), rest), {}, {
            __css: styles
          }));
        }));
        Text.displayName = "Text";

        // Treaties Data ( ) - Expanded
        var treatiesData = [
        // Priority Treaties
        {
          id: 1,
          name: "     ",
          date: "1998",
          topic: " ",
          states: "124",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/rome-statute-international-criminal-court",
          description: "        :         ."
        }, {
          id: 2,
          name: "  ",
          date: "1945",
          topic: " ",
          states: "193",
          link: "https://www.un.org/ar/about-us/un-charter",
          description: "           ."
        }, {
          id: 3,
          name: "    ",
          date: "1948",
          topic: " ",
          states: "153",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/convention-prevention-and-punishment-crime-genocide",
          description: "          ."
        }, {
          id: 4,
          name: "     ",
          date: "1973",
          topic: " ",
          states: "110",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/international-convention-suppression-and-punishment-crime-apartheid",
          description: "          ."
        }, {
          id: 5,
          name: "   ",
          date: "1948",
          topic: " ",
          states: "",
          link: "https://www.un.org/ar/about-us/universal-declaration-of-human-rights",
          description: "          ."
        }, {
          id: 6,
          name: "     ",
          date: "1966",
          topic: " ",
          states: "174",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/international-covenant-civil-and-political-rights",
          description: "   :       ."
        }, {
          id: 7,
          name: "      ",
          date: "1966",
          topic: " ",
          states: "172",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/international-covenant-economic-social-and-cultural-rights",
          description: "   :      ."
        }, {
          id: 8,
          name: "  ",
          date: "1949",
          topic: " ",
          states: "196",
          link: "https://ihl-databases.icrc.org/ar/ihl-treaties",
          description: "        ."
        }, {
          id: 9,
          name: "    ",
          date: "1989",
          topic: " ",
          states: "196",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/convention-rights-child",
          description: "         18 ."
        }, {
          id: 10,
          name: "      ()",
          date: "1979",
          topic: " ",
          states: "189",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/convention-elimination-all-forms-discrimination-against-women",
          description: "       ."
        }, {
          id: 11,
          name: "  ",
          date: "1984",
          topic: " ",
          states: "174",
          link: "https://www.ohchr.org/ar/instruments-mechanisms/instruments/convention-against-torture-and-other-cruel-inhuman-or-degrading",
          description: "       ."
        }, {
          id: 12,
          name: "    ",
          date: "1968",
          topic: " ",
          states: "191",
          link: "https://treaties.unoda.org/t/npt",
          description: "        ."
        }, {
          id: 13,
          name: "   ",
          date: "2015",
          topic: "",
          states: "195",
          link: "https://unfccc.int/sites/default/files/arabic_paris_agreement.pdf",
          description: "        ."
        }, {
          id: 14,
          name: "   ",
          date: "1961",
          topic: " ",
          states: "193",
          link: "https://treaties.un.org/Pages/ViewDetails.aspx?src=TREATY&mtdsg_no=III-3&chapter=3&clang=_en",
          description: "      ."
        }, {
          id: 15,
          name: "    ",
          date: "1982",
          topic: " ",
          states: "170",
          link: "https://www.un.org/Depts/los/convention_agreements/convention_overview_convention.htm",
          description: "       ."
        }, {
          id: 16,
          name: "  ",
          date: "1951",
          topic: " ",
          states: "147",
          link: "https://www.unhcr.org/ar/what-we-do/how-we-work/ensuring-rights/1951-refugee-convention",
          description: "      ."
        }, {
          id: 17,
          name: "   ",
          date: "1950",
          topic: " ",
          states: "46",
          link: "https://www.echr.coe.int/documents/d/echr/convention_ara",
          description: "         ."
        }, {
          id: 18,
          name: "   ",
          date: "1993",
          topic: " ",
          states: "193",
          link: "https://www.opcw.org/ar/alathaqya-alkmyayya",
          description: "      ."
        }];

        // Cases Data ( ) - Expanded
        var casesData = [
        // ICJ Cases
        {
          id: 1,
          name: "    (   )",
          court: "ICJ",
          year: "2024",
          summary: "          .    .",
          link: "https://www.icj-cij.org/case/192"
        }, {
          id: 2,
          name: "        ",
          court: "ICJ",
          year: "2024",
          summary: "        .",
          link: "https://www.icj-cij.org/case/186"
        }, {
          id: 3,
          name: "   (  )",
          court: "ICJ",
          year: "2019",
          summary: "        .",
          link: "https://www.icj-cij.org/case/178"
        }, {
          id: 4,
          name: "   ()",
          court: "ICJ",
          year: "2004",
          summary: "          .",
          link: "https://www.icj-cij.org/case/131"
        }, {
          id: 5,
          name: "  (   )",
          court: "ICJ",
          year: "1986",
          summary: "          .",
          link: "https://www.icj-cij.org/case/70"
        }, {
          id: 6,
          name: "   ",
          court: "ICJ",
          year: "2022",
          summary: "         .",
          link: "https://www.icj-cij.org/case/182"
        }, {
          id: 7,
          name: "    ()",
          court: "ICJ",
          year: "1996",
          summary: "        .",
          link: "https://www.icj-cij.org/case/95"
        },
        // ICC Cases
        {
          id: 8,
          name: "   ( )",
          court: "ICC",
          year: "2024",
          summary: "       .",
          link: "https://www.icc-cpi.int/palestine"
        }, {
          id: 9,
          name: "   ()",
          court: "ICC",
          year: "2023",
          summary: "         .",
          link: "https://www.icc-cpi.int/situations/ukraine"
        }, {
          id: 10,
          name: " ",
          court: "ICC",
          year: "2012",
          summary: "       -  .",
          link: "https://www.icc-cpi.int/drc/lubanga"
        }, {
          id: 11,
          name: " ",
          court: "ICC",
          year: "2019",
          summary: "  18        30 .",
          link: "https://www.icc-cpi.int/drc/ntaganda"
        }, {
          id: 12,
          name: " (  )",
          court: "ICC",
          year: "2016",
          summary: "      .",
          link: "https://www.icc-cpi.int/mali/al-mahdi"
        },
        // ECHR Cases
        {
          id: 13,
          name: "KlimaSeniorinnen  ",
          court: "ECHR",
          year: "2024",
          summary: "          .",
          link: "https://hudoc.echr.coe.int/"
        }, {
          id: 14,
          name: "Handyside   ",
          court: "ECHR",
          year: "1976",
          summary: "     '  '.",
          link: "https://hudoc.echr.coe.int/"
        }, {
          id: 15,
          name: "Soering   ",
          court: "ECHR",
          year: "1989",
          summary: "        .",
          link: "https://hudoc.echr.coe.int/"
        }];

        // Resolutions Data ( ) - Expanded
        var resolutionsData = [
        // Security Council
        {
          id: 1,
          number: "S/RES/2728",
          type: " ",
          year: "2024",
          subject: "        .",
          link: "https://undocs.org/S/RES/2728(2024)"
        }, {
          id: 2,
          number: "S/RES/2720",
          type: " ",
          year: "2023",
          subject: "     .",
          link: "https://undocs.org/S/RES/2720(2023)"
        }, {
          id: 3,
          number: "S/RES/2334",
          type: " ",
          year: "2016",
          subject: "       .",
          link: "https://undocs.org/ar/S/RES/2334(2016)"
        }, {
          id: 4,
          number: "S/RES/242",
          type: " ",
          year: "1967",
          subject: "      (  ).",
          link: "https://undocs.org/ar/S/RES/242(1967)"
        }, {
          id: 5,
          number: "S/RES/338",
          type: " ",
          year: "1973",
          subject: "     242.",
          link: "https://undocs.org/ar/S/RES/338(1973)"
        }, {
          id: 6,
          number: "S/RES/1325",
          type: " ",
          year: "2000",
          subject: "  :     .",
          link: "https://undocs.org/ar/S/RES/1325(2000)"
        }, {
          id: 7,
          number: "S/RES/1973",
          type: " ",
          year: "2011",
          subject: "       .",
          link: "https://undocs.org/ar/S/RES/1973(2011)"
        },
        // General Assembly
        {
          id: 8,
          number: "A/RES/ES-10/22",
          type: " ",
          year: "2023",
          subject: "      .",
          link: "https://undocs.org/A/RES/ES-10/22"
        }, {
          id: 9,
          number: "A/RES/ES-10/23",
          type: " ",
          year: "2024",
          subject: "    .",
          link: "https://undocs.org/A/RES/ES-10/23"
        }, {
          id: 10,
          number: "A/RES/194",
          type: " ",
          year: "1948",
          subject: "    .",
          link: "https://undocs.org/ar/A/RES/194(III)"
        }, {
          id: 11,
          number: "A/RES/181",
          type: " ",
          year: "1947",
          subject: "  .",
          link: "https://undocs.org/A/RES/181(II)"
        }, {
          id: 12,
          number: "A/RES/217A",
          type: " ",
          year: "1948",
          subject: "   .",
          link: "https://undocs.org/ar/A/RES/217(III)"
        }, {
          id: 13,
          number: "A/RES/60/1",
          type: " ",
          year: "2005",
          subject: "  (R2P).",
          link: "https://undocs.org/ar/A/RES/60/1"
        }, {
          id: 14,
          number: "A/RES/377",
          type: " ",
          year: "1950",
          subject: "    (   ).",
          link: "https://undocs.org/A/RES/377(V)"
        }];

        // Resources Data ()
        var resourcesData = [{
          id: 1,
          name: "   (ICJ)",
          description: "           .",
          url: "https://www.icj-cij.org",
          icon: "",
          category: ""
        }, {
          id: 2,
          name: "   (ICC)",
          description: "        .",
          url: "https://www.icc-cpi.int",
          icon: "",
          category: ""
        }, {
          id: 3,
          name: "    (ECHR)",
          description: "          .",
          url: "https://www.echr.coe.int",
          icon: "",
          category: ""
        }, {
          id: 4,
          name: " ",
          description: "       .",
          url: "https://www.un.org/ar",
          icon: "",
          category: ""
        }, {
          id: 5,
          name: "   (OHCHR)",
          description: "       .",
          url: "https://www.ohchr.org/ar",
          icon: "",
          category: ""
        }, {
          id: 6,
          name: "    (ICRC)",
          description: "      .",
          url: "https://www.icrc.org/ar",
          icon: "",
          category: ""
        }, {
          id: 7,
          name: "   ",
          description: "         .",
          url: "https://treaties.un.org",
          icon: "",
          category: " "
        }, {
          id: 8,
          name: "HUDOC (   )",
          description: "       .",
          url: "https://hudoc.echr.coe.int",
          icon: "",
          category: " "
        }, {
          id: 9,
          name: "UNSCR (  )",
          description: "     .",
          url: "https://www.un.org/securitycouncil/ar/content/resolutions",
          icon: "",
          category: " "
        }, {
          id: 10,
          name: "   (IOM)",
          description: "     .",
          url: "https://www.iom.int/ar",
          icon: "",
          category: ""
        }];
        var resolveFetch$3 = function resolveFetch$3(customFetch) {
          if (customFetch) {
            return function () {
              return customFetch.apply(void 0, arguments);
            };
          }
          return function () {
            return fetch.apply(void 0, arguments);
          };
        };

        /**
         * Base error for Supabase Edge Function invocations.
         *
         * @example
         * ```ts
         * import { FunctionsError } from '@supabase/functions-js'
         *
         * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {
         *   requestId: 'abc123',
         * })
         * ```
         */
        var FunctionsError = /*#__PURE__*/function (_Error2) {
          function FunctionsError(message) {
            var _this63;
            var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'FunctionsError';
            var context = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, FunctionsError);
            _this63 = _callSuper(this, FunctionsError, [message]);
            _this63.name = name;
            _this63.context = context;
            return _this63;
          }
          _inherits(FunctionsError, _Error2);
          return _createClass(FunctionsError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        /**
         * Error thrown when the network request to an Edge Function fails.
         *
         * @example
         * ```ts
         * import { FunctionsFetchError } from '@supabase/functions-js'
         *
         * throw new FunctionsFetchError({ requestId: 'abc123' })
         * ```
         */
        var FunctionsFetchError = /*#__PURE__*/function (_FunctionsError) {
          function FunctionsFetchError(context) {
            _classCallCheck(this, FunctionsFetchError);
            return _callSuper(this, FunctionsFetchError, ['Failed to send a request to the Edge Function', 'FunctionsFetchError', context]);
          }
          _inherits(FunctionsFetchError, _FunctionsError);
          return _createClass(FunctionsFetchError);
        }(FunctionsError);
        /**
         * Error thrown when the Supabase relay cannot reach the Edge Function.
         *
         * @example
         * ```ts
         * import { FunctionsRelayError } from '@supabase/functions-js'
         *
         * throw new FunctionsRelayError({ region: 'us-east-1' })
         * ```
         */
        var FunctionsRelayError = /*#__PURE__*/function (_FunctionsError2) {
          function FunctionsRelayError(context) {
            _classCallCheck(this, FunctionsRelayError);
            return _callSuper(this, FunctionsRelayError, ['Relay Error invoking the Edge Function', 'FunctionsRelayError', context]);
          }
          _inherits(FunctionsRelayError, _FunctionsError2);
          return _createClass(FunctionsRelayError);
        }(FunctionsError);
        /**
         * Error thrown when the Edge Function returns a non-2xx status code.
         *
         * @example
         * ```ts
         * import { FunctionsHttpError } from '@supabase/functions-js'
         *
         * throw new FunctionsHttpError({ status: 500 })
         * ```
         */
        var FunctionsHttpError = /*#__PURE__*/function (_FunctionsError3) {
          function FunctionsHttpError(context) {
            _classCallCheck(this, FunctionsHttpError);
            return _callSuper(this, FunctionsHttpError, ['Edge Function returned a non-2xx status code', 'FunctionsHttpError', context]);
          }
          _inherits(FunctionsHttpError, _FunctionsError3);
          return _createClass(FunctionsHttpError);
        }(FunctionsError); // Define the enum for the 'region' property
        var FunctionRegion;
        (function (FunctionRegion) {
          FunctionRegion["Any"] = "any";
          FunctionRegion["ApNortheast1"] = "ap-northeast-1";
          FunctionRegion["ApNortheast2"] = "ap-northeast-2";
          FunctionRegion["ApSouth1"] = "ap-south-1";
          FunctionRegion["ApSoutheast1"] = "ap-southeast-1";
          FunctionRegion["ApSoutheast2"] = "ap-southeast-2";
          FunctionRegion["CaCentral1"] = "ca-central-1";
          FunctionRegion["EuCentral1"] = "eu-central-1";
          FunctionRegion["EuWest1"] = "eu-west-1";
          FunctionRegion["EuWest2"] = "eu-west-2";
          FunctionRegion["EuWest3"] = "eu-west-3";
          FunctionRegion["SaEast1"] = "sa-east-1";
          FunctionRegion["UsEast1"] = "us-east-1";
          FunctionRegion["UsWest1"] = "us-west-1";
          FunctionRegion["UsWest2"] = "us-west-2";
        })(FunctionRegion || (FunctionRegion = {}));

        /**
         * Client for invoking Supabase Edge Functions.
         */
        var FunctionsClient = /*#__PURE__*/function () {
          /**
           * Creates a new Functions client bound to an Edge Functions URL.
           *
           * @example
           * ```ts
           * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
           *
           * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
           *   headers: { apikey: 'public-anon-key' },
           *   region: FunctionRegion.UsEast1,
           * })
           * ```
           */
          function FunctionsClient(url) {
            var _ref168 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref168$headers = _ref168.headers,
              headers = _ref168$headers === void 0 ? {} : _ref168$headers,
              customFetch = _ref168.customFetch,
              _ref168$region = _ref168.region,
              region = _ref168$region === void 0 ? FunctionRegion.Any : _ref168$region;
            _classCallCheck(this, FunctionsClient);
            this.url = url;
            this.headers = headers;
            this.region = region;
            this.fetch = resolveFetch$3(customFetch);
          }
          /**
           * Updates the authorization header
           * @param token - the new jwt token sent in the authorisation header
           * @example
           * ```ts
           * functions.setAuth(session.access_token)
           * ```
           */
          return _createClass(FunctionsClient, [{
            key: "setAuth",
            value: function setAuth(token) {
              this.headers.Authorization = "Bearer ".concat(token);
            }
            /**
             * Invokes a function
             * @param functionName - The name of the Function to invoke.
             * @param options - Options for invoking the Function.
             * @example
             * ```ts
             * const { data, error } = await functions.invoke('hello-world', {
             *   body: { name: 'Ada' },
             * })
             * ```
             */
          }, {
            key: "invoke",
            value: function invoke(functionName_1) {
              return __awaiter(this, arguments, void 0, function (functionName) {
                var _this64 = this;
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                return /*#__PURE__*/_regenerator().m(function _callee3() {
                  var _a, timeoutId, timeoutController, headers, method, functionArgs, signal, timeout, _headers, region, url, body, effectiveSignal, response, isRelayError, responseType, data, _t;
                  return _regenerator().w(function (_context4) {
                    while (1) switch (_context4.p = _context4.n) {
                      case 0:
                        _context4.p = 0;
                        headers = options.headers, method = options.method, functionArgs = options.body, signal = options.signal, timeout = options.timeout;
                        _headers = {};
                        region = options.region;
                        if (!region) {
                          region = _this64.region;
                        }
                        // Add region as query parameter using URL API
                        url = new URL("".concat(_this64.url, "/").concat(functionName));
                        if (region && region !== 'any') {
                          _headers['x-region'] = region;
                          url.searchParams.set('forceFunctionRegion', region);
                        }
                        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {
                          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
                            // will work for File as File inherits Blob
                            // also works for ArrayBuffer as it is the same underlying structure as a Blob
                            _headers['Content-Type'] = 'application/octet-stream';
                            body = functionArgs;
                          } else if (typeof functionArgs === 'string') {
                            // plain string
                            _headers['Content-Type'] = 'text/plain';
                            body = functionArgs;
                          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {
                            // don't set content-type headers
                            // Request will automatically add the right boundary value
                            body = functionArgs;
                          } else {
                            // default, assume this is JSON
                            _headers['Content-Type'] = 'application/json';
                            body = JSON.stringify(functionArgs);
                          }
                        } else {
                          if (functionArgs && typeof functionArgs !== 'string' && !(typeof Blob !== 'undefined' && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== 'undefined' && functionArgs instanceof FormData)) {
                            body = JSON.stringify(functionArgs);
                          } else {
                            body = functionArgs;
                          }
                        }
                        // Handle timeout by creating an AbortController
                        effectiveSignal = signal;
                        if (timeout) {
                          timeoutController = new AbortController();
                          timeoutId = setTimeout(function () {
                            return timeoutController.abort();
                          }, timeout);
                          // If user provided their own signal, we need to respect both
                          if (signal) {
                            effectiveSignal = timeoutController.signal;
                            // If the user's signal is aborted, abort our timeout controller too
                            signal.addEventListener('abort', function () {
                              return timeoutController.abort();
                            });
                          } else {
                            effectiveSignal = timeoutController.signal;
                          }
                        }
                        _context4.n = 1;
                        return _this64.fetch(url.toString(), {
                          method: method || 'POST',
                          // headers priority is (high to low):
                          // 1. invoke-level headers
                          // 2. client-level headers
                          // 3. default Content-Type header
                          headers: Object.assign(Object.assign(Object.assign({}, _headers), _this64.headers), headers),
                          body: body,
                          signal: effectiveSignal
                        }).catch(function (fetchError) {
                          throw new FunctionsFetchError(fetchError);
                        });
                      case 1:
                        response = _context4.v;
                        isRelayError = response.headers.get('x-relay-error');
                        if (!(isRelayError && isRelayError === 'true')) {
                          _context4.n = 2;
                          break;
                        }
                        throw new FunctionsRelayError(response);
                      case 2:
                        if (response.ok) {
                          _context4.n = 3;
                          break;
                        }
                        throw new FunctionsHttpError(response);
                      case 3:
                        responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();
                        if (!(responseType === 'application/json')) {
                          _context4.n = 5;
                          break;
                        }
                        _context4.n = 4;
                        return response.json();
                      case 4:
                        data = _context4.v;
                        _context4.n = 12;
                        break;
                      case 5:
                        if (!(responseType === 'application/octet-stream' || responseType === 'application/pdf')) {
                          _context4.n = 7;
                          break;
                        }
                        _context4.n = 6;
                        return response.blob();
                      case 6:
                        data = _context4.v;
                        _context4.n = 12;
                        break;
                      case 7:
                        if (!(responseType === 'text/event-stream')) {
                          _context4.n = 8;
                          break;
                        }
                        data = response;
                        _context4.n = 12;
                        break;
                      case 8:
                        if (!(responseType === 'multipart/form-data')) {
                          _context4.n = 10;
                          break;
                        }
                        _context4.n = 9;
                        return response.formData();
                      case 9:
                        data = _context4.v;
                        _context4.n = 12;
                        break;
                      case 10:
                        _context4.n = 11;
                        return response.text();
                      case 11:
                        data = _context4.v;
                      case 12:
                        return _context4.a(2, {
                          data: data,
                          error: null,
                          response: response
                        });
                      case 13:
                        _context4.p = 13;
                        _t = _context4.v;
                        return _context4.a(2, {
                          data: null,
                          error: _t,
                          response: _t instanceof FunctionsHttpError || _t instanceof FunctionsRelayError ? _t.context : undefined
                        });
                      case 14:
                        _context4.p = 14;
                        // Clear the timeout if it was set
                        if (timeoutId) {
                          clearTimeout(timeoutId);
                        }
                        return _context4.f(14);
                      case 15:
                        return _context4.a(2);
                    }
                  }, _callee3, null, [[0, 13, 14, 15]]);
                })();
              });
            }
          }]);
        }(); //#region src/PostgrestError.ts
        /**
        * Error format
        *
        * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}
        */
        var PostgrestError = /*#__PURE__*/function (_Error3) {
          /**
          * @example
          * ```ts
          * import PostgrestError from '@supabase/postgrest-js'
          *
          * throw new PostgrestError({
          *   message: 'Row level security prevented the request',
          *   details: 'RLS denied the insert',
          *   hint: 'Check your policies',
          *   code: 'PGRST301',
          * })
          * ```
          */
          function PostgrestError(context) {
            var _this65;
            _classCallCheck(this, PostgrestError);
            _this65 = _callSuper(this, PostgrestError, [context.message]);
            _this65.name = "PostgrestError";
            _this65.details = context.details;
            _this65.hint = context.hint;
            _this65.code = context.code;
            return _this65;
          }
          _inherits(PostgrestError, _Error3);
          return _createClass(PostgrestError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));

        //#endregion
        //#region src/PostgrestBuilder.ts
        var PostgrestBuilder = /*#__PURE__*/function () {
          /**
          * Creates a builder configured for a specific PostgREST request.
          *
          * @example
          * ```ts
          * import PostgrestQueryBuilder from '@supabase/postgrest-js'
          *
          * const builder = new PostgrestQueryBuilder(
          *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
          *   { headers: new Headers({ apikey: 'public-anon-key' }) }
          * )
          * ```
          */
          function PostgrestBuilder(builder) {
            _classCallCheck(this, PostgrestBuilder);
            var _builder$shouldThrowO, _builder$isMaybeSingl;
            this.shouldThrowOnError = false;
            this.method = builder.method;
            this.url = builder.url;
            this.headers = new Headers(builder.headers);
            this.schema = builder.schema;
            this.body = builder.body;
            this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;
            this.signal = builder.signal;
            this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;
            if (builder.fetch) this.fetch = builder.fetch;else this.fetch = fetch;
          }
          /**
          * If there's an error with the query, throwOnError will reject the promise by
          * throwing the error instead of returning it as part of a successful response.
          *
          * {@link https://github.com/supabase/supabase-js/issues/92}
          */
          return _createClass(PostgrestBuilder, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /**
            * Set an HTTP header for the request.
            */
          }, {
            key: "setHeader",
            value: function setHeader(name, value) {
              this.headers = new Headers(this.headers);
              this.headers.set(name, value);
              return this;
            }
          }, {
            key: "then",
            value: function then(onfulfilled, onrejected) {
              var _this = this;
              if (this.schema === void 0) ;else if (["GET", "HEAD"].includes(this.method)) this.headers.set("Accept-Profile", this.schema);else this.headers.set("Content-Profile", this.schema);
              if (this.method !== "GET" && this.method !== "HEAD") this.headers.set("Content-Type", "application/json");
              var _fetch = this.fetch;
              var res = _fetch(this.url.toString(), {
                method: this.method,
                headers: this.headers,
                body: JSON.stringify(this.body),
                signal: this.signal
              }).then(/*#__PURE__*/function () {
                var _ref169 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(res$1) {
                  var error, data, count, status, statusText, _this$headers$get2, _res$headers$get, _this$headers$get, body, countHeader, contentRange, _error$details, _body2;
                  return _regenerator().w(function (_context5) {
                    while (1) switch (_context5.n) {
                      case 0:
                        error = null;
                        data = null;
                        count = null;
                        status = res$1.status;
                        statusText = res$1.statusText;
                        if (!res$1.ok) {
                          _context5.n = 3;
                          break;
                        }
                        if (!(_this.method !== "HEAD")) {
                          _context5.n = 2;
                          break;
                        }
                        _context5.n = 1;
                        return res$1.text();
                      case 1:
                        body = _context5.v;
                        if (body === "") ;else if (_this.headers.get("Accept") === "text/csv") data = body;else if (_this.headers.get("Accept") && ((_this$headers$get = _this.headers.get("Accept")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes("application/vnd.pgrst.plan+text"))) data = body;else data = JSON.parse(body);
                      case 2:
                        countHeader = (_this$headers$get2 = _this.headers.get("Prefer")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);
                        contentRange = (_res$headers$get = res$1.headers.get("content-range")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split("/");
                        if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);
                        if (_this.isMaybeSingle && _this.method === "GET" && Array.isArray(data)) if (data.length > 1) {
                          error = {
                            code: "PGRST116",
                            details: "Results contain ".concat(data.length, " rows, application/vnd.pgrst.object+json requires 1 row"),
                            hint: null,
                            message: "JSON object requested, multiple (or no) rows returned"
                          };
                          data = null;
                          count = null;
                          status = 406;
                          statusText = "Not Acceptable";
                        } else if (data.length === 1) data = data[0];else data = null;
                        _context5.n = 5;
                        break;
                      case 3:
                        _context5.n = 4;
                        return res$1.text();
                      case 4:
                        _body2 = _context5.v;
                        try {
                          error = JSON.parse(_body2);
                          if (Array.isArray(error) && res$1.status === 404) {
                            data = [];
                            error = null;
                            status = 200;
                            statusText = "OK";
                          }
                        } catch (_unused) {
                          if (res$1.status === 404 && _body2 === "") {
                            status = 204;
                            statusText = "No Content";
                          } else error = {
                            message: _body2
                          };
                        }
                        if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes("0 rows"))) {
                          error = null;
                          status = 200;
                          statusText = "OK";
                        }
                        if (!(error && _this.shouldThrowOnError)) {
                          _context5.n = 5;
                          break;
                        }
                        throw new PostgrestError(error);
                      case 5:
                        return _context5.a(2, {
                          error: error,
                          data: data,
                          count: count,
                          status: status,
                          statusText: statusText
                        });
                    }
                  }, _callee4);
                }));
                return function (_x8) {
                  return _ref169.apply(this, arguments);
                };
              }());
              if (!this.shouldThrowOnError) res = res.catch(function (fetchError) {
                var _fetchError$name2;
                var errorDetails = "";
                var cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
                if (cause) {
                  var _cause$message, _cause$code, _fetchError$name, _cause$name;
                  var causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : "";
                  var causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : "";
                  errorDetails = "".concat((_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : "FetchError", ": ").concat(fetchError === null || fetchError === void 0 ? void 0 : fetchError.message);
                  errorDetails += "\n\nCaused by: ".concat((_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : "Error", ": ").concat(causeMessage);
                  if (causeCode) errorDetails += " (".concat(causeCode, ")");
                  if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += "\n".concat(cause.stack);
                } else {
                  var _fetchError$stack;
                  errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : "";
                }
                return {
                  error: {
                    message: "".concat((_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : "FetchError", ": ").concat(fetchError === null || fetchError === void 0 ? void 0 : fetchError.message),
                    details: errorDetails,
                    hint: "",
                    code: ""
                  },
                  data: null,
                  count: null,
                  status: 0,
                  statusText: ""
                };
              });
              return res.then(onfulfilled, onrejected);
            }
            /**
            * Override the type of the returned `data`.
            *
            * @typeParam NewResult - The new result type to override with
            * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
            */
          }, {
            key: "returns",
            value: function returns() {
              /* istanbul ignore next */
              return this;
            }
            /**
            * Override the type of the returned `data` field in the response.
            *
            * @typeParam NewResult - The new type to cast the response data to
            * @typeParam Options - Optional type configuration (defaults to { merge: true })
            * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
            * @example
            * ```typescript
            * // Merge with existing types (default behavior)
            * const query = supabase
            *   .from('users')
            *   .select()
            *   .overrideTypes<{ custom_field: string }>()
            *
            * // Replace existing types completely
            * const replaceQuery = supabase
            *   .from('users')
            *   .select()
            *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
            * ```
            * @returns A PostgrestBuilder instance with the new type
            */
          }, {
            key: "overrideTypes",
            value: function overrideTypes() {
              return this;
            }
          }]);
        }();

        //#endregion
        //#region src/PostgrestTransformBuilder.ts
        var PostgrestTransformBuilder = /*#__PURE__*/function (_PostgrestBuilder) {
          function PostgrestTransformBuilder() {
            _classCallCheck(this, PostgrestTransformBuilder);
            return _callSuper(this, PostgrestTransformBuilder, arguments);
          }
          _inherits(PostgrestTransformBuilder, _PostgrestBuilder);
          return _createClass(PostgrestTransformBuilder, [{
            key: "select",
            value:
            /**
            * Perform a SELECT on the query result.
            *
            * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
            * return modified rows. By calling this method, modified rows are returned in
            * `data`.
            *
            * @param columns - The columns to retrieve, separated by commas
            */
            function select(columns) {
              var quoted = false;
              var cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map(function (c) {
                if (/\s/.test(c) && !quoted) return "";
                if (c === "\"") quoted = !quoted;
                return c;
              }).join("");
              this.url.searchParams.set("select", cleanedColumns);
              this.headers.append("Prefer", "return=representation");
              return this;
            }
            /**
            * Order the query result by `column`.
            *
            * You can call this method multiple times to order by multiple columns.
            *
            * You can order referenced tables, but it only affects the ordering of the
            * parent table if you use `!inner` in the query.
            *
            * @param column - The column to order by
            * @param options - Named parameters
            * @param options.ascending - If `true`, the result will be in ascending order
            * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
            * `null`s appear last.
            * @param options.referencedTable - Set this to order a referenced table by
            * its columns
            * @param options.foreignTable - Deprecated, use `options.referencedTable`
            * instead
            */
          }, {
            key: "order",
            value: function order(column) {
              var _ref170 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                _ref170$ascending = _ref170.ascending,
                ascending = _ref170$ascending === void 0 ? true : _ref170$ascending,
                nullsFirst = _ref170.nullsFirst,
                foreignTable = _ref170.foreignTable,
                _ref170$referencedTab = _ref170.referencedTable,
                referencedTable = _ref170$referencedTab === void 0 ? foreignTable : _ref170$referencedTab;
              var key = referencedTable ? "".concat(referencedTable, ".order") : "order";
              var existingOrder = this.url.searchParams.get(key);
              this.url.searchParams.set(key, "".concat(existingOrder ? "".concat(existingOrder, ",") : "").concat(column, ".").concat(ascending ? "asc" : "desc").concat(nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"));
              return this;
            }
            /**
            * Limit the query result by `count`.
            *
            * @param count - The maximum number of rows to return
            * @param options - Named parameters
            * @param options.referencedTable - Set this to limit rows of referenced
            * tables instead of the parent table
            * @param options.foreignTable - Deprecated, use `options.referencedTable`
            * instead
            */
          }, {
            key: "limit",
            value: function limit(count) {
              var _ref171 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                foreignTable = _ref171.foreignTable,
                _ref171$referencedTab = _ref171.referencedTable,
                referencedTable = _ref171$referencedTab === void 0 ? foreignTable : _ref171$referencedTab;
              var key = typeof referencedTable === "undefined" ? "limit" : "".concat(referencedTable, ".limit");
              this.url.searchParams.set(key, "".concat(count));
              return this;
            }
            /**
            * Limit the query result by starting at an offset `from` and ending at the offset `to`.
            * Only records within this range are returned.
            * This respects the query order and if there is no order clause the range could behave unexpectedly.
            * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
            * and fourth rows of the query.
            *
            * @param from - The starting index from which to limit the result
            * @param to - The last index to which to limit the result
            * @param options - Named parameters
            * @param options.referencedTable - Set this to limit rows of referenced
            * tables instead of the parent table
            * @param options.foreignTable - Deprecated, use `options.referencedTable`
            * instead
            */
          }, {
            key: "range",
            value: function range(from, to) {
              var _ref172 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                foreignTable = _ref172.foreignTable,
                _ref172$referencedTab = _ref172.referencedTable,
                referencedTable = _ref172$referencedTab === void 0 ? foreignTable : _ref172$referencedTab;
              var keyOffset = typeof referencedTable === "undefined" ? "offset" : "".concat(referencedTable, ".offset");
              var keyLimit = typeof referencedTable === "undefined" ? "limit" : "".concat(referencedTable, ".limit");
              this.url.searchParams.set(keyOffset, "".concat(from));
              this.url.searchParams.set(keyLimit, "".concat(to - from + 1));
              return this;
            }
            /**
            * Set the AbortSignal for the fetch request.
            *
            * @param signal - The AbortSignal to use for the fetch request
            */
          }, {
            key: "abortSignal",
            value: function abortSignal(signal) {
              this.signal = signal;
              return this;
            }
            /**
            * Return `data` as a single object instead of an array of objects.
            *
            * Query result must be one row (e.g. using `.limit(1)`), otherwise this
            * returns an error.
            */
          }, {
            key: "single",
            value: function single() {
              this.headers.set("Accept", "application/vnd.pgrst.object+json");
              return this;
            }
            /**
            * Return `data` as a single object instead of an array of objects.
            *
            * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
            * this returns an error.
            */
          }, {
            key: "maybeSingle",
            value: function maybeSingle() {
              if (this.method === "GET") this.headers.set("Accept", "application/json");else this.headers.set("Accept", "application/vnd.pgrst.object+json");
              this.isMaybeSingle = true;
              return this;
            }
            /**
            * Return `data` as a string in CSV format.
            */
          }, {
            key: "csv",
            value: function csv() {
              this.headers.set("Accept", "text/csv");
              return this;
            }
            /**
            * Return `data` as an object in [GeoJSON](https://geojson.org) format.
            */
          }, {
            key: "geojson",
            value: function geojson() {
              this.headers.set("Accept", "application/geo+json");
              return this;
            }
            /**
            * Return `data` as the EXPLAIN plan for the query.
            *
            * You need to enable the
            * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
            * setting before using this method.
            *
            * @param options - Named parameters
            *
            * @param options.analyze - If `true`, the query will be executed and the
            * actual run time will be returned
            *
            * @param options.verbose - If `true`, the query identifier will be returned
            * and `data` will include the output columns of the query
            *
            * @param options.settings - If `true`, include information on configuration
            * parameters that affect query planning
            *
            * @param options.buffers - If `true`, include information on buffer usage
            *
            * @param options.wal - If `true`, include information on WAL record generation
            *
            * @param options.format - The format of the output, can be `"text"` (default)
            * or `"json"`
            */
          }, {
            key: "explain",
            value: function explain() {
              var _ref173 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref173$analyze = _ref173.analyze,
                analyze = _ref173$analyze === void 0 ? false : _ref173$analyze,
                _ref173$verbose = _ref173.verbose,
                verbose = _ref173$verbose === void 0 ? false : _ref173$verbose,
                _ref173$settings = _ref173.settings,
                settings = _ref173$settings === void 0 ? false : _ref173$settings,
                _ref173$buffers = _ref173.buffers,
                buffers = _ref173$buffers === void 0 ? false : _ref173$buffers,
                _ref173$wal = _ref173.wal,
                wal = _ref173$wal === void 0 ? false : _ref173$wal,
                _ref173$format = _ref173.format,
                format = _ref173$format === void 0 ? "text" : _ref173$format;
              var _this$headers$get;
              var options = [analyze ? "analyze" : null, verbose ? "verbose" : null, settings ? "settings" : null, buffers ? "buffers" : null, wal ? "wal" : null].filter(Boolean).join("|");
              var forMediatype = (_this$headers$get = this.headers.get("Accept")) !== null && _this$headers$get !== void 0 ? _this$headers$get : "application/json";
              this.headers.set("Accept", "application/vnd.pgrst.plan+".concat(format, "; for=\"").concat(forMediatype, "\"; options=").concat(options, ";"));
              if (format === "json") return this;else return this;
            }
            /**
            * Rollback the query.
            *
            * `data` will still be returned, but the query is not committed.
            */
          }, {
            key: "rollback",
            value: function rollback() {
              this.headers.append("Prefer", "tx=rollback");
              return this;
            }
            /**
            * Override the type of the returned `data`.
            *
            * @typeParam NewResult - The new result type to override with
            * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
            */
          }, {
            key: "returns",
            value: function returns() {
              return this;
            }
            /**
            * Set the maximum number of rows that can be affected by the query.
            * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
            *
            * @param value - The maximum number of rows that can be affected
            */
          }, {
            key: "maxAffected",
            value: function maxAffected(value) {
              this.headers.append("Prefer", "handling=strict");
              this.headers.append("Prefer", "max-affected=".concat(value));
              return this;
            }
          }]);
        }(PostgrestBuilder);

        //#endregion
        //#region src/PostgrestFilterBuilder.ts
        var PostgrestReservedCharsRegexp = /* @__PURE__ */new RegExp("[,()]");
        var PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {
          function PostgrestFilterBuilder() {
            _classCallCheck(this, PostgrestFilterBuilder);
            return _callSuper(this, PostgrestFilterBuilder, arguments);
          }
          _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);
          return _createClass(PostgrestFilterBuilder, [{
            key: "eq",
            value:
            /**
            * Match only rows where `column` is equal to `value`.
            *
            * To check if the value of `column` is NULL, you should use `.is()` instead.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
            function eq(column, value) {
              this.url.searchParams.append(column, "eq.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is not equal to `value`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "neq",
            value: function neq(column, value) {
              this.url.searchParams.append(column, "neq.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is greater than `value`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "gt",
            value: function gt(column, value) {
              this.url.searchParams.append(column, "gt.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is greater than or equal to `value`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "gte",
            value: function gte(column, value) {
              this.url.searchParams.append(column, "gte.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is less than `value`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "lt",
            value: function lt(column, value) {
              this.url.searchParams.append(column, "lt.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is less than or equal to `value`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "lte",
            value: function lte(column, value) {
              this.url.searchParams.append(column, "lte.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` matches `pattern` case-sensitively.
            *
            * @param column - The column to filter on
            * @param pattern - The pattern to match with
            */
          }, {
            key: "like",
            value: function like(column, pattern) {
              this.url.searchParams.append(column, "like.".concat(pattern));
              return this;
            }
            /**
            * Match only rows where `column` matches all of `patterns` case-sensitively.
            *
            * @param column - The column to filter on
            * @param patterns - The patterns to match with
            */
          }, {
            key: "likeAllOf",
            value: function likeAllOf(column, patterns) {
              this.url.searchParams.append(column, "like(all).{".concat(patterns.join(","), "}"));
              return this;
            }
            /**
            * Match only rows where `column` matches any of `patterns` case-sensitively.
            *
            * @param column - The column to filter on
            * @param patterns - The patterns to match with
            */
          }, {
            key: "likeAnyOf",
            value: function likeAnyOf(column, patterns) {
              this.url.searchParams.append(column, "like(any).{".concat(patterns.join(","), "}"));
              return this;
            }
            /**
            * Match only rows where `column` matches `pattern` case-insensitively.
            *
            * @param column - The column to filter on
            * @param pattern - The pattern to match with
            */
          }, {
            key: "ilike",
            value: function ilike(column, pattern) {
              this.url.searchParams.append(column, "ilike.".concat(pattern));
              return this;
            }
            /**
            * Match only rows where `column` matches all of `patterns` case-insensitively.
            *
            * @param column - The column to filter on
            * @param patterns - The patterns to match with
            */
          }, {
            key: "ilikeAllOf",
            value: function ilikeAllOf(column, patterns) {
              this.url.searchParams.append(column, "ilike(all).{".concat(patterns.join(","), "}"));
              return this;
            }
            /**
            * Match only rows where `column` matches any of `patterns` case-insensitively.
            *
            * @param column - The column to filter on
            * @param patterns - The patterns to match with
            */
          }, {
            key: "ilikeAnyOf",
            value: function ilikeAnyOf(column, patterns) {
              this.url.searchParams.append(column, "ilike(any).{".concat(patterns.join(","), "}"));
              return this;
            }
            /**
            * Match only rows where `column` matches the PostgreSQL regex `pattern`
            * case-sensitively (using the `~` operator).
            *
            * @param column - The column to filter on
            * @param pattern - The PostgreSQL regular expression pattern to match with
            */
          }, {
            key: "regexMatch",
            value: function regexMatch(column, pattern) {
              this.url.searchParams.append(column, "match.".concat(pattern));
              return this;
            }
            /**
            * Match only rows where `column` matches the PostgreSQL regex `pattern`
            * case-insensitively (using the `~*` operator).
            *
            * @param column - The column to filter on
            * @param pattern - The PostgreSQL regular expression pattern to match with
            */
          }, {
            key: "regexIMatch",
            value: function regexIMatch(column, pattern) {
              this.url.searchParams.append(column, "imatch.".concat(pattern));
              return this;
            }
            /**
            * Match only rows where `column` IS `value`.
            *
            * For non-boolean columns, this is only relevant for checking if the value of
            * `column` is NULL by setting `value` to `null`.
            *
            * For boolean columns, you can also set `value` to `true` or `false` and it
            * will behave the same way as `.eq()`.
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "is",
            value: function is(column, value) {
              this.url.searchParams.append(column, "is.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` IS DISTINCT FROM `value`.
            *
            * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
            * are considered equal (not distinct), and comparing `NULL` with any non-NULL
            * value returns true (distinct).
            *
            * @param column - The column to filter on
            * @param value - The value to filter with
            */
          }, {
            key: "isDistinct",
            value: function isDistinct(column, value) {
              this.url.searchParams.append(column, "isdistinct.".concat(value));
              return this;
            }
            /**
            * Match only rows where `column` is included in the `values` array.
            *
            * @param column - The column to filter on
            * @param values - The values array to filter with
            */
          }, {
            key: "in",
            value: function _in(column, values) {
              var cleanedValues = Array.from(new Set(values)).map(function (s) {
                if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s)) return "\"".concat(s, "\"");else return "".concat(s);
              }).join(",");
              this.url.searchParams.append(column, "in.(".concat(cleanedValues, ")"));
              return this;
            }
            /**
            * Match only rows where `column` is NOT included in the `values` array.
            *
            * @param column - The column to filter on
            * @param values - The values array to filter with
            */
          }, {
            key: "notIn",
            value: function notIn(column, values) {
              var cleanedValues = Array.from(new Set(values)).map(function (s) {
                if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s)) return "\"".concat(s, "\"");else return "".concat(s);
              }).join(",");
              this.url.searchParams.append(column, "not.in.(".concat(cleanedValues, ")"));
              return this;
            }
            /**
            * Only relevant for jsonb, array, and range columns. Match only rows where
            * `column` contains every element appearing in `value`.
            *
            * @param column - The jsonb, array, or range column to filter on
            * @param value - The jsonb, array, or range value to filter with
            */
          }, {
            key: "contains",
            value: function contains(column, value) {
              if (typeof value === "string") this.url.searchParams.append(column, "cs.".concat(value));else if (Array.isArray(value)) this.url.searchParams.append(column, "cs.{".concat(value.join(","), "}"));else this.url.searchParams.append(column, "cs.".concat(JSON.stringify(value)));
              return this;
            }
            /**
            * Only relevant for jsonb, array, and range columns. Match only rows where
            * every element appearing in `column` is contained by `value`.
            *
            * @param column - The jsonb, array, or range column to filter on
            * @param value - The jsonb, array, or range value to filter with
            */
          }, {
            key: "containedBy",
            value: function containedBy(column, value) {
              if (typeof value === "string") this.url.searchParams.append(column, "cd.".concat(value));else if (Array.isArray(value)) this.url.searchParams.append(column, "cd.{".concat(value.join(","), "}"));else this.url.searchParams.append(column, "cd.".concat(JSON.stringify(value)));
              return this;
            }
            /**
            * Only relevant for range columns. Match only rows where every element in
            * `column` is greater than any element in `range`.
            *
            * @param column - The range column to filter on
            * @param range - The range to filter with
            */
          }, {
            key: "rangeGt",
            value: function rangeGt(column, range) {
              this.url.searchParams.append(column, "sr.".concat(range));
              return this;
            }
            /**
            * Only relevant for range columns. Match only rows where every element in
            * `column` is either contained in `range` or greater than any element in
            * `range`.
            *
            * @param column - The range column to filter on
            * @param range - The range to filter with
            */
          }, {
            key: "rangeGte",
            value: function rangeGte(column, range) {
              this.url.searchParams.append(column, "nxl.".concat(range));
              return this;
            }
            /**
            * Only relevant for range columns. Match only rows where every element in
            * `column` is less than any element in `range`.
            *
            * @param column - The range column to filter on
            * @param range - The range to filter with
            */
          }, {
            key: "rangeLt",
            value: function rangeLt(column, range) {
              this.url.searchParams.append(column, "sl.".concat(range));
              return this;
            }
            /**
            * Only relevant for range columns. Match only rows where every element in
            * `column` is either contained in `range` or less than any element in
            * `range`.
            *
            * @param column - The range column to filter on
            * @param range - The range to filter with
            */
          }, {
            key: "rangeLte",
            value: function rangeLte(column, range) {
              this.url.searchParams.append(column, "nxr.".concat(range));
              return this;
            }
            /**
            * Only relevant for range columns. Match only rows where `column` is
            * mutually exclusive to `range` and there can be no element between the two
            * ranges.
            *
            * @param column - The range column to filter on
            * @param range - The range to filter with
            */
          }, {
            key: "rangeAdjacent",
            value: function rangeAdjacent(column, range) {
              this.url.searchParams.append(column, "adj.".concat(range));
              return this;
            }
            /**
            * Only relevant for array and range columns. Match only rows where
            * `column` and `value` have an element in common.
            *
            * @param column - The array or range column to filter on
            * @param value - The array or range value to filter with
            */
          }, {
            key: "overlaps",
            value: function overlaps(column, value) {
              if (typeof value === "string") this.url.searchParams.append(column, "ov.".concat(value));else this.url.searchParams.append(column, "ov.{".concat(value.join(","), "}"));
              return this;
            }
            /**
            * Only relevant for text and tsvector columns. Match only rows where
            * `column` matches the query string in `query`.
            *
            * @param column - The text or tsvector column to filter on
            * @param query - The query text to match with
            * @param options - Named parameters
            * @param options.config - The text search configuration to use
            * @param options.type - Change how the `query` text is interpreted
            */
          }, {
            key: "textSearch",
            value: function textSearch(column, query) {
              var _ref174 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                config = _ref174.config,
                type = _ref174.type;
              var typePart = "";
              if (type === "plain") typePart = "pl";else if (type === "phrase") typePart = "ph";else if (type === "websearch") typePart = "w";
              var configPart = config === void 0 ? "" : "(".concat(config, ")");
              this.url.searchParams.append(column, "".concat(typePart, "fts").concat(configPart, ".").concat(query));
              return this;
            }
            /**
            * Match only rows where each column in `query` keys is equal to its
            * associated value. Shorthand for multiple `.eq()`s.
            *
            * @param query - The object to filter with, with column names as keys mapped
            * to their filter values
            */
          }, {
            key: "match",
            value: function match(query) {
              var _this66 = this;
              Object.entries(query).forEach(function (_ref175) {
                var _ref176 = _slicedToArray(_ref175, 2),
                  column = _ref176[0],
                  value = _ref176[1];
                _this66.url.searchParams.append(column, "eq.".concat(value));
              });
              return this;
            }
            /**
            * Match only rows which doesn't satisfy the filter.
            *
            * Unlike most filters, `opearator` and `value` are used as-is and need to
            * follow [PostgREST
            * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
            * to make sure they are properly sanitized.
            *
            * @param column - The column to filter on
            * @param operator - The operator to be negated to filter with, following
            * PostgREST syntax
            * @param value - The value to filter with, following PostgREST syntax
            */
          }, {
            key: "not",
            value: function not(column, operator, value) {
              this.url.searchParams.append(column, "not.".concat(operator, ".").concat(value));
              return this;
            }
            /**
            * Match only rows which satisfy at least one of the filters.
            *
            * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
            * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
            * to make sure it's properly sanitized.
            *
            * It's currently not possible to do an `.or()` filter across multiple tables.
            *
            * @param filters - The filters to use, following PostgREST syntax
            * @param options - Named parameters
            * @param options.referencedTable - Set this to filter on referenced tables
            * instead of the parent table
            * @param options.foreignTable - Deprecated, use `referencedTable` instead
            */
          }, {
            key: "or",
            value: function or(filters) {
              var _ref177 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                foreignTable = _ref177.foreignTable,
                _ref177$referencedTab = _ref177.referencedTable,
                referencedTable = _ref177$referencedTab === void 0 ? foreignTable : _ref177$referencedTab;
              var key = referencedTable ? "".concat(referencedTable, ".or") : "or";
              this.url.searchParams.append(key, "(".concat(filters, ")"));
              return this;
            }
            /**
            * Match only rows which satisfy the filter. This is an escape hatch - you
            * should use the specific filter methods wherever possible.
            *
            * Unlike most filters, `opearator` and `value` are used as-is and need to
            * follow [PostgREST
            * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
            * to make sure they are properly sanitized.
            *
            * @param column - The column to filter on
            * @param operator - The operator to filter with, following PostgREST syntax
            * @param value - The value to filter with, following PostgREST syntax
            */
          }, {
            key: "filter",
            value: function filter(column, operator, value) {
              this.url.searchParams.append(column, "".concat(operator, ".").concat(value));
              return this;
            }
          }]);
        }(PostgrestTransformBuilder);

        //#endregion
        //#region src/PostgrestQueryBuilder.ts
        var PostgrestQueryBuilder = /*#__PURE__*/function () {
          /**
          * Creates a query builder scoped to a Postgres table or view.
          *
          * @example
          * ```ts
          * import PostgrestQueryBuilder from '@supabase/postgrest-js'
          *
          * const query = new PostgrestQueryBuilder(
          *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
          *   { headers: { apikey: 'public-anon-key' } }
          * )
          * ```
          */
          function PostgrestQueryBuilder(url, _ref178) {
            var _ref178$headers = _ref178.headers,
              headers = _ref178$headers === void 0 ? {} : _ref178$headers,
              schema = _ref178.schema,
              fetch$1 = _ref178.fetch;
            _classCallCheck(this, PostgrestQueryBuilder);
            this.url = url;
            this.headers = new Headers(headers);
            this.schema = schema;
            this.fetch = fetch$1;
          }
          /**
          * Clone URL and headers to prevent shared state between operations.
          */
          return _createClass(PostgrestQueryBuilder, [{
            key: "cloneRequestState",
            value: function cloneRequestState() {
              return {
                url: new URL(this.url.toString()),
                headers: new Headers(this.headers)
              };
            }
            /**
            * Perform a SELECT query on the table or view.
            *
            * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
            *
            * @param options - Named parameters
            *
            * @param options.head - When set to `true`, `data` will not be returned.
            * Useful if you only need the count.
            *
            * @param options.count - Count algorithm to use to count rows in the table or view.
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            */
          }, {
            key: "select",
            value: function select(columns, options) {
              var _ref179 = options !== null && options !== void 0 ? options : {},
                _ref179$head = _ref179.head,
                head = _ref179$head === void 0 ? false : _ref179$head,
                count = _ref179.count;
              var method = head ? "HEAD" : "GET";
              var quoted = false;
              var cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map(function (c) {
                if (/\s/.test(c) && !quoted) return "";
                if (c === "\"") quoted = !quoted;
                return c;
              }).join("");
              var _this$cloneRequestSta = this.cloneRequestState(),
                url = _this$cloneRequestSta.url,
                headers = _this$cloneRequestSta.headers;
              url.searchParams.set("select", cleanedColumns);
              if (count) headers.append("Prefer", "count=".concat(count));
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schema,
                fetch: this.fetch
              });
            }
            /**
            * Perform an INSERT into the table or view.
            *
            * By default, inserted rows are not returned. To return it, chain the call
            * with `.select()`.
            *
            * @param values - The values to insert. Pass an object to insert a single row
            * or an array to insert multiple rows.
            *
            * @param options - Named parameters
            *
            * @param options.count - Count algorithm to use to count inserted rows.
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            *
            * @param options.defaultToNull - Make missing fields default to `null`.
            * Otherwise, use the default value for the column. Only applies for bulk
            * inserts.
            */
          }, {
            key: "insert",
            value: function insert(values) {
              var _ref180 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                count = _ref180.count,
                _ref180$defaultToNull = _ref180.defaultToNull,
                defaultToNull = _ref180$defaultToNull === void 0 ? true : _ref180$defaultToNull;
              var _this$fetch;
              var method = "POST";
              var _this$cloneRequestSta2 = this.cloneRequestState(),
                url = _this$cloneRequestSta2.url,
                headers = _this$cloneRequestSta2.headers;
              if (count) headers.append("Prefer", "count=".concat(count));
              if (!defaultToNull) headers.append("Prefer", "missing=default");
              if (Array.isArray(values)) {
                var columns = values.reduce(function (acc, x) {
                  return acc.concat(Object.keys(x));
                }, []);
                if (columns.length > 0) {
                  var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {
                    return "\"".concat(column, "\"");
                  });
                  url.searchParams.set("columns", uniqueColumns.join(","));
                }
              }
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schema,
                body: values,
                fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch
              });
            }
            /**
            * Perform an UPSERT on the table or view. Depending on the column(s) passed
            * to `onConflict`, `.upsert()` allows you to perform the equivalent of
            * `.insert()` if a row with the corresponding `onConflict` columns doesn't
            * exist, or if it does exist, perform an alternative action depending on
            * `ignoreDuplicates`.
            *
            * By default, upserted rows are not returned. To return it, chain the call
            * with `.select()`.
            *
            * @param values - The values to upsert with. Pass an object to upsert a
            * single row or an array to upsert multiple rows.
            *
            * @param options - Named parameters
            *
            * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
            * duplicate rows are determined. Two rows are duplicates if all the
            * `onConflict` columns are equal.
            *
            * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
            * `false`, duplicate rows are merged with existing rows.
            *
            * @param options.count - Count algorithm to use to count upserted rows.
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            *
            * @param options.defaultToNull - Make missing fields default to `null`.
            * Otherwise, use the default value for the column. This only applies when
            * inserting new rows, not when merging with existing rows under
            * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
            *
            * @example Upsert a single row using a unique key
            * ```ts
            * // Upserting a single row, overwriting based on the 'username' unique column
            * const { data, error } = await supabase
            *   .from('users')
            *   .upsert({ username: 'supabot' }, { onConflict: 'username' })
            *
            * // Example response:
            * // {
            * //   data: [
            * //     { id: 4, message: 'bar', username: 'supabot' }
            * //   ],
            * //   error: null
            * // }
            * ```
            *
            * @example Upsert with conflict resolution and exact row counting
            * ```ts
            * // Upserting and returning exact count
            * const { data, error, count } = await supabase
            *   .from('users')
            *   .upsert(
            *     {
            *       id: 3,
            *       message: 'foo',
            *       username: 'supabot'
            *     },
            *     {
            *       onConflict: 'username',
            *       count: 'exact'
            *     }
            *   )
            *
            * // Example response:
            * // {
            * //   data: [
            * //     {
            * //       id: 42,
            * //       handle: "saoirse",
            * //       display_name: "Saoirse"
            * //     }
            * //   ],
            * //   count: 1,
            * //   error: null
            * // }
            * ```
            */
          }, {
            key: "upsert",
            value: function upsert(values) {
              var _ref181 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                onConflict = _ref181.onConflict,
                _ref181$ignoreDuplica = _ref181.ignoreDuplicates,
                ignoreDuplicates = _ref181$ignoreDuplica === void 0 ? false : _ref181$ignoreDuplica,
                count = _ref181.count,
                _ref181$defaultToNull = _ref181.defaultToNull,
                defaultToNull = _ref181$defaultToNull === void 0 ? true : _ref181$defaultToNull;
              var _this$fetch2;
              var method = "POST";
              var _this$cloneRequestSta3 = this.cloneRequestState(),
                url = _this$cloneRequestSta3.url,
                headers = _this$cloneRequestSta3.headers;
              headers.append("Prefer", "resolution=".concat(ignoreDuplicates ? "ignore" : "merge", "-duplicates"));
              if (onConflict !== void 0) url.searchParams.set("on_conflict", onConflict);
              if (count) headers.append("Prefer", "count=".concat(count));
              if (!defaultToNull) headers.append("Prefer", "missing=default");
              if (Array.isArray(values)) {
                var columns = values.reduce(function (acc, x) {
                  return acc.concat(Object.keys(x));
                }, []);
                if (columns.length > 0) {
                  var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {
                    return "\"".concat(column, "\"");
                  });
                  url.searchParams.set("columns", uniqueColumns.join(","));
                }
              }
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schema,
                body: values,
                fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch
              });
            }
            /**
            * Perform an UPDATE on the table or view.
            *
            * By default, updated rows are not returned. To return it, chain the call
            * with `.select()` after filters.
            *
            * @param values - The values to update with
            *
            * @param options - Named parameters
            *
            * @param options.count - Count algorithm to use to count updated rows.
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            */
          }, {
            key: "update",
            value: function update(values) {
              var _ref182 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                count = _ref182.count;
              var _this$fetch3;
              var method = "PATCH";
              var _this$cloneRequestSta4 = this.cloneRequestState(),
                url = _this$cloneRequestSta4.url,
                headers = _this$cloneRequestSta4.headers;
              if (count) headers.append("Prefer", "count=".concat(count));
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schema,
                body: values,
                fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch
              });
            }
            /**
            * Perform a DELETE on the table or view.
            *
            * By default, deleted rows are not returned. To return it, chain the call
            * with `.select()` after filters.
            *
            * @param options - Named parameters
            *
            * @param options.count - Count algorithm to use to count deleted rows.
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            */
          }, {
            key: "delete",
            value: function _delete() {
              var _ref183 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                count = _ref183.count;
              var _this$fetch4;
              var method = "DELETE";
              var _this$cloneRequestSta5 = this.cloneRequestState(),
                url = _this$cloneRequestSta5.url,
                headers = _this$cloneRequestSta5.headers;
              if (count) headers.append("Prefer", "count=".concat(count));
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schema,
                fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch
              });
            }
          }]);
        }();

        //#endregion
        //#region src/PostgrestClient.ts
        /**
        * PostgREST client.
        *
        * @typeParam Database - Types for the schema from the [type
        * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
        *
        * @typeParam SchemaName - Postgres schema to switch to. Must be a string
        * literal, the same one passed to the constructor. If the schema is not
        * `"public"`, this must be supplied manually.
        */
        var PostgrestClient = /*#__PURE__*/function () {
          /**
          * Creates a PostgREST client.
          *
          * @param url - URL of the PostgREST endpoint
          * @param options - Named parameters
          * @param options.headers - Custom headers
          * @param options.schema - Postgres schema to switch to
          * @param options.fetch - Custom fetch
          * @example
          * ```ts
          * import PostgrestClient from '@supabase/postgrest-js'
          *
          * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
          *   headers: { apikey: 'public-anon-key' },
          *   schema: 'public',
          * })
          * ```
          */
          function PostgrestClient(url) {
            var _ref184 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref184$headers = _ref184.headers,
              headers = _ref184$headers === void 0 ? {} : _ref184$headers,
              schema = _ref184.schema,
              fetch$1 = _ref184.fetch;
            _classCallCheck(this, PostgrestClient);
            this.url = url;
            this.headers = new Headers(headers);
            this.schemaName = schema;
            this.fetch = fetch$1;
          }
          /**
          * Perform a query on a table or a view.
          *
          * @param relation - The table or view name to query
          */
          return _createClass(PostgrestClient, [{
            key: "from",
            value: function from(relation) {
              if (!relation || typeof relation !== "string" || relation.trim() === "") throw new Error("Invalid relation name: relation must be a non-empty string.");
              return new PostgrestQueryBuilder(new URL("".concat(this.url, "/").concat(relation)), {
                headers: new Headers(this.headers),
                schema: this.schemaName,
                fetch: this.fetch
              });
            }
            /**
            * Select a schema to query or perform an function (rpc) call.
            *
            * The schema needs to be on the list of exposed schemas inside Supabase.
            *
            * @param schema - The schema to query
            */
          }, {
            key: "schema",
            value: function schema(_schema) {
              return new PostgrestClient(this.url, {
                headers: this.headers,
                schema: _schema,
                fetch: this.fetch
              });
            }
            /**
            * Perform a function call.
            *
            * @param fn - The function name to call
            * @param args - The arguments to pass to the function call
            * @param options - Named parameters
            * @param options.head - When set to `true`, `data` will not be returned.
            * Useful if you only need the count.
            * @param options.get - When set to `true`, the function will be called with
            * read-only access mode.
            * @param options.count - Count algorithm to use to count rows returned by the
            * function. Only applicable for [set-returning
            * functions](https://www.postgresql.org/docs/current/functions-srf.html).
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            *
            * @example
            * ```ts
            * // For cross-schema functions where type inference fails, use overrideTypes:
            * const { data } = await supabase
            *   .schema('schema_b')
            *   .rpc('function_a', {})
            *   .overrideTypes<{ id: string; user_id: string }[]>()
            * ```
            */
          }, {
            key: "rpc",
            value: function rpc(fn) {
              var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var _ref185 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref185$head = _ref185.head,
                head = _ref185$head === void 0 ? false : _ref185$head,
                _ref185$get = _ref185.get,
                get = _ref185$get === void 0 ? false : _ref185$get,
                count = _ref185.count;
              var _this$fetch;
              var method;
              var url = new URL("".concat(this.url, "/rpc/").concat(fn));
              var body;
              var _isObject2 = function _isObject(v) {
                return v !== null && _typeof2(v) === "object" && (!Array.isArray(v) || v.some(_isObject2));
              };
              var _hasObjectArg = head && Object.values(args).some(_isObject2);
              if (_hasObjectArg) {
                method = "POST";
                body = args;
              } else if (head || get) {
                method = head ? "HEAD" : "GET";
                Object.entries(args).filter(function (_ref186) {
                  var _ref187 = _slicedToArray(_ref186, 2),
                    _ = _ref187[0],
                    value = _ref187[1];
                  return value !== void 0;
                }).map(function (_ref188) {
                  var _ref189 = _slicedToArray(_ref188, 2),
                    name = _ref189[0],
                    value = _ref189[1];
                  return [name, Array.isArray(value) ? "{".concat(value.join(","), "}") : "".concat(value)];
                }).forEach(function (_ref190) {
                  var _ref191 = _slicedToArray(_ref190, 2),
                    name = _ref191[0],
                    value = _ref191[1];
                  url.searchParams.append(name, value);
                });
              } else {
                method = "POST";
                body = args;
              }
              var headers = new Headers(this.headers);
              if (_hasObjectArg) headers.set("Prefer", count ? "count=".concat(count, ",return=minimal") : "return=minimal");else if (count) headers.set("Prefer", "count=".concat(count));
              return new PostgrestFilterBuilder({
                method: method,
                url: url,
                headers: headers,
                schema: this.schemaName,
                body: body,
                fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch
              });
            }
          }]);
        }();

        /**
         * Utilities for creating WebSocket instances across runtimes.
         */
        var WebSocketFactory = /*#__PURE__*/function () {
          /**
           * Static-only utility  prevent instantiation.
           */
          function WebSocketFactory() {
            _classCallCheck(this, WebSocketFactory);
          }
          return _createClass(WebSocketFactory, null, [{
            key: "detectEnvironment",
            value: function detectEnvironment() {
              var _a;
              if (typeof WebSocket !== 'undefined') {
                return {
                  type: 'native',
                  constructor: WebSocket
                };
              }
              if (typeof globalThis !== 'undefined' && typeof globalThis.WebSocket !== 'undefined') {
                return {
                  type: 'native',
                  constructor: globalThis.WebSocket
                };
              }
              if (typeof global !== 'undefined' && typeof global.WebSocket !== 'undefined') {
                return {
                  type: 'native',
                  constructor: global.WebSocket
                };
              }
              if (typeof globalThis !== 'undefined' && typeof globalThis.WebSocketPair !== 'undefined' && typeof globalThis.WebSocket === 'undefined') {
                return {
                  type: 'cloudflare',
                  error: 'Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.',
                  workaround: 'Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.'
                };
              }
              if (typeof globalThis !== 'undefined' && globalThis.EdgeRuntime || typeof navigator !== 'undefined' && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes('Vercel-Edge'))) {
                return {
                  type: 'unsupported',
                  error: 'Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.',
                  workaround: 'Use serverless functions or a different deployment target for WebSocket functionality.'
                };
              }
              // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings
              var _process = globalThis['process'];
              if (_process) {
                var processVersions = _process['versions'];
                if (processVersions && processVersions['node']) {
                  // Remove 'v' prefix if present and parse the major version
                  var versionString = processVersions['node'];
                  var nodeVersion = parseInt(versionString.replace(/^v/, '').split('.')[0]);
                  // Node.js 22+ should have native WebSocket
                  if (nodeVersion >= 22) {
                    // Check if native WebSocket is available (should be in Node.js 22+)
                    if (typeof globalThis.WebSocket !== 'undefined') {
                      return {
                        type: 'native',
                        constructor: globalThis.WebSocket
                      };
                    }
                    // If not available, user needs to provide it
                    return {
                      type: 'unsupported',
                      error: "Node.js ".concat(nodeVersion, " detected but native WebSocket not found."),
                      workaround: 'Provide a WebSocket implementation via the transport option.'
                    };
                  }
                  // Node.js < 22 doesn't have native WebSocket
                  return {
                    type: 'unsupported',
                    error: "Node.js ".concat(nodeVersion, " detected without native WebSocket support."),
                    workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\n' + 'import ws from "ws"\n' + 'new RealtimeClient(url, { transport: ws })'
                  };
                }
              }
              return {
                type: 'unsupported',
                error: 'Unknown JavaScript runtime without WebSocket support.',
                workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
              };
            }
            /**
             * Returns the best available WebSocket constructor for the current runtime.
             *
             * @example
             * ```ts
             * const WS = WebSocketFactory.getWebSocketConstructor()
             * const socket = new WS('wss://realtime.supabase.co/socket')
             * ```
             */
          }, {
            key: "getWebSocketConstructor",
            value: function getWebSocketConstructor() {
              var env = this.detectEnvironment();
              if (env.constructor) {
                return env.constructor;
              }
              var errorMessage = env.error || 'WebSocket not supported in this environment.';
              if (env.workaround) {
                errorMessage += "\n\nSuggested solution: ".concat(env.workaround);
              }
              throw new Error(errorMessage);
            }
            /**
             * Creates a WebSocket using the detected constructor.
             *
             * @example
             * ```ts
             * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
             * ```
             */
          }, {
            key: "createWebSocket",
            value: function createWebSocket(url, protocols) {
              var WS = this.getWebSocketConstructor();
              return new WS(url, protocols);
            }
            /**
             * Detects whether the runtime can establish WebSocket connections.
             *
             * @example
             * ```ts
             * if (!WebSocketFactory.isWebSocketSupported()) {
             *   console.warn('Falling back to long polling')
             * }
             * ```
             */
          }, {
            key: "isWebSocketSupported",
            value: function isWebSocketSupported() {
              try {
                var env = this.detectEnvironment();
                return env.type === 'native' || env.type === 'ws';
              } catch (_a) {
                return false;
              }
            }
          }]);
        }(); // Generated automatically during releases by scripts/update-version-files.ts
        // This file provides runtime access to the package version for:
        // - HTTP request headers (e.g., X-Client-Info header for API requests)
        // - Debugging and support (identifying which version is running)
        // - Telemetry and logging (version reporting in errors/analytics)
        // - Ensuring build artifacts match the published package version
        var version$3 = '2.90.1';
        var DEFAULT_VERSION = "realtime-js/".concat(version$3);
        var VSN_1_0_0 = '1.0.0';
        var VSN_2_0_0 = '2.0.0';
        var DEFAULT_VSN = VSN_1_0_0;
        var DEFAULT_TIMEOUT = 10000;
        var WS_CLOSE_NORMAL = 1000;
        var MAX_PUSH_BUFFER_SIZE = 100;
        var SOCKET_STATES;
        (function (SOCKET_STATES) {
          SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
          SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
          SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
          SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
        })(SOCKET_STATES || (SOCKET_STATES = {}));
        var CHANNEL_STATES;
        (function (CHANNEL_STATES) {
          CHANNEL_STATES["closed"] = "closed";
          CHANNEL_STATES["errored"] = "errored";
          CHANNEL_STATES["joined"] = "joined";
          CHANNEL_STATES["joining"] = "joining";
          CHANNEL_STATES["leaving"] = "leaving";
        })(CHANNEL_STATES || (CHANNEL_STATES = {}));
        var CHANNEL_EVENTS;
        (function (CHANNEL_EVENTS) {
          CHANNEL_EVENTS["close"] = "phx_close";
          CHANNEL_EVENTS["error"] = "phx_error";
          CHANNEL_EVENTS["join"] = "phx_join";
          CHANNEL_EVENTS["reply"] = "phx_reply";
          CHANNEL_EVENTS["leave"] = "phx_leave";
          CHANNEL_EVENTS["access_token"] = "access_token";
        })(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
        var TRANSPORTS;
        (function (TRANSPORTS) {
          TRANSPORTS["websocket"] = "websocket";
        })(TRANSPORTS || (TRANSPORTS = {}));
        var CONNECTION_STATE;
        (function (CONNECTION_STATE) {
          CONNECTION_STATE["Connecting"] = "connecting";
          CONNECTION_STATE["Open"] = "open";
          CONNECTION_STATE["Closing"] = "closing";
          CONNECTION_STATE["Closed"] = "closed";
        })(CONNECTION_STATE || (CONNECTION_STATE = {}));
        var Serializer = /*#__PURE__*/function () {
          function Serializer(allowedMetadataKeys) {
            _classCallCheck(this, Serializer);
            this.HEADER_LENGTH = 1;
            this.USER_BROADCAST_PUSH_META_LENGTH = 6;
            this.KINDS = {
              userBroadcastPush: 3,
              userBroadcast: 4
            };
            this.BINARY_ENCODING = 0;
            this.JSON_ENCODING = 1;
            this.BROADCAST_EVENT = 'broadcast';
            this.allowedMetadataKeys = [];
            this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
          }
          return _createClass(Serializer, [{
            key: "encode",
            value: function encode(msg, callback) {
              if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === 'string') {
                return callback(this._binaryEncodeUserBroadcastPush(msg));
              }
              var payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
              return callback(JSON.stringify(payload));
            }
          }, {
            key: "_binaryEncodeUserBroadcastPush",
            value: function _binaryEncodeUserBroadcastPush(message) {
              var _a;
              if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {
                return this._encodeBinaryUserBroadcastPush(message);
              } else {
                return this._encodeJsonUserBroadcastPush(message);
              }
            }
          }, {
            key: "_encodeBinaryUserBroadcastPush",
            value: function _encodeBinaryUserBroadcastPush(message) {
              var _a, _b;
              var userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
              return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
            }
          }, {
            key: "_encodeJsonUserBroadcastPush",
            value: function _encodeJsonUserBroadcastPush(message) {
              var _a, _b;
              var userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
              var encoder = new TextEncoder();
              var encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
              return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
            }
          }, {
            key: "_encodeUserBroadcastPush",
            value: function _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
              var _a, _b;
              var topic = message.topic;
              var ref = (_a = message.ref) !== null && _a !== void 0 ? _a : '';
              var joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : '';
              var userEvent = message.payload.event;
              // Filter metadata based on allowed keys
              var rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
              var metadata = Object.keys(rest).length === 0 ? '' : JSON.stringify(rest);
              // Validate lengths don't exceed uint8 max value (255)
              if (joinRef.length > 255) {
                throw new Error("joinRef length ".concat(joinRef.length, " exceeds maximum of 255"));
              }
              if (ref.length > 255) {
                throw new Error("ref length ".concat(ref.length, " exceeds maximum of 255"));
              }
              if (topic.length > 255) {
                throw new Error("topic length ".concat(topic.length, " exceeds maximum of 255"));
              }
              if (userEvent.length > 255) {
                throw new Error("userEvent length ".concat(userEvent.length, " exceeds maximum of 255"));
              }
              if (metadata.length > 255) {
                throw new Error("metadata length ".concat(metadata.length, " exceeds maximum of 255"));
              }
              var metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
              var header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
              var view = new DataView(header);
              var offset = 0;
              view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind
              view.setUint8(offset++, joinRef.length);
              view.setUint8(offset++, ref.length);
              view.setUint8(offset++, topic.length);
              view.setUint8(offset++, userEvent.length);
              view.setUint8(offset++, metadata.length);
              view.setUint8(offset++, encodingType);
              Array.from(joinRef, function (char) {
                return view.setUint8(offset++, char.charCodeAt(0));
              });
              Array.from(ref, function (char) {
                return view.setUint8(offset++, char.charCodeAt(0));
              });
              Array.from(topic, function (char) {
                return view.setUint8(offset++, char.charCodeAt(0));
              });
              Array.from(userEvent, function (char) {
                return view.setUint8(offset++, char.charCodeAt(0));
              });
              Array.from(metadata, function (char) {
                return view.setUint8(offset++, char.charCodeAt(0));
              });
              var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
              combined.set(new Uint8Array(header), 0);
              combined.set(new Uint8Array(encodedPayload), header.byteLength);
              return combined.buffer;
            }
          }, {
            key: "decode",
            value: function decode(rawPayload, callback) {
              if (this._isArrayBuffer(rawPayload)) {
                var result = this._binaryDecode(rawPayload);
                return callback(result);
              }
              if (typeof rawPayload === 'string') {
                var jsonPayload = JSON.parse(rawPayload);
                var _jsonPayload = _slicedToArray(jsonPayload, 5),
                  join_ref = _jsonPayload[0],
                  ref = _jsonPayload[1],
                  topic = _jsonPayload[2],
                  event = _jsonPayload[3],
                  payload = _jsonPayload[4];
                return callback({
                  join_ref: join_ref,
                  ref: ref,
                  topic: topic,
                  event: event,
                  payload: payload
                });
              }
              return callback({});
            }
          }, {
            key: "_binaryDecode",
            value: function _binaryDecode(buffer) {
              var view = new DataView(buffer);
              var kind = view.getUint8(0);
              var decoder = new TextDecoder();
              switch (kind) {
                case this.KINDS.userBroadcast:
                  return this._decodeUserBroadcast(buffer, view, decoder);
              }
            }
          }, {
            key: "_decodeUserBroadcast",
            value: function _decodeUserBroadcast(buffer, view, decoder) {
              var topicSize = view.getUint8(1);
              var userEventSize = view.getUint8(2);
              var metadataSize = view.getUint8(3);
              var payloadEncoding = view.getUint8(4);
              var offset = this.HEADER_LENGTH + 4;
              var topic = decoder.decode(buffer.slice(offset, offset + topicSize));
              offset = offset + topicSize;
              var userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
              offset = offset + userEventSize;
              var metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
              offset = offset + metadataSize;
              var payload = buffer.slice(offset, buffer.byteLength);
              var parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
              var data = {
                type: this.BROADCAST_EVENT,
                event: userEvent,
                payload: parsedPayload
              };
              // Metadata is optional and always JSON encoded
              if (metadataSize > 0) {
                data['meta'] = JSON.parse(metadata);
              }
              return {
                join_ref: null,
                ref: null,
                topic: topic,
                event: this.BROADCAST_EVENT,
                payload: data
              };
            }
          }, {
            key: "_isArrayBuffer",
            value: function _isArrayBuffer(buffer) {
              var _a;
              return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ArrayBuffer';
            }
          }, {
            key: "_pick",
            value: function _pick(obj, keys) {
              if (!obj || _typeof2(obj) !== 'object') {
                return {};
              }
              return Object.fromEntries(Object.entries(obj).filter(function (_ref192) {
                var _ref193 = _slicedToArray(_ref192, 1),
                  key = _ref193[0];
                return keys.includes(key);
              }));
            }
          }]);
        }();
        /**
         * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
         *
         * @example
         *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
         *      return [1000, 5000, 10000][tries - 1] || 10000
         *    })
         *    reconnectTimer.scheduleTimeout() // fires after 1000
         *    reconnectTimer.scheduleTimeout() // fires after 5000
         *    reconnectTimer.reset()
         *    reconnectTimer.scheduleTimeout() // fires after 1000
         */
        var Timer = /*#__PURE__*/function () {
          function Timer(callback, timerCalc) {
            _classCallCheck(this, Timer);
            this.callback = callback;
            this.timerCalc = timerCalc;
            this.timer = undefined;
            this.tries = 0;
            this.callback = callback;
            this.timerCalc = timerCalc;
          }
          return _createClass(Timer, [{
            key: "reset",
            value: function reset() {
              this.tries = 0;
              clearTimeout(this.timer);
              this.timer = undefined;
            }
            // Cancels any previous scheduleTimeout and schedules callback
          }, {
            key: "scheduleTimeout",
            value: function scheduleTimeout() {
              var _this67 = this;
              clearTimeout(this.timer);
              this.timer = setTimeout(function () {
                _this67.tries = _this67.tries + 1;
                _this67.callback();
              }, this.timerCalc(this.tries + 1));
            }
          }]);
        }();
        /**
         * Helpers to convert the change Payload into native JS types.
         */
        // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
        // 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
        var PostgresTypes;
        (function (PostgresTypes) {
          PostgresTypes["abstime"] = "abstime";
          PostgresTypes["bool"] = "bool";
          PostgresTypes["date"] = "date";
          PostgresTypes["daterange"] = "daterange";
          PostgresTypes["float4"] = "float4";
          PostgresTypes["float8"] = "float8";
          PostgresTypes["int2"] = "int2";
          PostgresTypes["int4"] = "int4";
          PostgresTypes["int4range"] = "int4range";
          PostgresTypes["int8"] = "int8";
          PostgresTypes["int8range"] = "int8range";
          PostgresTypes["json"] = "json";
          PostgresTypes["jsonb"] = "jsonb";
          PostgresTypes["money"] = "money";
          PostgresTypes["numeric"] = "numeric";
          PostgresTypes["oid"] = "oid";
          PostgresTypes["reltime"] = "reltime";
          PostgresTypes["text"] = "text";
          PostgresTypes["time"] = "time";
          PostgresTypes["timestamp"] = "timestamp";
          PostgresTypes["timestamptz"] = "timestamptz";
          PostgresTypes["timetz"] = "timetz";
          PostgresTypes["tsrange"] = "tsrange";
          PostgresTypes["tstzrange"] = "tstzrange";
        })(PostgresTypes || (PostgresTypes = {}));
        /**
         * Takes an array of columns and an object of string values then converts each string value
         * to its mapped type.
         *
         * @param {{name: String, type: String}[]} columns
         * @param {Object} record
         * @param {Object} options The map of various options that can be applied to the mapper
         * @param {Array} options.skipTypes The array of types that should not be converted
         *
         * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})
         * //=>{ first_name: 'Paul', age: 33 }
         */
        var convertChangeData = function convertChangeData(columns, record) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _a;
          var skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
          if (!record) {
            return {};
          }
          return Object.keys(record).reduce(function (acc, rec_key) {
            acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
            return acc;
          }, {});
        };
        /**
         * Converts the value of an individual column.
         *
         * @param {String} columnName The column that you want to convert
         * @param {{name: String, type: String}[]} columns All of the columns
         * @param {Object} record The map of string values
         * @param {Array} skipTypes An array of types that should not be converted
         * @return {object} Useless information
         *
         * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])
         * //=> 33
         * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])
         * //=> "33"
         */
        var convertColumn = function convertColumn(columnName, columns, record, skipTypes) {
          var column = columns.find(function (x) {
            return x.name === columnName;
          });
          var colType = column === null || column === void 0 ? void 0 : column.type;
          var value = record[columnName];
          if (colType && !skipTypes.includes(colType)) {
            return convertCell(colType, value);
          }
          return noop$1(value);
        };
        /**
         * If the value of the cell is `null`, returns null.
         * Otherwise converts the string value to the correct type.
         * @param {String} type A postgres column type
         * @param {String} value The cell value
         *
         * @example convertCell('bool', 't')
         * //=> true
         * @example convertCell('int8', '10')
         * //=> 10
         * @example convertCell('_int4', '{1,2,3,4}')
         * //=> [1,2,3,4]
         */
        var convertCell = function convertCell(type, value) {
          // if data type is an array
          if (type.charAt(0) === '_') {
            var dataType = type.slice(1, type.length);
            return toArray(value, dataType);
          }
          // If not null, convert to correct type.
          switch (type) {
            case PostgresTypes.bool:
              return toBoolean(value);
            case PostgresTypes.float4:
            case PostgresTypes.float8:
            case PostgresTypes.int2:
            case PostgresTypes.int4:
            case PostgresTypes.int8:
            case PostgresTypes.numeric:
            case PostgresTypes.oid:
              return toNumber(value);
            case PostgresTypes.json:
            case PostgresTypes.jsonb:
              return toJson(value);
            case PostgresTypes.timestamp:
              return toTimestampString(value);
            // Format to be consistent with PostgREST
            case PostgresTypes.abstime: // To allow users to cast it based on Timezone
            case PostgresTypes.date: // To allow users to cast it based on Timezone
            case PostgresTypes.daterange:
            case PostgresTypes.int4range:
            case PostgresTypes.int8range:
            case PostgresTypes.money:
            case PostgresTypes.reltime: // To allow users to cast it based on Timezone
            case PostgresTypes.text:
            case PostgresTypes.time: // To allow users to cast it based on Timezone
            case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone
            case PostgresTypes.timetz: // To allow users to cast it based on Timezone
            case PostgresTypes.tsrange:
            case PostgresTypes.tstzrange:
              return noop$1(value);
            default:
              // Return the value for remaining types
              return noop$1(value);
          }
        };
        var noop$1 = function noop$1(value) {
          return value;
        };
        var toBoolean = function toBoolean(value) {
          switch (value) {
            case 't':
              return true;
            case 'f':
              return false;
            default:
              return value;
          }
        };
        var toNumber = function toNumber(value) {
          if (typeof value === 'string') {
            var parsedValue = parseFloat(value);
            if (!Number.isNaN(parsedValue)) {
              return parsedValue;
            }
          }
          return value;
        };
        var toJson = function toJson(value) {
          if (typeof value === 'string') {
            try {
              return JSON.parse(value);
            } catch (_a) {
              return value;
            }
          }
          return value;
        };
        /**
         * Converts a Postgres Array into a native JS array
         *
         * @example toArray('{}', 'int4')
         * //=> []
         * @example toArray('{"[2021-01-01,2021-12-31)","(2021-01-01,2021-12-32]"}', 'daterange')
         * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']
         * @example toArray([1,2,3,4], 'int4')
         * //=> [1,2,3,4]
         */
        var toArray = function toArray(value, type) {
          if (typeof value !== 'string') {
            return value;
          }
          var lastIdx = value.length - 1;
          var closeBrace = value[lastIdx];
          var openBrace = value[0];
          // Confirm value is a Postgres array by checking curly brackets
          if (openBrace === '{' && closeBrace === '}') {
            var arr;
            var valTrim = value.slice(1, lastIdx);
            // TODO: find a better solution to separate Postgres array data
            try {
              arr = JSON.parse('[' + valTrim + ']');
            } catch (_) {
              // WARNING: splitting on comma does not cover all edge cases
              arr = valTrim ? valTrim.split(',') : [];
            }
            return arr.map(function (val) {
              return convertCell(type, val);
            });
          }
          return value;
        };
        /**
         * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'
         * See https://github.com/supabase/supabase/issues/18
         *
         * @example toTimestampString('2019-09-10 00:00:00')
         * //=> '2019-09-10T00:00:00'
         */
        var toTimestampString = function toTimestampString(value) {
          if (typeof value === 'string') {
            return value.replace(' ', 'T');
          }
          return value;
        };
        var httpEndpointURL = function httpEndpointURL(socketUrl) {
          var wsUrl = new URL(socketUrl);
          wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');
          wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, '') // remove all trailing slashes
          .replace(/\/socket\/websocket$/i, '') // remove the socket/websocket path
          .replace(/\/socket$/i, '') // remove the socket path
          .replace(/\/websocket$/i, ''); // remove the websocket path
          if (wsUrl.pathname === '' || wsUrl.pathname === '/') {
            wsUrl.pathname = '/api/broadcast';
          } else {
            wsUrl.pathname = wsUrl.pathname + '/api/broadcast';
          }
          return wsUrl.href;
        };
        var Push = /*#__PURE__*/function () {
          /**
           * Initializes the Push
           *
           * @param channel The Channel
           * @param event The event, for example `"phx_join"`
           * @param payload The payload, for example `{user_id: 123}`
           * @param timeout The push timeout in milliseconds
           */
          function Push(channel, event) {
            var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_TIMEOUT;
            _classCallCheck(this, Push);
            this.channel = channel;
            this.event = event;
            this.payload = payload;
            this.timeout = timeout;
            this.sent = false;
            this.timeoutTimer = undefined;
            this.ref = '';
            this.receivedResp = null;
            this.recHooks = [];
            this.refEvent = null;
          }
          return _createClass(Push, [{
            key: "resend",
            value: function resend(timeout) {
              this.timeout = timeout;
              this._cancelRefEvent();
              this.ref = '';
              this.refEvent = null;
              this.receivedResp = null;
              this.sent = false;
              this.send();
            }
          }, {
            key: "send",
            value: function send() {
              if (this._hasReceived('timeout')) {
                return;
              }
              this.startTimeout();
              this.sent = true;
              this.channel.socket.push({
                topic: this.channel.topic,
                event: this.event,
                payload: this.payload,
                ref: this.ref,
                join_ref: this.channel._joinRef()
              });
            }
          }, {
            key: "updatePayload",
            value: function updatePayload(payload) {
              this.payload = Object.assign(Object.assign({}, this.payload), payload);
            }
          }, {
            key: "receive",
            value: function receive(status, callback) {
              var _a;
              if (this._hasReceived(status)) {
                callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
              }
              this.recHooks.push({
                status: status,
                callback: callback
              });
              return this;
            }
          }, {
            key: "startTimeout",
            value: function startTimeout() {
              var _this68 = this;
              if (this.timeoutTimer) {
                return;
              }
              this.ref = this.channel.socket._makeRef();
              this.refEvent = this.channel._replyEventName(this.ref);
              var callback = function callback(payload) {
                _this68._cancelRefEvent();
                _this68._cancelTimeout();
                _this68.receivedResp = payload;
                _this68._matchReceive(payload);
              };
              this.channel._on(this.refEvent, {}, callback);
              this.timeoutTimer = setTimeout(function () {
                _this68.trigger('timeout', {});
              }, this.timeout);
            }
          }, {
            key: "trigger",
            value: function trigger(status, response) {
              if (this.refEvent) this.channel._trigger(this.refEvent, {
                status: status,
                response: response
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this._cancelRefEvent();
              this._cancelTimeout();
            }
          }, {
            key: "_cancelRefEvent",
            value: function _cancelRefEvent() {
              if (!this.refEvent) {
                return;
              }
              this.channel._off(this.refEvent, {});
            }
          }, {
            key: "_cancelTimeout",
            value: function _cancelTimeout() {
              clearTimeout(this.timeoutTimer);
              this.timeoutTimer = undefined;
            }
          }, {
            key: "_matchReceive",
            value: function _matchReceive(_ref194) {
              var status = _ref194.status,
                response = _ref194.response;
              this.recHooks.filter(function (h) {
                return h.status === status;
              }).forEach(function (h) {
                return h.callback(response);
              });
            }
          }, {
            key: "_hasReceived",
            value: function _hasReceived(status) {
              return this.receivedResp && this.receivedResp.status === status;
            }
          }]);
        }();
        /*
          This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
          License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
        */
        var REALTIME_PRESENCE_LISTEN_EVENTS;
        (function (REALTIME_PRESENCE_LISTEN_EVENTS) {
          REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
          REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
          REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
        })(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
        var RealtimePresence = /*#__PURE__*/function () {
          /**
           * Creates a Presence helper that keeps the local presence state in sync with the server.
           *
           * @param channel - The realtime channel to bind to.
           * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.
           *
           * @example
           * ```ts
           * const presence = new RealtimePresence(channel)
           *
           * channel.on('presence', ({ event, key }) => {
           *   console.log(`Presence ${event} on ${key}`)
           * })
           * ```
           */
          function RealtimePresence(channel, opts) {
            var _this69 = this;
            _classCallCheck(this, RealtimePresence);
            this.channel = channel;
            this.state = {};
            this.pendingDiffs = [];
            this.joinRef = null;
            this.enabled = false;
            this.caller = {
              onJoin: function onJoin() {},
              onLeave: function onLeave() {},
              onSync: function onSync() {}
            };
            var events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
              state: 'presence_state',
              diff: 'presence_diff'
            };
            this.channel._on(events.state, {}, function (newState) {
              var _this69$caller = _this69.caller,
                onJoin = _this69$caller.onJoin,
                onLeave = _this69$caller.onLeave,
                onSync = _this69$caller.onSync;
              _this69.joinRef = _this69.channel._joinRef();
              _this69.state = RealtimePresence.syncState(_this69.state, newState, onJoin, onLeave);
              _this69.pendingDiffs.forEach(function (diff) {
                _this69.state = RealtimePresence.syncDiff(_this69.state, diff, onJoin, onLeave);
              });
              _this69.pendingDiffs = [];
              onSync();
            });
            this.channel._on(events.diff, {}, function (diff) {
              var _this69$caller2 = _this69.caller,
                onJoin = _this69$caller2.onJoin,
                onLeave = _this69$caller2.onLeave,
                onSync = _this69$caller2.onSync;
              if (_this69.inPendingSyncState()) {
                _this69.pendingDiffs.push(diff);
              } else {
                _this69.state = RealtimePresence.syncDiff(_this69.state, diff, onJoin, onLeave);
                onSync();
              }
            });
            this.onJoin(function (key, currentPresences, newPresences) {
              _this69.channel._trigger('presence', {
                event: 'join',
                key: key,
                currentPresences: currentPresences,
                newPresences: newPresences
              });
            });
            this.onLeave(function (key, currentPresences, leftPresences) {
              _this69.channel._trigger('presence', {
                event: 'leave',
                key: key,
                currentPresences: currentPresences,
                leftPresences: leftPresences
              });
            });
            this.onSync(function () {
              _this69.channel._trigger('presence', {
                event: 'sync'
              });
            });
          }
          /**
           * Used to sync the list of presences on the server with the
           * client's state.
           *
           * An optional `onJoin` and `onLeave` callback can be provided to
           * react to changes in the client's local presences across
           * disconnects and reconnects with the server.
           *
           * @internal
           */
          return _createClass(RealtimePresence, [{
            key: "onJoin",
            value: /** @internal */
            function onJoin(callback) {
              this.caller.onJoin = callback;
            }
            /** @internal */
          }, {
            key: "onLeave",
            value: function onLeave(callback) {
              this.caller.onLeave = callback;
            }
            /** @internal */
          }, {
            key: "onSync",
            value: function onSync(callback) {
              this.caller.onSync = callback;
            }
            /** @internal */
          }, {
            key: "inPendingSyncState",
            value: function inPendingSyncState() {
              return !this.joinRef || this.joinRef !== this.channel._joinRef();
            }
          }], [{
            key: "syncState",
            value: function syncState(currentState, newState, onJoin, onLeave) {
              var state = this.cloneDeep(currentState);
              var transformedState = this.transformState(newState);
              var joins = {};
              var leaves = {};
              this.map(state, function (key, presences) {
                if (!transformedState[key]) {
                  leaves[key] = presences;
                }
              });
              this.map(transformedState, function (key, newPresences) {
                var currentPresences = state[key];
                if (currentPresences) {
                  var newPresenceRefs = newPresences.map(function (m) {
                    return m.presence_ref;
                  });
                  var curPresenceRefs = currentPresences.map(function (m) {
                    return m.presence_ref;
                  });
                  var joinedPresences = newPresences.filter(function (m) {
                    return curPresenceRefs.indexOf(m.presence_ref) < 0;
                  });
                  var leftPresences = currentPresences.filter(function (m) {
                    return newPresenceRefs.indexOf(m.presence_ref) < 0;
                  });
                  if (joinedPresences.length > 0) {
                    joins[key] = joinedPresences;
                  }
                  if (leftPresences.length > 0) {
                    leaves[key] = leftPresences;
                  }
                } else {
                  joins[key] = newPresences;
                }
              });
              return this.syncDiff(state, {
                joins: joins,
                leaves: leaves
              }, onJoin, onLeave);
            }
            /**
             * Used to sync a diff of presence join and leave events from the
             * server, as they happen.
             *
             * Like `syncState`, `syncDiff` accepts optional `onJoin` and
             * `onLeave` callbacks to react to a user joining or leaving from a
             * device.
             *
             * @internal
             */
          }, {
            key: "syncDiff",
            value: function syncDiff(state, diff, onJoin, onLeave) {
              var _this70 = this;
              var _joins$leaves = {
                  joins: this.transformState(diff.joins),
                  leaves: this.transformState(diff.leaves)
                },
                joins = _joins$leaves.joins,
                leaves = _joins$leaves.leaves;
              if (!onJoin) {
                onJoin = function onJoin() {};
              }
              if (!onLeave) {
                onLeave = function onLeave() {};
              }
              this.map(joins, function (key, newPresences) {
                var _a;
                var currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
                state[key] = _this70.cloneDeep(newPresences);
                if (currentPresences.length > 0) {
                  var _state$key;
                  var joinedPresenceRefs = state[key].map(function (m) {
                    return m.presence_ref;
                  });
                  var curPresences = currentPresences.filter(function (m) {
                    return joinedPresenceRefs.indexOf(m.presence_ref) < 0;
                  });
                  (_state$key = state[key]).unshift.apply(_state$key, _toConsumableArray(curPresences));
                }
                onJoin(key, currentPresences, newPresences);
              });
              this.map(leaves, function (key, leftPresences) {
                var currentPresences = state[key];
                if (!currentPresences) return;
                var presenceRefsToRemove = leftPresences.map(function (m) {
                  return m.presence_ref;
                });
                currentPresences = currentPresences.filter(function (m) {
                  return presenceRefsToRemove.indexOf(m.presence_ref) < 0;
                });
                state[key] = currentPresences;
                onLeave(key, currentPresences, leftPresences);
                if (currentPresences.length === 0) delete state[key];
              });
              return state;
            }
            /** @internal */
          }, {
            key: "map",
            value: function map(obj, func) {
              return Object.getOwnPropertyNames(obj).map(function (key) {
                return func(key, obj[key]);
              });
            }
            /**
             * Remove 'metas' key
             * Change 'phx_ref' to 'presence_ref'
             * Remove 'phx_ref' and 'phx_ref_prev'
             *
             * @example
             * // returns {
             *  abc123: [
             *    { presence_ref: '2', user_id: 1 },
             *    { presence_ref: '3', user_id: 2 }
             *  ]
             * }
             * RealtimePresence.transformState({
             *  abc123: {
             *    metas: [
             *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
             *      { phx_ref: '3', user_id: 2 }
             *    ]
             *  }
             * })
             *
             * @internal
             */
          }, {
            key: "transformState",
            value: function transformState(state) {
              state = this.cloneDeep(state);
              return Object.getOwnPropertyNames(state).reduce(function (newState, key) {
                var presences = state[key];
                if ('metas' in presences) {
                  newState[key] = presences.metas.map(function (presence) {
                    presence['presence_ref'] = presence['phx_ref'];
                    delete presence['phx_ref'];
                    delete presence['phx_ref_prev'];
                    return presence;
                  });
                } else {
                  newState[key] = presences;
                }
                return newState;
              }, {});
            }
            /** @internal */
          }, {
            key: "cloneDeep",
            value: function cloneDeep(obj) {
              return JSON.parse(JSON.stringify(obj));
            }
          }]);
        }();
        var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
        (function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
          REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
          REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
          REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
          REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
        })(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
        var REALTIME_LISTEN_TYPES;
        (function (REALTIME_LISTEN_TYPES) {
          REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
          REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
          REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
          REALTIME_LISTEN_TYPES["SYSTEM"] = "system";
        })(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
        var REALTIME_SUBSCRIBE_STATES;
        (function (REALTIME_SUBSCRIBE_STATES) {
          REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
          REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
          REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
          REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
        })(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
        /** A channel is the basic building block of Realtime
         * and narrows the scope of data flow to subscribed clients.
         * You can think of a channel as a chatroom where participants are able to see who's online
         * and send and receive messages.
         */
        var RealtimeChannel = /*#__PURE__*/function () {
          /**
           * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.
           *
           * The topic determines which realtime stream you are subscribing to. Config options let you
           * enable acknowledgement for broadcasts, presence tracking, or private channels.
           *
           * @example
           * ```ts
           * import RealtimeClient from '@supabase/realtime-js'
           *
           * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
           *   params: { apikey: 'public-anon-key' },
           * })
           * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)
           * ```
           */
          function RealtimeChannel(/** Topic name can be any string. */
          topic) {
            var _this71 = this;
            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              config: {}
            };
            var socket = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, RealtimeChannel);
            var _a, _b;
            this.topic = topic;
            this.params = params;
            this.socket = socket;
            this.bindings = {};
            this.state = CHANNEL_STATES.closed;
            this.joinedOnce = false;
            this.pushBuffer = [];
            this.subTopic = topic.replace(/^realtime:/i, '');
            this.params.config = Object.assign({
              broadcast: {
                ack: false,
                self: false
              },
              presence: {
                key: '',
                enabled: false
              },
              private: false
            }, params.config);
            this.timeout = this.socket.timeout;
            this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
            this.rejoinTimer = new Timer(function () {
              return _this71._rejoinUntilConnected();
            }, this.socket.reconnectAfterMs);
            this.joinPush.receive('ok', function () {
              _this71.state = CHANNEL_STATES.joined;
              _this71.rejoinTimer.reset();
              _this71.pushBuffer.forEach(function (pushEvent) {
                return pushEvent.send();
              });
              _this71.pushBuffer = [];
            });
            this._onClose(function () {
              _this71.rejoinTimer.reset();
              _this71.socket.log('channel', "close ".concat(_this71.topic, " ").concat(_this71._joinRef()));
              _this71.state = CHANNEL_STATES.closed;
              _this71.socket._remove(_this71);
            });
            this._onError(function (reason) {
              if (_this71._isLeaving() || _this71._isClosed()) {
                return;
              }
              _this71.socket.log('channel', "error ".concat(_this71.topic), reason);
              _this71.state = CHANNEL_STATES.errored;
              _this71.rejoinTimer.scheduleTimeout();
            });
            this.joinPush.receive('timeout', function () {
              if (!_this71._isJoining()) {
                return;
              }
              _this71.socket.log('channel', "timeout ".concat(_this71.topic), _this71.joinPush.timeout);
              _this71.state = CHANNEL_STATES.errored;
              _this71.rejoinTimer.scheduleTimeout();
            });
            this.joinPush.receive('error', function (reason) {
              if (_this71._isLeaving() || _this71._isClosed()) {
                return;
              }
              _this71.socket.log('channel', "error ".concat(_this71.topic), reason);
              _this71.state = CHANNEL_STATES.errored;
              _this71.rejoinTimer.scheduleTimeout();
            });
            this._on(CHANNEL_EVENTS.reply, {}, function (payload, ref) {
              _this71._trigger(_this71._replyEventName(ref), payload);
            });
            this.presence = new RealtimePresence(this);
            this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
            this.private = this.params.config.private || false;
            if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
              throw "tried to use replay on public channel '".concat(this.topic, "'. It must be a private channel.");
            }
          }
          /** Subscribe registers your client with the server */
          return _createClass(RealtimeChannel, [{
            key: "subscribe",
            value: function subscribe(callback) {
              var _this72 = this;
              var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;
              var _a, _b, _c;
              if (!this.socket.isConnected()) {
                this.socket.connect();
              }
              if (this.state == CHANNEL_STATES.closed) {
                var _this$params$config = this.params.config,
                  broadcast = _this$params$config.broadcast,
                  presence = _this$params$config.presence,
                  isPrivate = _this$params$config.private;
                var postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(function (r) {
                  return r.filter;
                })) !== null && _b !== void 0 ? _b : [];
                var presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
                var accessTokenPayload = {};
                var _config6 = {
                  broadcast: broadcast,
                  presence: Object.assign(Object.assign({}, presence), {
                    enabled: presence_enabled
                  }),
                  postgres_changes: postgres_changes,
                  private: isPrivate
                };
                if (this.socket.accessTokenValue) {
                  accessTokenPayload.access_token = this.socket.accessTokenValue;
                }
                this._onError(function (e) {
                  return callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e);
                });
                this._onClose(function () {
                  return callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED);
                });
                this.updateJoinPayload(Object.assign({
                  config: _config6
                }, accessTokenPayload));
                this.joinedOnce = true;
                this._rejoin(timeout);
                this.joinPush.receive('ok', /*#__PURE__*/function () {
                  var _ref196 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref195) {
                    var postgres_changes, _a, clientPostgresBindings, bindingsLen, newPostgresBindings, i, clientPostgresBinding, _clientPostgresBindin, event, schema, table, _filter2, serverPostgresFilter;
                    return _regenerator().w(function (_context6) {
                      while (1) switch (_context6.n) {
                        case 0:
                          postgres_changes = _ref195.postgres_changes;
                          // Only refresh auth if using callback-based tokens
                          if (!_this72.socket._isManualToken()) {
                            _this72.socket.setAuth();
                          }
                          if (!(postgres_changes === undefined)) {
                            _context6.n = 1;
                            break;
                          }
                          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
                          return _context6.a(2);
                        case 1:
                          clientPostgresBindings = _this72.bindings.postgres_changes;
                          bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
                          newPostgresBindings = [];
                          i = 0;
                        case 2:
                          if (!(i < bindingsLen)) {
                            _context6.n = 5;
                            break;
                          }
                          clientPostgresBinding = clientPostgresBindings[i];
                          _clientPostgresBindin = clientPostgresBinding.filter, event = _clientPostgresBindin.event, schema = _clientPostgresBindin.schema, table = _clientPostgresBindin.table, _filter2 = _clientPostgresBindin.filter;
                          serverPostgresFilter = postgres_changes && postgres_changes[i];
                          if (!(serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, _filter2))) {
                            _context6.n = 3;
                            break;
                          }
                          newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                            id: serverPostgresFilter.id
                          }));
                          _context6.n = 4;
                          break;
                        case 3:
                          _this72.unsubscribe();
                          _this72.state = CHANNEL_STATES.errored;
                          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));
                          return _context6.a(2);
                        case 4:
                          i++;
                          _context6.n = 2;
                          break;
                        case 5:
                          _this72.bindings.postgres_changes = newPostgresBindings;
                          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
                          return _context6.a(2);
                        case 6:
                          return _context6.a(2);
                      }
                    }, _callee5);
                  }));
                  return function (_x9) {
                    return _ref196.apply(this, arguments);
                  };
                }()).receive('error', function (error) {
                  _this72.state = CHANNEL_STATES.errored;
                  callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));
                  return;
                }).receive('timeout', function () {
                  callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
                  return;
                });
              }
              return this;
            }
            /**
             * Returns the current presence state for this channel.
             *
             * The shape is a map keyed by presence key (for example a user id) where each entry contains the
             * tracked metadata for that user.
             */
          }, {
            key: "presenceState",
            value: function presenceState() {
              return this.presence.state;
            }
            /**
             * Sends the supplied payload to the presence tracker so other subscribers can see that this
             * client is online. Use `untrack` to stop broadcasting presence for the same key.
             */
          }, {
            key: "track",
            value: (function () {
              var _track = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(payload) {
                var opts,
                  _args6 = arguments;
                return _regenerator().w(function (_context7) {
                  while (1) switch (_context7.n) {
                    case 0:
                      opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                      _context7.n = 1;
                      return this.send({
                        type: 'presence',
                        event: 'track',
                        payload: payload
                      }, opts.timeout || this.timeout);
                    case 1:
                      return _context7.a(2, _context7.v);
                  }
                }, _callee6, this);
              }));
              function track(_x0) {
                return _track.apply(this, arguments);
              }
              return track;
            }()
            /**
             * Removes the current presence state for this client.
             */
            )
          }, {
            key: "untrack",
            value: (function () {
              var _untrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
                var opts,
                  _args7 = arguments;
                return _regenerator().w(function (_context8) {
                  while (1) switch (_context8.n) {
                    case 0:
                      opts = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
                      _context8.n = 1;
                      return this.send({
                        type: 'presence',
                        event: 'untrack'
                      }, opts);
                    case 1:
                      return _context8.a(2, _context8.v);
                  }
                }, _callee7, this);
              }));
              function untrack() {
                return _untrack.apply(this, arguments);
              }
              return untrack;
            }())
          }, {
            key: "on",
            value: function on(type, filter, callback) {
              var _this73 = this;
              if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
                this.socket.log('channel', "resubscribe to ".concat(this.topic, " due to change in presence callbacks on joined channel"));
                this.unsubscribe().then(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
                  return _regenerator().w(function (_context9) {
                    while (1) switch (_context9.n) {
                      case 0:
                        _context9.n = 1;
                        return _this73.subscribe();
                      case 1:
                        return _context9.a(2, _context9.v);
                    }
                  }, _callee8);
                })));
              }
              return this._on(type, filter, callback);
            }
            /**
             * Sends a broadcast message explicitly via REST API.
             *
             * This method always uses the REST API endpoint regardless of WebSocket connection state.
             * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
             *
             * @param event The name of the broadcast event
             * @param payload Payload to be sent (required)
             * @param opts Options including timeout
             * @returns Promise resolving to object with success status, and error details if failed
             */
          }, {
            key: "httpSend",
            value: (function () {
              var _httpSend = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(event, payload) {
                var opts,
                  _a,
                  headers,
                  options,
                  response,
                  errorMessage,
                  errorBody,
                  _args9 = arguments,
                  _t2;
                return _regenerator().w(function (_context0) {
                  while (1) switch (_context0.p = _context0.n) {
                    case 0:
                      opts = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};
                      if (!(payload === undefined || payload === null)) {
                        _context0.n = 1;
                        break;
                      }
                      return _context0.a(2, Promise.reject('Payload is required for httpSend()'));
                    case 1:
                      headers = {
                        apikey: this.socket.apiKey ? this.socket.apiKey : '',
                        'Content-Type': 'application/json'
                      };
                      if (this.socket.accessTokenValue) {
                        headers['Authorization'] = "Bearer ".concat(this.socket.accessTokenValue);
                      }
                      options = {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                          messages: [{
                            topic: this.subTopic,
                            event: event,
                            payload: payload,
                            private: this.private
                          }]
                        })
                      };
                      _context0.n = 2;
                      return this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
                    case 2:
                      response = _context0.v;
                      if (!(response.status === 202)) {
                        _context0.n = 3;
                        break;
                      }
                      return _context0.a(2, {
                        success: true
                      });
                    case 3:
                      errorMessage = response.statusText;
                      _context0.p = 4;
                      _context0.n = 5;
                      return response.json();
                    case 5:
                      errorBody = _context0.v;
                      errorMessage = errorBody.error || errorBody.message || errorMessage;
                      _context0.n = 7;
                      break;
                    case 6:
                      _context0.p = 6;
                      _t2 = _context0.v;
                    case 7:
                      return _context0.a(2, Promise.reject(new Error(errorMessage)));
                  }
                }, _callee9, this, [[4, 6]]);
              }));
              function httpSend(_x1, _x10) {
                return _httpSend.apply(this, arguments);
              }
              return httpSend;
            }()
            /**
             * Sends a message into the channel.
             *
             * @param args Arguments to send to channel
             * @param args.type The type of event to send
             * @param args.event The name of the event being sent
             * @param args.payload Payload to be sent
             * @param opts Options to be used during the send process
             */
            )
          }, {
            key: "send",
            value: (function () {
              var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(args) {
                var _this74 = this;
                var opts,
                  _a,
                  _b,
                  event,
                  endpoint_payload,
                  headers,
                  options,
                  response,
                  _args0 = arguments,
                  _t3;
                return _regenerator().w(function (_context1) {
                  while (1) switch (_context1.p = _context1.n) {
                    case 0:
                      opts = _args0.length > 1 && _args0[1] !== undefined ? _args0[1] : {};
                      if (!(!this._canPush() && args.type === 'broadcast')) {
                        _context1.n = 7;
                        break;
                      }
                      console.warn('Realtime send() is automatically falling back to REST API. ' + 'This behavior will be deprecated in the future. ' + 'Please use httpSend() explicitly for REST delivery.');
                      event = args.event, endpoint_payload = args.payload;
                      headers = {
                        apikey: this.socket.apiKey ? this.socket.apiKey : '',
                        'Content-Type': 'application/json'
                      };
                      if (this.socket.accessTokenValue) {
                        headers['Authorization'] = "Bearer ".concat(this.socket.accessTokenValue);
                      }
                      options = {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                          messages: [{
                            topic: this.subTopic,
                            event: event,
                            payload: endpoint_payload,
                            private: this.private
                          }]
                        })
                      };
                      _context1.p = 1;
                      _context1.n = 2;
                      return this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
                    case 2:
                      response = _context1.v;
                      _context1.n = 3;
                      return (_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel();
                    case 3:
                      return _context1.a(2, response.ok ? 'ok' : 'error');
                    case 4:
                      _context1.p = 4;
                      _t3 = _context1.v;
                      if (!(_t3.name === 'AbortError')) {
                        _context1.n = 5;
                        break;
                      }
                      return _context1.a(2, 'timed out');
                    case 5:
                      return _context1.a(2, 'error');
                    case 6:
                      _context1.n = 8;
                      break;
                    case 7:
                      return _context1.a(2, new Promise(function (resolve) {
                        var _a, _b, _c;
                        var push = _this74._push(args.type, args, opts.timeout || _this74.timeout);
                        if (args.type === 'broadcast' && !((_c = (_b = (_a = _this74.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
                          resolve('ok');
                        }
                        push.receive('ok', function () {
                          return resolve('ok');
                        });
                        push.receive('error', function () {
                          return resolve('error');
                        });
                        push.receive('timeout', function () {
                          return resolve('timed out');
                        });
                      }));
                    case 8:
                      return _context1.a(2);
                  }
                }, _callee0, this, [[1, 4]]);
              }));
              function send(_x11) {
                return _send.apply(this, arguments);
              }
              return send;
            }()
            /**
             * Updates the payload that will be sent the next time the channel joins (reconnects).
             * Useful for rotating access tokens or updating config without re-creating the channel.
             */
            )
          }, {
            key: "updateJoinPayload",
            value: function updateJoinPayload(payload) {
              this.joinPush.updatePayload(payload);
            }
            /**
             * Leaves the channel.
             *
             * Unsubscribes from server events, and instructs channel to terminate on server.
             * Triggers onClose() hooks.
             *
             * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
             * channel.unsubscribe().receive("ok", () => alert("left!") )
             */
          }, {
            key: "unsubscribe",
            value: function unsubscribe() {
              var _this75 = this;
              var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;
              this.state = CHANNEL_STATES.leaving;
              var onClose = function onClose() {
                _this75.socket.log('channel', "leave ".concat(_this75.topic));
                _this75._trigger(CHANNEL_EVENTS.close, 'leave', _this75._joinRef());
              };
              this.joinPush.destroy();
              var leavePush = null;
              return new Promise(function (resolve) {
                leavePush = new Push(_this75, CHANNEL_EVENTS.leave, {}, timeout);
                leavePush.receive('ok', function () {
                  onClose();
                  resolve('ok');
                }).receive('timeout', function () {
                  onClose();
                  resolve('timed out');
                }).receive('error', function () {
                  resolve('error');
                });
                leavePush.send();
                if (!_this75._canPush()) {
                  leavePush.trigger('ok', {});
                }
              }).finally(function () {
                leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
              });
            }
            /**
             * Teardown the channel.
             *
             * Destroys and stops related timers.
             */
          }, {
            key: "teardown",
            value: function teardown() {
              this.pushBuffer.forEach(function (push) {
                return push.destroy();
              });
              this.pushBuffer = [];
              this.rejoinTimer.reset();
              this.joinPush.destroy();
              this.state = CHANNEL_STATES.closed;
              this.bindings = {};
            }
            /** @internal */
          }, {
            key: "_fetchWithTimeout",
            value: (function () {
              var _fetchWithTimeout2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(url, options, timeout) {
                var controller, id, response;
                return _regenerator().w(function (_context10) {
                  while (1) switch (_context10.n) {
                    case 0:
                      controller = new AbortController();
                      id = setTimeout(function () {
                        return controller.abort();
                      }, timeout);
                      _context10.n = 1;
                      return this.socket.fetch(url, Object.assign(Object.assign({}, options), {
                        signal: controller.signal
                      }));
                    case 1:
                      response = _context10.v;
                      clearTimeout(id);
                      return _context10.a(2, response);
                  }
                }, _callee1, this);
              }));
              function _fetchWithTimeout(_x12, _x13, _x14) {
                return _fetchWithTimeout2.apply(this, arguments);
              }
              return _fetchWithTimeout;
            }() /** @internal */)
          }, {
            key: "_push",
            value: function _push(event, payload) {
              var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;
              if (!this.joinedOnce) {
                throw "tried to push '".concat(event, "' to '").concat(this.topic, "' before joining. Use channel.subscribe() before pushing events");
              }
              var pushEvent = new Push(this, event, payload, timeout);
              if (this._canPush()) {
                pushEvent.send();
              } else {
                this._addToPushBuffer(pushEvent);
              }
              return pushEvent;
            }
            /** @internal */
          }, {
            key: "_addToPushBuffer",
            value: function _addToPushBuffer(pushEvent) {
              pushEvent.startTimeout();
              this.pushBuffer.push(pushEvent);
              // Enforce buffer size limit
              if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
                var removedPush = this.pushBuffer.shift();
                if (removedPush) {
                  removedPush.destroy();
                  this.socket.log('channel', "discarded push due to buffer overflow: ".concat(removedPush.event), removedPush.payload);
                }
              }
            }
            /**
             * Overridable message hook
             *
             * Receives all events for specialized message handling before dispatching to the channel callbacks.
             * Must return the payload, modified or unmodified.
             *
             * @internal
             */
          }, {
            key: "_onMessage",
            value: function _onMessage(_event, payload, _ref) {
              return payload;
            }
            /** @internal */
          }, {
            key: "_isMember",
            value: function _isMember(topic) {
              return this.topic === topic;
            }
            /** @internal */
          }, {
            key: "_joinRef",
            value: function _joinRef() {
              return this.joinPush.ref;
            }
            /** @internal */
          }, {
            key: "_trigger",
            value: function _trigger(type, payload, ref) {
              var _this76 = this;
              var _a, _b;
              var typeLower = type.toLocaleLowerCase();
              var _CHANNEL_EVENTS = CHANNEL_EVENTS,
                close = _CHANNEL_EVENTS.close,
                error = _CHANNEL_EVENTS.error,
                leave = _CHANNEL_EVENTS.leave,
                join = _CHANNEL_EVENTS.join;
              var events = [close, error, leave, join];
              if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
                return;
              }
              var handledPayload = this._onMessage(typeLower, payload, ref);
              if (payload && !handledPayload) {
                throw 'channel onMessage callbacks must return the payload, modified or unmodified';
              }
              if (['insert', 'update', 'delete'].includes(typeLower)) {
                (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(function (bind) {
                  var _a, _b, _c;
                  return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
                }).map(function (bind) {
                  return bind.callback(handledPayload, ref);
                });
              } else {
                (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(function (bind) {
                  var _a, _b, _c, _d, _e, _f, _g, _h;
                  if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {
                    if ('id' in bind) {
                      var bindId = bind.id;
                      var bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
                      return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())) && (!((_d = bind.filter) === null || _d === void 0 ? void 0 : _d.table) || bind.filter.table === ((_e = payload.data) === null || _e === void 0 ? void 0 : _e.table));
                    } else {
                      var _bindEvent = (_g = (_f = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _f === void 0 ? void 0 : _f.event) === null || _g === void 0 ? void 0 : _g.toLocaleLowerCase();
                      return _bindEvent === '*' || _bindEvent === ((_h = payload === null || payload === void 0 ? void 0 : payload.event) === null || _h === void 0 ? void 0 : _h.toLocaleLowerCase());
                    }
                  } else {
                    return bind.type.toLocaleLowerCase() === typeLower;
                  }
                }).map(function (bind) {
                  if (_typeof2(handledPayload) === 'object' && 'ids' in handledPayload) {
                    var postgresChanges = handledPayload.data;
                    var schema = postgresChanges.schema,
                      table = postgresChanges.table,
                      commit_timestamp = postgresChanges.commit_timestamp,
                      _type2 = postgresChanges.type,
                      errors = postgresChanges.errors;
                    var enrichedPayload = {
                      schema: schema,
                      table: table,
                      commit_timestamp: commit_timestamp,
                      eventType: _type2,
                      new: {},
                      old: {},
                      errors: errors
                    };
                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), _this76._getPayloadRecords(postgresChanges));
                  }
                  bind.callback(handledPayload, ref);
                });
              }
            }
            /** @internal */
          }, {
            key: "_isClosed",
            value: function _isClosed() {
              return this.state === CHANNEL_STATES.closed;
            }
            /** @internal */
          }, {
            key: "_isJoined",
            value: function _isJoined() {
              return this.state === CHANNEL_STATES.joined;
            }
            /** @internal */
          }, {
            key: "_isJoining",
            value: function _isJoining() {
              return this.state === CHANNEL_STATES.joining;
            }
            /** @internal */
          }, {
            key: "_isLeaving",
            value: function _isLeaving() {
              return this.state === CHANNEL_STATES.leaving;
            }
            /** @internal */
          }, {
            key: "_replyEventName",
            value: function _replyEventName(ref) {
              return "chan_reply_".concat(ref);
            }
            /** @internal */
          }, {
            key: "_on",
            value: function _on(type, filter, callback) {
              var typeLower = type.toLocaleLowerCase();
              var binding = {
                type: typeLower,
                filter: filter,
                callback: callback
              };
              if (this.bindings[typeLower]) {
                this.bindings[typeLower].push(binding);
              } else {
                this.bindings[typeLower] = [binding];
              }
              return this;
            }
            /** @internal */
          }, {
            key: "_off",
            value: function _off(type, filter) {
              var typeLower = type.toLocaleLowerCase();
              if (this.bindings[typeLower]) {
                this.bindings[typeLower] = this.bindings[typeLower].filter(function (bind) {
                  var _a;
                  return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
                });
              }
              return this;
            }
            /** @internal */
          }, {
            key: "_rejoinUntilConnected",
            value: /** @internal */
            function _rejoinUntilConnected() {
              this.rejoinTimer.scheduleTimeout();
              if (this.socket.isConnected()) {
                this._rejoin();
              }
            }
            /**
             * Registers a callback that will be executed when the channel closes.
             *
             * @internal
             */
          }, {
            key: "_onClose",
            value: function _onClose(callback) {
              this._on(CHANNEL_EVENTS.close, {}, callback);
            }
            /**
             * Registers a callback that will be executed when the channel encounteres an error.
             *
             * @internal
             */
          }, {
            key: "_onError",
            value: function _onError(callback) {
              this._on(CHANNEL_EVENTS.error, {}, function (reason) {
                return callback(reason);
              });
            }
            /**
             * Returns `true` if the socket is connected and the channel has been joined.
             *
             * @internal
             */
          }, {
            key: "_canPush",
            value: function _canPush() {
              return this.socket.isConnected() && this._isJoined();
            }
            /** @internal */
          }, {
            key: "_rejoin",
            value: function _rejoin() {
              var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;
              if (this._isLeaving()) {
                return;
              }
              this.socket._leaveOpenTopic(this.topic);
              this.state = CHANNEL_STATES.joining;
              this.joinPush.resend(timeout);
            }
            /** @internal */
          }, {
            key: "_getPayloadRecords",
            value: function _getPayloadRecords(payload) {
              var records = {
                new: {},
                old: {}
              };
              if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
                records.new = convertChangeData(payload.columns, payload.record);
              }
              if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
                records.old = convertChangeData(payload.columns, payload.old_record);
              }
              return records;
            }
          }], [{
            key: "isEqual",
            value: function isEqual(obj1, obj2) {
              if (Object.keys(obj1).length !== Object.keys(obj2).length) {
                return false;
              }
              for (var _k3 in obj1) {
                if (obj1[_k3] !== obj2[_k3]) {
                  return false;
                }
              }
              return true;
            }
            /**
             * Compares two optional filter values for equality.
             * Treats undefined, null, and empty string as equivalent empty values.
             * @internal
             */
          }, {
            key: "isFilterValueEqual",
            value: function isFilterValueEqual(serverValue, clientValue) {
              var normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;
              var normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;
              return normalizedServer === normalizedClient;
            }
          }]);
        }();
        var noop = function noop() {};
        // Connection-related constants
        var CONNECTION_TIMEOUTS = {
          HEARTBEAT_INTERVAL: 25000,
          RECONNECT_DELAY: 10,
          HEARTBEAT_TIMEOUT_FALLBACK: 100
        };
        var RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];
        var DEFAULT_RECONNECT_FALLBACK = 10000;
        var WORKER_SCRIPT = "\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });";
        var RealtimeClient = /*#__PURE__*/function () {
          /**
           * Initializes the Socket.
           *
           * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
           * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
           * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
           * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
           * @param options.params The optional params to pass when connecting.
           * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
           * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
           * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.
           * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
           * @param options.logLevel Sets the log level for Realtime
           * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
           * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
           * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
           * @param options.worker Use Web Worker to set a side flow. Defaults to false.
           * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
           * @example
           * ```ts
           * import RealtimeClient from '@supabase/realtime-js'
           *
           * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
           *   params: { apikey: 'public-anon-key' },
           * })
           * client.connect()
           * ```
           */
          function RealtimeClient(endPoint, options) {
            _classCallCheck(this, RealtimeClient);
            var _a;
            this.accessTokenValue = null;
            this.apiKey = null;
            this._manuallySetToken = false;
            this.channels = new Array();
            this.endPoint = '';
            this.httpEndpoint = '';
            /** @deprecated headers cannot be set on websocket connections */
            this.headers = {};
            this.params = {};
            this.timeout = DEFAULT_TIMEOUT;
            this.transport = null;
            this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
            this.heartbeatTimer = undefined;
            this.pendingHeartbeatRef = null;
            this.heartbeatCallback = noop;
            this.ref = 0;
            this.reconnectTimer = null;
            this.vsn = DEFAULT_VSN;
            this.logger = noop;
            this.conn = null;
            this.sendBuffer = [];
            this.serializer = new Serializer();
            this.stateChangeCallbacks = {
              open: [],
              close: [],
              error: [],
              message: []
            };
            this.accessToken = null;
            this._connectionState = 'disconnected';
            this._wasManualDisconnect = false;
            this._authPromise = null;
            this._heartbeatSentAt = null;
            /**
             * Use either custom fetch, if provided, or default fetch to make HTTP requests
             *
             * @internal
             */
            this._resolveFetch = function (customFetch) {
              if (customFetch) {
                return function () {
                  return customFetch.apply(void 0, arguments);
                };
              }
              return function () {
                return fetch.apply(void 0, arguments);
              };
            };
            // Validate required parameters
            if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {
              throw new Error('API key is required to connect to Realtime');
            }
            this.apiKey = options.params.apikey;
            // Initialize endpoint URLs
            this.endPoint = "".concat(endPoint, "/").concat(TRANSPORTS.websocket);
            this.httpEndpoint = httpEndpointURL(endPoint);
            this._initializeOptions(options);
            this._setupReconnectionTimer();
            this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
          }
          /**
           * Connects the socket, unless already connected.
           */
          return _createClass(RealtimeClient, [{
            key: "connect",
            value: function connect() {
              // Skip if already connecting, disconnecting, or connected
              if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
                return;
              }
              this._setConnectionState('connecting');
              // Trigger auth if needed and not already in progress
              // This ensures auth is called for standalone RealtimeClient usage
              // while avoiding race conditions with SupabaseClient's immediate setAuth call
              if (this.accessToken && !this._authPromise) {
                this._setAuthSafely('connect');
              }
              // Establish WebSocket connection
              if (this.transport) {
                // Use custom transport if provided
                this.conn = new this.transport(this.endpointURL());
              } else {
                // Try to use native WebSocket
                try {
                  this.conn = WebSocketFactory.createWebSocket(this.endpointURL());
                } catch (error) {
                  this._setConnectionState('disconnected');
                  var errorMessage = error.message;
                  // Provide helpful error message based on environment
                  if (errorMessage.includes('Node.js')) {
                    throw new Error("".concat(errorMessage, "\n\n") + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\n\n' + 'Option 1: Use Node.js 22+ which has native WebSocket support\n' + 'Option 2: Install and provide the "ws" package:\n\n' + '  npm install ws\n\n' + '  import ws from "ws"\n' + '  const client = new RealtimeClient(url, {\n' + '    ...options,\n' + '    transport: ws\n' + '  })');
                  }
                  throw new Error("WebSocket not available: ".concat(errorMessage));
                }
              }
              this._setupConnectionHandlers();
            }
            /**
             * Returns the URL of the websocket.
             * @returns string The URL of the websocket.
             */
          }, {
            key: "endpointURL",
            value: function endpointURL() {
              return this._appendParams(this.endPoint, Object.assign({}, this.params, {
                vsn: this.vsn
              }));
            }
            /**
             * Disconnects the socket.
             *
             * @param code A numeric status code to send on disconnect.
             * @param reason A custom reason for the disconnect.
             */
          }, {
            key: "disconnect",
            value: function disconnect(code, reason) {
              var _this77 = this;
              if (this.isDisconnecting()) {
                return;
              }
              this._setConnectionState('disconnecting', true);
              if (this.conn) {
                // Setup fallback timer to prevent hanging in disconnecting state
                var fallbackTimer = setTimeout(function () {
                  _this77._setConnectionState('disconnected');
                }, 100);
                this.conn.onclose = function () {
                  clearTimeout(fallbackTimer);
                  _this77._setConnectionState('disconnected');
                };
                // Close the WebSocket connection if close method exists
                if (typeof this.conn.close === 'function') {
                  if (code) {
                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');
                  } else {
                    this.conn.close();
                  }
                }
                this._teardownConnection();
              } else {
                this._setConnectionState('disconnected');
              }
            }
            /**
             * Returns all created channels
             */
          }, {
            key: "getChannels",
            value: function getChannels() {
              return this.channels;
            }
            /**
             * Unsubscribes and removes a single channel
             * @param channel A RealtimeChannel instance
             */
          }, {
            key: "removeChannel",
            value: (function () {
              var _removeChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(channel) {
                var status;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      _context11.n = 1;
                      return channel.unsubscribe();
                    case 1:
                      status = _context11.v;
                      if (this.channels.length === 0) {
                        this.disconnect();
                      }
                      return _context11.a(2, status);
                  }
                }, _callee10, this);
              }));
              function removeChannel(_x15) {
                return _removeChannel.apply(this, arguments);
              }
              return removeChannel;
            }()
            /**
             * Unsubscribes and removes all channels
             */
            )
          }, {
            key: "removeAllChannels",
            value: (function () {
              var _removeAllChannels = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
                var values_1;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      _context12.n = 1;
                      return Promise.all(this.channels.map(function (channel) {
                        return channel.unsubscribe();
                      }));
                    case 1:
                      values_1 = _context12.v;
                      this.channels = [];
                      this.disconnect();
                      return _context12.a(2, values_1);
                  }
                }, _callee11, this);
              }));
              function removeAllChannels() {
                return _removeAllChannels.apply(this, arguments);
              }
              return removeAllChannels;
            }()
            /**
             * Logs the message.
             *
             * For customized logging, `this.logger` can be overridden.
             */
            )
          }, {
            key: "log",
            value: function log(kind, msg, data) {
              this.logger(kind, msg, data);
            }
            /**
             * Returns the current state of the socket.
             */
          }, {
            key: "connectionState",
            value: function connectionState() {
              switch (this.conn && this.conn.readyState) {
                case SOCKET_STATES.connecting:
                  return CONNECTION_STATE.Connecting;
                case SOCKET_STATES.open:
                  return CONNECTION_STATE.Open;
                case SOCKET_STATES.closing:
                  return CONNECTION_STATE.Closing;
                default:
                  return CONNECTION_STATE.Closed;
              }
            }
            /**
             * Returns `true` is the connection is open.
             */
          }, {
            key: "isConnected",
            value: function isConnected() {
              return this.connectionState() === CONNECTION_STATE.Open;
            }
            /**
             * Returns `true` if the connection is currently connecting.
             */
          }, {
            key: "isConnecting",
            value: function isConnecting() {
              return this._connectionState === 'connecting';
            }
            /**
             * Returns `true` if the connection is currently disconnecting.
             */
          }, {
            key: "isDisconnecting",
            value: function isDisconnecting() {
              return this._connectionState === 'disconnecting';
            }
            /**
             * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
             *
             * Topics are automatically prefixed with `realtime:` to match the Realtime service.
             * If a channel with the same topic already exists it will be returned instead of creating
             * a duplicate connection.
             */
          }, {
            key: "channel",
            value: function channel(topic) {
              var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                config: {}
              };
              var realtimeTopic = "realtime:".concat(topic);
              var exists = this.getChannels().find(function (c) {
                return c.topic === realtimeTopic;
              });
              if (!exists) {
                var chan = new RealtimeChannel("realtime:".concat(topic), params, this);
                this.channels.push(chan);
                return chan;
              } else {
                return exists;
              }
            }
            /**
             * Push out a message if the socket is connected.
             *
             * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
             */
          }, {
            key: "push",
            value: function push(data) {
              var _this78 = this;
              var topic = data.topic,
                event = data.event,
                payload = data.payload,
                ref = data.ref;
              var callback = function callback() {
                _this78.encode(data, function (result) {
                  var _a;
                  (_a = _this78.conn) === null || _a === void 0 ? void 0 : _a.send(result);
                });
              };
              this.log('push', "".concat(topic, " ").concat(event, " (").concat(ref, ")"), payload);
              if (this.isConnected()) {
                callback();
              } else {
                this.sendBuffer.push(callback);
              }
            }
            /**
             * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
             *
             * If param is null it will use the `accessToken` callback function or the token set on the client.
             *
             * On callback used, it will set the value of the token internal to the client.
             *
             * When a token is explicitly provided, it will be preserved across channel operations
             * (including removeChannel and resubscribe). The `accessToken` callback will not be
             * invoked until `setAuth()` is called without arguments.
             *
             * @param token A JWT string to override the token set on the client.
             *
             * @example
             * // Use a manual token (preserved across resubscribes, ignores accessToken callback)
             * client.realtime.setAuth('my-custom-jwt')
             *
             * // Switch back to using the accessToken callback
             * client.realtime.setAuth()
             */
          }, {
            key: "setAuth",
            value: (function () {
              var _setAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
                var token,
                  _args12 = arguments;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.p = _context13.n) {
                    case 0:
                      token = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : null;
                      this._authPromise = this._performAuth(token);
                      _context13.p = 1;
                      _context13.n = 2;
                      return this._authPromise;
                    case 2:
                      _context13.p = 2;
                      this._authPromise = null;
                      return _context13.f(2);
                    case 3:
                      return _context13.a(2);
                  }
                }, _callee12, this, [[1,, 2, 3]]);
              }));
              function setAuth() {
                return _setAuth.apply(this, arguments);
              }
              return setAuth;
            }()
            /**
             * Returns true if the current access token was explicitly set via setAuth(token),
             * false if it was obtained via the accessToken callback.
             * @internal
             */
            )
          }, {
            key: "_isManualToken",
            value: function _isManualToken() {
              return this._manuallySetToken;
            }
            /**
             * Sends a heartbeat message if the socket is connected.
             */
          }, {
            key: "sendHeartbeat",
            value: (function () {
              var _sendHeartbeat = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
                var _this79 = this;
                var _a;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      if (this.isConnected()) {
                        _context14.n = 1;
                        break;
                      }
                      try {
                        this.heartbeatCallback('disconnected');
                      } catch (e) {
                        this.log('error', 'error in heartbeat callback', e);
                      }
                      return _context14.a(2);
                    case 1:
                      if (!this.pendingHeartbeatRef) {
                        _context14.n = 2;
                        break;
                      }
                      this.pendingHeartbeatRef = null;
                      this._heartbeatSentAt = null;
                      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
                      try {
                        this.heartbeatCallback('timeout');
                      } catch (e) {
                        this.log('error', 'error in heartbeat callback', e);
                      }
                      // Force reconnection after heartbeat timeout
                      this._wasManualDisconnect = false;
                      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'heartbeat timeout');
                      setTimeout(function () {
                        var _a;
                        if (!_this79.isConnected()) {
                          (_a = _this79.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
                        }
                      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
                      return _context14.a(2);
                    case 2:
                      // Send heartbeat message to server
                      this._heartbeatSentAt = Date.now();
                      this.pendingHeartbeatRef = this._makeRef();
                      this.push({
                        topic: 'phoenix',
                        event: 'heartbeat',
                        payload: {},
                        ref: this.pendingHeartbeatRef
                      });
                      try {
                        this.heartbeatCallback('sent');
                      } catch (e) {
                        this.log('error', 'error in heartbeat callback', e);
                      }
                      this._setAuthSafely('heartbeat');
                    case 3:
                      return _context14.a(2);
                  }
                }, _callee13, this);
              }));
              function sendHeartbeat() {
                return _sendHeartbeat.apply(this, arguments);
              }
              return sendHeartbeat;
            }()
            /**
             * Sets a callback that receives lifecycle events for internal heartbeat messages.
             * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
             */
            )
          }, {
            key: "onHeartbeat",
            value: function onHeartbeat(callback) {
              this.heartbeatCallback = callback;
            }
            /**
             * Flushes send buffer
             */
          }, {
            key: "flushSendBuffer",
            value: function flushSendBuffer() {
              if (this.isConnected() && this.sendBuffer.length > 0) {
                this.sendBuffer.forEach(function (callback) {
                  return callback();
                });
                this.sendBuffer = [];
              }
            }
            /**
             * Return the next message ref, accounting for overflows
             *
             * @internal
             */
          }, {
            key: "_makeRef",
            value: function _makeRef() {
              var newRef = this.ref + 1;
              if (newRef === this.ref) {
                this.ref = 0;
              } else {
                this.ref = newRef;
              }
              return this.ref.toString();
            }
            /**
             * Unsubscribe from channels with the specified topic.
             *
             * @internal
             */
          }, {
            key: "_leaveOpenTopic",
            value: function _leaveOpenTopic(topic) {
              var dupChannel = this.channels.find(function (c) {
                return c.topic === topic && (c._isJoined() || c._isJoining());
              });
              if (dupChannel) {
                this.log('transport', "leaving duplicate topic \"".concat(topic, "\""));
                dupChannel.unsubscribe();
              }
            }
            /**
             * Removes a subscription from the socket.
             *
             * @param channel An open subscription.
             *
             * @internal
             */
          }, {
            key: "_remove",
            value: function _remove(channel) {
              this.channels = this.channels.filter(function (c) {
                return c.topic !== channel.topic;
              });
            }
            /** @internal */
          }, {
            key: "_onConnMessage",
            value: function _onConnMessage(rawMessage) {
              var _this80 = this;
              this.decode(rawMessage.data, function (msg) {
                // Handle heartbeat responses
                if (msg.topic === 'phoenix' && msg.event === 'phx_reply' && msg.ref && msg.ref === _this80.pendingHeartbeatRef) {
                  var latency = _this80._heartbeatSentAt ? Date.now() - _this80._heartbeatSentAt : undefined;
                  try {
                    _this80.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);
                  } catch (e) {
                    _this80.log('error', 'error in heartbeat callback', e);
                  }
                  _this80._heartbeatSentAt = null;
                  _this80.pendingHeartbeatRef = null;
                }
                // Log incoming message
                var topic = msg.topic,
                  event = msg.event,
                  payload = msg.payload,
                  ref = msg.ref;
                var refString = ref ? "(".concat(ref, ")") : '';
                var status = payload.status || '';
                _this80.log('receive', "".concat(status, " ").concat(topic, " ").concat(event, " ").concat(refString).trim(), payload);
                // Route message to appropriate channels
                _this80.channels.filter(function (channel) {
                  return channel._isMember(topic);
                }).forEach(function (channel) {
                  return channel._trigger(event, payload, ref);
                });
                _this80._triggerStateCallbacks('message', msg);
              });
            }
            /**
             * Clear specific timer
             * @internal
             */
          }, {
            key: "_clearTimer",
            value: function _clearTimer(timer) {
              var _a;
              if (timer === 'heartbeat' && this.heartbeatTimer) {
                clearInterval(this.heartbeatTimer);
                this.heartbeatTimer = undefined;
              } else if (timer === 'reconnect') {
                (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();
              }
            }
            /**
             * Clear all timers
             * @internal
             */
          }, {
            key: "_clearAllTimers",
            value: function _clearAllTimers() {
              this._clearTimer('heartbeat');
              this._clearTimer('reconnect');
            }
            /**
             * Setup connection handlers for WebSocket events
             * @internal
             */
          }, {
            key: "_setupConnectionHandlers",
            value: function _setupConnectionHandlers() {
              var _this81 = this;
              if (!this.conn) return;
              // Set binary type if supported (browsers and most WebSocket implementations)
              if ('binaryType' in this.conn) {
                this.conn.binaryType = 'arraybuffer';
              }
              this.conn.onopen = function () {
                return _this81._onConnOpen();
              };
              this.conn.onerror = function (error) {
                return _this81._onConnError(error);
              };
              this.conn.onmessage = function (event) {
                return _this81._onConnMessage(event);
              };
              this.conn.onclose = function (event) {
                return _this81._onConnClose(event);
              };
              if (this.conn.readyState === SOCKET_STATES.open) {
                this._onConnOpen();
              }
            }
            /**
             * Teardown connection and cleanup resources
             * @internal
             */
          }, {
            key: "_teardownConnection",
            value: function _teardownConnection() {
              if (this.conn) {
                if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {
                  try {
                    this.conn.close();
                  } catch (e) {
                    this.log('error', 'Error closing connection', e);
                  }
                }
                this.conn.onopen = null;
                this.conn.onerror = null;
                this.conn.onmessage = null;
                this.conn.onclose = null;
                this.conn = null;
              }
              this._clearAllTimers();
              this._terminateWorker();
              this.channels.forEach(function (channel) {
                return channel.teardown();
              });
            }
            /** @internal */
          }, {
            key: "_onConnOpen",
            value: function _onConnOpen() {
              var _this82 = this;
              this._setConnectionState('connected');
              this.log('transport', "connected to ".concat(this.endpointURL()));
              // Wait for any pending auth operations before flushing send buffer
              // This ensures channel join messages include the correct access token
              var authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
              authPromise.then(function () {
                _this82.flushSendBuffer();
              }).catch(function (e) {
                _this82.log('error', 'error waiting for auth on connect', e);
                // Proceed anyway to avoid hanging connections
                _this82.flushSendBuffer();
              });
              this._clearTimer('reconnect');
              if (!this.worker) {
                this._startHeartbeat();
              } else {
                if (!this.workerRef) {
                  this._startWorkerHeartbeat();
                }
              }
              this._triggerStateCallbacks('open');
            }
            /** @internal */
          }, {
            key: "_startHeartbeat",
            value: function _startHeartbeat() {
              var _this83 = this;
              this.heartbeatTimer && clearInterval(this.heartbeatTimer);
              this.heartbeatTimer = setInterval(function () {
                return _this83.sendHeartbeat();
              }, this.heartbeatIntervalMs);
            }
            /** @internal */
          }, {
            key: "_startWorkerHeartbeat",
            value: function _startWorkerHeartbeat() {
              var _this84 = this;
              if (this.workerUrl) {
                this.log('worker', "starting worker for from ".concat(this.workerUrl));
              } else {
                this.log('worker', "starting default worker");
              }
              var objectUrl = this._workerObjectUrl(this.workerUrl);
              this.workerRef = new Worker(objectUrl);
              this.workerRef.onerror = function (error) {
                _this84.log('worker', 'worker error', error.message);
                _this84._terminateWorker();
              };
              this.workerRef.onmessage = function (event) {
                if (event.data.event === 'keepAlive') {
                  _this84.sendHeartbeat();
                }
              };
              this.workerRef.postMessage({
                event: 'start',
                interval: this.heartbeatIntervalMs
              });
            }
            /**
             * Terminate the Web Worker and clear the reference
             * @internal
             */
          }, {
            key: "_terminateWorker",
            value: function _terminateWorker() {
              if (this.workerRef) {
                this.log('worker', 'terminating worker');
                this.workerRef.terminate();
                this.workerRef = undefined;
              }
            }
            /** @internal */
          }, {
            key: "_onConnClose",
            value: function _onConnClose(event) {
              var _a;
              this._setConnectionState('disconnected');
              this.log('transport', 'close', event);
              this._triggerChanError();
              this._clearTimer('heartbeat');
              // Only schedule reconnection if it wasn't a manual disconnect
              if (!this._wasManualDisconnect) {
                (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
              }
              this._triggerStateCallbacks('close', event);
            }
            /** @internal */
          }, {
            key: "_onConnError",
            value: function _onConnError(error) {
              this._setConnectionState('disconnected');
              this.log('transport', "".concat(error));
              this._triggerChanError();
              this._triggerStateCallbacks('error', error);
            }
            /** @internal */
          }, {
            key: "_triggerChanError",
            value: function _triggerChanError() {
              this.channels.forEach(function (channel) {
                return channel._trigger(CHANNEL_EVENTS.error);
              });
            }
            /** @internal */
          }, {
            key: "_appendParams",
            value: function _appendParams(url, params) {
              if (Object.keys(params).length === 0) {
                return url;
              }
              var prefix = url.match(/\?/) ? '&' : '?';
              var query = new URLSearchParams(params);
              return "".concat(url).concat(prefix).concat(query);
            }
          }, {
            key: "_workerObjectUrl",
            value: function _workerObjectUrl(url) {
              var result_url;
              if (url) {
                result_url = url;
              } else {
                var blob = new Blob([WORKER_SCRIPT], {
                  type: 'application/javascript'
                });
                result_url = URL.createObjectURL(blob);
              }
              return result_url;
            }
            /**
             * Set connection state with proper state management
             * @internal
             */
          }, {
            key: "_setConnectionState",
            value: function _setConnectionState(state) {
              var manual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              this._connectionState = state;
              if (state === 'connecting') {
                this._wasManualDisconnect = false;
              } else if (state === 'disconnecting') {
                this._wasManualDisconnect = manual;
              }
            }
            /**
             * Perform the actual auth operation
             * @internal
             */
          }, {
            key: "_performAuth",
            value: (function () {
              var _performAuth2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14() {
                var token,
                  tokenToSend,
                  isManualToken,
                  _args14 = arguments,
                  _t4;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.p = _context15.n) {
                    case 0:
                      token = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : null;
                      isManualToken = false;
                      if (!token) {
                        _context15.n = 1;
                        break;
                      }
                      tokenToSend = token;
                      // Track if this is a manually-provided token
                      isManualToken = true;
                      _context15.n = 7;
                      break;
                    case 1:
                      if (!this.accessToken) {
                        _context15.n = 6;
                        break;
                      }
                      _context15.p = 2;
                      _context15.n = 3;
                      return this.accessToken();
                    case 3:
                      tokenToSend = _context15.v;
                      _context15.n = 5;
                      break;
                    case 4:
                      _context15.p = 4;
                      _t4 = _context15.v;
                      this.log('error', 'Error fetching access token from callback', _t4);
                      // Fall back to cached value if callback fails
                      tokenToSend = this.accessTokenValue;
                    case 5:
                      _context15.n = 7;
                      break;
                    case 6:
                      tokenToSend = this.accessTokenValue;
                    case 7:
                      // Track whether this token was manually set or fetched via callback
                      if (isManualToken) {
                        this._manuallySetToken = true;
                      } else if (this.accessToken) {
                        // If we used the callback, clear the manual flag
                        this._manuallySetToken = false;
                      }
                      if (this.accessTokenValue != tokenToSend) {
                        this.accessTokenValue = tokenToSend;
                        this.channels.forEach(function (channel) {
                          var payload = {
                            access_token: tokenToSend,
                            version: DEFAULT_VERSION
                          };
                          tokenToSend && channel.updateJoinPayload(payload);
                          if (channel.joinedOnce && channel._isJoined()) {
                            channel._push(CHANNEL_EVENTS.access_token, {
                              access_token: tokenToSend
                            });
                          }
                        });
                      }
                    case 8:
                      return _context15.a(2);
                  }
                }, _callee14, this, [[2, 4]]);
              }));
              function _performAuth() {
                return _performAuth2.apply(this, arguments);
              }
              return _performAuth;
            }()
            /**
             * Wait for any in-flight auth operations to complete
             * @internal
             */
            )
          }, {
            key: "_waitForAuthIfNeeded",
            value: (function () {
              var _waitForAuthIfNeeded2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
                return _regenerator().w(function (_context16) {
                  while (1) switch (_context16.n) {
                    case 0:
                      if (!this._authPromise) {
                        _context16.n = 1;
                        break;
                      }
                      _context16.n = 1;
                      return this._authPromise;
                    case 1:
                      return _context16.a(2);
                  }
                }, _callee15, this);
              }));
              function _waitForAuthIfNeeded() {
                return _waitForAuthIfNeeded2.apply(this, arguments);
              }
              return _waitForAuthIfNeeded;
            }()
            /**
             * Safely call setAuth with standardized error handling
             * @internal
             */
            )
          }, {
            key: "_setAuthSafely",
            value: function _setAuthSafely() {
              var _this85 = this;
              var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'general';
              // Only refresh auth if using callback-based tokens
              if (!this._isManualToken()) {
                this.setAuth().catch(function (e) {
                  _this85.log('error', "Error setting auth in ".concat(context), e);
                });
              }
            }
            /**
             * Trigger state change callbacks with proper error handling
             * @internal
             */
          }, {
            key: "_triggerStateCallbacks",
            value: function _triggerStateCallbacks(event, data) {
              var _this86 = this;
              try {
                this.stateChangeCallbacks[event].forEach(function (callback) {
                  try {
                    callback(data);
                  } catch (e) {
                    _this86.log('error', "error in ".concat(event, " callback"), e);
                  }
                });
              } catch (e) {
                this.log('error', "error triggering ".concat(event, " callbacks"), e);
              }
            }
            /**
             * Setup reconnection timer with proper configuration
             * @internal
             */
          }, {
            key: "_setupReconnectionTimer",
            value: function _setupReconnectionTimer() {
              var _this87 = this;
              this.reconnectTimer = new Timer(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
                return _regenerator().w(function (_context18) {
                  while (1) switch (_context18.n) {
                    case 0:
                      setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
                        return _regenerator().w(function (_context17) {
                          while (1) switch (_context17.n) {
                            case 0:
                              _context17.n = 1;
                              return _this87._waitForAuthIfNeeded();
                            case 1:
                              if (!_this87.isConnected()) {
                                _this87.connect();
                              }
                            case 2:
                              return _context17.a(2);
                          }
                        }, _callee16);
                      })), CONNECTION_TIMEOUTS.RECONNECT_DELAY);
                    case 1:
                      return _context18.a(2);
                  }
                }, _callee17);
              })), this.reconnectAfterMs);
            }
            /**
             * Initialize client options with defaults
             * @internal
             */
          }, {
            key: "_initializeOptions",
            value: function _initializeOptions(options) {
              var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
              // Set defaults
              this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;
              this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
              this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
              this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
              this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
              this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
              this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;
              // Handle special cases
              if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
              if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
              if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
                this.logLevel = options.logLevel || options.log_level;
                this.params = Object.assign(Object.assign({}, this.params), {
                  log_level: this.logLevel
                });
              }
              // Set up functions with defaults
              this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : function (tries) {
                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
              };
              switch (this.vsn) {
                case VSN_1_0_0:
                  this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : function (payload, callback) {
                    return callback(JSON.stringify(payload));
                  };
                  this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : function (payload, callback) {
                    return callback(JSON.parse(payload));
                  };
                  break;
                case VSN_2_0_0:
                  this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
                  this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
                  break;
                default:
                  throw new Error("Unsupported serializer version: ".concat(this.vsn));
              }
              // Handle worker setup
              if (this.worker) {
                if (typeof window !== 'undefined' && !window.Worker) {
                  throw new Error('Web Worker is not supported');
                }
                this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
              }
            }
          }]);
        }(); // src/errors/IcebergError.ts
        var IcebergError = /*#__PURE__*/function (_Error4) {
          function IcebergError(message, opts) {
            var _opts$icebergType;
            var _this88;
            _classCallCheck(this, IcebergError);
            _this88 = _callSuper(this, IcebergError, [message]);
            _this88.name = "IcebergError";
            _this88.status = opts.status;
            _this88.icebergType = opts.icebergType;
            _this88.icebergCode = opts.icebergCode;
            _this88.details = opts.details;
            _this88.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && ((_opts$icebergType = opts.icebergType) === null || _opts$icebergType === void 0 ? void 0 : _opts$icebergType.includes("CommitState")) === true;
            return _this88;
          }
          /**
           * Returns true if the error is a 404 Not Found error.
           */
          _inherits(IcebergError, _Error4);
          return _createClass(IcebergError, [{
            key: "isNotFound",
            value: function isNotFound() {
              return this.status === 404;
            }
            /**
             * Returns true if the error is a 409 Conflict error.
             */
          }, {
            key: "isConflict",
            value: function isConflict() {
              return this.status === 409;
            }
            /**
             * Returns true if the error is a 419 Authentication Timeout error.
             */
          }, {
            key: "isAuthenticationTimeout",
            value: function isAuthenticationTimeout() {
              return this.status === 419;
            }
          }]);
        }(/*#__PURE__*/_wrapNativeSuper(Error));

        // src/utils/url.ts
        function buildUrl(baseUrl, path, query) {
          var url = new URL(path, baseUrl);
          if (query) {
            for (var _i0 = 0, _Object$entries5 = Object.entries(query); _i0 < _Object$entries5.length; _i0++) {
              var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i0], 2),
                _key69 = _Object$entries5$_i[0],
                value = _Object$entries5$_i[1];
              if (value !== void 0) {
                url.searchParams.set(_key69, value);
              }
            }
          }
          return url.toString();
        }

        // src/http/createFetchClient.ts
        function buildAuthHeaders(_x16) {
          return _buildAuthHeaders.apply(this, arguments);
        }
        function _buildAuthHeaders() {
          _buildAuthHeaders = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee258(auth) {
            return _regenerator().w(function (_context259) {
              while (1) switch (_context259.n) {
                case 0:
                  if (!(!auth || auth.type === "none")) {
                    _context259.n = 1;
                    break;
                  }
                  return _context259.a(2, {});
                case 1:
                  if (!(auth.type === "bearer")) {
                    _context259.n = 2;
                    break;
                  }
                  return _context259.a(2, {
                    Authorization: "Bearer ".concat(auth.token)
                  });
                case 2:
                  if (!(auth.type === "header")) {
                    _context259.n = 3;
                    break;
                  }
                  return _context259.a(2, _defineProperty2({}, auth.name, auth.value));
                case 3:
                  if (!(auth.type === "custom")) {
                    _context259.n = 5;
                    break;
                  }
                  _context259.n = 4;
                  return auth.getHeaders();
                case 4:
                  return _context259.a(2, _context259.v);
                case 5:
                  return _context259.a(2, {});
              }
            }, _callee258);
          }));
          return _buildAuthHeaders.apply(this, arguments);
        }
        function createFetchClient(options) {
          var _options$fetchImpl;
          var fetchFn = (_options$fetchImpl = options.fetchImpl) !== null && _options$fetchImpl !== void 0 ? _options$fetchImpl : globalThis.fetch;
          return {
            request: function request(_ref200) {
              return _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
                var method, path, query, body, headers, url, authHeaders, res, text, isJson, data, _errorDetail$message, errBody, errorDetail;
                return _regenerator().w(function (_context19) {
                  while (1) switch (_context19.n) {
                    case 0:
                      method = _ref200.method, path = _ref200.path, query = _ref200.query, body = _ref200.body, headers = _ref200.headers;
                      url = buildUrl(options.baseUrl, path, query);
                      _context19.n = 1;
                      return buildAuthHeaders(options.auth);
                    case 1:
                      authHeaders = _context19.v;
                      _context19.n = 2;
                      return fetchFn(url, {
                        method: method,
                        headers: _objectSpread3(_objectSpread3(_objectSpread3({}, body ? {
                          "Content-Type": "application/json"
                        } : {}), authHeaders), headers),
                        body: body ? JSON.stringify(body) : void 0
                      });
                    case 2:
                      res = _context19.v;
                      _context19.n = 3;
                      return res.text();
                    case 3:
                      text = _context19.v;
                      isJson = (res.headers.get("content-type") || "").includes("application/json");
                      data = isJson && text ? JSON.parse(text) : text;
                      if (res.ok) {
                        _context19.n = 4;
                        break;
                      }
                      errBody = isJson ? data : void 0;
                      errorDetail = errBody === null || errBody === void 0 ? void 0 : errBody.error;
                      throw new IcebergError((_errorDetail$message = errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.message) !== null && _errorDetail$message !== void 0 ? _errorDetail$message : "Request failed with status ".concat(res.status), {
                        status: res.status,
                        icebergType: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.type,
                        icebergCode: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.code,
                        details: errBody
                      });
                    case 4:
                      return _context19.a(2, {
                        status: res.status,
                        headers: res.headers,
                        data: data
                      });
                  }
                }, _callee18);
              }))();
            }
          };
        }

        // src/catalog/namespaces.ts
        function namespaceToPath(namespace) {
          return namespace.join("");
        }
        var NamespaceOperations = /*#__PURE__*/function () {
          function NamespaceOperations(client) {
            var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            _classCallCheck(this, NamespaceOperations);
            this.client = client;
            this.prefix = prefix;
          }
          return _createClass(NamespaceOperations, [{
            key: "listNamespaces",
            value: function () {
              var _listNamespaces = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(parent) {
                var query, response;
                return _regenerator().w(function (_context20) {
                  while (1) switch (_context20.n) {
                    case 0:
                      query = parent ? {
                        parent: namespaceToPath(parent.namespace)
                      } : void 0;
                      _context20.n = 1;
                      return this.client.request({
                        method: "GET",
                        path: "".concat(this.prefix, "/namespaces"),
                        query: query
                      });
                    case 1:
                      response = _context20.v;
                      return _context20.a(2, response.data.namespaces.map(function (ns) {
                        return {
                          namespace: ns
                        };
                      }));
                  }
                }, _callee19, this);
              }));
              function listNamespaces(_x17) {
                return _listNamespaces.apply(this, arguments);
              }
              return listNamespaces;
            }()
          }, {
            key: "createNamespace",
            value: function () {
              var _createNamespace = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(id, metadata) {
                var request, response;
                return _regenerator().w(function (_context21) {
                  while (1) switch (_context21.n) {
                    case 0:
                      request = {
                        namespace: id.namespace,
                        properties: metadata === null || metadata === void 0 ? void 0 : metadata.properties
                      };
                      _context21.n = 1;
                      return this.client.request({
                        method: "POST",
                        path: "".concat(this.prefix, "/namespaces"),
                        body: request
                      });
                    case 1:
                      response = _context21.v;
                      return _context21.a(2, response.data);
                  }
                }, _callee20, this);
              }));
              function createNamespace(_x18, _x19) {
                return _createNamespace.apply(this, arguments);
              }
              return createNamespace;
            }()
          }, {
            key: "dropNamespace",
            value: function () {
              var _dropNamespace = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(id) {
                return _regenerator().w(function (_context22) {
                  while (1) switch (_context22.n) {
                    case 0:
                      _context22.n = 1;
                      return this.client.request({
                        method: "DELETE",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath(id.namespace))
                      });
                    case 1:
                      return _context22.a(2);
                  }
                }, _callee21, this);
              }));
              function dropNamespace(_x20) {
                return _dropNamespace.apply(this, arguments);
              }
              return dropNamespace;
            }()
          }, {
            key: "loadNamespaceMetadata",
            value: function () {
              var _loadNamespaceMetadata = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22(id) {
                var response;
                return _regenerator().w(function (_context23) {
                  while (1) switch (_context23.n) {
                    case 0:
                      _context23.n = 1;
                      return this.client.request({
                        method: "GET",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath(id.namespace))
                      });
                    case 1:
                      response = _context23.v;
                      return _context23.a(2, {
                        properties: response.data.properties
                      });
                  }
                }, _callee22, this);
              }));
              function loadNamespaceMetadata(_x21) {
                return _loadNamespaceMetadata.apply(this, arguments);
              }
              return loadNamespaceMetadata;
            }()
          }, {
            key: "namespaceExists",
            value: function () {
              var _namespaceExists = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23(id) {
                var _t5;
                return _regenerator().w(function (_context24) {
                  while (1) switch (_context24.p = _context24.n) {
                    case 0:
                      _context24.p = 0;
                      _context24.n = 1;
                      return this.client.request({
                        method: "HEAD",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath(id.namespace))
                      });
                    case 1:
                      return _context24.a(2, true);
                    case 2:
                      _context24.p = 2;
                      _t5 = _context24.v;
                      if (!(_t5 instanceof IcebergError && _t5.status === 404)) {
                        _context24.n = 3;
                        break;
                      }
                      return _context24.a(2, false);
                    case 3:
                      throw _t5;
                    case 4:
                      return _context24.a(2);
                  }
                }, _callee23, this, [[0, 2]]);
              }));
              function namespaceExists(_x22) {
                return _namespaceExists.apply(this, arguments);
              }
              return namespaceExists;
            }()
          }, {
            key: "createNamespaceIfNotExists",
            value: function () {
              var _createNamespaceIfNotExists = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee24(id, metadata) {
                var _t6;
                return _regenerator().w(function (_context25) {
                  while (1) switch (_context25.p = _context25.n) {
                    case 0:
                      _context25.p = 0;
                      _context25.n = 1;
                      return this.createNamespace(id, metadata);
                    case 1:
                      return _context25.a(2, _context25.v);
                    case 2:
                      _context25.p = 2;
                      _t6 = _context25.v;
                      if (!(_t6 instanceof IcebergError && _t6.status === 409)) {
                        _context25.n = 3;
                        break;
                      }
                      return _context25.a(2);
                    case 3:
                      throw _t6;
                    case 4:
                      return _context25.a(2);
                  }
                }, _callee24, this, [[0, 2]]);
              }));
              function createNamespaceIfNotExists(_x23, _x24) {
                return _createNamespaceIfNotExists.apply(this, arguments);
              }
              return createNamespaceIfNotExists;
            }()
          }]);
        }();

        // src/catalog/tables.ts
        function namespaceToPath2(namespace) {
          return namespace.join("");
        }
        var TableOperations = /*#__PURE__*/function () {
          function TableOperations(client) {
            var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var accessDelegation = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, TableOperations);
            this.client = client;
            this.prefix = prefix;
            this.accessDelegation = accessDelegation;
          }
          return _createClass(TableOperations, [{
            key: "listTables",
            value: function () {
              var _listTables = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee25(namespace) {
                var response;
                return _regenerator().w(function (_context26) {
                  while (1) switch (_context26.n) {
                    case 0:
                      _context26.n = 1;
                      return this.client.request({
                        method: "GET",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(namespace.namespace), "/tables")
                      });
                    case 1:
                      response = _context26.v;
                      return _context26.a(2, response.data.identifiers);
                  }
                }, _callee25, this);
              }));
              function listTables(_x25) {
                return _listTables.apply(this, arguments);
              }
              return listTables;
            }()
          }, {
            key: "createTable",
            value: function () {
              var _createTable = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee26(namespace, request) {
                var headers, response;
                return _regenerator().w(function (_context27) {
                  while (1) switch (_context27.n) {
                    case 0:
                      headers = {};
                      if (this.accessDelegation) {
                        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
                      }
                      _context27.n = 1;
                      return this.client.request({
                        method: "POST",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(namespace.namespace), "/tables"),
                        body: request,
                        headers: headers
                      });
                    case 1:
                      response = _context27.v;
                      return _context27.a(2, response.data.metadata);
                  }
                }, _callee26, this);
              }));
              function createTable(_x26, _x27) {
                return _createTable.apply(this, arguments);
              }
              return createTable;
            }()
          }, {
            key: "updateTable",
            value: function () {
              var _updateTable = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee27(id, request) {
                var response;
                return _regenerator().w(function (_context28) {
                  while (1) switch (_context28.n) {
                    case 0:
                      _context28.n = 1;
                      return this.client.request({
                        method: "POST",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(id.namespace), "/tables/").concat(id.name),
                        body: request
                      });
                    case 1:
                      response = _context28.v;
                      return _context28.a(2, {
                        "metadata-location": response.data["metadata-location"],
                        metadata: response.data.metadata
                      });
                  }
                }, _callee27, this);
              }));
              function updateTable(_x28, _x29) {
                return _updateTable.apply(this, arguments);
              }
              return updateTable;
            }()
          }, {
            key: "dropTable",
            value: function () {
              var _dropTable = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee28(id, options) {
                var _options$purge;
                return _regenerator().w(function (_context29) {
                  while (1) switch (_context29.n) {
                    case 0:
                      _context29.n = 1;
                      return this.client.request({
                        method: "DELETE",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(id.namespace), "/tables/").concat(id.name),
                        query: {
                          purgeRequested: String((_options$purge = options === null || options === void 0 ? void 0 : options.purge) !== null && _options$purge !== void 0 ? _options$purge : false)
                        }
                      });
                    case 1:
                      return _context29.a(2);
                  }
                }, _callee28, this);
              }));
              function dropTable(_x30, _x31) {
                return _dropTable.apply(this, arguments);
              }
              return dropTable;
            }()
          }, {
            key: "loadTable",
            value: function () {
              var _loadTable = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee29(id) {
                var headers, response;
                return _regenerator().w(function (_context30) {
                  while (1) switch (_context30.n) {
                    case 0:
                      headers = {};
                      if (this.accessDelegation) {
                        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
                      }
                      _context30.n = 1;
                      return this.client.request({
                        method: "GET",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(id.namespace), "/tables/").concat(id.name),
                        headers: headers
                      });
                    case 1:
                      response = _context30.v;
                      return _context30.a(2, response.data.metadata);
                  }
                }, _callee29, this);
              }));
              function loadTable(_x32) {
                return _loadTable.apply(this, arguments);
              }
              return loadTable;
            }()
          }, {
            key: "tableExists",
            value: function () {
              var _tableExists = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee30(id) {
                var headers, _t7;
                return _regenerator().w(function (_context31) {
                  while (1) switch (_context31.p = _context31.n) {
                    case 0:
                      headers = {};
                      if (this.accessDelegation) {
                        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
                      }
                      _context31.p = 1;
                      _context31.n = 2;
                      return this.client.request({
                        method: "HEAD",
                        path: "".concat(this.prefix, "/namespaces/").concat(namespaceToPath2(id.namespace), "/tables/").concat(id.name),
                        headers: headers
                      });
                    case 2:
                      return _context31.a(2, true);
                    case 3:
                      _context31.p = 3;
                      _t7 = _context31.v;
                      if (!(_t7 instanceof IcebergError && _t7.status === 404)) {
                        _context31.n = 4;
                        break;
                      }
                      return _context31.a(2, false);
                    case 4:
                      throw _t7;
                    case 5:
                      return _context31.a(2);
                  }
                }, _callee30, this, [[1, 3]]);
              }));
              function tableExists(_x33) {
                return _tableExists.apply(this, arguments);
              }
              return tableExists;
            }()
          }, {
            key: "createTableIfNotExists",
            value: function () {
              var _createTableIfNotExists = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee31(namespace, request) {
                var _t8;
                return _regenerator().w(function (_context32) {
                  while (1) switch (_context32.p = _context32.n) {
                    case 0:
                      _context32.p = 0;
                      _context32.n = 1;
                      return this.createTable(namespace, request);
                    case 1:
                      return _context32.a(2, _context32.v);
                    case 2:
                      _context32.p = 2;
                      _t8 = _context32.v;
                      if (!(_t8 instanceof IcebergError && _t8.status === 409)) {
                        _context32.n = 4;
                        break;
                      }
                      _context32.n = 3;
                      return this.loadTable({
                        namespace: namespace.namespace,
                        name: request.name
                      });
                    case 3:
                      return _context32.a(2, _context32.v);
                    case 4:
                      throw _t8;
                    case 5:
                      return _context32.a(2);
                  }
                }, _callee31, this, [[0, 2]]);
              }));
              function createTableIfNotExists(_x34, _x35) {
                return _createTableIfNotExists.apply(this, arguments);
              }
              return createTableIfNotExists;
            }()
          }]);
        }();

        // src/catalog/IcebergRestCatalog.ts
        var IcebergRestCatalog = /*#__PURE__*/function () {
          /**
           * Creates a new Iceberg REST Catalog client.
           *
           * @param options - Configuration options for the catalog client
           */
          function IcebergRestCatalog(options) {
            var _options$accessDelega;
            _classCallCheck(this, IcebergRestCatalog);
            var prefix = "v1";
            if (options.catalogName) {
              prefix += "/".concat(options.catalogName);
            }
            var baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : "".concat(options.baseUrl, "/");
            this.client = createFetchClient({
              baseUrl: baseUrl,
              auth: options.auth,
              fetchImpl: options.fetch
            });
            this.accessDelegation = (_options$accessDelega = options.accessDelegation) === null || _options$accessDelega === void 0 ? void 0 : _options$accessDelega.join(",");
            this.namespaceOps = new NamespaceOperations(this.client, prefix);
            this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
          }
          /**
           * Lists all namespaces in the catalog.
           *
           * @param parent - Optional parent namespace to list children under
           * @returns Array of namespace identifiers
           *
           * @example
           * ```typescript
           * // List all top-level namespaces
           * const namespaces = await catalog.listNamespaces();
           *
           * // List namespaces under a parent
           * const children = await catalog.listNamespaces({ namespace: ['analytics'] });
           * ```
           */
          return _createClass(IcebergRestCatalog, [{
            key: "listNamespaces",
            value: (function () {
              var _listNamespaces2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee32(parent) {
                return _regenerator().w(function (_context33) {
                  while (1) switch (_context33.n) {
                    case 0:
                      return _context33.a(2, this.namespaceOps.listNamespaces(parent));
                  }
                }, _callee32, this);
              }));
              function listNamespaces(_x36) {
                return _listNamespaces2.apply(this, arguments);
              }
              return listNamespaces;
            }()
            /**
             * Creates a new namespace in the catalog.
             *
             * @param id - Namespace identifier to create
             * @param metadata - Optional metadata properties for the namespace
             * @returns Response containing the created namespace and its properties
             *
             * @example
             * ```typescript
             * const response = await catalog.createNamespace(
             *   { namespace: ['analytics'] },
             *   { properties: { owner: 'data-team' } }
             * );
             * console.log(response.namespace); // ['analytics']
             * console.log(response.properties); // { owner: 'data-team', ... }
             * ```
             */
            )
          }, {
            key: "createNamespace",
            value: (function () {
              var _createNamespace2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee33(id, metadata) {
                return _regenerator().w(function (_context34) {
                  while (1) switch (_context34.n) {
                    case 0:
                      return _context34.a(2, this.namespaceOps.createNamespace(id, metadata));
                  }
                }, _callee33, this);
              }));
              function createNamespace(_x37, _x38) {
                return _createNamespace2.apply(this, arguments);
              }
              return createNamespace;
            }()
            /**
             * Drops a namespace from the catalog.
             *
             * The namespace must be empty (contain no tables) before it can be dropped.
             *
             * @param id - Namespace identifier to drop
             *
             * @example
             * ```typescript
             * await catalog.dropNamespace({ namespace: ['analytics'] });
             * ```
             */
            )
          }, {
            key: "dropNamespace",
            value: (function () {
              var _dropNamespace2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee34(id) {
                return _regenerator().w(function (_context35) {
                  while (1) switch (_context35.n) {
                    case 0:
                      _context35.n = 1;
                      return this.namespaceOps.dropNamespace(id);
                    case 1:
                      return _context35.a(2);
                  }
                }, _callee34, this);
              }));
              function dropNamespace(_x39) {
                return _dropNamespace2.apply(this, arguments);
              }
              return dropNamespace;
            }()
            /**
             * Loads metadata for a namespace.
             *
             * @param id - Namespace identifier to load
             * @returns Namespace metadata including properties
             *
             * @example
             * ```typescript
             * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });
             * console.log(metadata.properties);
             * ```
             */
            )
          }, {
            key: "loadNamespaceMetadata",
            value: (function () {
              var _loadNamespaceMetadata2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee35(id) {
                return _regenerator().w(function (_context36) {
                  while (1) switch (_context36.n) {
                    case 0:
                      return _context36.a(2, this.namespaceOps.loadNamespaceMetadata(id));
                  }
                }, _callee35, this);
              }));
              function loadNamespaceMetadata(_x40) {
                return _loadNamespaceMetadata2.apply(this, arguments);
              }
              return loadNamespaceMetadata;
            }()
            /**
             * Lists all tables in a namespace.
             *
             * @param namespace - Namespace identifier to list tables from
             * @returns Array of table identifiers
             *
             * @example
             * ```typescript
             * const tables = await catalog.listTables({ namespace: ['analytics'] });
             * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]
             * ```
             */
            )
          }, {
            key: "listTables",
            value: (function () {
              var _listTables2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee36(namespace) {
                return _regenerator().w(function (_context37) {
                  while (1) switch (_context37.n) {
                    case 0:
                      return _context37.a(2, this.tableOps.listTables(namespace));
                  }
                }, _callee36, this);
              }));
              function listTables(_x41) {
                return _listTables2.apply(this, arguments);
              }
              return listTables;
            }()
            /**
             * Creates a new table in the catalog.
             *
             * @param namespace - Namespace to create the table in
             * @param request - Table creation request including name, schema, partition spec, etc.
             * @returns Table metadata for the created table
             *
             * @example
             * ```typescript
             * const metadata = await catalog.createTable(
             *   { namespace: ['analytics'] },
             *   {
             *     name: 'events',
             *     schema: {
             *       type: 'struct',
             *       fields: [
             *         { id: 1, name: 'id', type: 'long', required: true },
             *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
             *       ],
             *       'schema-id': 0
             *     },
             *     'partition-spec': {
             *       'spec-id': 0,
             *       fields: [
             *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }
             *       ]
             *     }
             *   }
             * );
             * ```
             */
            )
          }, {
            key: "createTable",
            value: (function () {
              var _createTable2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee37(namespace, request) {
                return _regenerator().w(function (_context38) {
                  while (1) switch (_context38.n) {
                    case 0:
                      return _context38.a(2, this.tableOps.createTable(namespace, request));
                  }
                }, _callee37, this);
              }));
              function createTable(_x42, _x43) {
                return _createTable2.apply(this, arguments);
              }
              return createTable;
            }()
            /**
             * Updates an existing table's metadata.
             *
             * Can update the schema, partition spec, or properties of a table.
             *
             * @param id - Table identifier to update
             * @param request - Update request with fields to modify
             * @returns Response containing the metadata location and updated table metadata
             *
             * @example
             * ```typescript
             * const response = await catalog.updateTable(
             *   { namespace: ['analytics'], name: 'events' },
             *   {
             *     properties: { 'read.split.target-size': '134217728' }
             *   }
             * );
             * console.log(response['metadata-location']); // s3://...
             * console.log(response.metadata); // TableMetadata object
             * ```
             */
            )
          }, {
            key: "updateTable",
            value: (function () {
              var _updateTable2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee38(id, request) {
                return _regenerator().w(function (_context39) {
                  while (1) switch (_context39.n) {
                    case 0:
                      return _context39.a(2, this.tableOps.updateTable(id, request));
                  }
                }, _callee38, this);
              }));
              function updateTable(_x44, _x45) {
                return _updateTable2.apply(this, arguments);
              }
              return updateTable;
            }()
            /**
             * Drops a table from the catalog.
             *
             * @param id - Table identifier to drop
             *
             * @example
             * ```typescript
             * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });
             * ```
             */
            )
          }, {
            key: "dropTable",
            value: (function () {
              var _dropTable2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee39(id, options) {
                return _regenerator().w(function (_context40) {
                  while (1) switch (_context40.n) {
                    case 0:
                      _context40.n = 1;
                      return this.tableOps.dropTable(id, options);
                    case 1:
                      return _context40.a(2);
                  }
                }, _callee39, this);
              }));
              function dropTable(_x46, _x47) {
                return _dropTable2.apply(this, arguments);
              }
              return dropTable;
            }()
            /**
             * Loads metadata for a table.
             *
             * @param id - Table identifier to load
             * @returns Table metadata including schema, partition spec, location, etc.
             *
             * @example
             * ```typescript
             * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });
             * console.log(metadata.schema);
             * console.log(metadata.location);
             * ```
             */
            )
          }, {
            key: "loadTable",
            value: (function () {
              var _loadTable2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee40(id) {
                return _regenerator().w(function (_context41) {
                  while (1) switch (_context41.n) {
                    case 0:
                      return _context41.a(2, this.tableOps.loadTable(id));
                  }
                }, _callee40, this);
              }));
              function loadTable(_x48) {
                return _loadTable2.apply(this, arguments);
              }
              return loadTable;
            }()
            /**
             * Checks if a namespace exists in the catalog.
             *
             * @param id - Namespace identifier to check
             * @returns True if the namespace exists, false otherwise
             *
             * @example
             * ```typescript
             * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });
             * console.log(exists); // true or false
             * ```
             */
            )
          }, {
            key: "namespaceExists",
            value: (function () {
              var _namespaceExists2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee41(id) {
                return _regenerator().w(function (_context42) {
                  while (1) switch (_context42.n) {
                    case 0:
                      return _context42.a(2, this.namespaceOps.namespaceExists(id));
                  }
                }, _callee41, this);
              }));
              function namespaceExists(_x49) {
                return _namespaceExists2.apply(this, arguments);
              }
              return namespaceExists;
            }()
            /**
             * Checks if a table exists in the catalog.
             *
             * @param id - Table identifier to check
             * @returns True if the table exists, false otherwise
             *
             * @example
             * ```typescript
             * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });
             * console.log(exists); // true or false
             * ```
             */
            )
          }, {
            key: "tableExists",
            value: (function () {
              var _tableExists2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee42(id) {
                return _regenerator().w(function (_context43) {
                  while (1) switch (_context43.n) {
                    case 0:
                      return _context43.a(2, this.tableOps.tableExists(id));
                  }
                }, _callee42, this);
              }));
              function tableExists(_x50) {
                return _tableExists2.apply(this, arguments);
              }
              return tableExists;
            }()
            /**
             * Creates a namespace if it does not exist.
             *
             * If the namespace already exists, returns void. If created, returns the response.
             *
             * @param id - Namespace identifier to create
             * @param metadata - Optional metadata properties for the namespace
             * @returns Response containing the created namespace and its properties, or void if it already exists
             *
             * @example
             * ```typescript
             * const response = await catalog.createNamespaceIfNotExists(
             *   { namespace: ['analytics'] },
             *   { properties: { owner: 'data-team' } }
             * );
             * if (response) {
             *   console.log('Created:', response.namespace);
             * } else {
             *   console.log('Already exists');
             * }
             * ```
             */
            )
          }, {
            key: "createNamespaceIfNotExists",
            value: (function () {
              var _createNamespaceIfNotExists2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee43(id, metadata) {
                return _regenerator().w(function (_context44) {
                  while (1) switch (_context44.n) {
                    case 0:
                      return _context44.a(2, this.namespaceOps.createNamespaceIfNotExists(id, metadata));
                  }
                }, _callee43, this);
              }));
              function createNamespaceIfNotExists(_x51, _x52) {
                return _createNamespaceIfNotExists2.apply(this, arguments);
              }
              return createNamespaceIfNotExists;
            }()
            /**
             * Creates a table if it does not exist.
             *
             * If the table already exists, returns its metadata instead.
             *
             * @param namespace - Namespace to create the table in
             * @param request - Table creation request including name, schema, partition spec, etc.
             * @returns Table metadata for the created or existing table
             *
             * @example
             * ```typescript
             * const metadata = await catalog.createTableIfNotExists(
             *   { namespace: ['analytics'] },
             *   {
             *     name: 'events',
             *     schema: {
             *       type: 'struct',
             *       fields: [
             *         { id: 1, name: 'id', type: 'long', required: true },
             *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
             *       ],
             *       'schema-id': 0
             *     }
             *   }
             * );
             * ```
             */
            )
          }, {
            key: "createTableIfNotExists",
            value: (function () {
              var _createTableIfNotExists2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee44(namespace, request) {
                return _regenerator().w(function (_context45) {
                  while (1) switch (_context45.n) {
                    case 0:
                      return _context45.a(2, this.tableOps.createTableIfNotExists(namespace, request));
                  }
                }, _callee44, this);
              }));
              function createTableIfNotExists(_x53, _x54) {
                return _createTableIfNotExists2.apply(this, arguments);
              }
              return createTableIfNotExists;
            }())
          }]);
        }();

        //#region src/lib/errors.ts
        var StorageError = /*#__PURE__*/function (_Error5) {
          function StorageError(message) {
            var _this89;
            _classCallCheck(this, StorageError);
            _this89 = _callSuper(this, StorageError, [message]);
            _this89.__isStorageError = true;
            _this89.name = "StorageError";
            return _this89;
          }
          _inherits(StorageError, _Error5);
          return _createClass(StorageError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        function isStorageError(error) {
          return _typeof2(error) === "object" && error !== null && "__isStorageError" in error;
        }
        var StorageApiError = /*#__PURE__*/function (_StorageError) {
          function StorageApiError(message, status, statusCode) {
            var _this90;
            _classCallCheck(this, StorageApiError);
            _this90 = _callSuper(this, StorageApiError, [message]);
            _this90.name = "StorageApiError";
            _this90.status = status;
            _this90.statusCode = statusCode;
            return _this90;
          }
          _inherits(StorageApiError, _StorageError);
          return _createClass(StorageApiError, [{
            key: "toJSON",
            value: function toJSON() {
              return {
                name: this.name,
                message: this.message,
                status: this.status,
                statusCode: this.statusCode
              };
            }
          }]);
        }(StorageError);
        var StorageUnknownError = /*#__PURE__*/function (_StorageError2) {
          function StorageUnknownError(message, originalError) {
            var _this91;
            _classCallCheck(this, StorageUnknownError);
            _this91 = _callSuper(this, StorageUnknownError, [message]);
            _this91.name = "StorageUnknownError";
            _this91.originalError = originalError;
            return _this91;
          }
          _inherits(StorageUnknownError, _StorageError2);
          return _createClass(StorageUnknownError);
        }(StorageError);

        //#endregion
        //#region src/lib/helpers.ts
        var resolveFetch$1$1 = function resolveFetch$1$1(customFetch) {
          if (customFetch) return function () {
            return customFetch.apply(void 0, arguments);
          };
          return function () {
            return fetch.apply(void 0, arguments);
          };
        };
        var resolveResponse$1 = function resolveResponse$1() {
          return Response;
        };
        var _recursiveToCamel = function recursiveToCamel(item) {
          if (Array.isArray(item)) return item.map(function (el) {
            return _recursiveToCamel(el);
          });else if (typeof item === "function" || item !== Object(item)) return item;
          var result = {};
          Object.entries(item).forEach(function (_ref201) {
            var _ref202 = _slicedToArray(_ref201, 2),
              key = _ref202[0],
              value = _ref202[1];
            var newKey = key.replace(/([-_][a-z])/gi, function (c) {
              return c.toUpperCase().replace(/[-_]/g, "");
            });
            result[newKey] = _recursiveToCamel(value);
          });
          return result;
        };
        /**
        * Determine if input is a plain object
        * An object is plain if it's created by either {}, new Object(), or Object.create(null)
        * source: https://github.com/sindresorhus/is-plain-obj
        */
        var isPlainObject$1 = function isPlainObject$1(value) {
          if (_typeof2(value) !== "object" || value === null) return false;
          var prototype = Object.getPrototypeOf(value);
          return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
        };
        /**
        * Validates if a given bucket name is valid according to Supabase Storage API rules
        * Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()
        *
        * Rules:
        * - Length: 1-100 characters
        * - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters
        * - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?
        * - Forbidden: path separators (/, \), path traversal (..), leading/trailing whitespace
        *
        * AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html
        *
        * @param bucketName - The bucket name to validate
        * @returns true if valid, false otherwise
        */
        var isValidBucketName = function isValidBucketName(bucketName) {
          if (!bucketName || typeof bucketName !== "string") return false;
          if (bucketName.length === 0 || bucketName.length > 100) return false;
          if (bucketName.trim() !== bucketName) return false;
          if (bucketName.includes("/") || bucketName.includes("\\")) return false;
          return /^[\w!.\*'() &$@=;:+,?-]+$/.test(bucketName);
        };

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/typeof.js
        function _typeof$1(o) {
          "@babel/helpers - typeof";

          return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o$1) {
            return typeof o$1;
          } : function (o$1) {
            return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
          }, _typeof$1(o);
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js
        function toPrimitive$1(t, r) {
          if ("object" != _typeof$1(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != _typeof$1(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js
        function toPropertyKey$1(t) {
          var i = toPrimitive$1(t, "string");
          return "symbol" == _typeof$1(i) ? i : i + "";
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/defineProperty.js
        function _defineProperty$2(e, r, t) {
          return (r = toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js
        function ownKeys$2(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r$1) {
              return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread2$1(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$2(Object(t), true).forEach(function (r$1) {
              _defineProperty$2(e, r$1, t[r$1]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r$1) {
              Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
            });
          }
          return e;
        }

        //#endregion
        //#region src/lib/fetch.ts
        var _getErrorMessage$1 = function _getErrorMessage$1(err) {
          var _err$error;
          return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);
        };
        var handleError$1 = /*#__PURE__*/function () {
          var _ref203 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee45(error, reject, options) {
            var _t9, _t0, _t1;
            return _regenerator().w(function (_context46) {
              while (1) switch (_context46.n) {
                case 0:
                  _t0 = error;
                  _context46.n = 1;
                  return resolveResponse$1();
                case 1:
                  _t1 = _context46.v;
                  _t9 = _t0 instanceof _t1;
                  if (!_t9) {
                    _context46.n = 2;
                    break;
                  }
                  _t9 = !(options === null || options === void 0 ? void 0 : options.noResolveJson);
                case 2:
                  if (!_t9) {
                    _context46.n = 3;
                    break;
                  }
                  error.json().then(function (err) {
                    var status = error.status || 500;
                    var statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + "";
                    reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));
                  }).catch(function (err) {
                    reject(new StorageUnknownError(_getErrorMessage$1(err), err));
                  });
                  _context46.n = 4;
                  break;
                case 3:
                  reject(new StorageUnknownError(_getErrorMessage$1(error), error));
                case 4:
                  return _context46.a(2);
              }
            }, _callee45);
          }));
          return function handleError$1(_x55, _x56, _x57) {
            return _ref203.apply(this, arguments);
          };
        }();
        var _getRequestParams$1 = function _getRequestParams$1(method, options, parameters, body) {
          var params = {
            method: method,
            headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
          };
          if (method === "GET" || !body) return params;
          if (isPlainObject$1(body)) {
            params.headers = _objectSpread2$1({
              "Content-Type": "application/json"
            }, options === null || options === void 0 ? void 0 : options.headers);
            params.body = JSON.stringify(body);
          } else params.body = body;
          if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;
          return _objectSpread2$1(_objectSpread2$1({}, params), parameters);
        };
        function _handleRequest$1(_x58, _x59, _x60, _x61, _x62, _x63) {
          return _handleRequest$.apply(this, arguments);
        }
        function _handleRequest$() {
          _handleRequest$ = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee259(fetcher, method, url, options, parameters, body) {
            return _regenerator().w(function (_context260) {
              while (1) switch (_context260.n) {
                case 0:
                  return _context260.a(2, new Promise(function (resolve, reject) {
                    fetcher(url, _getRequestParams$1(method, options, parameters, body)).then(function (result) {
                      if (!result.ok) throw result;
                      if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
                      return result.json();
                    }).then(function (data) {
                      return resolve(data);
                    }).catch(function (error) {
                      return handleError$1(error, reject, options);
                    });
                  }));
              }
            }, _callee259);
          }));
          return _handleRequest$.apply(this, arguments);
        }
        function get(_x64, _x65, _x66, _x67) {
          return _get2.apply(this, arguments);
        }
        function _get2() {
          _get2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee260(fetcher, url, options, parameters) {
            return _regenerator().w(function (_context261) {
              while (1) switch (_context261.n) {
                case 0:
                  return _context261.a(2, _handleRequest$1(fetcher, "GET", url, options, parameters));
              }
            }, _callee260);
          }));
          return _get2.apply(this, arguments);
        }
        function post$1(_x68, _x69, _x70, _x71, _x72) {
          return _post$.apply(this, arguments);
        }
        function _post$() {
          _post$ = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee261(fetcher, url, body, options, parameters) {
            return _regenerator().w(function (_context262) {
              while (1) switch (_context262.n) {
                case 0:
                  return _context262.a(2, _handleRequest$1(fetcher, "POST", url, options, parameters, body));
              }
            }, _callee261);
          }));
          return _post$.apply(this, arguments);
        }
        function put(_x73, _x74, _x75, _x76, _x77) {
          return _put.apply(this, arguments);
        }
        function _put() {
          _put = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee262(fetcher, url, body, options, parameters) {
            return _regenerator().w(function (_context263) {
              while (1) switch (_context263.n) {
                case 0:
                  return _context263.a(2, _handleRequest$1(fetcher, "PUT", url, options, parameters, body));
              }
            }, _callee262);
          }));
          return _put.apply(this, arguments);
        }
        function head(_x78, _x79, _x80, _x81) {
          return _head.apply(this, arguments);
        }
        function _head() {
          _head = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee263(fetcher, url, options, parameters) {
            return _regenerator().w(function (_context264) {
              while (1) switch (_context264.n) {
                case 0:
                  return _context264.a(2, _handleRequest$1(fetcher, "HEAD", url, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                    noResolveJson: true
                  }), parameters));
              }
            }, _callee263);
          }));
          return _head.apply(this, arguments);
        }
        function _remove3(_x82, _x83, _x84, _x85, _x86) {
          return _remove2.apply(this, arguments);
        } //#endregion
        //#region src/packages/StreamDownloadBuilder.ts
        function _remove2() {
          _remove2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee264(fetcher, url, body, options, parameters) {
            return _regenerator().w(function (_context265) {
              while (1) switch (_context265.n) {
                case 0:
                  return _context265.a(2, _handleRequest$1(fetcher, "DELETE", url, options, parameters, body));
              }
            }, _callee264);
          }));
          return _remove2.apply(this, arguments);
        }
        var StreamDownloadBuilder = /*#__PURE__*/function () {
          function StreamDownloadBuilder(downloadFn, shouldThrowOnError) {
            _classCallCheck(this, StreamDownloadBuilder);
            this.downloadFn = downloadFn;
            this.shouldThrowOnError = shouldThrowOnError;
          }
          return _createClass(StreamDownloadBuilder, [{
            key: "then",
            value: function then(onfulfilled, onrejected) {
              return this.execute().then(onfulfilled, onrejected);
            }
          }, {
            key: "execute",
            value: function () {
              var _execute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee46() {
                var _this, _t10, _t11;
                return _regenerator().w(function (_context47) {
                  while (1) switch (_context47.p = _context47.n) {
                    case 0:
                      _this = this;
                      _context47.p = 1;
                      _context47.n = 2;
                      return _this.downloadFn();
                    case 2:
                      _t10 = _context47.v.body;
                      return _context47.a(2, {
                        data: _t10,
                        error: null
                      });
                    case 3:
                      _context47.p = 3;
                      _t11 = _context47.v;
                      if (!_this.shouldThrowOnError) {
                        _context47.n = 4;
                        break;
                      }
                      throw _t11;
                    case 4:
                      if (!isStorageError(_t11)) {
                        _context47.n = 5;
                        break;
                      }
                      return _context47.a(2, {
                        data: null,
                        error: _t11
                      });
                    case 5:
                      throw _t11;
                    case 6:
                      return _context47.a(2);
                  }
                }, _callee46, this, [[1, 3]]);
              }));
              function execute() {
                return _execute.apply(this, arguments);
              }
              return execute;
            }()
          }]);
        }();

        //#endregion
        //#region src/packages/BlobDownloadBuilder.ts
        var _Symbol$toStringTag;
        _Symbol$toStringTag = Symbol.toStringTag;
        var BlobDownloadBuilder = /*#__PURE__*/function () {
          function BlobDownloadBuilder(downloadFn, shouldThrowOnError) {
            _classCallCheck(this, BlobDownloadBuilder);
            this.downloadFn = downloadFn;
            this.shouldThrowOnError = shouldThrowOnError;
            this[_Symbol$toStringTag] = "BlobDownloadBuilder";
            this.promise = null;
          }
          return _createClass(BlobDownloadBuilder, [{
            key: "asStream",
            value: function asStream() {
              return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
            }
          }, {
            key: "then",
            value: function then(onfulfilled, onrejected) {
              return this.getPromise().then(onfulfilled, onrejected);
            }
          }, {
            key: "catch",
            value: function _catch(onrejected) {
              return this.getPromise().catch(onrejected);
            }
          }, {
            key: "finally",
            value: function _finally(onfinally) {
              return this.getPromise().finally(onfinally);
            }
          }, {
            key: "getPromise",
            value: function getPromise() {
              if (!this.promise) this.promise = this.execute();
              return this.promise;
            }
          }, {
            key: "execute",
            value: function () {
              var _execute2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee47() {
                var _this, _t12, _t13;
                return _regenerator().w(function (_context48) {
                  while (1) switch (_context48.p = _context48.n) {
                    case 0:
                      _this = this;
                      _context48.p = 1;
                      _context48.n = 2;
                      return _this.downloadFn();
                    case 2:
                      _context48.n = 3;
                      return _context48.v.blob();
                    case 3:
                      _t12 = _context48.v;
                      return _context48.a(2, {
                        data: _t12,
                        error: null
                      });
                    case 4:
                      _context48.p = 4;
                      _t13 = _context48.v;
                      if (!_this.shouldThrowOnError) {
                        _context48.n = 5;
                        break;
                      }
                      throw _t13;
                    case 5:
                      if (!isStorageError(_t13)) {
                        _context48.n = 6;
                        break;
                      }
                      return _context48.a(2, {
                        data: null,
                        error: _t13
                      });
                    case 6:
                      throw _t13;
                    case 7:
                      return _context48.a(2);
                  }
                }, _callee47, this, [[1, 4]]);
              }));
              function execute() {
                return _execute2.apply(this, arguments);
              }
              return execute;
            }()
          }]);
        }();

        //#endregion
        //#region src/packages/StorageFileApi.ts
        var DEFAULT_SEARCH_OPTIONS = {
          limit: 100,
          offset: 0,
          sortBy: {
            column: "name",
            order: "asc"
          }
        };
        var DEFAULT_FILE_OPTIONS = {
          cacheControl: "3600",
          contentType: "text/plain;charset=UTF-8",
          upsert: false
        };
        var StorageFileApi = /*#__PURE__*/function () {
          function StorageFileApi(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var bucketId = arguments.length > 2 ? arguments[2] : undefined;
            var fetch$1 = arguments.length > 3 ? arguments[3] : undefined;
            _classCallCheck(this, StorageFileApi);
            this.shouldThrowOnError = false;
            this.url = url;
            this.headers = headers;
            this.bucketId = bucketId;
            this.fetch = resolveFetch$1$1(fetch$1);
          }
          /**
          * Enable throwing errors instead of returning them.
          *
          * @category File Buckets
          */
          return _createClass(StorageFileApi, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /**
            * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
            *
            * @param method HTTP method.
            * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
            * @param fileBody The body of the file to be stored in the bucket.
            */
          }, {
            key: "uploadOrUpdate",
            value: (function () {
              var _uploadOrUpdate = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee48(method, path, fileBody, fileOptions) {
                var _this, body, options, headers, metadata, cleanPath, _path, data, _t14;
                return _regenerator().w(function (_context49) {
                  while (1) switch (_context49.p = _context49.n) {
                    case 0:
                      _this = this;
                      _context49.p = 1;
                      options = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_FILE_OPTIONS), fileOptions);
                      headers = _objectSpread2$1(_objectSpread2$1({}, _this.headers), method === "POST" && {
                        "x-upsert": String(options.upsert)
                      });
                      metadata = options.metadata;
                      if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
                        body = new FormData();
                        body.append("cacheControl", options.cacheControl);
                        if (metadata) body.append("metadata", _this.encodeMetadata(metadata));
                        body.append("", fileBody);
                      } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
                        body = fileBody;
                        if (!body.has("cacheControl")) body.append("cacheControl", options.cacheControl);
                        if (metadata && !body.has("metadata")) body.append("metadata", _this.encodeMetadata(metadata));
                      } else {
                        body = fileBody;
                        headers["cache-control"] = "max-age=".concat(options.cacheControl);
                        headers["content-type"] = options.contentType;
                        if (metadata) headers["x-metadata"] = _this.toBase64(_this.encodeMetadata(metadata));
                        if ((typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && _typeof2(body) === "object" && "pipe" in body && typeof body.pipe === "function") && !options.duplex) options.duplex = "half";
                      }
                      if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2$1(_objectSpread2$1({}, headers), fileOptions.headers);
                      cleanPath = _this._removeEmptyFolders(path);
                      _path = _this._getFinalPath(cleanPath);
                      _context49.n = 2;
                      return (method == "PUT" ? put : post$1)(_this.fetch, "".concat(_this.url, "/object/").concat(_path), body, _objectSpread2$1({
                        headers: headers
                      }, (options === null || options === void 0 ? void 0 : options.duplex) ? {
                        duplex: options.duplex
                      } : {}));
                    case 2:
                      data = _context49.v;
                      return _context49.a(2, {
                        data: {
                          path: cleanPath,
                          id: data.Id,
                          fullPath: data.Key
                        },
                        error: null
                      });
                    case 3:
                      _context49.p = 3;
                      _t14 = _context49.v;
                      if (!_this.shouldThrowOnError) {
                        _context49.n = 4;
                        break;
                      }
                      throw _t14;
                    case 4:
                      if (!isStorageError(_t14)) {
                        _context49.n = 5;
                        break;
                      }
                      return _context49.a(2, {
                        data: null,
                        error: _t14
                      });
                    case 5:
                      throw _t14;
                    case 6:
                      return _context49.a(2);
                  }
                }, _callee48, this, [[1, 3]]);
              }));
              function uploadOrUpdate(_x87, _x88, _x89, _x90) {
                return _uploadOrUpdate.apply(this, arguments);
              }
              return uploadOrUpdate;
            }()
            /**
            * Uploads a file to an existing bucket.
            *
            * @category File Buckets
            * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
            * @param fileBody The body of the file to be stored in the bucket.
            * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
            * @returns Promise with response containing file path, id, and fullPath or error
            *
            * @example Upload file
            * ```js
            * const avatarFile = event.target.files[0]
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .upload('public/avatar1.png', avatarFile, {
            *     cacheControl: '3600',
            *     upsert: false
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "path": "public/avatar1.png",
            *     "fullPath": "avatars/public/avatar1.png"
            *   },
            *   "error": null
            * }
            * ```
            *
            * @example Upload file using `ArrayBuffer` from base64 file data
            * ```js
            * import { decode } from 'base64-arraybuffer'
            *
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .upload('public/avatar1.png', decode('base64FileData'), {
            *     contentType: 'image/png'
            *   })
            * ```
            */
            )
          }, {
            key: "upload",
            value: (function () {
              var _upload = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee49(path, fileBody, fileOptions) {
                return _regenerator().w(function (_context50) {
                  while (1) switch (_context50.n) {
                    case 0:
                      return _context50.a(2, this.uploadOrUpdate("POST", path, fileBody, fileOptions));
                  }
                }, _callee49, this);
              }));
              function upload(_x91, _x92, _x93) {
                return _upload.apply(this, arguments);
              }
              return upload;
            }()
            /**
            * Upload a file with a token generated from `createSignedUploadUrl`.
            *
            * @category File Buckets
            * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
            * @param token The token generated from `createSignedUploadUrl`
            * @param fileBody The body of the file to be stored in the bucket.
            * @param fileOptions HTTP headers (cacheControl, contentType, etc.).
            * **Note:** The `upsert` option has no effect here. To enable upsert behavior,
            * pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.
            * @returns Promise with response containing file path and fullPath or error
            *
            * @example Upload to a signed URL
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "path": "folder/cat.jpg",
            *     "fullPath": "avatars/folder/cat.jpg"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "uploadToSignedUrl",
            value: (function () {
              var _uploadToSignedUrl = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee50(path, token, fileBody, fileOptions) {
                var _this3, cleanPath, _path, url, body, options, headers, _t15, _t16, _t17, _t18;
                return _regenerator().w(function (_context51) {
                  while (1) switch (_context51.p = _context51.n) {
                    case 0:
                      _this3 = this;
                      cleanPath = _this3._removeEmptyFolders(path);
                      _path = _this3._getFinalPath(cleanPath);
                      url = new URL(_this3.url + "/object/upload/sign/".concat(_path));
                      url.searchParams.set("token", token);
                      _context51.p = 1;
                      options = _objectSpread2$1({
                        upsert: DEFAULT_FILE_OPTIONS.upsert
                      }, fileOptions);
                      headers = _objectSpread2$1(_objectSpread2$1({}, _this3.headers), {
                        "x-upsert": String(options.upsert)
                      });
                      if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
                        body = new FormData();
                        body.append("cacheControl", options.cacheControl);
                        body.append("", fileBody);
                      } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
                        body = fileBody;
                        body.append("cacheControl", options.cacheControl);
                      } else {
                        body = fileBody;
                        headers["cache-control"] = "max-age=".concat(options.cacheControl);
                        headers["content-type"] = options.contentType;
                      }
                      _t15 = cleanPath;
                      _context51.n = 2;
                      return put(_this3.fetch, url.toString(), body, {
                        headers: headers
                      });
                    case 2:
                      _t16 = _context51.v.Key;
                      _t17 = {
                        path: _t15,
                        fullPath: _t16
                      };
                      return _context51.a(2, {
                        data: _t17,
                        error: null
                      });
                    case 3:
                      _context51.p = 3;
                      _t18 = _context51.v;
                      if (!_this3.shouldThrowOnError) {
                        _context51.n = 4;
                        break;
                      }
                      throw _t18;
                    case 4:
                      if (!isStorageError(_t18)) {
                        _context51.n = 5;
                        break;
                      }
                      return _context51.a(2, {
                        data: null,
                        error: _t18
                      });
                    case 5:
                      throw _t18;
                    case 6:
                      return _context51.a(2);
                  }
                }, _callee50, this, [[1, 3]]);
              }));
              function uploadToSignedUrl(_x94, _x95, _x96, _x97) {
                return _uploadToSignedUrl.apply(this, arguments);
              }
              return uploadToSignedUrl;
            }()
            /**
            * Creates a signed upload URL.
            * Signed upload URLs can be used to upload files to the bucket without further authentication.
            * They are valid for 2 hours.
            *
            * @category File Buckets
            * @param path The file path, including the current file name. For example `folder/image.png`.
            * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
            * @returns Promise with response containing signed upload URL, token, and path or error
            *
            * @example Create Signed Upload URL
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .createSignedUploadUrl('folder/cat.jpg')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "signedUrl": "https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>",
            *     "path": "folder/cat.jpg",
            *     "token": "<TOKEN>"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "createSignedUploadUrl",
            value: (function () {
              var _createSignedUploadUrl = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee51(path, options) {
                var _this4, _path, headers, data, url, token, _t19;
                return _regenerator().w(function (_context52) {
                  while (1) switch (_context52.p = _context52.n) {
                    case 0:
                      _this4 = this;
                      _context52.p = 1;
                      _path = _this4._getFinalPath(path);
                      headers = _objectSpread2$1({}, _this4.headers);
                      if (options === null || options === void 0 ? void 0 : options.upsert) headers["x-upsert"] = "true";
                      _context52.n = 2;
                      return post$1(_this4.fetch, "".concat(_this4.url, "/object/upload/sign/").concat(_path), {}, {
                        headers: headers
                      });
                    case 2:
                      data = _context52.v;
                      url = new URL(_this4.url + data.url);
                      token = url.searchParams.get("token");
                      if (token) {
                        _context52.n = 3;
                        break;
                      }
                      throw new StorageError("No token returned by API");
                    case 3:
                      return _context52.a(2, {
                        data: {
                          signedUrl: url.toString(),
                          path: path,
                          token: token
                        },
                        error: null
                      });
                    case 4:
                      _context52.p = 4;
                      _t19 = _context52.v;
                      if (!_this4.shouldThrowOnError) {
                        _context52.n = 5;
                        break;
                      }
                      throw _t19;
                    case 5:
                      if (!isStorageError(_t19)) {
                        _context52.n = 6;
                        break;
                      }
                      return _context52.a(2, {
                        data: null,
                        error: _t19
                      });
                    case 6:
                      throw _t19;
                    case 7:
                      return _context52.a(2);
                  }
                }, _callee51, this, [[1, 4]]);
              }));
              function createSignedUploadUrl(_x98, _x99) {
                return _createSignedUploadUrl.apply(this, arguments);
              }
              return createSignedUploadUrl;
            }()
            /**
            * Replaces an existing file at the specified path with a new one.
            *
            * @category File Buckets
            * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
            * @param fileBody The body of the file to be stored in the bucket.
            * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
            * @returns Promise with response containing file path, id, and fullPath or error
            *
            * @example Update file
            * ```js
            * const avatarFile = event.target.files[0]
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .update('public/avatar1.png', avatarFile, {
            *     cacheControl: '3600',
            *     upsert: true
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "path": "public/avatar1.png",
            *     "fullPath": "avatars/public/avatar1.png"
            *   },
            *   "error": null
            * }
            * ```
            *
            * @example Update file using `ArrayBuffer` from base64 file data
            * ```js
            * import {decode} from 'base64-arraybuffer'
            *
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .update('public/avatar1.png', decode('base64FileData'), {
            *     contentType: 'image/png'
            *   })
            * ```
            */
            )
          }, {
            key: "update",
            value: (function () {
              var _update = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee52(path, fileBody, fileOptions) {
                return _regenerator().w(function (_context53) {
                  while (1) switch (_context53.n) {
                    case 0:
                      return _context53.a(2, this.uploadOrUpdate("PUT", path, fileBody, fileOptions));
                  }
                }, _callee52, this);
              }));
              function update(_x100, _x101, _x102) {
                return _update.apply(this, arguments);
              }
              return update;
            }()
            /**
            * Moves an existing file to a new path in the same bucket.
            *
            * @category File Buckets
            * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
            * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
            * @param options The destination options.
            * @returns Promise with response containing success message or error
            *
            * @example Move file
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .move('public/avatar1.png', 'private/avatar2.png')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "message": "Successfully moved"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "move",
            value: (function () {
              var _move = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee53(fromPath, toPath, options) {
                var _this6, _t20, _t21;
                return _regenerator().w(function (_context54) {
                  while (1) switch (_context54.p = _context54.n) {
                    case 0:
                      _this6 = this;
                      _context54.p = 1;
                      _context54.n = 2;
                      return post$1(_this6.fetch, "".concat(_this6.url, "/object/move"), {
                        bucketId: _this6.bucketId,
                        sourceKey: fromPath,
                        destinationKey: toPath,
                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
                      }, {
                        headers: _this6.headers
                      });
                    case 2:
                      _t20 = _context54.v;
                      return _context54.a(2, {
                        data: _t20,
                        error: null
                      });
                    case 3:
                      _context54.p = 3;
                      _t21 = _context54.v;
                      if (!_this6.shouldThrowOnError) {
                        _context54.n = 4;
                        break;
                      }
                      throw _t21;
                    case 4:
                      if (!isStorageError(_t21)) {
                        _context54.n = 5;
                        break;
                      }
                      return _context54.a(2, {
                        data: null,
                        error: _t21
                      });
                    case 5:
                      throw _t21;
                    case 6:
                      return _context54.a(2);
                  }
                }, _callee53, this, [[1, 3]]);
              }));
              function move(_x103, _x104, _x105) {
                return _move.apply(this, arguments);
              }
              return move;
            }()
            /**
            * Copies an existing file to a new path in the same bucket.
            *
            * @category File Buckets
            * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
            * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
            * @param options The destination options.
            * @returns Promise with response containing copied file path or error
            *
            * @example Copy file
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .copy('public/avatar1.png', 'private/avatar2.png')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "path": "avatars/private/avatar2.png"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "copy",
            value: (function () {
              var _copy = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee54(fromPath, toPath, options) {
                var _this7, _t22, _t23, _t24;
                return _regenerator().w(function (_context55) {
                  while (1) switch (_context55.p = _context55.n) {
                    case 0:
                      _this7 = this;
                      _context55.p = 1;
                      _context55.n = 2;
                      return post$1(_this7.fetch, "".concat(_this7.url, "/object/copy"), {
                        bucketId: _this7.bucketId,
                        sourceKey: fromPath,
                        destinationKey: toPath,
                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
                      }, {
                        headers: _this7.headers
                      });
                    case 2:
                      _t22 = _context55.v.Key;
                      _t23 = {
                        path: _t22
                      };
                      return _context55.a(2, {
                        data: _t23,
                        error: null
                      });
                    case 3:
                      _context55.p = 3;
                      _t24 = _context55.v;
                      if (!_this7.shouldThrowOnError) {
                        _context55.n = 4;
                        break;
                      }
                      throw _t24;
                    case 4:
                      if (!isStorageError(_t24)) {
                        _context55.n = 5;
                        break;
                      }
                      return _context55.a(2, {
                        data: null,
                        error: _t24
                      });
                    case 5:
                      throw _t24;
                    case 6:
                      return _context55.a(2);
                  }
                }, _callee54, this, [[1, 3]]);
              }));
              function copy(_x106, _x107, _x108) {
                return _copy.apply(this, arguments);
              }
              return copy;
            }()
            /**
            * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
            *
            * @category File Buckets
            * @param path The file path, including the current file name. For example `folder/image.png`.
            * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
            * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
            * @param options.transform Transform the asset before serving it to the client.
            * @returns Promise with response containing signed URL or error
            *
            * @example Create Signed URL
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .createSignedUrl('folder/avatar1.png', 60)
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
            *   },
            *   "error": null
            * }
            * ```
            *
            * @example Create a signed URL for an asset with transformations
            * ```js
            * const { data } = await supabase
            *   .storage
            *   .from('avatars')
            *   .createSignedUrl('folder/avatar1.png', 60, {
            *     transform: {
            *       width: 100,
            *       height: 100,
            *     }
            *   })
            * ```
            *
            * @example Create a signed URL which triggers the download of the asset
            * ```js
            * const { data } = await supabase
            *   .storage
            *   .from('avatars')
            *   .createSignedUrl('folder/avatar1.png', 60, {
            *     download: true,
            *   })
            * ```
            */
            )
          }, {
            key: "createSignedUrl",
            value: (function () {
              var _createSignedUrl = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee55(path, expiresIn, options) {
                var _this8, _path, data, downloadQueryParam, _t25;
                return _regenerator().w(function (_context56) {
                  while (1) switch (_context56.p = _context56.n) {
                    case 0:
                      _this8 = this;
                      _context56.p = 1;
                      _path = _this8._getFinalPath(path);
                      _context56.n = 2;
                      return post$1(_this8.fetch, "".concat(_this8.url, "/object/sign/").concat(_path), _objectSpread2$1({
                        expiresIn: expiresIn
                      }, (options === null || options === void 0 ? void 0 : options.transform) ? {
                        transform: options.transform
                      } : {}), {
                        headers: _this8.headers
                      });
                    case 2:
                      data = _context56.v;
                      downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "&download=".concat(options.download === true ? "" : options.download) : "";
                      data = {
                        signedUrl: encodeURI("".concat(_this8.url).concat(data.signedURL).concat(downloadQueryParam))
                      };
                      return _context56.a(2, {
                        data: data,
                        error: null
                      });
                    case 3:
                      _context56.p = 3;
                      _t25 = _context56.v;
                      if (!_this8.shouldThrowOnError) {
                        _context56.n = 4;
                        break;
                      }
                      throw _t25;
                    case 4:
                      if (!isStorageError(_t25)) {
                        _context56.n = 5;
                        break;
                      }
                      return _context56.a(2, {
                        data: null,
                        error: _t25
                      });
                    case 5:
                      throw _t25;
                    case 6:
                      return _context56.a(2);
                  }
                }, _callee55, this, [[1, 3]]);
              }));
              function createSignedUrl(_x109, _x110, _x111) {
                return _createSignedUrl.apply(this, arguments);
              }
              return createSignedUrl;
            }()
            /**
            * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
            *
            * @category File Buckets
            * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
            * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
            * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
            * @returns Promise with response containing array of objects with signedUrl, path, and error or error
            *
            * @example Create Signed URLs
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": [
            *     {
            *       "error": null,
            *       "path": "folder/avatar1.png",
            *       "signedURL": "/object/sign/avatars/folder/avatar1.png?token=<TOKEN>",
            *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
            *     },
            *     {
            *       "error": null,
            *       "path": "folder/avatar2.png",
            *       "signedURL": "/object/sign/avatars/folder/avatar2.png?token=<TOKEN>",
            *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>"
            *     }
            *   ],
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "createSignedUrls",
            value: (function () {
              var _createSignedUrls = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee56(paths, expiresIn, options) {
                var _this9, data, downloadQueryParam, _t26;
                return _regenerator().w(function (_context57) {
                  while (1) switch (_context57.p = _context57.n) {
                    case 0:
                      _this9 = this;
                      _context57.p = 1;
                      _context57.n = 2;
                      return post$1(_this9.fetch, "".concat(_this9.url, "/object/sign/").concat(_this9.bucketId), {
                        expiresIn: expiresIn,
                        paths: paths
                      }, {
                        headers: _this9.headers
                      });
                    case 2:
                      data = _context57.v;
                      downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "&download=".concat(options.download === true ? "" : options.download) : "";
                      return _context57.a(2, {
                        data: data.map(function (datum) {
                          return _objectSpread2$1(_objectSpread2$1({}, datum), {}, {
                            signedUrl: datum.signedURL ? encodeURI("".concat(_this9.url).concat(datum.signedURL).concat(downloadQueryParam)) : null
                          });
                        }),
                        error: null
                      });
                    case 3:
                      _context57.p = 3;
                      _t26 = _context57.v;
                      if (!_this9.shouldThrowOnError) {
                        _context57.n = 4;
                        break;
                      }
                      throw _t26;
                    case 4:
                      if (!isStorageError(_t26)) {
                        _context57.n = 5;
                        break;
                      }
                      return _context57.a(2, {
                        data: null,
                        error: _t26
                      });
                    case 5:
                      throw _t26;
                    case 6:
                      return _context57.a(2);
                  }
                }, _callee56, this, [[1, 3]]);
              }));
              function createSignedUrls(_x112, _x113, _x114) {
                return _createSignedUrls.apply(this, arguments);
              }
              return createSignedUrls;
            }()
            /**
            * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
            *
            * @category File Buckets
            * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
            * @param options.transform Transform the asset before serving it to the client.
            * @returns BlobDownloadBuilder instance for downloading the file
            *
            * @example Download file
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .download('folder/avatar1.png')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": <BLOB>,
            *   "error": null
            * }
            * ```
            *
            * @example Download file with transformations
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .download('folder/avatar1.png', {
            *     transform: {
            *       width: 100,
            *       height: 100,
            *       quality: 80
            *     }
            *   })
            * ```
            */
            )
          }, {
            key: "download",
            value: function download(path, options) {
              var _this92 = this;
              var renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image/authenticated" : "object";
              var transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
              var queryString = transformationQuery ? "?".concat(transformationQuery) : "";
              var _path = this._getFinalPath(path);
              var downloadFn = function downloadFn() {
                return get(_this92.fetch, "".concat(_this92.url, "/").concat(renderPath, "/").concat(_path).concat(queryString), {
                  headers: _this92.headers,
                  noResolveJson: true
                });
              };
              return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
            }
            /**
            * Retrieves the details of an existing file.
            *
            * @category File Buckets
            * @param path The file path, including the file name. For example `folder/image.png`.
            * @returns Promise with response containing file metadata or error
            *
            * @example Get file info
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .info('folder/avatar1.png')
            * ```
            */
          }, {
            key: "info",
            value: (function () {
              var _info = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee57(path) {
                var _this10, _path, _t27, _t28, _t29;
                return _regenerator().w(function (_context58) {
                  while (1) switch (_context58.p = _context58.n) {
                    case 0:
                      _this10 = this;
                      _path = _this10._getFinalPath(path);
                      _context58.p = 1;
                      _t27 = _recursiveToCamel;
                      _context58.n = 2;
                      return get(_this10.fetch, "".concat(_this10.url, "/object/info/").concat(_path), {
                        headers: _this10.headers
                      });
                    case 2:
                      _t28 = _t27(_context58.v);
                      return _context58.a(2, {
                        data: _t28,
                        error: null
                      });
                    case 3:
                      _context58.p = 3;
                      _t29 = _context58.v;
                      if (!_this10.shouldThrowOnError) {
                        _context58.n = 4;
                        break;
                      }
                      throw _t29;
                    case 4:
                      if (!isStorageError(_t29)) {
                        _context58.n = 5;
                        break;
                      }
                      return _context58.a(2, {
                        data: null,
                        error: _t29
                      });
                    case 5:
                      throw _t29;
                    case 6:
                      return _context58.a(2);
                  }
                }, _callee57, this, [[1, 3]]);
              }));
              function info(_x115) {
                return _info.apply(this, arguments);
              }
              return info;
            }()
            /**
            * Checks the existence of a file.
            *
            * @category File Buckets
            * @param path The file path, including the file name. For example `folder/image.png`.
            * @returns Promise with response containing boolean indicating file existence or error
            *
            * @example Check file existence
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .exists('folder/avatar1.png')
            * ```
            */
            )
          }, {
            key: "exists",
            value: (function () {
              var _exists = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee58(path) {
                var _this11, _path, originalError, _t30;
                return _regenerator().w(function (_context59) {
                  while (1) switch (_context59.p = _context59.n) {
                    case 0:
                      _this11 = this;
                      _path = _this11._getFinalPath(path);
                      _context59.p = 1;
                      _context59.n = 2;
                      return head(_this11.fetch, "".concat(_this11.url, "/object/").concat(_path), {
                        headers: _this11.headers
                      });
                    case 2:
                      return _context59.a(2, {
                        data: true,
                        error: null
                      });
                    case 3:
                      _context59.p = 3;
                      _t30 = _context59.v;
                      if (!_this11.shouldThrowOnError) {
                        _context59.n = 4;
                        break;
                      }
                      throw _t30;
                    case 4:
                      if (!(isStorageError(_t30) && _t30 instanceof StorageUnknownError)) {
                        _context59.n = 5;
                        break;
                      }
                      originalError = _t30.originalError;
                      if (![400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
                        _context59.n = 5;
                        break;
                      }
                      return _context59.a(2, {
                        data: false,
                        error: _t30
                      });
                    case 5:
                      throw _t30;
                    case 6:
                      return _context59.a(2);
                  }
                }, _callee58, this, [[1, 3]]);
              }));
              function exists(_x116) {
                return _exists.apply(this, arguments);
              }
              return exists;
            }()
            /**
            * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
            * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
            *
            * @category File Buckets
            * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
            * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
            * @param options.transform Transform the asset before serving it to the client.
            * @returns Object with public URL
            *
            * @example Returns the URL for an asset in a public bucket
            * ```js
            * const { data } = supabase
            *   .storage
            *   .from('public-bucket')
            *   .getPublicUrl('folder/avatar1.png')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "publicUrl": "https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png"
            *   }
            * }
            * ```
            *
            * @example Returns the URL for an asset in a public bucket with transformations
            * ```js
            * const { data } = supabase
            *   .storage
            *   .from('public-bucket')
            *   .getPublicUrl('folder/avatar1.png', {
            *     transform: {
            *       width: 100,
            *       height: 100,
            *     }
            *   })
            * ```
            *
            * @example Returns the URL which triggers the download of an asset in a public bucket
            * ```js
            * const { data } = supabase
            *   .storage
            *   .from('public-bucket')
            *   .getPublicUrl('folder/avatar1.png', {
            *     download: true,
            *   })
            * ```
            */
            )
          }, {
            key: "getPublicUrl",
            value: function getPublicUrl(path, options) {
              var _path = this._getFinalPath(path);
              var _queryString = [];
              var downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "download=".concat(options.download === true ? "" : options.download) : "";
              if (downloadQueryParam !== "") _queryString.push(downloadQueryParam);
              var renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image" : "object";
              var transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
              if (transformationQuery !== "") _queryString.push(transformationQuery);
              var queryString = _queryString.join("&");
              if (queryString !== "") queryString = "?".concat(queryString);
              return {
                data: {
                  publicUrl: encodeURI("".concat(this.url, "/").concat(renderPath, "/public/").concat(_path).concat(queryString))
                }
              };
            }
            /**
            * Deletes files within the same bucket
            *
            * @category File Buckets
            * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
            * @returns Promise with response containing array of deleted file objects or error
            *
            * @example Delete file
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .remove(['folder/avatar1.png'])
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": [],
            *   "error": null
            * }
            * ```
            */
          }, {
            key: "remove",
            value: (function () {
              var _remove4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee59(paths) {
                var _this12, _t31, _t32;
                return _regenerator().w(function (_context60) {
                  while (1) switch (_context60.p = _context60.n) {
                    case 0:
                      _this12 = this;
                      _context60.p = 1;
                      _context60.n = 2;
                      return _remove3(_this12.fetch, "".concat(_this12.url, "/object/").concat(_this12.bucketId), {
                        prefixes: paths
                      }, {
                        headers: _this12.headers
                      });
                    case 2:
                      _t31 = _context60.v;
                      return _context60.a(2, {
                        data: _t31,
                        error: null
                      });
                    case 3:
                      _context60.p = 3;
                      _t32 = _context60.v;
                      if (!_this12.shouldThrowOnError) {
                        _context60.n = 4;
                        break;
                      }
                      throw _t32;
                    case 4:
                      if (!isStorageError(_t32)) {
                        _context60.n = 5;
                        break;
                      }
                      return _context60.a(2, {
                        data: null,
                        error: _t32
                      });
                    case 5:
                      throw _t32;
                    case 6:
                      return _context60.a(2);
                  }
                }, _callee59, this, [[1, 3]]);
              }));
              function remove(_x117) {
                return _remove4.apply(this, arguments);
              }
              return remove;
            }()
            /**
            * Get file metadata
            * @param id the file id to retrieve metadata
            */
            /**
            * Update file metadata
            * @param id the file id to update metadata
            * @param meta the new file metadata
            */
            /**
            * Lists all the files and folders within a path of the bucket.
            *
            * @category File Buckets
            * @param path The folder path.
            * @param options Search options including limit (defaults to 100), offset, sortBy, and search
            * @param parameters Optional fetch parameters including signal for cancellation
            * @returns Promise with response containing array of files or error
            *
            * @example List files in a bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .list('folder', {
            *     limit: 100,
            *     offset: 0,
            *     sortBy: { column: 'name', order: 'asc' },
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": [
            *     {
            *       "name": "avatar1.png",
            *       "id": "e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2",
            *       "updated_at": "2024-05-22T23:06:05.580Z",
            *       "created_at": "2024-05-22T23:04:34.443Z",
            *       "last_accessed_at": "2024-05-22T23:04:34.443Z",
            *       "metadata": {
            *         "eTag": "\"c5e8c553235d9af30ef4f6e280790b92\"",
            *         "size": 32175,
            *         "mimetype": "image/png",
            *         "cacheControl": "max-age=3600",
            *         "lastModified": "2024-05-22T23:06:05.574Z",
            *         "contentLength": 32175,
            *         "httpStatusCode": 200
            *       }
            *     }
            *   ],
            *   "error": null
            * }
            * ```
            *
            * @example Search files in a bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .from('avatars')
            *   .list('folder', {
            *     limit: 100,
            *     offset: 0,
            *     sortBy: { column: 'name', order: 'asc' },
            *     search: 'jon'
            *   })
            * ```
            */
            )
          }, {
            key: "list",
            value: (function () {
              var _list2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee60(path, options, parameters) {
                var _this13, body, _t33, _t34;
                return _regenerator().w(function (_context61) {
                  while (1) switch (_context61.p = _context61.n) {
                    case 0:
                      _this13 = this;
                      _context61.p = 1;
                      body = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, DEFAULT_SEARCH_OPTIONS), options), {}, {
                        prefix: path || ""
                      });
                      _context61.n = 2;
                      return post$1(_this13.fetch, "".concat(_this13.url, "/object/list/").concat(_this13.bucketId), body, {
                        headers: _this13.headers
                      }, parameters);
                    case 2:
                      _t33 = _context61.v;
                      return _context61.a(2, {
                        data: _t33,
                        error: null
                      });
                    case 3:
                      _context61.p = 3;
                      _t34 = _context61.v;
                      if (!_this13.shouldThrowOnError) {
                        _context61.n = 4;
                        break;
                      }
                      throw _t34;
                    case 4:
                      if (!isStorageError(_t34)) {
                        _context61.n = 5;
                        break;
                      }
                      return _context61.a(2, {
                        data: null,
                        error: _t34
                      });
                    case 5:
                      throw _t34;
                    case 6:
                      return _context61.a(2);
                  }
                }, _callee60, this, [[1, 3]]);
              }));
              function list(_x118, _x119, _x120) {
                return _list2.apply(this, arguments);
              }
              return list;
            }()
            /**
            * @experimental this method signature might change in the future
            *
            * @category File Buckets
            * @param options search options
            * @param parameters
            */
            )
          }, {
            key: "listV2",
            value: (function () {
              var _listV = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee61(options, parameters) {
                var _this14, body, _t35, _t36;
                return _regenerator().w(function (_context62) {
                  while (1) switch (_context62.p = _context62.n) {
                    case 0:
                      _this14 = this;
                      _context62.p = 1;
                      body = _objectSpread2$1({}, options);
                      _context62.n = 2;
                      return post$1(_this14.fetch, "".concat(_this14.url, "/object/list-v2/").concat(_this14.bucketId), body, {
                        headers: _this14.headers
                      }, parameters);
                    case 2:
                      _t35 = _context62.v;
                      return _context62.a(2, {
                        data: _t35,
                        error: null
                      });
                    case 3:
                      _context62.p = 3;
                      _t36 = _context62.v;
                      if (!_this14.shouldThrowOnError) {
                        _context62.n = 4;
                        break;
                      }
                      throw _t36;
                    case 4:
                      if (!isStorageError(_t36)) {
                        _context62.n = 5;
                        break;
                      }
                      return _context62.a(2, {
                        data: null,
                        error: _t36
                      });
                    case 5:
                      throw _t36;
                    case 6:
                      return _context62.a(2);
                  }
                }, _callee61, this, [[1, 3]]);
              }));
              function listV2(_x121, _x122) {
                return _listV.apply(this, arguments);
              }
              return listV2;
            }())
          }, {
            key: "encodeMetadata",
            value: function encodeMetadata(metadata) {
              return JSON.stringify(metadata);
            }
          }, {
            key: "toBase64",
            value: function toBase64(data) {
              if (typeof Buffer !== "undefined") return Buffer.from(data).toString("base64");
              return btoa(data);
            }
          }, {
            key: "_getFinalPath",
            value: function _getFinalPath(path) {
              return "".concat(this.bucketId, "/").concat(path.replace(/^\/+/, ""));
            }
          }, {
            key: "_removeEmptyFolders",
            value: function _removeEmptyFolders(path) {
              return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
            }
          }, {
            key: "transformOptsToQueryString",
            value: function transformOptsToQueryString(transform) {
              var params = [];
              if (transform.width) params.push("width=".concat(transform.width));
              if (transform.height) params.push("height=".concat(transform.height));
              if (transform.resize) params.push("resize=".concat(transform.resize));
              if (transform.format) params.push("format=".concat(transform.format));
              if (transform.quality) params.push("quality=".concat(transform.quality));
              return params.join("&");
            }
          }]);
        }();

        //#endregion
        //#region src/lib/version.ts
        var version$2 = "2.90.1";

        //#endregion
        //#region src/lib/constants.ts
        var DEFAULT_HEADERS$1$1 = {
          "X-Client-Info": "storage-js/".concat(version$2)
        };

        //#endregion
        //#region src/packages/StorageBucketApi.ts
        var StorageBucketApi = /*#__PURE__*/function () {
          function StorageBucketApi(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            var opts = arguments.length > 3 ? arguments[3] : undefined;
            _classCallCheck(this, StorageBucketApi);
            this.shouldThrowOnError = false;
            var baseUrl = new URL(url);
            if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
              if (/supabase\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes("storage.supabase.")) baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
            }
            this.url = baseUrl.href.replace(/\/$/, "");
            this.headers = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_HEADERS$1$1), headers);
            this.fetch = resolveFetch$1$1(fetch$1);
          }
          /**
          * Enable throwing errors instead of returning them.
          *
          * @category File Buckets
          */
          return _createClass(StorageBucketApi, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /**
            * Retrieves the details of all Storage buckets within an existing project.
            *
            * @category File Buckets
            * @param options Query parameters for listing buckets
            * @param options.limit Maximum number of buckets to return
            * @param options.offset Number of buckets to skip
            * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
            * @param options.sortOrder Sort order ('asc' or 'desc')
            * @param options.search Search term to filter bucket names
            * @returns Promise with response containing array of buckets or error
            *
            * @example List buckets
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .listBuckets()
            * ```
            *
            * @example List buckets with options
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .listBuckets({
            *     limit: 10,
            *     offset: 0,
            *     sortColumn: 'created_at',
            *     sortOrder: 'desc',
            *     search: 'prod'
            *   })
            * ```
            */
          }, {
            key: "listBuckets",
            value: (function () {
              var _listBuckets = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee62(options) {
                var _this, queryString, _t37, _t38;
                return _regenerator().w(function (_context63) {
                  while (1) switch (_context63.p = _context63.n) {
                    case 0:
                      _this = this;
                      _context63.p = 1;
                      queryString = _this.listBucketOptionsToQueryString(options);
                      _context63.n = 2;
                      return get(_this.fetch, "".concat(_this.url, "/bucket").concat(queryString), {
                        headers: _this.headers
                      });
                    case 2:
                      _t37 = _context63.v;
                      return _context63.a(2, {
                        data: _t37,
                        error: null
                      });
                    case 3:
                      _context63.p = 3;
                      _t38 = _context63.v;
                      if (!_this.shouldThrowOnError) {
                        _context63.n = 4;
                        break;
                      }
                      throw _t38;
                    case 4:
                      if (!isStorageError(_t38)) {
                        _context63.n = 5;
                        break;
                      }
                      return _context63.a(2, {
                        data: null,
                        error: _t38
                      });
                    case 5:
                      throw _t38;
                    case 6:
                      return _context63.a(2);
                  }
                }, _callee62, this, [[1, 3]]);
              }));
              function listBuckets(_x123) {
                return _listBuckets.apply(this, arguments);
              }
              return listBuckets;
            }()
            /**
            * Retrieves the details of an existing Storage bucket.
            *
            * @category File Buckets
            * @param id The unique identifier of the bucket you would like to retrieve.
            * @returns Promise with response containing bucket details or error
            *
            * @example Get bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .getBucket('avatars')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "id": "avatars",
            *     "name": "avatars",
            *     "owner": "",
            *     "public": false,
            *     "file_size_limit": 1024,
            *     "allowed_mime_types": [
            *       "image/png"
            *     ],
            *     "created_at": "2024-05-22T22:26:05.100Z",
            *     "updated_at": "2024-05-22T22:26:05.100Z"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "getBucket",
            value: (function () {
              var _getBucket = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee63(id) {
                var _this2, _t39, _t40;
                return _regenerator().w(function (_context64) {
                  while (1) switch (_context64.p = _context64.n) {
                    case 0:
                      _this2 = this;
                      _context64.p = 1;
                      _context64.n = 2;
                      return get(_this2.fetch, "".concat(_this2.url, "/bucket/").concat(id), {
                        headers: _this2.headers
                      });
                    case 2:
                      _t39 = _context64.v;
                      return _context64.a(2, {
                        data: _t39,
                        error: null
                      });
                    case 3:
                      _context64.p = 3;
                      _t40 = _context64.v;
                      if (!_this2.shouldThrowOnError) {
                        _context64.n = 4;
                        break;
                      }
                      throw _t40;
                    case 4:
                      if (!isStorageError(_t40)) {
                        _context64.n = 5;
                        break;
                      }
                      return _context64.a(2, {
                        data: null,
                        error: _t40
                      });
                    case 5:
                      throw _t40;
                    case 6:
                      return _context64.a(2);
                  }
                }, _callee63, this, [[1, 3]]);
              }));
              function getBucket(_x124) {
                return _getBucket.apply(this, arguments);
              }
              return getBucket;
            }()
            /**
            * Creates a new Storage bucket
            *
            * @category File Buckets
            * @param id A unique identifier for the bucket you are creating.
            * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
            * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
            * The global file size limit takes precedence over this value.
            * The default value is null, which doesn't set a per bucket file size limit.
            * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
            * The default value is null, which allows files with all mime types to be uploaded.
            * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
            * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
            *   - default bucket type is `STANDARD`
            * @returns Promise with response containing newly created bucket name or error
            *
            * @example Create bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .createBucket('avatars', {
            *     public: false,
            *     allowedMimeTypes: ['image/png'],
            *     fileSizeLimit: 1024
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "name": "avatars"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "createBucket",
            value: (function () {
              var _createBucket = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee64(id) {
                var options,
                  _this3,
                  _args64 = arguments,
                  _t41,
                  _t42;
                return _regenerator().w(function (_context65) {
                  while (1) switch (_context65.p = _context65.n) {
                    case 0:
                      options = _args64.length > 1 && _args64[1] !== undefined ? _args64[1] : {
                        public: false
                      };
                      _this3 = this;
                      _context65.p = 1;
                      _context65.n = 2;
                      return post$1(_this3.fetch, "".concat(_this3.url, "/bucket"), {
                        id: id,
                        name: id,
                        type: options.type,
                        public: options.public,
                        file_size_limit: options.fileSizeLimit,
                        allowed_mime_types: options.allowedMimeTypes
                      }, {
                        headers: _this3.headers
                      });
                    case 2:
                      _t41 = _context65.v;
                      return _context65.a(2, {
                        data: _t41,
                        error: null
                      });
                    case 3:
                      _context65.p = 3;
                      _t42 = _context65.v;
                      if (!_this3.shouldThrowOnError) {
                        _context65.n = 4;
                        break;
                      }
                      throw _t42;
                    case 4:
                      if (!isStorageError(_t42)) {
                        _context65.n = 5;
                        break;
                      }
                      return _context65.a(2, {
                        data: null,
                        error: _t42
                      });
                    case 5:
                      throw _t42;
                    case 6:
                      return _context65.a(2);
                  }
                }, _callee64, this, [[1, 3]]);
              }));
              function createBucket(_x125) {
                return _createBucket.apply(this, arguments);
              }
              return createBucket;
            }()
            /**
            * Updates a Storage bucket
            *
            * @category File Buckets
            * @param id A unique identifier for the bucket you are updating.
            * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
            * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
            * The global file size limit takes precedence over this value.
            * The default value is null, which doesn't set a per bucket file size limit.
            * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
            * The default value is null, which allows files with all mime types to be uploaded.
            * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
            * @returns Promise with response containing success message or error
            *
            * @example Update bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .updateBucket('avatars', {
            *     public: false,
            *     allowedMimeTypes: ['image/png'],
            *     fileSizeLimit: 1024
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "message": "Successfully updated"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "updateBucket",
            value: (function () {
              var _updateBucket = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee65(id, options) {
                var _this4, _t43, _t44;
                return _regenerator().w(function (_context66) {
                  while (1) switch (_context66.p = _context66.n) {
                    case 0:
                      _this4 = this;
                      _context66.p = 1;
                      _context66.n = 2;
                      return put(_this4.fetch, "".concat(_this4.url, "/bucket/").concat(id), {
                        id: id,
                        name: id,
                        public: options.public,
                        file_size_limit: options.fileSizeLimit,
                        allowed_mime_types: options.allowedMimeTypes
                      }, {
                        headers: _this4.headers
                      });
                    case 2:
                      _t43 = _context66.v;
                      return _context66.a(2, {
                        data: _t43,
                        error: null
                      });
                    case 3:
                      _context66.p = 3;
                      _t44 = _context66.v;
                      if (!_this4.shouldThrowOnError) {
                        _context66.n = 4;
                        break;
                      }
                      throw _t44;
                    case 4:
                      if (!isStorageError(_t44)) {
                        _context66.n = 5;
                        break;
                      }
                      return _context66.a(2, {
                        data: null,
                        error: _t44
                      });
                    case 5:
                      throw _t44;
                    case 6:
                      return _context66.a(2);
                  }
                }, _callee65, this, [[1, 3]]);
              }));
              function updateBucket(_x126, _x127) {
                return _updateBucket.apply(this, arguments);
              }
              return updateBucket;
            }()
            /**
            * Removes all objects inside a single bucket.
            *
            * @category File Buckets
            * @param id The unique identifier of the bucket you would like to empty.
            * @returns Promise with success message or error
            *
            * @example Empty bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .emptyBucket('avatars')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "message": "Successfully emptied"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "emptyBucket",
            value: (function () {
              var _emptyBucket = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee66(id) {
                var _this5, _t45, _t46;
                return _regenerator().w(function (_context67) {
                  while (1) switch (_context67.p = _context67.n) {
                    case 0:
                      _this5 = this;
                      _context67.p = 1;
                      _context67.n = 2;
                      return post$1(_this5.fetch, "".concat(_this5.url, "/bucket/").concat(id, "/empty"), {}, {
                        headers: _this5.headers
                      });
                    case 2:
                      _t45 = _context67.v;
                      return _context67.a(2, {
                        data: _t45,
                        error: null
                      });
                    case 3:
                      _context67.p = 3;
                      _t46 = _context67.v;
                      if (!_this5.shouldThrowOnError) {
                        _context67.n = 4;
                        break;
                      }
                      throw _t46;
                    case 4:
                      if (!isStorageError(_t46)) {
                        _context67.n = 5;
                        break;
                      }
                      return _context67.a(2, {
                        data: null,
                        error: _t46
                      });
                    case 5:
                      throw _t46;
                    case 6:
                      return _context67.a(2);
                  }
                }, _callee66, this, [[1, 3]]);
              }));
              function emptyBucket(_x128) {
                return _emptyBucket.apply(this, arguments);
              }
              return emptyBucket;
            }()
            /**
            * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
            * You must first `empty()` the bucket.
            *
            * @category File Buckets
            * @param id The unique identifier of the bucket you would like to delete.
            * @returns Promise with success message or error
            *
            * @example Delete bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .deleteBucket('avatars')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "message": "Successfully deleted"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "deleteBucket",
            value: (function () {
              var _deleteBucket = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee67(id) {
                var _this6, _t47, _t48;
                return _regenerator().w(function (_context68) {
                  while (1) switch (_context68.p = _context68.n) {
                    case 0:
                      _this6 = this;
                      _context68.p = 1;
                      _context68.n = 2;
                      return _remove3(_this6.fetch, "".concat(_this6.url, "/bucket/").concat(id), {}, {
                        headers: _this6.headers
                      });
                    case 2:
                      _t47 = _context68.v;
                      return _context68.a(2, {
                        data: _t47,
                        error: null
                      });
                    case 3:
                      _context68.p = 3;
                      _t48 = _context68.v;
                      if (!_this6.shouldThrowOnError) {
                        _context68.n = 4;
                        break;
                      }
                      throw _t48;
                    case 4:
                      if (!isStorageError(_t48)) {
                        _context68.n = 5;
                        break;
                      }
                      return _context68.a(2, {
                        data: null,
                        error: _t48
                      });
                    case 5:
                      throw _t48;
                    case 6:
                      return _context68.a(2);
                  }
                }, _callee67, this, [[1, 3]]);
              }));
              function deleteBucket(_x129) {
                return _deleteBucket.apply(this, arguments);
              }
              return deleteBucket;
            }())
          }, {
            key: "listBucketOptionsToQueryString",
            value: function listBucketOptionsToQueryString(options) {
              var params = {};
              if (options) {
                if ("limit" in options) params.limit = String(options.limit);
                if ("offset" in options) params.offset = String(options.offset);
                if (options.search) params.search = options.search;
                if (options.sortColumn) params.sortColumn = options.sortColumn;
                if (options.sortOrder) params.sortOrder = options.sortOrder;
              }
              return Object.keys(params).length > 0 ? "?" + new URLSearchParams(params).toString() : "";
            }
          }]);
        }();

        //#endregion
        //#region src/packages/StorageAnalyticsClient.ts
        /**
        * Client class for managing Analytics Buckets using Iceberg tables
        * Provides methods for creating, listing, and deleting analytics buckets
        */
        var StorageAnalyticsClient = /*#__PURE__*/function () {
          /**
          * @alpha
          *
          * Creates a new StorageAnalyticsClient instance
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Analytics Buckets
          * @param url - The base URL for the storage API
          * @param headers - HTTP headers to include in requests
          * @param fetch - Optional custom fetch implementation
          *
          * @example
          * ```typescript
          * const client = new StorageAnalyticsClient(url, headers)
          * ```
          */
          function StorageAnalyticsClient(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, StorageAnalyticsClient);
            this.shouldThrowOnError = false;
            this.url = url.replace(/\/$/, "");
            this.headers = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_HEADERS$1$1), headers);
            this.fetch = resolveFetch$1$1(fetch$1);
          }
          /**
          * @alpha
          *
          * Enable throwing errors instead of returning them in the response
          * When enabled, failed operations will throw instead of returning { data: null, error }
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Analytics Buckets
          * @returns This instance for method chaining
          */
          return _createClass(StorageAnalyticsClient, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /**
            * @alpha
            *
            * Creates a new analytics bucket using Iceberg tables
            * Analytics buckets are optimized for analytical queries and data processing
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Analytics Buckets
            * @param name A unique name for the bucket you are creating
            * @returns Promise with response containing newly created analytics bucket or error
            *
            * @example Create analytics bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .analytics
            *   .createBucket('analytics-data')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "name": "analytics-data",
            *     "type": "ANALYTICS",
            *     "format": "iceberg",
            *     "created_at": "2024-05-22T22:26:05.100Z",
            *     "updated_at": "2024-05-22T22:26:05.100Z"
            *   },
            *   "error": null
            * }
            * ```
            */
          }, {
            key: "createBucket",
            value: (function () {
              var _createBucket2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee68(name) {
                var _this, _t49, _t50;
                return _regenerator().w(function (_context69) {
                  while (1) switch (_context69.p = _context69.n) {
                    case 0:
                      _this = this;
                      _context69.p = 1;
                      _context69.n = 2;
                      return post$1(_this.fetch, "".concat(_this.url, "/bucket"), {
                        name: name
                      }, {
                        headers: _this.headers
                      });
                    case 2:
                      _t49 = _context69.v;
                      return _context69.a(2, {
                        data: _t49,
                        error: null
                      });
                    case 3:
                      _context69.p = 3;
                      _t50 = _context69.v;
                      if (!_this.shouldThrowOnError) {
                        _context69.n = 4;
                        break;
                      }
                      throw _t50;
                    case 4:
                      if (!isStorageError(_t50)) {
                        _context69.n = 5;
                        break;
                      }
                      return _context69.a(2, {
                        data: null,
                        error: _t50
                      });
                    case 5:
                      throw _t50;
                    case 6:
                      return _context69.a(2);
                  }
                }, _callee68, this, [[1, 3]]);
              }));
              function createBucket(_x130) {
                return _createBucket2.apply(this, arguments);
              }
              return createBucket;
            }()
            /**
            * @alpha
            *
            * Retrieves the details of all Analytics Storage buckets within an existing project
            * Only returns buckets of type 'ANALYTICS'
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Analytics Buckets
            * @param options Query parameters for listing buckets
            * @param options.limit Maximum number of buckets to return
            * @param options.offset Number of buckets to skip
            * @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')
            * @param options.sortOrder Sort order ('asc' or 'desc')
            * @param options.search Search term to filter bucket names
            * @returns Promise with response containing array of analytics buckets or error
            *
            * @example List analytics buckets
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .analytics
            *   .listBuckets({
            *     limit: 10,
            *     offset: 0,
            *     sortColumn: 'created_at',
            *     sortOrder: 'desc'
            *   })
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": [
            *     {
            *       "name": "analytics-data",
            *       "type": "ANALYTICS",
            *       "format": "iceberg",
            *       "created_at": "2024-05-22T22:26:05.100Z",
            *       "updated_at": "2024-05-22T22:26:05.100Z"
            *     }
            *   ],
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "listBuckets",
            value: (function () {
              var _listBuckets2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee69(options) {
                var _this2, queryParams, queryString, url, _t51, _t52;
                return _regenerator().w(function (_context70) {
                  while (1) switch (_context70.p = _context70.n) {
                    case 0:
                      _this2 = this;
                      _context70.p = 1;
                      queryParams = new URLSearchParams();
                      if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set("limit", options.limit.toString());
                      if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set("offset", options.offset.toString());
                      if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set("sortColumn", options.sortColumn);
                      if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set("sortOrder", options.sortOrder);
                      if (options === null || options === void 0 ? void 0 : options.search) queryParams.set("search", options.search);
                      queryString = queryParams.toString();
                      url = queryString ? "".concat(_this2.url, "/bucket?").concat(queryString) : "".concat(_this2.url, "/bucket");
                      _context70.n = 2;
                      return get(_this2.fetch, url, {
                        headers: _this2.headers
                      });
                    case 2:
                      _t51 = _context70.v;
                      return _context70.a(2, {
                        data: _t51,
                        error: null
                      });
                    case 3:
                      _context70.p = 3;
                      _t52 = _context70.v;
                      if (!_this2.shouldThrowOnError) {
                        _context70.n = 4;
                        break;
                      }
                      throw _t52;
                    case 4:
                      if (!isStorageError(_t52)) {
                        _context70.n = 5;
                        break;
                      }
                      return _context70.a(2, {
                        data: null,
                        error: _t52
                      });
                    case 5:
                      throw _t52;
                    case 6:
                      return _context70.a(2);
                  }
                }, _callee69, this, [[1, 3]]);
              }));
              function listBuckets(_x131) {
                return _listBuckets2.apply(this, arguments);
              }
              return listBuckets;
            }()
            /**
            * @alpha
            *
            * Deletes an existing analytics bucket
            * A bucket can't be deleted with existing objects inside it
            * You must first empty the bucket before deletion
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Analytics Buckets
            * @param bucketName The unique identifier of the bucket you would like to delete
            * @returns Promise with response containing success message or error
            *
            * @example Delete analytics bucket
            * ```js
            * const { data, error } = await supabase
            *   .storage
            *   .analytics
            *   .deleteBucket('analytics-data')
            * ```
            *
            * Response:
            * ```json
            * {
            *   "data": {
            *     "message": "Successfully deleted"
            *   },
            *   "error": null
            * }
            * ```
            */
            )
          }, {
            key: "deleteBucket",
            value: (function () {
              var _deleteBucket2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee70(bucketName) {
                var _this3, _t53, _t54;
                return _regenerator().w(function (_context71) {
                  while (1) switch (_context71.p = _context71.n) {
                    case 0:
                      _this3 = this;
                      _context71.p = 1;
                      _context71.n = 2;
                      return _remove3(_this3.fetch, "".concat(_this3.url, "/bucket/").concat(bucketName), {}, {
                        headers: _this3.headers
                      });
                    case 2:
                      _t53 = _context71.v;
                      return _context71.a(2, {
                        data: _t53,
                        error: null
                      });
                    case 3:
                      _context71.p = 3;
                      _t54 = _context71.v;
                      if (!_this3.shouldThrowOnError) {
                        _context71.n = 4;
                        break;
                      }
                      throw _t54;
                    case 4:
                      if (!isStorageError(_t54)) {
                        _context71.n = 5;
                        break;
                      }
                      return _context71.a(2, {
                        data: null,
                        error: _t54
                      });
                    case 5:
                      throw _t54;
                    case 6:
                      return _context71.a(2);
                  }
                }, _callee70, this, [[1, 3]]);
              }));
              function deleteBucket(_x132) {
                return _deleteBucket2.apply(this, arguments);
              }
              return deleteBucket;
            }()
            /**
            * @alpha
            *
            * Get an Iceberg REST Catalog client configured for a specific analytics bucket
            * Use this to perform advanced table and namespace operations within the bucket
            * The returned client provides full access to the Apache Iceberg REST Catalog API
            * with the Supabase `{ data, error }` pattern for consistent error handling on all operations.
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Analytics Buckets
            * @param bucketName - The name of the analytics bucket (warehouse) to connect to
            * @returns The wrapped Iceberg catalog client
            * @throws {StorageError} If the bucket name is invalid
            *
            * @example Get catalog and create table
            * ```js
            * // First, create an analytics bucket
            * const { data: bucket, error: bucketError } = await supabase
            *   .storage
            *   .analytics
            *   .createBucket('analytics-data')
            *
            * // Get the Iceberg catalog for that bucket
            * const catalog = supabase.storage.analytics.from('analytics-data')
            *
            * // Create a namespace
            * const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })
            *
            * // Create a table with schema
            * const { data: tableMetadata, error: tableError } = await catalog.createTable(
            *   { namespace: ['default'] },
            *   {
            *     name: 'events',
            *     schema: {
            *       type: 'struct',
            *       fields: [
            *         { id: 1, name: 'id', type: 'long', required: true },
            *         { id: 2, name: 'timestamp', type: 'timestamp', required: true },
            *         { id: 3, name: 'user_id', type: 'string', required: false }
            *       ],
            *       'schema-id': 0,
            *       'identifier-field-ids': [1]
            *     },
            *     'partition-spec': {
            *       'spec-id': 0,
            *       fields: []
            *     },
            *     'write-order': {
            *       'order-id': 0,
            *       fields: []
            *     },
            *     properties: {
            *       'write.format.default': 'parquet'
            *     }
            *   }
            * )
            * ```
            *
            * @example List tables in namespace
            * ```js
            * const catalog = supabase.storage.analytics.from('analytics-data')
            *
            * // List all tables in the default namespace
            * const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })
            * if (listError) {
            *   if (listError.isNotFound()) {
            *     console.log('Namespace not found')
            *   }
            *   return
            * }
            * console.log(tables) // [{ namespace: ['default'], name: 'events' }]
            * ```
            *
            * @example Working with namespaces
            * ```js
            * const catalog = supabase.storage.analytics.from('analytics-data')
            *
            * // List all namespaces
            * const { data: namespaces } = await catalog.listNamespaces()
            *
            * // Create namespace with properties
            * await catalog.createNamespace(
            *   { namespace: ['production'] },
            *   { properties: { owner: 'data-team', env: 'prod' } }
            * )
            * ```
            *
            * @example Cleanup operations
            * ```js
            * const catalog = supabase.storage.analytics.from('analytics-data')
            *
            * // Drop table with purge option (removes all data)
            * const { error: dropError } = await catalog.dropTable(
            *   { namespace: ['default'], name: 'events' },
            *   { purge: true }
            * )
            *
            * if (dropError?.isNotFound()) {
            *   console.log('Table does not exist')
            * }
            *
            * // Drop namespace (must be empty)
            * await catalog.dropNamespace({ namespace: ['default'] })
            * ```
            *
            * @remarks
            * This method provides a bridge between Supabase's bucket management and the standard
            * Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.
            * All authentication and configuration is handled automatically using your Supabase credentials.
            *
            * **Error Handling**: Invalid bucket names throw immediately. All catalog
            * operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.
            * Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.
            * Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.
            *
            * **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently
            * deletes all table data. Without it, the table is marked as deleted but data remains.
            *
            * **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.
            * For complete API documentation and advanced usage, refer to the
            * [iceberg-js documentation](https://supabase.github.io/iceberg-js/).
            */
            )
          }, {
            key: "from",
            value: function from(bucketName) {
              var _this4 = this;
              if (!isValidBucketName(bucketName)) throw new StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
              var catalog = new IcebergRestCatalog({
                baseUrl: this.url,
                catalogName: bucketName,
                auth: {
                  type: "custom",
                  getHeaders: function () {
                    var _getHeaders = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee71() {
                      return _regenerator().w(function (_context72) {
                        while (1) switch (_context72.n) {
                          case 0:
                            return _context72.a(2, _this4.headers);
                        }
                      }, _callee71);
                    }));
                    function getHeaders() {
                      return _getHeaders.apply(this, arguments);
                    }
                    return getHeaders;
                  }()
                },
                fetch: this.fetch
              });
              var shouldThrowOnError = this.shouldThrowOnError;
              return new Proxy(catalog, {
                get: function get(target, prop) {
                  var value = target[prop];
                  if (typeof value !== "function") return value;
                  return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee72() {
                    var _len39,
                      args,
                      _key70,
                      _args72 = arguments,
                      _t55,
                      _t56;
                    return _regenerator().w(function (_context73) {
                      while (1) switch (_context73.p = _context73.n) {
                        case 0:
                          _context73.p = 0;
                          for (_len39 = _args72.length, args = new Array(_len39), _key70 = 0; _key70 < _len39; _key70++) {
                            args[_key70] = _args72[_key70];
                          }
                          _context73.n = 1;
                          return value.apply(target, args);
                        case 1:
                          _t55 = _context73.v;
                          return _context73.a(2, {
                            data: _t55,
                            error: null
                          });
                        case 2:
                          _context73.p = 2;
                          _t56 = _context73.v;
                          if (!shouldThrowOnError) {
                            _context73.n = 3;
                            break;
                          }
                          throw _t56;
                        case 3:
                          return _context73.a(2, {
                            data: null,
                            error: _t56
                          });
                      }
                    }, _callee72, null, [[0, 2]]);
                  }));
                }
              });
            }
          }]);
        }();

        //#endregion
        //#region src/lib/vectors/constants.ts
        var DEFAULT_HEADERS$2 = {
          "X-Client-Info": "storage-js/".concat(version$2),
          "Content-Type": "application/json"
        };

        //#endregion
        //#region src/lib/vectors/errors.ts
        /**
        * Base error class for all Storage Vectors errors
        */
        var StorageVectorsError = /*#__PURE__*/function (_Error6) {
          function StorageVectorsError(message) {
            var _this93;
            _classCallCheck(this, StorageVectorsError);
            _this93 = _callSuper(this, StorageVectorsError, [message]);
            _this93.__isStorageVectorsError = true;
            _this93.name = "StorageVectorsError";
            return _this93;
          }
          _inherits(StorageVectorsError, _Error6);
          return _createClass(StorageVectorsError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        /**
        * Type guard to check if an error is a StorageVectorsError
        * @param error - The error to check
        * @returns True if the error is a StorageVectorsError
        */
        function isStorageVectorsError(error) {
          return _typeof2(error) === "object" && error !== null && "__isStorageVectorsError" in error;
        }
        /**
        * API error returned from S3 Vectors service
        * Includes HTTP status code and service-specific error code
        */
        var StorageVectorsApiError = /*#__PURE__*/function (_StorageVectorsError) {
          function StorageVectorsApiError(message, status, statusCode) {
            var _this94;
            _classCallCheck(this, StorageVectorsApiError);
            _this94 = _callSuper(this, StorageVectorsApiError, [message]);
            _this94.name = "StorageVectorsApiError";
            _this94.status = status;
            _this94.statusCode = statusCode;
            return _this94;
          }
          _inherits(StorageVectorsApiError, _StorageVectorsError);
          return _createClass(StorageVectorsApiError, [{
            key: "toJSON",
            value: function toJSON() {
              return {
                name: this.name,
                message: this.message,
                status: this.status,
                statusCode: this.statusCode
              };
            }
          }]);
        }(StorageVectorsError);
        /**
        * Unknown error that doesn't match expected error patterns
        * Wraps the original error for debugging
        */
        var StorageVectorsUnknownError = /*#__PURE__*/function (_StorageVectorsError2) {
          function StorageVectorsUnknownError(message, originalError) {
            var _this95;
            _classCallCheck(this, StorageVectorsUnknownError);
            _this95 = _callSuper(this, StorageVectorsUnknownError, [message]);
            _this95.name = "StorageVectorsUnknownError";
            _this95.originalError = originalError;
            return _this95;
          }
          _inherits(StorageVectorsUnknownError, _StorageVectorsError2);
          return _createClass(StorageVectorsUnknownError);
        }(StorageVectorsError);

        //#endregion
        //#region src/lib/vectors/helpers.ts
        /**
        * Resolves the fetch implementation to use
        * Uses custom fetch if provided, otherwise uses native fetch
        *
        * @param customFetch - Optional custom fetch implementation
        * @returns Resolved fetch function
        */
        var resolveFetch$2 = function resolveFetch$2(customFetch) {
          if (customFetch) return function () {
            return customFetch.apply(void 0, arguments);
          };
          return function () {
            return fetch.apply(void 0, arguments);
          };
        };
        /**
        * Determine if input is a plain object
        * An object is plain if it's created by either {}, new Object(), or Object.create(null)
        *
        * @param value - Value to check
        * @returns True if value is a plain object
        * @source https://github.com/sindresorhus/is-plain-obj
        */
        var isPlainObject = function isPlainObject(value) {
          if (_typeof2(value) !== "object" || value === null) return false;
          var prototype = Object.getPrototypeOf(value);
          return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
        };

        //#endregion
        //#region src/lib/vectors/fetch.ts
        /**
        * Extracts error message from various error response formats
        * @param err - Error object from API
        * @returns Human-readable error message
        */
        var _getErrorMessage$2 = function _getErrorMessage$2(err) {
          return err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
        };
        /**
        * Handles fetch errors and converts them to StorageVectors error types
        * @param error - The error caught from fetch
        * @param reject - Promise rejection function
        * @param options - Fetch options that may affect error handling
        */
        var handleError$2 = /*#__PURE__*/function () {
          var _ref205 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee73(error, reject, options) {
            var status, responseError, statusCode;
            return _regenerator().w(function (_context74) {
              while (1) switch (_context74.n) {
                case 0:
                  if (error && _typeof2(error) === "object" && "status" in error && "ok" in error && typeof error.status === "number" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
                    status = error.status || 500;
                    responseError = error;
                    if (typeof responseError.json === "function") responseError.json().then(function (err) {
                      var statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
                      reject(new StorageVectorsApiError(_getErrorMessage$2(err), status, statusCode));
                    }).catch(function () {
                      var statusCode = status + "";
                      reject(new StorageVectorsApiError(responseError.statusText || "HTTP ".concat(status, " error"), status, statusCode));
                    });else {
                      statusCode = status + "";
                      reject(new StorageVectorsApiError(responseError.statusText || "HTTP ".concat(status, " error"), status, statusCode));
                    }
                  } else reject(new StorageVectorsUnknownError(_getErrorMessage$2(error), error));
                case 1:
                  return _context74.a(2);
              }
            }, _callee73);
          }));
          return function handleError$2(_x133, _x134, _x135) {
            return _ref205.apply(this, arguments);
          };
        }();
        /**
        * Builds request parameters for fetch calls
        * @param method - HTTP method
        * @param options - Custom fetch options
        * @param parameters - Additional fetch parameters like AbortSignal
        * @param body - Request body (will be JSON stringified if plain object)
        * @returns Complete fetch request parameters
        */
        var _getRequestParams$2 = function _getRequestParams$2(method, options, parameters, body) {
          var params = {
            method: method,
            headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
          };
          if (!body) return params;
          if (isPlainObject(body)) {
            params.headers = _objectSpread2$1({
              "Content-Type": "application/json"
            }, options === null || options === void 0 ? void 0 : options.headers);
            params.body = JSON.stringify(body);
          } else params.body = body;
          return _objectSpread2$1(_objectSpread2$1({}, params), parameters);
        };
        /**
        * Internal request handler that wraps fetch with error handling
        * @param fetcher - Fetch function to use
        * @param method - HTTP method
        * @param url - Request URL
        * @param options - Custom fetch options
        * @param parameters - Additional fetch parameters
        * @param body - Request body
        * @returns Promise with parsed response or error
        */
        function _handleRequest$2(_x136, _x137, _x138, _x139, _x140, _x141) {
          return _handleRequest$3.apply(this, arguments);
        }
        /**
        * Performs a POST request
        * @param fetcher - Fetch function to use
        * @param url - Request URL
        * @param body - Request body to be JSON stringified
        * @param options - Custom fetch options
        * @param parameters - Additional fetch parameters
        * @returns Promise with parsed response
        */
        function _handleRequest$3() {
          _handleRequest$3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee265(fetcher, method, url, options, parameters, body) {
            return _regenerator().w(function (_context266) {
              while (1) switch (_context266.n) {
                case 0:
                  return _context266.a(2, new Promise(function (resolve, reject) {
                    fetcher(url, _getRequestParams$2(method, options, parameters, body)).then(function (result) {
                      if (!result.ok) throw result;
                      if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
                      var contentType = result.headers.get("content-type");
                      if (!contentType || !contentType.includes("application/json")) return {};
                      return result.json();
                    }).then(function (data) {
                      return resolve(data);
                    }).catch(function (error) {
                      return handleError$2(error, reject, options);
                    });
                  }));
              }
            }, _callee265);
          }));
          return _handleRequest$3.apply(this, arguments);
        }
        function post(_x142, _x143, _x144, _x145, _x146) {
          return _post.apply(this, arguments);
        } //#endregion
        //#region src/lib/vectors/VectorIndexApi.ts
        /**
        * @hidden
        * Base implementation for vector index operations.
        * Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.
        */
        function _post() {
          _post = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee266(fetcher, url, body, options, parameters) {
            return _regenerator().w(function (_context267) {
              while (1) switch (_context267.n) {
                case 0:
                  return _context267.a(2, _handleRequest$2(fetcher, "POST", url, options, parameters, body));
              }
            }, _callee266);
          }));
          return _post.apply(this, arguments);
        }
        var VectorIndexApi = /*#__PURE__*/function () {
          /** Creates a new VectorIndexApi instance */
          function VectorIndexApi(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, VectorIndexApi);
            this.shouldThrowOnError = false;
            this.url = url.replace(/\/$/, "");
            this.headers = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_HEADERS$2), headers);
            this.fetch = resolveFetch$2(fetch$1);
          }
          /** Enable throwing errors instead of returning them in the response */
          return _createClass(VectorIndexApi, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /** Creates a new vector index within a bucket */
          }, {
            key: "createIndex",
            value: (function () {
              var _createIndex = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee74(options) {
                var _this, _t57, _t58, _t59;
                return _regenerator().w(function (_context75) {
                  while (1) switch (_context75.p = _context75.n) {
                    case 0:
                      _this = this;
                      _context75.p = 1;
                      _context75.n = 2;
                      return post(_this.fetch, "".concat(_this.url, "/CreateIndex"), options, {
                        headers: _this.headers
                      });
                    case 2:
                      _t57 = _context75.v;
                      if (_t57) {
                        _context75.n = 3;
                        break;
                      }
                      _t57 = {};
                    case 3:
                      _t58 = _t57;
                      return _context75.a(2, {
                        data: _t58,
                        error: null
                      });
                    case 4:
                      _context75.p = 4;
                      _t59 = _context75.v;
                      if (!_this.shouldThrowOnError) {
                        _context75.n = 5;
                        break;
                      }
                      throw _t59;
                    case 5:
                      if (!isStorageVectorsError(_t59)) {
                        _context75.n = 6;
                        break;
                      }
                      return _context75.a(2, {
                        data: null,
                        error: _t59
                      });
                    case 6:
                      throw _t59;
                    case 7:
                      return _context75.a(2);
                  }
                }, _callee74, this, [[1, 4]]);
              }));
              function createIndex(_x147) {
                return _createIndex.apply(this, arguments);
              }
              return createIndex;
            }() /** Retrieves metadata for a specific vector index */)
          }, {
            key: "getIndex",
            value: (function () {
              var _getIndex = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee75(vectorBucketName, indexName) {
                var _this2, _t60, _t61;
                return _regenerator().w(function (_context76) {
                  while (1) switch (_context76.p = _context76.n) {
                    case 0:
                      _this2 = this;
                      _context76.p = 1;
                      _context76.n = 2;
                      return post(_this2.fetch, "".concat(_this2.url, "/GetIndex"), {
                        vectorBucketName: vectorBucketName,
                        indexName: indexName
                      }, {
                        headers: _this2.headers
                      });
                    case 2:
                      _t60 = _context76.v;
                      return _context76.a(2, {
                        data: _t60,
                        error: null
                      });
                    case 3:
                      _context76.p = 3;
                      _t61 = _context76.v;
                      if (!_this2.shouldThrowOnError) {
                        _context76.n = 4;
                        break;
                      }
                      throw _t61;
                    case 4:
                      if (!isStorageVectorsError(_t61)) {
                        _context76.n = 5;
                        break;
                      }
                      return _context76.a(2, {
                        data: null,
                        error: _t61
                      });
                    case 5:
                      throw _t61;
                    case 6:
                      return _context76.a(2);
                  }
                }, _callee75, this, [[1, 3]]);
              }));
              function getIndex(_x148, _x149) {
                return _getIndex.apply(this, arguments);
              }
              return getIndex;
            }() /** Lists vector indexes within a bucket with optional filtering and pagination */)
          }, {
            key: "listIndexes",
            value: (function () {
              var _listIndexes = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee76(options) {
                var _this3, _t62, _t63;
                return _regenerator().w(function (_context77) {
                  while (1) switch (_context77.p = _context77.n) {
                    case 0:
                      _this3 = this;
                      _context77.p = 1;
                      _context77.n = 2;
                      return post(_this3.fetch, "".concat(_this3.url, "/ListIndexes"), options, {
                        headers: _this3.headers
                      });
                    case 2:
                      _t62 = _context77.v;
                      return _context77.a(2, {
                        data: _t62,
                        error: null
                      });
                    case 3:
                      _context77.p = 3;
                      _t63 = _context77.v;
                      if (!_this3.shouldThrowOnError) {
                        _context77.n = 4;
                        break;
                      }
                      throw _t63;
                    case 4:
                      if (!isStorageVectorsError(_t63)) {
                        _context77.n = 5;
                        break;
                      }
                      return _context77.a(2, {
                        data: null,
                        error: _t63
                      });
                    case 5:
                      throw _t63;
                    case 6:
                      return _context77.a(2);
                  }
                }, _callee76, this, [[1, 3]]);
              }));
              function listIndexes(_x150) {
                return _listIndexes.apply(this, arguments);
              }
              return listIndexes;
            }() /** Deletes a vector index and all its data */)
          }, {
            key: "deleteIndex",
            value: (function () {
              var _deleteIndex = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee77(vectorBucketName, indexName) {
                var _this4, _t64, _t65, _t66;
                return _regenerator().w(function (_context78) {
                  while (1) switch (_context78.p = _context78.n) {
                    case 0:
                      _this4 = this;
                      _context78.p = 1;
                      _context78.n = 2;
                      return post(_this4.fetch, "".concat(_this4.url, "/DeleteIndex"), {
                        vectorBucketName: vectorBucketName,
                        indexName: indexName
                      }, {
                        headers: _this4.headers
                      });
                    case 2:
                      _t64 = _context78.v;
                      if (_t64) {
                        _context78.n = 3;
                        break;
                      }
                      _t64 = {};
                    case 3:
                      _t65 = _t64;
                      return _context78.a(2, {
                        data: _t65,
                        error: null
                      });
                    case 4:
                      _context78.p = 4;
                      _t66 = _context78.v;
                      if (!_this4.shouldThrowOnError) {
                        _context78.n = 5;
                        break;
                      }
                      throw _t66;
                    case 5:
                      if (!isStorageVectorsError(_t66)) {
                        _context78.n = 6;
                        break;
                      }
                      return _context78.a(2, {
                        data: null,
                        error: _t66
                      });
                    case 6:
                      throw _t66;
                    case 7:
                      return _context78.a(2);
                  }
                }, _callee77, this, [[1, 4]]);
              }));
              function deleteIndex(_x151, _x152) {
                return _deleteIndex.apply(this, arguments);
              }
              return deleteIndex;
            }())
          }]);
        }();

        //#endregion
        //#region src/lib/vectors/VectorDataApi.ts
        /**
        * @hidden
        * Base implementation for vector data operations.
        * Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.
        */
        var VectorDataApi = /*#__PURE__*/function () {
          /** Creates a new VectorDataApi instance */
          function VectorDataApi(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, VectorDataApi);
            this.shouldThrowOnError = false;
            this.url = url.replace(/\/$/, "");
            this.headers = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_HEADERS$2), headers);
            this.fetch = resolveFetch$2(fetch$1);
          }
          /** Enable throwing errors instead of returning them in the response */
          return _createClass(VectorDataApi, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /** Inserts or updates vectors in batch (1-500 per request) */
          }, {
            key: "putVectors",
            value: (function () {
              var _putVectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee78(options) {
                var _this, _t67, _t68, _t69;
                return _regenerator().w(function (_context79) {
                  while (1) switch (_context79.p = _context79.n) {
                    case 0:
                      _this = this;
                      _context79.p = 1;
                      if (!(options.vectors.length < 1 || options.vectors.length > 500)) {
                        _context79.n = 2;
                        break;
                      }
                      throw new Error("Vector batch size must be between 1 and 500 items");
                    case 2:
                      _context79.n = 3;
                      return post(_this.fetch, "".concat(_this.url, "/PutVectors"), options, {
                        headers: _this.headers
                      });
                    case 3:
                      _t67 = _context79.v;
                      if (_t67) {
                        _context79.n = 4;
                        break;
                      }
                      _t67 = {};
                    case 4:
                      _t68 = _t67;
                      return _context79.a(2, {
                        data: _t68,
                        error: null
                      });
                    case 5:
                      _context79.p = 5;
                      _t69 = _context79.v;
                      if (!_this.shouldThrowOnError) {
                        _context79.n = 6;
                        break;
                      }
                      throw _t69;
                    case 6:
                      if (!isStorageVectorsError(_t69)) {
                        _context79.n = 7;
                        break;
                      }
                      return _context79.a(2, {
                        data: null,
                        error: _t69
                      });
                    case 7:
                      throw _t69;
                    case 8:
                      return _context79.a(2);
                  }
                }, _callee78, this, [[1, 5]]);
              }));
              function putVectors(_x153) {
                return _putVectors.apply(this, arguments);
              }
              return putVectors;
            }() /** Retrieves vectors by their keys in batch */)
          }, {
            key: "getVectors",
            value: (function () {
              var _getVectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee79(options) {
                var _this2, _t70, _t71;
                return _regenerator().w(function (_context80) {
                  while (1) switch (_context80.p = _context80.n) {
                    case 0:
                      _this2 = this;
                      _context80.p = 1;
                      _context80.n = 2;
                      return post(_this2.fetch, "".concat(_this2.url, "/GetVectors"), options, {
                        headers: _this2.headers
                      });
                    case 2:
                      _t70 = _context80.v;
                      return _context80.a(2, {
                        data: _t70,
                        error: null
                      });
                    case 3:
                      _context80.p = 3;
                      _t71 = _context80.v;
                      if (!_this2.shouldThrowOnError) {
                        _context80.n = 4;
                        break;
                      }
                      throw _t71;
                    case 4:
                      if (!isStorageVectorsError(_t71)) {
                        _context80.n = 5;
                        break;
                      }
                      return _context80.a(2, {
                        data: null,
                        error: _t71
                      });
                    case 5:
                      throw _t71;
                    case 6:
                      return _context80.a(2);
                  }
                }, _callee79, this, [[1, 3]]);
              }));
              function getVectors(_x154) {
                return _getVectors.apply(this, arguments);
              }
              return getVectors;
            }() /** Lists vectors in an index with pagination */)
          }, {
            key: "listVectors",
            value: (function () {
              var _listVectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee80(options) {
                var _this3, _t72, _t73;
                return _regenerator().w(function (_context81) {
                  while (1) switch (_context81.p = _context81.n) {
                    case 0:
                      _this3 = this;
                      _context81.p = 1;
                      if (!(options.segmentCount !== void 0)) {
                        _context81.n = 3;
                        break;
                      }
                      if (!(options.segmentCount < 1 || options.segmentCount > 16)) {
                        _context81.n = 2;
                        break;
                      }
                      throw new Error("segmentCount must be between 1 and 16");
                    case 2:
                      if (!(options.segmentIndex !== void 0)) {
                        _context81.n = 3;
                        break;
                      }
                      if (!(options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount)) {
                        _context81.n = 3;
                        break;
                      }
                      throw new Error("segmentIndex must be between 0 and ".concat(options.segmentCount - 1));
                    case 3:
                      _context81.n = 4;
                      return post(_this3.fetch, "".concat(_this3.url, "/ListVectors"), options, {
                        headers: _this3.headers
                      });
                    case 4:
                      _t72 = _context81.v;
                      return _context81.a(2, {
                        data: _t72,
                        error: null
                      });
                    case 5:
                      _context81.p = 5;
                      _t73 = _context81.v;
                      if (!_this3.shouldThrowOnError) {
                        _context81.n = 6;
                        break;
                      }
                      throw _t73;
                    case 6:
                      if (!isStorageVectorsError(_t73)) {
                        _context81.n = 7;
                        break;
                      }
                      return _context81.a(2, {
                        data: null,
                        error: _t73
                      });
                    case 7:
                      throw _t73;
                    case 8:
                      return _context81.a(2);
                  }
                }, _callee80, this, [[1, 5]]);
              }));
              function listVectors(_x155) {
                return _listVectors.apply(this, arguments);
              }
              return listVectors;
            }() /** Queries for similar vectors using approximate nearest neighbor search */)
          }, {
            key: "queryVectors",
            value: (function () {
              var _queryVectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee81(options) {
                var _this4, _t74, _t75;
                return _regenerator().w(function (_context82) {
                  while (1) switch (_context82.p = _context82.n) {
                    case 0:
                      _this4 = this;
                      _context82.p = 1;
                      _context82.n = 2;
                      return post(_this4.fetch, "".concat(_this4.url, "/QueryVectors"), options, {
                        headers: _this4.headers
                      });
                    case 2:
                      _t74 = _context82.v;
                      return _context82.a(2, {
                        data: _t74,
                        error: null
                      });
                    case 3:
                      _context82.p = 3;
                      _t75 = _context82.v;
                      if (!_this4.shouldThrowOnError) {
                        _context82.n = 4;
                        break;
                      }
                      throw _t75;
                    case 4:
                      if (!isStorageVectorsError(_t75)) {
                        _context82.n = 5;
                        break;
                      }
                      return _context82.a(2, {
                        data: null,
                        error: _t75
                      });
                    case 5:
                      throw _t75;
                    case 6:
                      return _context82.a(2);
                  }
                }, _callee81, this, [[1, 3]]);
              }));
              function queryVectors(_x156) {
                return _queryVectors.apply(this, arguments);
              }
              return queryVectors;
            }() /** Deletes vectors by their keys in batch (1-500 per request) */)
          }, {
            key: "deleteVectors",
            value: (function () {
              var _deleteVectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee82(options) {
                var _this5, _t76, _t77, _t78;
                return _regenerator().w(function (_context83) {
                  while (1) switch (_context83.p = _context83.n) {
                    case 0:
                      _this5 = this;
                      _context83.p = 1;
                      if (!(options.keys.length < 1 || options.keys.length > 500)) {
                        _context83.n = 2;
                        break;
                      }
                      throw new Error("Keys batch size must be between 1 and 500 items");
                    case 2:
                      _context83.n = 3;
                      return post(_this5.fetch, "".concat(_this5.url, "/DeleteVectors"), options, {
                        headers: _this5.headers
                      });
                    case 3:
                      _t76 = _context83.v;
                      if (_t76) {
                        _context83.n = 4;
                        break;
                      }
                      _t76 = {};
                    case 4:
                      _t77 = _t76;
                      return _context83.a(2, {
                        data: _t77,
                        error: null
                      });
                    case 5:
                      _context83.p = 5;
                      _t78 = _context83.v;
                      if (!_this5.shouldThrowOnError) {
                        _context83.n = 6;
                        break;
                      }
                      throw _t78;
                    case 6:
                      if (!isStorageVectorsError(_t78)) {
                        _context83.n = 7;
                        break;
                      }
                      return _context83.a(2, {
                        data: null,
                        error: _t78
                      });
                    case 7:
                      throw _t78;
                    case 8:
                      return _context83.a(2);
                  }
                }, _callee82, this, [[1, 5]]);
              }));
              function deleteVectors(_x157) {
                return _deleteVectors.apply(this, arguments);
              }
              return deleteVectors;
            }())
          }]);
        }();

        //#endregion
        //#region src/lib/vectors/VectorBucketApi.ts
        /**
        * @hidden
        * Base implementation for vector bucket operations.
        * Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.
        */
        var VectorBucketApi = /*#__PURE__*/function () {
          /** Creates a new VectorBucketApi instance */
          function VectorBucketApi(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            _classCallCheck(this, VectorBucketApi);
            this.shouldThrowOnError = false;
            this.url = url.replace(/\/$/, "");
            this.headers = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_HEADERS$2), headers);
            this.fetch = resolveFetch$2(fetch$1);
          }
          /** Enable throwing errors instead of returning them in the response */
          return _createClass(VectorBucketApi, [{
            key: "throwOnError",
            value: function throwOnError() {
              this.shouldThrowOnError = true;
              return this;
            }
            /** Creates a new vector bucket */
          }, {
            key: "createBucket",
            value: (function () {
              var _createBucket3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee83(vectorBucketName) {
                var _this, _t79, _t80, _t81;
                return _regenerator().w(function (_context84) {
                  while (1) switch (_context84.p = _context84.n) {
                    case 0:
                      _this = this;
                      _context84.p = 1;
                      _context84.n = 2;
                      return post(_this.fetch, "".concat(_this.url, "/CreateVectorBucket"), {
                        vectorBucketName: vectorBucketName
                      }, {
                        headers: _this.headers
                      });
                    case 2:
                      _t79 = _context84.v;
                      if (_t79) {
                        _context84.n = 3;
                        break;
                      }
                      _t79 = {};
                    case 3:
                      _t80 = _t79;
                      return _context84.a(2, {
                        data: _t80,
                        error: null
                      });
                    case 4:
                      _context84.p = 4;
                      _t81 = _context84.v;
                      if (!_this.shouldThrowOnError) {
                        _context84.n = 5;
                        break;
                      }
                      throw _t81;
                    case 5:
                      if (!isStorageVectorsError(_t81)) {
                        _context84.n = 6;
                        break;
                      }
                      return _context84.a(2, {
                        data: null,
                        error: _t81
                      });
                    case 6:
                      throw _t81;
                    case 7:
                      return _context84.a(2);
                  }
                }, _callee83, this, [[1, 4]]);
              }));
              function createBucket(_x158) {
                return _createBucket3.apply(this, arguments);
              }
              return createBucket;
            }() /** Retrieves metadata for a specific vector bucket */)
          }, {
            key: "getBucket",
            value: (function () {
              var _getBucket2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee84(vectorBucketName) {
                var _this2, _t82, _t83;
                return _regenerator().w(function (_context85) {
                  while (1) switch (_context85.p = _context85.n) {
                    case 0:
                      _this2 = this;
                      _context85.p = 1;
                      _context85.n = 2;
                      return post(_this2.fetch, "".concat(_this2.url, "/GetVectorBucket"), {
                        vectorBucketName: vectorBucketName
                      }, {
                        headers: _this2.headers
                      });
                    case 2:
                      _t82 = _context85.v;
                      return _context85.a(2, {
                        data: _t82,
                        error: null
                      });
                    case 3:
                      _context85.p = 3;
                      _t83 = _context85.v;
                      if (!_this2.shouldThrowOnError) {
                        _context85.n = 4;
                        break;
                      }
                      throw _t83;
                    case 4:
                      if (!isStorageVectorsError(_t83)) {
                        _context85.n = 5;
                        break;
                      }
                      return _context85.a(2, {
                        data: null,
                        error: _t83
                      });
                    case 5:
                      throw _t83;
                    case 6:
                      return _context85.a(2);
                  }
                }, _callee84, this, [[1, 3]]);
              }));
              function getBucket(_x159) {
                return _getBucket2.apply(this, arguments);
              }
              return getBucket;
            }() /** Lists vector buckets with optional filtering and pagination */)
          }, {
            key: "listBuckets",
            value: (function () {
              var _listBuckets3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee85() {
                var options,
                  _this3,
                  _args85 = arguments,
                  _t84,
                  _t85;
                return _regenerator().w(function (_context86) {
                  while (1) switch (_context86.p = _context86.n) {
                    case 0:
                      options = _args85.length > 0 && _args85[0] !== undefined ? _args85[0] : {};
                      _this3 = this;
                      _context86.p = 1;
                      _context86.n = 2;
                      return post(_this3.fetch, "".concat(_this3.url, "/ListVectorBuckets"), options, {
                        headers: _this3.headers
                      });
                    case 2:
                      _t84 = _context86.v;
                      return _context86.a(2, {
                        data: _t84,
                        error: null
                      });
                    case 3:
                      _context86.p = 3;
                      _t85 = _context86.v;
                      if (!_this3.shouldThrowOnError) {
                        _context86.n = 4;
                        break;
                      }
                      throw _t85;
                    case 4:
                      if (!isStorageVectorsError(_t85)) {
                        _context86.n = 5;
                        break;
                      }
                      return _context86.a(2, {
                        data: null,
                        error: _t85
                      });
                    case 5:
                      throw _t85;
                    case 6:
                      return _context86.a(2);
                  }
                }, _callee85, this, [[1, 3]]);
              }));
              function listBuckets() {
                return _listBuckets3.apply(this, arguments);
              }
              return listBuckets;
            }() /** Deletes a vector bucket (must be empty first) */)
          }, {
            key: "deleteBucket",
            value: (function () {
              var _deleteBucket3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee86(vectorBucketName) {
                var _this4, _t86, _t87, _t88;
                return _regenerator().w(function (_context87) {
                  while (1) switch (_context87.p = _context87.n) {
                    case 0:
                      _this4 = this;
                      _context87.p = 1;
                      _context87.n = 2;
                      return post(_this4.fetch, "".concat(_this4.url, "/DeleteVectorBucket"), {
                        vectorBucketName: vectorBucketName
                      }, {
                        headers: _this4.headers
                      });
                    case 2:
                      _t86 = _context87.v;
                      if (_t86) {
                        _context87.n = 3;
                        break;
                      }
                      _t86 = {};
                    case 3:
                      _t87 = _t86;
                      return _context87.a(2, {
                        data: _t87,
                        error: null
                      });
                    case 4:
                      _context87.p = 4;
                      _t88 = _context87.v;
                      if (!_this4.shouldThrowOnError) {
                        _context87.n = 5;
                        break;
                      }
                      throw _t88;
                    case 5:
                      if (!isStorageVectorsError(_t88)) {
                        _context87.n = 6;
                        break;
                      }
                      return _context87.a(2, {
                        data: null,
                        error: _t88
                      });
                    case 6:
                      throw _t88;
                    case 7:
                      return _context87.a(2);
                  }
                }, _callee86, this, [[1, 4]]);
              }));
              function deleteBucket(_x160) {
                return _deleteBucket3.apply(this, arguments);
              }
              return deleteBucket;
            }())
          }]);
        }();

        //#endregion
        //#region src/lib/vectors/StorageVectorsClient.ts
        /**
        *
        * @alpha
        *
        * Main client for interacting with S3 Vectors API
        * Provides access to bucket, index, and vector data operations
        *
        * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
        *
        * **Usage Patterns:**
        *
        * ```typescript
        * const { data, error } = await supabase
        *  .storage
        *  .vectors
        *  .createBucket('embeddings-prod')
        *
        * // Access index operations via buckets
        * const bucket = supabase.storage.vectors.from('embeddings-prod')
        * await bucket.createIndex({
        *   indexName: 'documents',
        *   dataType: 'float32',
        *   dimension: 1536,
        *   distanceMetric: 'cosine'
        * })
        *
        * // Access vector operations via index
        * const index = bucket.index('documents')
        * await index.putVectors({
        *   vectors: [
        *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
        *   ]
        * })
        *
        * // Query similar vectors
        * const { data } = await index.queryVectors({
        *   queryVector: { float32: [...] },
        *   topK: 5,
        *   returnDistance: true
        * })
        * ```
        */
        var StorageVectorsClient = /*#__PURE__*/function (_VectorBucketApi) {
          /**
          * @alpha
          *
          * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @param url - Base URL of the Storage Vectors REST API.
          * @param options.headers - Optional headers (for example `Authorization`) applied to every request.
          * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.
          *
          * @example
          * ```typescript
          * const client = new StorageVectorsClient(url, options)
          * ```
          */
          function StorageVectorsClient(url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, StorageVectorsClient);
            return _callSuper(this, StorageVectorsClient, [url, options.headers || {}, options.fetch]);
          }
          /**
          *
          * @alpha
          *
          * Access operations for a specific vector bucket
          * Returns a scoped client for index and vector operations within the bucket
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @param vectorBucketName - Name of the vector bucket
          * @returns Bucket-scoped client with index and vector operations
          *
          * @example
          * ```typescript
          * const bucket = supabase.storage.vectors.from('embeddings-prod')
          * ```
          */
          _inherits(StorageVectorsClient, _VectorBucketApi);
          return _createClass(StorageVectorsClient, [{
            key: "from",
            value: function from(vectorBucketName) {
              return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
            }
            /**
            *
            * @alpha
            *
            * Creates a new vector bucket
            * Vector buckets are containers for vector indexes and their data
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param vectorBucketName - Unique name for the vector bucket
            * @returns Promise with empty response on success or error
            *
            * @example
            * ```typescript
            * const { data, error } = await supabase
            *   .storage
            *   .vectors
            *   .createBucket('embeddings-prod')
            * ```
            */
          }, {
            key: "createBucket",
            value: (function () {
              var _createBucket4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee87(vectorBucketName) {
                var _this96 = this;
                var _superprop_getCreateBucket, _this;
                return _regenerator().w(function (_context88) {
                  while (1) switch (_context88.n) {
                    case 0:
                      _superprop_getCreateBucket = function _superprop_getCreateBucket() {
                        return _superPropGet(StorageVectorsClient, "createBucket", _this96, 1);
                      }, _this = this;
                      return _context88.a(2, _superprop_getCreateBucket().call(_this, vectorBucketName));
                  }
                }, _callee87, this);
              }));
              function createBucket(_x161) {
                return _createBucket4.apply(this, arguments);
              }
              return createBucket;
            }()
            /**
            *
            * @alpha
            *
            * Retrieves metadata for a specific vector bucket
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param vectorBucketName - Name of the vector bucket
            * @returns Promise with bucket metadata or error
            *
            * @example
            * ```typescript
            * const { data, error } = await supabase
            *   .storage
            *   .vectors
            *   .getBucket('embeddings-prod')
            *
            * console.log('Bucket created:', data?.vectorBucket.creationTime)
            * ```
            */
            )
          }, {
            key: "getBucket",
            value: (function () {
              var _getBucket3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee88(vectorBucketName) {
                var _this97 = this;
                var _superprop_getGetBucket, _this2;
                return _regenerator().w(function (_context89) {
                  while (1) switch (_context89.n) {
                    case 0:
                      _superprop_getGetBucket = function _superprop_getGetBucket() {
                        return _superPropGet(StorageVectorsClient, "getBucket", _this97, 1);
                      }, _this2 = this;
                      return _context89.a(2, _superprop_getGetBucket().call(_this2, vectorBucketName));
                  }
                }, _callee88, this);
              }));
              function getBucket(_x162) {
                return _getBucket3.apply(this, arguments);
              }
              return getBucket;
            }()
            /**
            *
            * @alpha
            *
            * Lists all vector buckets with optional filtering and pagination
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Optional filters (prefix, maxResults, nextToken)
            * @returns Promise with list of buckets or error
            *
            * @example
            * ```typescript
            * const { data, error } = await supabase
            *   .storage
            *   .vectors
            *   .listBuckets({ prefix: 'embeddings-' })
            *
            * data?.vectorBuckets.forEach(bucket => {
            *   console.log(bucket.vectorBucketName)
            * })
            * ```
            */
            )
          }, {
            key: "listBuckets",
            value: (function () {
              var _listBuckets4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee89() {
                var _this98 = this;
                var options,
                  _superprop_getListBuckets,
                  _this3,
                  _args89 = arguments;
                return _regenerator().w(function (_context90) {
                  while (1) switch (_context90.n) {
                    case 0:
                      options = _args89.length > 0 && _args89[0] !== undefined ? _args89[0] : {};
                      _superprop_getListBuckets = function _superprop_getListBuckets() {
                        return _superPropGet(StorageVectorsClient, "listBuckets", _this98, 1);
                      }, _this3 = this;
                      return _context90.a(2, _superprop_getListBuckets().call(_this3, options));
                  }
                }, _callee89, this);
              }));
              function listBuckets() {
                return _listBuckets4.apply(this, arguments);
              }
              return listBuckets;
            }()
            /**
            *
            * @alpha
            *
            * Deletes a vector bucket (bucket must be empty)
            * All indexes must be deleted before deleting the bucket
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param vectorBucketName - Name of the vector bucket to delete
            * @returns Promise with empty response on success or error
            *
            * @example
            * ```typescript
            * const { data, error } = await supabase
            *   .storage
            *   .vectors
            *   .deleteBucket('embeddings-old')
            * ```
            */
            )
          }, {
            key: "deleteBucket",
            value: (function () {
              var _deleteBucket4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee90(vectorBucketName) {
                var _this99 = this;
                var _superprop_getDeleteBucket, _this4;
                return _regenerator().w(function (_context91) {
                  while (1) switch (_context91.n) {
                    case 0:
                      _superprop_getDeleteBucket = function _superprop_getDeleteBucket() {
                        return _superPropGet(StorageVectorsClient, "deleteBucket", _this99, 1);
                      }, _this4 = this;
                      return _context91.a(2, _superprop_getDeleteBucket().call(_this4, vectorBucketName));
                  }
                }, _callee90, this);
              }));
              function deleteBucket(_x163) {
                return _deleteBucket4.apply(this, arguments);
              }
              return deleteBucket;
            }())
          }]);
        }(VectorBucketApi);
        /**
        *
        * @alpha
        *
        * Scoped client for operations within a specific vector bucket
        * Provides index management and access to vector operations
        *
        * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
        */
        var VectorBucketScope = /*#__PURE__*/function (_VectorIndexApi) {
          /**
          * @alpha
          *
          * Creates a helper that automatically scopes all index operations to the provided bucket.
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @example
          * ```typescript
          * const bucket = supabase.storage.vectors.from('embeddings-prod')
          * ```
          */
          function VectorBucketScope(url, headers, vectorBucketName, fetch$1) {
            var _this100;
            _classCallCheck(this, VectorBucketScope);
            _this100 = _callSuper(this, VectorBucketScope, [url, headers, fetch$1]);
            _this100.vectorBucketName = vectorBucketName;
            return _this100;
          }
          /**
          *
          * @alpha
          *
          * Creates a new vector index in this bucket
          * Convenience method that automatically includes the bucket name
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @param options - Index configuration (vectorBucketName is automatically set)
          * @returns Promise with empty response on success or error
          *
          * @example
          * ```typescript
          * const bucket = supabase.storage.vectors.from('embeddings-prod')
          * await bucket.createIndex({
          *   indexName: 'documents-openai',
          *   dataType: 'float32',
          *   dimension: 1536,
          *   distanceMetric: 'cosine',
          *   metadataConfiguration: {
          *     nonFilterableMetadataKeys: ['raw_text']
          *   }
          * })
          * ```
          */
          _inherits(VectorBucketScope, _VectorIndexApi);
          return _createClass(VectorBucketScope, [{
            key: "createIndex",
            value: (function () {
              var _createIndex2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee91(options) {
                var _this101 = this;
                var _superprop_getCreateIndex, _this5;
                return _regenerator().w(function (_context92) {
                  while (1) switch (_context92.n) {
                    case 0:
                      _superprop_getCreateIndex = function _superprop_getCreateIndex() {
                        return _superPropGet(VectorBucketScope, "createIndex", _this101, 1);
                      }, _this5 = this;
                      return _context92.a(2, _superprop_getCreateIndex().call(_this5, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this5.vectorBucketName
                      })));
                  }
                }, _callee91, this);
              }));
              function createIndex(_x164) {
                return _createIndex2.apply(this, arguments);
              }
              return createIndex;
            }()
            /**
            *
            * @alpha
            *
            * Lists indexes in this bucket
            * Convenience method that automatically includes the bucket name
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Listing options (vectorBucketName is automatically set)
            * @returns Promise with response containing indexes array and pagination token or error
            *
            * @example
            * ```typescript
            * const bucket = supabase.storage.vectors.from('embeddings-prod')
            * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
            * ```
            */
            )
          }, {
            key: "listIndexes",
            value: (function () {
              var _listIndexes2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee92() {
                var _this102 = this;
                var options,
                  _superprop_getListIndexes,
                  _this6,
                  _args92 = arguments;
                return _regenerator().w(function (_context93) {
                  while (1) switch (_context93.n) {
                    case 0:
                      options = _args92.length > 0 && _args92[0] !== undefined ? _args92[0] : {};
                      _superprop_getListIndexes = function _superprop_getListIndexes() {
                        return _superPropGet(VectorBucketScope, "listIndexes", _this102, 1);
                      }, _this6 = this;
                      return _context93.a(2, _superprop_getListIndexes().call(_this6, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this6.vectorBucketName
                      })));
                  }
                }, _callee92, this);
              }));
              function listIndexes() {
                return _listIndexes2.apply(this, arguments);
              }
              return listIndexes;
            }()
            /**
            *
            * @alpha
            *
            * Retrieves metadata for a specific index in this bucket
            * Convenience method that automatically includes the bucket name
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param indexName - Name of the index to retrieve
            * @returns Promise with index metadata or error
            *
            * @example
            * ```typescript
            * const bucket = supabase.storage.vectors.from('embeddings-prod')
            * const { data } = await bucket.getIndex('documents-openai')
            * console.log('Dimension:', data?.index.dimension)
            * ```
            */
            )
          }, {
            key: "getIndex",
            value: (function () {
              var _getIndex2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee93(indexName) {
                var _this103 = this;
                var _superprop_getGetIndex, _this7;
                return _regenerator().w(function (_context94) {
                  while (1) switch (_context94.n) {
                    case 0:
                      _superprop_getGetIndex = function _superprop_getGetIndex() {
                        return _superPropGet(VectorBucketScope, "getIndex", _this103, 1);
                      }, _this7 = this;
                      return _context94.a(2, _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName));
                  }
                }, _callee93, this);
              }));
              function getIndex(_x165) {
                return _getIndex2.apply(this, arguments);
              }
              return getIndex;
            }()
            /**
            *
            * @alpha
            *
            * Deletes an index from this bucket
            * Convenience method that automatically includes the bucket name
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param indexName - Name of the index to delete
            * @returns Promise with empty response on success or error
            *
            * @example
            * ```typescript
            * const bucket = supabase.storage.vectors.from('embeddings-prod')
            * await bucket.deleteIndex('old-index')
            * ```
            */
            )
          }, {
            key: "deleteIndex",
            value: (function () {
              var _deleteIndex2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee94(indexName) {
                var _this104 = this;
                var _superprop_getDeleteIndex, _this8;
                return _regenerator().w(function (_context95) {
                  while (1) switch (_context95.n) {
                    case 0:
                      _superprop_getDeleteIndex = function _superprop_getDeleteIndex() {
                        return _superPropGet(VectorBucketScope, "deleteIndex", _this104, 1);
                      }, _this8 = this;
                      return _context95.a(2, _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName));
                  }
                }, _callee94, this);
              }));
              function deleteIndex(_x166) {
                return _deleteIndex2.apply(this, arguments);
              }
              return deleteIndex;
            }()
            /**
            *
            * @alpha
            *
            * Access operations for a specific index within this bucket
            * Returns a scoped client for vector data operations
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param indexName - Name of the index
            * @returns Index-scoped client with vector data operations
            *
            * @example
            * ```typescript
            * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
            *
            * // Insert vectors
            * await index.putVectors({
            *   vectors: [
            *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
            *   ]
            * })
            *
            * // Query similar vectors
            * const { data } = await index.queryVectors({
            *   queryVector: { float32: [...] },
            *   topK: 5
            * })
            * ```
            */
            )
          }, {
            key: "index",
            value: function index(indexName) {
              return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
            }
          }]);
        }(VectorIndexApi);
        /**
        *
        * @alpha
        *
        * Scoped client for operations within a specific vector index
        * Provides vector data operations (put, get, list, query, delete)
        *
        * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
        */
        var VectorIndexScope = /*#__PURE__*/function (_VectorDataApi) {
          /**
          *
          * @alpha
          *
          * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @example
          * ```typescript
          * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
          * ```
          */
          function VectorIndexScope(url, headers, vectorBucketName, indexName, fetch$1) {
            var _this105;
            _classCallCheck(this, VectorIndexScope);
            _this105 = _callSuper(this, VectorIndexScope, [url, headers, fetch$1]);
            _this105.vectorBucketName = vectorBucketName;
            _this105.indexName = indexName;
            return _this105;
          }
          /**
          *
          * @alpha
          *
          * Inserts or updates vectors in this index
          * Convenience method that automatically includes bucket and index names
          *
          * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
          *
          * @category Vector Buckets
          * @param options - Vector insertion options (bucket and index names automatically set)
          * @returns Promise with empty response on success or error
          *
          * @example
          * ```typescript
          * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
          * await index.putVectors({
          *   vectors: [
          *     {
          *       key: 'doc-1',
          *       data: { float32: [0.1, 0.2, ...] },
          *       metadata: { title: 'Introduction', page: 1 }
          *     }
          *   ]
          * })
          * ```
          */
          _inherits(VectorIndexScope, _VectorDataApi);
          return _createClass(VectorIndexScope, [{
            key: "putVectors",
            value: (function () {
              var _putVectors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee95(options) {
                var _this106 = this;
                var _superprop_getPutVectors, _this9;
                return _regenerator().w(function (_context96) {
                  while (1) switch (_context96.n) {
                    case 0:
                      _superprop_getPutVectors = function _superprop_getPutVectors() {
                        return _superPropGet(VectorIndexScope, "putVectors", _this106, 1);
                      }, _this9 = this;
                      return _context96.a(2, _superprop_getPutVectors().call(_this9, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this9.vectorBucketName,
                        indexName: _this9.indexName
                      })));
                  }
                }, _callee95, this);
              }));
              function putVectors(_x167) {
                return _putVectors2.apply(this, arguments);
              }
              return putVectors;
            }()
            /**
            *
            * @alpha
            *
            * Retrieves vectors by keys from this index
            * Convenience method that automatically includes bucket and index names
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Vector retrieval options (bucket and index names automatically set)
            * @returns Promise with response containing vectors array or error
            *
            * @example
            * ```typescript
            * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
            * const { data } = await index.getVectors({
            *   keys: ['doc-1', 'doc-2'],
            *   returnMetadata: true
            * })
            * ```
            */
            )
          }, {
            key: "getVectors",
            value: (function () {
              var _getVectors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee96(options) {
                var _this107 = this;
                var _superprop_getGetVectors, _this10;
                return _regenerator().w(function (_context97) {
                  while (1) switch (_context97.n) {
                    case 0:
                      _superprop_getGetVectors = function _superprop_getGetVectors() {
                        return _superPropGet(VectorIndexScope, "getVectors", _this107, 1);
                      }, _this10 = this;
                      return _context97.a(2, _superprop_getGetVectors().call(_this10, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this10.vectorBucketName,
                        indexName: _this10.indexName
                      })));
                  }
                }, _callee96, this);
              }));
              function getVectors(_x168) {
                return _getVectors2.apply(this, arguments);
              }
              return getVectors;
            }()
            /**
            *
            * @alpha
            *
            * Lists vectors in this index with pagination
            * Convenience method that automatically includes bucket and index names
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Listing options (bucket and index names automatically set)
            * @returns Promise with response containing vectors array and pagination token or error
            *
            * @example
            * ```typescript
            * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
            * const { data } = await index.listVectors({
            *   maxResults: 500,
            *   returnMetadata: true
            * })
            * ```
            */
            )
          }, {
            key: "listVectors",
            value: (function () {
              var _listVectors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee97() {
                var _this108 = this;
                var options,
                  _superprop_getListVectors,
                  _this11,
                  _args97 = arguments;
                return _regenerator().w(function (_context98) {
                  while (1) switch (_context98.n) {
                    case 0:
                      options = _args97.length > 0 && _args97[0] !== undefined ? _args97[0] : {};
                      _superprop_getListVectors = function _superprop_getListVectors() {
                        return _superPropGet(VectorIndexScope, "listVectors", _this108, 1);
                      }, _this11 = this;
                      return _context98.a(2, _superprop_getListVectors().call(_this11, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this11.vectorBucketName,
                        indexName: _this11.indexName
                      })));
                  }
                }, _callee97, this);
              }));
              function listVectors() {
                return _listVectors2.apply(this, arguments);
              }
              return listVectors;
            }()
            /**
            *
            * @alpha
            *
            * Queries for similar vectors in this index
            * Convenience method that automatically includes bucket and index names
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Query options (bucket and index names automatically set)
            * @returns Promise with response containing matches array of similar vectors ordered by distance or error
            *
            * @example
            * ```typescript
            * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
            * const { data } = await index.queryVectors({
            *   queryVector: { float32: [0.1, 0.2, ...] },
            *   topK: 5,
            *   filter: { category: 'technical' },
            *   returnDistance: true,
            *   returnMetadata: true
            * })
            * ```
            */
            )
          }, {
            key: "queryVectors",
            value: (function () {
              var _queryVectors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee98(options) {
                var _this109 = this;
                var _superprop_getQueryVectors, _this12;
                return _regenerator().w(function (_context99) {
                  while (1) switch (_context99.n) {
                    case 0:
                      _superprop_getQueryVectors = function _superprop_getQueryVectors() {
                        return _superPropGet(VectorIndexScope, "queryVectors", _this109, 1);
                      }, _this12 = this;
                      return _context99.a(2, _superprop_getQueryVectors().call(_this12, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this12.vectorBucketName,
                        indexName: _this12.indexName
                      })));
                  }
                }, _callee98, this);
              }));
              function queryVectors(_x169) {
                return _queryVectors2.apply(this, arguments);
              }
              return queryVectors;
            }()
            /**
            *
            * @alpha
            *
            * Deletes vectors by keys from this index
            * Convenience method that automatically includes bucket and index names
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @param options - Deletion options (bucket and index names automatically set)
            * @returns Promise with empty response on success or error
            *
            * @example
            * ```typescript
            * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
            * await index.deleteVectors({
            *   keys: ['doc-1', 'doc-2', 'doc-3']
            * })
            * ```
            */
            )
          }, {
            key: "deleteVectors",
            value: (function () {
              var _deleteVectors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee99(options) {
                var _this110 = this;
                var _superprop_getDeleteVectors, _this13;
                return _regenerator().w(function (_context100) {
                  while (1) switch (_context100.n) {
                    case 0:
                      _superprop_getDeleteVectors = function _superprop_getDeleteVectors() {
                        return _superPropGet(VectorIndexScope, "deleteVectors", _this110, 1);
                      }, _this13 = this;
                      return _context100.a(2, _superprop_getDeleteVectors().call(_this13, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
                        vectorBucketName: _this13.vectorBucketName,
                        indexName: _this13.indexName
                      })));
                  }
                }, _callee99, this);
              }));
              function deleteVectors(_x170) {
                return _deleteVectors2.apply(this, arguments);
              }
              return deleteVectors;
            }())
          }]);
        }(VectorDataApi);

        //#endregion
        //#region src/StorageClient.ts
        var StorageClient = /*#__PURE__*/function (_StorageBucketApi) {
          /**
          * Creates a client for Storage buckets, files, analytics, and vectors.
          *
          * @category File Buckets
          * @example
          * ```ts
          * import { StorageClient } from '@supabase/storage-js'
          *
          * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {
          *   apikey: 'public-anon-key',
          * })
          * const avatars = storage.from('avatars')
          * ```
          */
          function StorageClient(url) {
            var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fetch$1 = arguments.length > 2 ? arguments[2] : undefined;
            var opts = arguments.length > 3 ? arguments[3] : undefined;
            _classCallCheck(this, StorageClient);
            return _callSuper(this, StorageClient, [url, headers, fetch$1, opts]);
          }
          /**
          * Perform file operation in a bucket.
          *
          * @category File Buckets
          * @param id The bucket id to operate on.
          *
          * @example
          * ```typescript
          * const avatars = supabase.storage.from('avatars')
          * ```
          */
          _inherits(StorageClient, _StorageBucketApi);
          return _createClass(StorageClient, [{
            key: "from",
            value: function from(id) {
              return new StorageFileApi(this.url, this.headers, id, this.fetch);
            }
            /**
            *
            * @alpha
            *
            * Access vector storage operations.
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Vector Buckets
            * @returns A StorageVectorsClient instance configured with the current storage settings.
            */
          }, {
            key: "vectors",
            get: function get() {
              return new StorageVectorsClient(this.url + "/vector", {
                headers: this.headers,
                fetch: this.fetch
              });
            }
            /**
            *
            * @alpha
            *
            * Access analytics storage operations using Iceberg tables.
            *
            * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
            *
            * @category Analytics Buckets
            * @returns A StorageAnalyticsClient instance configured with the current storage settings.
            */
          }, {
            key: "analytics",
            get: function get() {
              return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
            }
          }]);
        }(StorageBucketApi);

        // Generated automatically during releases by scripts/update-version-files.ts
        // This file provides runtime access to the package version for:
        // - HTTP request headers (e.g., X-Client-Info header for API requests)
        // - Debugging and support (identifying which version is running)
        // - Telemetry and logging (version reporting in errors/analytics)
        // - Ensuring build artifacts match the published package version
        var version$1 = '2.90.1';

        /** Current session will be checked for refresh at this interval. */
        var AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;
        /**
         * A token refresh will be attempted this many ticks before the current session expires. */
        var AUTO_REFRESH_TICK_THRESHOLD = 3;
        /*
         * Earliest time before an access token expires that the session should be refreshed.
         */
        var EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
        var GOTRUE_URL = 'http://localhost:9999';
        var STORAGE_KEY = 'supabase.auth.token';
        var DEFAULT_HEADERS$1 = {
          'X-Client-Info': "gotrue-js/".concat(version$1)
        };
        var API_VERSION_HEADER_NAME = 'X-Supabase-Api-Version';
        var API_VERSIONS = {
          '2024-01-01': {
            timestamp: Date.parse('2024-01-01T00:00:00.0Z'),
            name: '2024-01-01'
          }
        };
        var BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
        var JWKS_TTL = 10 * 60 * 1000; // 10 minutes

        /**
         * Base error thrown by Supabase Auth helpers.
         *
         * @example
         * ```ts
         * import { AuthError } from '@supabase/auth-js'
         *
         * throw new AuthError('Unexpected auth error', 500, 'unexpected')
         * ```
         */
        var AuthError = /*#__PURE__*/function (_Error7) {
          function AuthError(message, status, code) {
            var _this111;
            _classCallCheck(this, AuthError);
            _this111 = _callSuper(this, AuthError, [message]);
            _this111.__isAuthError = true;
            _this111.name = 'AuthError';
            _this111.status = status;
            _this111.code = code;
            return _this111;
          }
          _inherits(AuthError, _Error7);
          return _createClass(AuthError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        function isAuthError(error) {
          return _typeof2(error) === 'object' && error !== null && '__isAuthError' in error;
        }
        /**
         * Error returned directly from the GoTrue REST API.
         *
         * @example
         * ```ts
         * import { AuthApiError } from '@supabase/auth-js'
         *
         * throw new AuthApiError('Invalid credentials', 400, 'invalid_credentials')
         * ```
         */
        var AuthApiError = /*#__PURE__*/function (_AuthError) {
          function AuthApiError(message, status, code) {
            var _this112;
            _classCallCheck(this, AuthApiError);
            _this112 = _callSuper(this, AuthApiError, [message, status, code]);
            _this112.name = 'AuthApiError';
            _this112.status = status;
            _this112.code = code;
            return _this112;
          }
          _inherits(AuthApiError, _AuthError);
          return _createClass(AuthApiError);
        }(AuthError);
        function isAuthApiError(error) {
          return isAuthError(error) && error.name === 'AuthApiError';
        }
        /**
         * Wraps non-standard errors so callers can inspect the root cause.
         *
         * @example
         * ```ts
         * import { AuthUnknownError } from '@supabase/auth-js'
         *
         * try {
         *   await someAuthCall()
         * } catch (err) {
         *   throw new AuthUnknownError('Auth failed', err)
         * }
         * ```
         */
        var AuthUnknownError = /*#__PURE__*/function (_AuthError2) {
          function AuthUnknownError(message, originalError) {
            var _this113;
            _classCallCheck(this, AuthUnknownError);
            _this113 = _callSuper(this, AuthUnknownError, [message]);
            _this113.name = 'AuthUnknownError';
            _this113.originalError = originalError;
            return _this113;
          }
          _inherits(AuthUnknownError, _AuthError2);
          return _createClass(AuthUnknownError);
        }(AuthError);
        /**
         * Flexible error class used to create named auth errors at runtime.
         *
         * @example
         * ```ts
         * import { CustomAuthError } from '@supabase/auth-js'
         *
         * throw new CustomAuthError('My custom auth error', 'MyAuthError', 400, 'custom_code')
         * ```
         */
        var CustomAuthError = /*#__PURE__*/function (_AuthError3) {
          function CustomAuthError(message, name, status, code) {
            var _this114;
            _classCallCheck(this, CustomAuthError);
            _this114 = _callSuper(this, CustomAuthError, [message, status, code]);
            _this114.name = name;
            _this114.status = status;
            return _this114;
          }
          _inherits(CustomAuthError, _AuthError3);
          return _createClass(CustomAuthError);
        }(AuthError);
        /**
         * Error thrown when an operation requires a session but none is present.
         *
         * @example
         * ```ts
         * import { AuthSessionMissingError } from '@supabase/auth-js'
         *
         * throw new AuthSessionMissingError()
         * ```
         */
        var AuthSessionMissingError = /*#__PURE__*/function (_CustomAuthError) {
          function AuthSessionMissingError() {
            _classCallCheck(this, AuthSessionMissingError);
            return _callSuper(this, AuthSessionMissingError, ['Auth session missing!', 'AuthSessionMissingError', 400, undefined]);
          }
          _inherits(AuthSessionMissingError, _CustomAuthError);
          return _createClass(AuthSessionMissingError);
        }(CustomAuthError);
        function isAuthSessionMissingError(error) {
          return isAuthError(error) && error.name === 'AuthSessionMissingError';
        }
        /**
         * Error thrown when the token response is malformed.
         *
         * @example
         * ```ts
         * import { AuthInvalidTokenResponseError } from '@supabase/auth-js'
         *
         * throw new AuthInvalidTokenResponseError()
         * ```
         */
        var AuthInvalidTokenResponseError = /*#__PURE__*/function (_CustomAuthError2) {
          function AuthInvalidTokenResponseError() {
            _classCallCheck(this, AuthInvalidTokenResponseError);
            return _callSuper(this, AuthInvalidTokenResponseError, ['Auth session or user missing', 'AuthInvalidTokenResponseError', 500, undefined]);
          }
          _inherits(AuthInvalidTokenResponseError, _CustomAuthError2);
          return _createClass(AuthInvalidTokenResponseError);
        }(CustomAuthError);
        /**
         * Error thrown when email/password credentials are invalid.
         *
         * @example
         * ```ts
         * import { AuthInvalidCredentialsError } from '@supabase/auth-js'
         *
         * throw new AuthInvalidCredentialsError('Email or password is incorrect')
         * ```
         */
        var AuthInvalidCredentialsError = /*#__PURE__*/function (_CustomAuthError3) {
          function AuthInvalidCredentialsError(message) {
            _classCallCheck(this, AuthInvalidCredentialsError);
            return _callSuper(this, AuthInvalidCredentialsError, [message, 'AuthInvalidCredentialsError', 400, undefined]);
          }
          _inherits(AuthInvalidCredentialsError, _CustomAuthError3);
          return _createClass(AuthInvalidCredentialsError);
        }(CustomAuthError);
        /**
         * Error thrown when implicit grant redirects contain an error.
         *
         * @example
         * ```ts
         * import { AuthImplicitGrantRedirectError } from '@supabase/auth-js'
         *
         * throw new AuthImplicitGrantRedirectError('OAuth redirect failed', {
         *   error: 'access_denied',
         *   code: 'oauth_error',
         * })
         * ```
         */
        var AuthImplicitGrantRedirectError = /*#__PURE__*/function (_CustomAuthError4) {
          function AuthImplicitGrantRedirectError(message) {
            var _this115;
            var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, AuthImplicitGrantRedirectError);
            _this115 = _callSuper(this, AuthImplicitGrantRedirectError, [message, 'AuthImplicitGrantRedirectError', 500, undefined]);
            _this115.details = null;
            _this115.details = details;
            return _this115;
          }
          _inherits(AuthImplicitGrantRedirectError, _CustomAuthError4);
          return _createClass(AuthImplicitGrantRedirectError, [{
            key: "toJSON",
            value: function toJSON() {
              return {
                name: this.name,
                message: this.message,
                status: this.status,
                details: this.details
              };
            }
          }]);
        }(CustomAuthError);
        function isAuthImplicitGrantRedirectError(error) {
          return isAuthError(error) && error.name === 'AuthImplicitGrantRedirectError';
        }
        /**
         * Error thrown during PKCE code exchanges.
         *
         * @example
         * ```ts
         * import { AuthPKCEGrantCodeExchangeError } from '@supabase/auth-js'
         *
         * throw new AuthPKCEGrantCodeExchangeError('PKCE exchange failed')
         * ```
         */
        var AuthPKCEGrantCodeExchangeError = /*#__PURE__*/function (_CustomAuthError5) {
          function AuthPKCEGrantCodeExchangeError(message) {
            var _this116;
            var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, AuthPKCEGrantCodeExchangeError);
            _this116 = _callSuper(this, AuthPKCEGrantCodeExchangeError, [message, 'AuthPKCEGrantCodeExchangeError', 500, undefined]);
            _this116.details = null;
            _this116.details = details;
            return _this116;
          }
          _inherits(AuthPKCEGrantCodeExchangeError, _CustomAuthError5);
          return _createClass(AuthPKCEGrantCodeExchangeError, [{
            key: "toJSON",
            value: function toJSON() {
              return {
                name: this.name,
                message: this.message,
                status: this.status,
                details: this.details
              };
            }
          }]);
        }(CustomAuthError);
        /**
         * Error thrown when the PKCE code verifier is not found in storage.
         * This typically happens when the auth flow was initiated in a different
         * browser, device, or the storage was cleared.
         *
         * @example
         * ```ts
         * import { AuthPKCECodeVerifierMissingError } from '@supabase/auth-js'
         *
         * throw new AuthPKCECodeVerifierMissingError()
         * ```
         */
        var AuthPKCECodeVerifierMissingError = /*#__PURE__*/function (_CustomAuthError6) {
          function AuthPKCECodeVerifierMissingError() {
            _classCallCheck(this, AuthPKCECodeVerifierMissingError);
            return _callSuper(this, AuthPKCECodeVerifierMissingError, ['PKCE code verifier not found in storage. ' + 'This can happen if the auth flow was initiated in a different browser or device, ' + 'or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), ' + 'use @supabase/ssr on both the server and client to store the code verifier in cookies.', 'AuthPKCECodeVerifierMissingError', 400, 'pkce_code_verifier_not_found']);
          }
          _inherits(AuthPKCECodeVerifierMissingError, _CustomAuthError6);
          return _createClass(AuthPKCECodeVerifierMissingError);
        }(CustomAuthError);
        /**
         * Error thrown when a transient fetch issue occurs.
         *
         * @example
         * ```ts
         * import { AuthRetryableFetchError } from '@supabase/auth-js'
         *
         * throw new AuthRetryableFetchError('Service temporarily unavailable', 503)
         * ```
         */
        var AuthRetryableFetchError = /*#__PURE__*/function (_CustomAuthError7) {
          function AuthRetryableFetchError(message, status) {
            _classCallCheck(this, AuthRetryableFetchError);
            return _callSuper(this, AuthRetryableFetchError, [message, 'AuthRetryableFetchError', status, undefined]);
          }
          _inherits(AuthRetryableFetchError, _CustomAuthError7);
          return _createClass(AuthRetryableFetchError);
        }(CustomAuthError);
        function isAuthRetryableFetchError(error) {
          return isAuthError(error) && error.name === 'AuthRetryableFetchError';
        }
        /**
         * This error is thrown on certain methods when the password used is deemed
         * weak. Inspect the reasons to identify what password strength rules are
         * inadequate.
         */
        /**
         * Error thrown when a supplied password is considered weak.
         *
         * @example
         * ```ts
         * import { AuthWeakPasswordError } from '@supabase/auth-js'
         *
         * throw new AuthWeakPasswordError('Password too short', 400, ['min_length'])
         * ```
         */
        var AuthWeakPasswordError = /*#__PURE__*/function (_CustomAuthError8) {
          function AuthWeakPasswordError(message, status, reasons) {
            var _this117;
            _classCallCheck(this, AuthWeakPasswordError);
            _this117 = _callSuper(this, AuthWeakPasswordError, [message, 'AuthWeakPasswordError', status, 'weak_password']);
            _this117.reasons = reasons;
            return _this117;
          }
          _inherits(AuthWeakPasswordError, _CustomAuthError8);
          return _createClass(AuthWeakPasswordError);
        }(CustomAuthError);
        /**
         * Error thrown when a JWT cannot be verified or parsed.
         *
         * @example
         * ```ts
         * import { AuthInvalidJwtError } from '@supabase/auth-js'
         *
         * throw new AuthInvalidJwtError('Token signature is invalid')
         * ```
         */
        var AuthInvalidJwtError = /*#__PURE__*/function (_CustomAuthError9) {
          function AuthInvalidJwtError(message) {
            _classCallCheck(this, AuthInvalidJwtError);
            return _callSuper(this, AuthInvalidJwtError, [message, 'AuthInvalidJwtError', 400, 'invalid_jwt']);
          }
          _inherits(AuthInvalidJwtError, _CustomAuthError9);
          return _createClass(AuthInvalidJwtError);
        }(CustomAuthError);
        /**
         * Avoid modifying this file. It's part of
         * https://github.com/supabase-community/base64url-js.  Submit all fixes on
         * that repo!
         */
        /**
         * An array of characters that encode 6 bits into a Base64-URL alphabet
         * character.
         */
        var TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');
        /**
         * An array of characters that can appear in a Base64-URL encoded string but
         * should be ignored.
         */
        var IGNORE_BASE64URL = ' \t\n\r='.split('');
        /**
         * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2
         * used to skip the character, or if -1 used to error out.
         */
        var FROM_BASE64URL = function () {
          var charMap = new Array(128);
          for (var i = 0; i < charMap.length; i += 1) {
            charMap[i] = -1;
          }
          for (var _i1 = 0; _i1 < IGNORE_BASE64URL.length; _i1 += 1) {
            charMap[IGNORE_BASE64URL[_i1].charCodeAt(0)] = -2;
          }
          for (var _i10 = 0; _i10 < TO_BASE64URL.length; _i10 += 1) {
            charMap[TO_BASE64URL[_i10].charCodeAt(0)] = _i10;
          }
          return charMap;
        }();
        /**
         * Converts a byte to a Base64-URL string.
         *
         * @param byte The byte to convert, or null to flush at the end of the byte sequence.
         * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.
         * @param emit A function called with the next Base64 character when ready.
         */
        function byteToBase64URL(byte, state, emit) {
          if (byte !== null) {
            state.queue = state.queue << 8 | byte;
            state.queuedBits += 8;
            while (state.queuedBits >= 6) {
              var pos = state.queue >> state.queuedBits - 6 & 63;
              emit(TO_BASE64URL[pos]);
              state.queuedBits -= 6;
            }
          } else if (state.queuedBits > 0) {
            state.queue = state.queue << 6 - state.queuedBits;
            state.queuedBits = 6;
            while (state.queuedBits >= 6) {
              var _pos = state.queue >> state.queuedBits - 6 & 63;
              emit(TO_BASE64URL[_pos]);
              state.queuedBits -= 6;
            }
          }
        }
        /**
         * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.
         *
         * @param charCode The char code of the JavaScript string.
         * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.
         * @param emit A function called with the next byte.
         */
        function byteFromBase64URL(charCode, state, emit) {
          var bits = FROM_BASE64URL[charCode];
          if (bits > -1) {
            // valid Base64-URL character
            state.queue = state.queue << 6 | bits;
            state.queuedBits += 6;
            while (state.queuedBits >= 8) {
              emit(state.queue >> state.queuedBits - 8 & 0xff);
              state.queuedBits -= 8;
            }
          } else if (bits === -2) {
            // ignore spaces, tabs, newlines, =
            return;
          } else {
            throw new Error("Invalid Base64-URL character \"".concat(String.fromCharCode(charCode), "\""));
          }
        }
        /**
         * Converts a Base64-URL encoded string into a JavaScript string. It is assumed
         * that the underlying string has been encoded as UTF-8.
         *
         * @param str The Base64-URL encoded string.
         */
        function stringFromBase64URL(str) {
          var conv = [];
          var utf8Emit = function utf8Emit(codepoint) {
            conv.push(String.fromCodePoint(codepoint));
          };
          var utf8State = {
            utf8seq: 0,
            codepoint: 0
          };
          var b64State = {
            queue: 0,
            queuedBits: 0
          };
          var byteEmit = function byteEmit(byte) {
            stringFromUTF8(byte, utf8State, utf8Emit);
          };
          for (var i = 0; i < str.length; i += 1) {
            byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
          }
          return conv.join('');
        }
        /**
         * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.
         *
         * @param codepoint The Unicode codepoint.
         * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.
         */
        function codepointToUTF8(codepoint, emit) {
          if (codepoint <= 0x7f) {
            emit(codepoint);
            return;
          } else if (codepoint <= 0x7ff) {
            emit(0xc0 | codepoint >> 6);
            emit(0x80 | codepoint & 0x3f);
            return;
          } else if (codepoint <= 0xffff) {
            emit(0xe0 | codepoint >> 12);
            emit(0x80 | codepoint >> 6 & 0x3f);
            emit(0x80 | codepoint & 0x3f);
            return;
          } else if (codepoint <= 0x10ffff) {
            emit(0xf0 | codepoint >> 18);
            emit(0x80 | codepoint >> 12 & 0x3f);
            emit(0x80 | codepoint >> 6 & 0x3f);
            emit(0x80 | codepoint & 0x3f);
            return;
          }
          throw new Error("Unrecognized Unicode codepoint: ".concat(codepoint.toString(16)));
        }
        /**
         * Converts a JavaScript string to a sequence of UTF-8 bytes.
         *
         * @param str  The string to convert to UTF-8.
         * @param emit Function which will be called for each UTF-8 byte of the string.
         */
        function stringToUTF8(str, emit) {
          for (var i = 0; i < str.length; i += 1) {
            var codepoint = str.charCodeAt(i);
            if (codepoint > 0xd7ff && codepoint <= 0xdbff) {
              // most UTF-16 codepoints are Unicode codepoints, except values in this
              // range where the next UTF-16 codepoint needs to be combined with the
              // current one to get the Unicode codepoint
              var highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;
              var lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;
              codepoint = (lowSurrogate | highSurrogate) + 0x10000;
              i += 1;
            }
            codepointToUTF8(codepoint, emit);
          }
        }
        /**
         * Converts a UTF-8 byte to a Unicode codepoint.
         *
         * @param byte  The UTF-8 byte next in the sequence.
         * @param state The shared state between consecutive UTF-8 bytes in the
         *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.
         * @param emit  Function which will be called for each codepoint.
         */
        function stringFromUTF8(byte, state, emit) {
          if (state.utf8seq === 0) {
            if (byte <= 0x7f) {
              emit(byte);
              return;
            }
            // count the number of 1 leading bits until you reach 0
            for (var leadingBit = 1; leadingBit < 6; leadingBit += 1) {
              if ((byte >> 7 - leadingBit & 1) === 0) {
                state.utf8seq = leadingBit;
                break;
              }
            }
            if (state.utf8seq === 2) {
              state.codepoint = byte & 31;
            } else if (state.utf8seq === 3) {
              state.codepoint = byte & 15;
            } else if (state.utf8seq === 4) {
              state.codepoint = byte & 7;
            } else {
              throw new Error('Invalid UTF-8 sequence');
            }
            state.utf8seq -= 1;
          } else if (state.utf8seq > 0) {
            if (byte <= 0x7f) {
              throw new Error('Invalid UTF-8 sequence');
            }
            state.codepoint = state.codepoint << 6 | byte & 63;
            state.utf8seq -= 1;
            if (state.utf8seq === 0) {
              emit(state.codepoint);
            }
          }
        }
        /**
         * Helper functions to convert different types of strings to Uint8Array
         */
        function base64UrlToUint8Array(str) {
          var result = [];
          var state = {
            queue: 0,
            queuedBits: 0
          };
          var onByte = function onByte(byte) {
            result.push(byte);
          };
          for (var i = 0; i < str.length; i += 1) {
            byteFromBase64URL(str.charCodeAt(i), state, onByte);
          }
          return new Uint8Array(result);
        }
        function stringToUint8Array(str) {
          var result = [];
          stringToUTF8(str, function (byte) {
            return result.push(byte);
          });
          return new Uint8Array(result);
        }
        function bytesToBase64URL(bytes) {
          var result = [];
          var state = {
            queue: 0,
            queuedBits: 0
          };
          var onChar = function onChar(char) {
            result.push(char);
          };
          bytes.forEach(function (byte) {
            return byteToBase64URL(byte, state, onChar);
          });
          // always call with `null` after processing all bytes
          byteToBase64URL(null, state, onChar);
          return result.join('');
        }
        function expiresAt(expiresIn) {
          var timeNow = Math.round(Date.now() / 1000);
          return timeNow + expiresIn;
        }
        /**
         * Generates a unique identifier for internal callback subscriptions.
         *
         * This function uses JavaScript Symbols to create guaranteed-unique identifiers
         * for auth state change callbacks. Symbols are ideal for this use case because:
         * - They are guaranteed unique by the JavaScript runtime
         * - They work in all environments (browser, SSR, Node.js)
         * - They avoid issues with Next.js 16 deterministic rendering requirements
         * - They are perfect for internal, non-serializable identifiers
         *
         * Note: This function is only used for internal subscription management,
         * not for security-critical operations like session tokens.
         */
        function generateCallbackId() {
          return Symbol('auth-callback');
        }
        var isBrowser = function isBrowser() {
          return typeof window !== 'undefined' && typeof document !== 'undefined';
        };
        var localStorageWriteTests = {
          tested: false,
          writable: false
        };
        /**
         * Checks whether localStorage is supported on this browser.
         */
        var supportsLocalStorage = function supportsLocalStorage() {
          if (!isBrowser()) {
            return false;
          }
          try {
            if (_typeof2(globalThis.localStorage) !== 'object') {
              return false;
            }
          } catch (e) {
            // DOM exception when accessing `localStorage`
            return false;
          }
          if (localStorageWriteTests.tested) {
            return localStorageWriteTests.writable;
          }
          var randomKey = "lswt-".concat(Math.random()).concat(Math.random());
          try {
            globalThis.localStorage.setItem(randomKey, randomKey);
            globalThis.localStorage.removeItem(randomKey);
            localStorageWriteTests.tested = true;
            localStorageWriteTests.writable = true;
          } catch (e) {
            // localStorage can't be written to
            // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document
            localStorageWriteTests.tested = true;
            localStorageWriteTests.writable = false;
          }
          return localStorageWriteTests.writable;
        };
        /**
         * Extracts parameters encoded in the URL both in the query and fragment.
         */
        function parseParametersFromURL(href) {
          var result = {};
          var url = new URL(href);
          if (url.hash && url.hash[0] === '#') {
            try {
              var hashSearchParams = new URLSearchParams(url.hash.substring(1));
              hashSearchParams.forEach(function (value, key) {
                result[key] = value;
              });
            } catch (e) {
              // hash is not a query string
            }
          }
          // search parameters take precedence over hash parameters
          url.searchParams.forEach(function (value, key) {
            result[key] = value;
          });
          return result;
        }
        var resolveFetch$1 = function resolveFetch$1(customFetch) {
          if (customFetch) {
            return function () {
              return customFetch.apply(void 0, arguments);
            };
          }
          return function () {
            return fetch.apply(void 0, arguments);
          };
        };
        var looksLikeFetchResponse = function looksLikeFetchResponse(maybeResponse) {
          return _typeof2(maybeResponse) === 'object' && maybeResponse !== null && 'status' in maybeResponse && 'ok' in maybeResponse && 'json' in maybeResponse && typeof maybeResponse.json === 'function';
        };
        // Storage helpers
        var setItemAsync = /*#__PURE__*/function () {
          var _ref206 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee100(storage, key, data) {
            return _regenerator().w(function (_context101) {
              while (1) switch (_context101.n) {
                case 0:
                  _context101.n = 1;
                  return storage.setItem(key, JSON.stringify(data));
                case 1:
                  return _context101.a(2);
              }
            }, _callee100);
          }));
          return function setItemAsync(_x171, _x172, _x173) {
            return _ref206.apply(this, arguments);
          };
        }();
        var getItemAsync = /*#__PURE__*/function () {
          var _ref207 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee101(storage, key) {
            var value, _t89;
            return _regenerator().w(function (_context102) {
              while (1) switch (_context102.p = _context102.n) {
                case 0:
                  _context102.n = 1;
                  return storage.getItem(key);
                case 1:
                  value = _context102.v;
                  if (value) {
                    _context102.n = 2;
                    break;
                  }
                  return _context102.a(2, null);
                case 2:
                  _context102.p = 2;
                  return _context102.a(2, JSON.parse(value));
                case 3:
                  _context102.p = 3;
                  _t89 = _context102.v;
                  return _context102.a(2, value);
              }
            }, _callee101, null, [[2, 3]]);
          }));
          return function getItemAsync(_x174, _x175) {
            return _ref207.apply(this, arguments);
          };
        }();
        var removeItemAsync = /*#__PURE__*/function () {
          var _ref208 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee102(storage, key) {
            return _regenerator().w(function (_context103) {
              while (1) switch (_context103.n) {
                case 0:
                  _context103.n = 1;
                  return storage.removeItem(key);
                case 1:
                  return _context103.a(2);
              }
            }, _callee102);
          }));
          return function removeItemAsync(_x176, _x177) {
            return _ref208.apply(this, arguments);
          };
        }();
        /**
         * A deferred represents some asynchronous work that is not yet finished, which
         * may or may not culminate in a value.
         * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts
         */
        var Deferred = /*#__PURE__*/_createClass(function Deferred() {
          var _this118 = this;
          _classCallCheck(this, Deferred);
          this.promise = new Deferred.promiseConstructor(function (res, rej) {
            _this118.resolve = res;
            _this118.reject = rej;
          });
        });
        Deferred.promiseConstructor = Promise;
        function decodeJWT(token) {
          var parts = token.split('.');
          if (parts.length !== 3) {
            throw new AuthInvalidJwtError('Invalid JWT structure');
          }
          // Regex checks for base64url format
          for (var i = 0; i < parts.length; i++) {
            if (!BASE64URL_REGEX.test(parts[i])) {
              throw new AuthInvalidJwtError('JWT not in base64url format');
            }
          }
          var data = {
            // using base64url lib
            header: JSON.parse(stringFromBase64URL(parts[0])),
            payload: JSON.parse(stringFromBase64URL(parts[1])),
            signature: base64UrlToUint8Array(parts[2]),
            raw: {
              header: parts[0],
              payload: parts[1]
            }
          };
          return data;
        }
        /**
         * Creates a promise that resolves to null after some time.
         */
        function sleep(_x178) {
          return _sleep.apply(this, arguments);
        }
        /**
         * Converts the provided async function into a retryable function. Each result
         * or thrown error is sent to the isRetryable function which should return true
         * if the function should run again.
         */
        function _sleep() {
          _sleep = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee267(time) {
            return _regenerator().w(function (_context268) {
              while (1) switch (_context268.n) {
                case 0:
                  _context268.n = 1;
                  return new Promise(function (accept) {
                    setTimeout(function () {
                      return accept(null);
                    }, time);
                  });
                case 1:
                  return _context268.a(2, _context268.v);
              }
            }, _callee267);
          }));
          return _sleep.apply(this, arguments);
        }
        function retryable(fn, isRetryable) {
          var promise = new Promise(function (accept, reject) {
            _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee103() {
              var attempt, result, _t90;
              return _regenerator().w(function (_context104) {
                while (1) switch (_context104.p = _context104.n) {
                  case 0:
                    attempt = 0;
                  case 1:
                    if (!(attempt < Infinity)) {
                      _context104.n = 7;
                      break;
                    }
                    _context104.p = 2;
                    _context104.n = 3;
                    return fn(attempt);
                  case 3:
                    result = _context104.v;
                    if (isRetryable(attempt, null, result)) {
                      _context104.n = 4;
                      break;
                    }
                    accept(result);
                    return _context104.a(2);
                  case 4:
                    _context104.n = 6;
                    break;
                  case 5:
                    _context104.p = 5;
                    _t90 = _context104.v;
                    if (isRetryable(attempt, _t90)) {
                      _context104.n = 6;
                      break;
                    }
                    reject(_t90);
                    return _context104.a(2);
                  case 6:
                    attempt++;
                    _context104.n = 1;
                    break;
                  case 7:
                    return _context104.a(2);
                }
              }, _callee103, null, [[2, 5]]);
            }))();
          });
          return promise;
        }
        function dec2hex(dec) {
          return ('0' + dec.toString(16)).substr(-2);
        }
        // Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs
        function generatePKCEVerifier() {
          var verifierLength = 56;
          var array = new Uint32Array(verifierLength);
          if (typeof crypto === 'undefined') {
            var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            var charSetLen = charSet.length;
            var verifier = '';
            for (var i = 0; i < verifierLength; i++) {
              verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
            }
            return verifier;
          }
          crypto.getRandomValues(array);
          return Array.from(array, dec2hex).join('');
        }
        function sha256(_x179) {
          return _sha.apply(this, arguments);
        }
        function _sha() {
          _sha = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee268(randomString) {
            var encoder, encodedData, hash, bytes;
            return _regenerator().w(function (_context269) {
              while (1) switch (_context269.n) {
                case 0:
                  encoder = new TextEncoder();
                  encodedData = encoder.encode(randomString);
                  _context269.n = 1;
                  return crypto.subtle.digest('SHA-256', encodedData);
                case 1:
                  hash = _context269.v;
                  bytes = new Uint8Array(hash);
                  return _context269.a(2, Array.from(bytes).map(function (c) {
                    return String.fromCharCode(c);
                  }).join(''));
              }
            }, _callee268);
          }));
          return _sha.apply(this, arguments);
        }
        function generatePKCEChallenge(_x180) {
          return _generatePKCEChallenge.apply(this, arguments);
        }
        function _generatePKCEChallenge() {
          _generatePKCEChallenge = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee269(verifier) {
            var hasCryptoSupport, hashed;
            return _regenerator().w(function (_context270) {
              while (1) switch (_context270.n) {
                case 0:
                  hasCryptoSupport = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined' && typeof TextEncoder !== 'undefined';
                  if (hasCryptoSupport) {
                    _context270.n = 1;
                    break;
                  }
                  console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');
                  return _context270.a(2, verifier);
                case 1:
                  _context270.n = 2;
                  return sha256(verifier);
                case 2:
                  hashed = _context270.v;
                  return _context270.a(2, btoa(hashed).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''));
              }
            }, _callee269);
          }));
          return _generatePKCEChallenge.apply(this, arguments);
        }
        function getCodeChallengeAndMethod(_x181, _x182) {
          return _getCodeChallengeAndMethod.apply(this, arguments);
        }
        /** Parses the API version which is 2YYY-MM-DD. */
        function _getCodeChallengeAndMethod() {
          _getCodeChallengeAndMethod = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee270(storage, storageKey) {
            var isPasswordRecovery,
              codeVerifier,
              storedCodeVerifier,
              codeChallenge,
              codeChallengeMethod,
              _args270 = arguments;
            return _regenerator().w(function (_context271) {
              while (1) switch (_context271.n) {
                case 0:
                  isPasswordRecovery = _args270.length > 2 && _args270[2] !== undefined ? _args270[2] : false;
                  codeVerifier = generatePKCEVerifier();
                  storedCodeVerifier = codeVerifier;
                  if (isPasswordRecovery) {
                    storedCodeVerifier += '/PASSWORD_RECOVERY';
                  }
                  _context271.n = 1;
                  return setItemAsync(storage, "".concat(storageKey, "-code-verifier"), storedCodeVerifier);
                case 1:
                  _context271.n = 2;
                  return generatePKCEChallenge(codeVerifier);
                case 2:
                  codeChallenge = _context271.v;
                  codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
                  return _context271.a(2, [codeChallenge, codeChallengeMethod]);
              }
            }, _callee270);
          }));
          return _getCodeChallengeAndMethod.apply(this, arguments);
        }
        var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
        function parseResponseAPIVersion(response) {
          var apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
          if (!apiVersion) {
            return null;
          }
          if (!apiVersion.match(API_VERSION_REGEX)) {
            return null;
          }
          try {
            var date = new Date("".concat(apiVersion, "T00:00:00.0Z"));
            return date;
          } catch (e) {
            return null;
          }
        }
        function validateExp(exp) {
          if (!exp) {
            throw new Error('Missing exp claim');
          }
          var timeNow = Math.floor(Date.now() / 1000);
          if (exp <= timeNow) {
            throw new Error('JWT has expired');
          }
        }
        function getAlgorithm(alg) {
          switch (alg) {
            case 'RS256':
              return {
                name: 'RSASSA-PKCS1-v1_5',
                hash: {
                  name: 'SHA-256'
                }
              };
            case 'ES256':
              return {
                name: 'ECDSA',
                namedCurve: 'P-256',
                hash: {
                  name: 'SHA-256'
                }
              };
            default:
              throw new Error('Invalid alg claim');
          }
        }
        var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
        function validateUUID(str) {
          if (!UUID_REGEX.test(str)) {
            throw new Error('@supabase/auth-js: Expected parameter to be UUID but is not');
          }
        }
        function userNotAvailableProxy() {
          var proxyTarget = {};
          return new Proxy(proxyTarget, {
            get: function get(target, prop) {
              if (prop === '__isUserNotAvailableProxy') {
                return true;
              }
              // Preventative check for common problematic symbols during cloning/inspection
              // These symbols might be accessed by structuredClone or other internal mechanisms.
              if (_typeof2(prop) === 'symbol') {
                var sProp = prop.toString();
                if (sProp === 'Symbol(Symbol.toPrimitive)' || sProp === 'Symbol(Symbol.toStringTag)' || sProp === 'Symbol(util.inspect.custom)') {
                  // Node.js util.inspect
                  return undefined;
                }
              }
              throw new Error("@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"".concat(prop, "\" property of the session object is not supported. Please use getUser() instead."));
            },
            set: function set(_target, prop) {
              throw new Error("@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"".concat(prop, "\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate."));
            },
            deleteProperty: function deleteProperty(_target, prop) {
              throw new Error("@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"".concat(prop, "\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate."));
            }
          });
        }
        /**
         * Creates a proxy around a user object that warns when properties are accessed on the server.
         * This is used to alert developers that using user data from getSession() on the server is insecure.
         *
         * @param user The actual user object to wrap
         * @param suppressWarningRef An object with a 'value' property that controls warning suppression
         * @returns A proxied user object that warns on property access
         */
        function insecureUserWarningProxy(user, suppressWarningRef) {
          return new Proxy(user, {
            get: function get(target, prop, receiver) {
              // Allow internal checks without warning
              if (prop === '__isInsecureUserWarningProxy') {
                return true;
              }
              // Preventative check for common problematic symbols during cloning/inspection
              // These symbols might be accessed by structuredClone or other internal mechanisms
              if (_typeof2(prop) === 'symbol') {
                var sProp = prop.toString();
                if (sProp === 'Symbol(Symbol.toPrimitive)' || sProp === 'Symbol(Symbol.toStringTag)' || sProp === 'Symbol(util.inspect.custom)' || sProp === 'Symbol(nodejs.util.inspect.custom)') {
                  // Return the actual value for these symbols to allow proper inspection
                  return Reflect.get(target, prop, receiver);
                }
              }
              // Emit warning on first property access
              if (!suppressWarningRef.value && typeof prop === 'string') {
                console.warn('Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.');
                suppressWarningRef.value = true;
              }
              return Reflect.get(target, prop, receiver);
            }
          });
        }
        /**
         * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).
         * Note: Only works for JSON-safe data.
         */
        function deepClone(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        var _getErrorMessage = function _getErrorMessage(err) {
          return err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
        };
        var NETWORK_ERROR_CODES = [502, 503, 504];
        function handleError(_x183) {
          return _handleError.apply(this, arguments);
        }
        function _handleError() {
          _handleError = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee271(error) {
            var _a, data, errorCode, responseAPIVersion, _t166;
            return _regenerator().w(function (_context272) {
              while (1) switch (_context272.p = _context272.n) {
                case 0:
                  if (looksLikeFetchResponse(error)) {
                    _context272.n = 1;
                    break;
                  }
                  throw new AuthRetryableFetchError(_getErrorMessage(error), 0);
                case 1:
                  if (!NETWORK_ERROR_CODES.includes(error.status)) {
                    _context272.n = 2;
                    break;
                  }
                  throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);
                case 2:
                  _context272.p = 2;
                  _context272.n = 3;
                  return error.json();
                case 3:
                  data = _context272.v;
                  _context272.n = 5;
                  break;
                case 4:
                  _context272.p = 4;
                  _t166 = _context272.v;
                  throw new AuthUnknownError(_getErrorMessage(_t166), _t166);
                case 5:
                  errorCode = undefined;
                  responseAPIVersion = parseResponseAPIVersion(error);
                  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS['2024-01-01'].timestamp && _typeof2(data) === 'object' && data && typeof data.code === 'string') {
                    errorCode = data.code;
                  } else if (_typeof2(data) === 'object' && data && typeof data.error_code === 'string') {
                    errorCode = data.error_code;
                  }
                  if (errorCode) {
                    _context272.n = 7;
                    break;
                  }
                  if (!(_typeof2(data) === 'object' && data && _typeof2(data.weak_password) === 'object' && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce(function (a, i) {
                    return a && typeof i === 'string';
                  }, true))) {
                    _context272.n = 6;
                    break;
                  }
                  throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
                case 6:
                  _context272.n = 9;
                  break;
                case 7:
                  if (!(errorCode === 'weak_password')) {
                    _context272.n = 8;
                    break;
                  }
                  throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
                case 8:
                  if (!(errorCode === 'session_not_found')) {
                    _context272.n = 9;
                    break;
                  }
                  throw new AuthSessionMissingError();
                case 9:
                  throw new AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
                case 10:
                  return _context272.a(2);
              }
            }, _callee271, null, [[2, 4]]);
          }));
          return _handleError.apply(this, arguments);
        }
        var _getRequestParams = function _getRequestParams(method, options, parameters, body) {
          var params = {
            method: method,
            headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
          };
          if (method === 'GET') {
            return params;
          }
          params.headers = Object.assign({
            'Content-Type': 'application/json;charset=UTF-8'
          }, options === null || options === void 0 ? void 0 : options.headers);
          params.body = JSON.stringify(body);
          return Object.assign(Object.assign({}, params), parameters);
        };
        function _request(_x184, _x185, _x186, _x187) {
          return _request2.apply(this, arguments);
        }
        function _request2() {
          _request2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee272(fetcher, method, url, options) {
            var _a, headers, qs, queryString, data;
            return _regenerator().w(function (_context273) {
              while (1) switch (_context273.n) {
                case 0:
                  headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
                  if (!headers[API_VERSION_HEADER_NAME]) {
                    headers[API_VERSION_HEADER_NAME] = API_VERSIONS['2024-01-01'].name;
                  }
                  if (options === null || options === void 0 ? void 0 : options.jwt) {
                    headers['Authorization'] = "Bearer ".concat(options.jwt);
                  }
                  qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
                  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
                    qs['redirect_to'] = options.redirectTo;
                  }
                  queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';
                  _context273.n = 1;
                  return _handleRequest(fetcher, method, url + queryString, {
                    headers: headers,
                    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
                  }, {}, options === null || options === void 0 ? void 0 : options.body);
                case 1:
                  data = _context273.v;
                  return _context273.a(2, (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {
                    data: Object.assign({}, data),
                    error: null
                  });
              }
            }, _callee272);
          }));
          return _request2.apply(this, arguments);
        }
        function _handleRequest(_x188, _x189, _x190, _x191, _x192, _x193) {
          return _handleRequest2.apply(this, arguments);
        }
        function _handleRequest2() {
          _handleRequest2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee273(fetcher, method, url, options, parameters, body) {
            var requestParams, result, _t167, _t168;
            return _regenerator().w(function (_context274) {
              while (1) switch (_context274.p = _context274.n) {
                case 0:
                  requestParams = _getRequestParams(method, options, parameters, body);
                  _context274.p = 1;
                  _context274.n = 2;
                  return fetcher(url, Object.assign({}, requestParams));
                case 2:
                  result = _context274.v;
                  _context274.n = 4;
                  break;
                case 3:
                  _context274.p = 3;
                  _t167 = _context274.v;
                  console.error(_t167);
                  // fetch failed, likely due to a network or CORS error
                  throw new AuthRetryableFetchError(_getErrorMessage(_t167), 0);
                case 4:
                  if (result.ok) {
                    _context274.n = 5;
                    break;
                  }
                  _context274.n = 5;
                  return handleError(result);
                case 5:
                  if (!(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
                    _context274.n = 6;
                    break;
                  }
                  return _context274.a(2, result);
                case 6:
                  _context274.p = 6;
                  _context274.n = 7;
                  return result.json();
                case 7:
                  return _context274.a(2, _context274.v);
                case 8:
                  _context274.p = 8;
                  _t168 = _context274.v;
                  _context274.n = 9;
                  return handleError(_t168);
                case 9:
                  return _context274.a(2);
              }
            }, _callee273, null, [[6, 8], [1, 3]]);
          }));
          return _handleRequest2.apply(this, arguments);
        }
        function _sessionResponse(data) {
          var _a;
          var session = null;
          if (hasSession(data)) {
            session = Object.assign({}, data);
            if (!data.expires_at) {
              session.expires_at = expiresAt(data.expires_in);
            }
          }
          var user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
          return {
            data: {
              session: session,
              user: user
            },
            error: null
          };
        }
        function _sessionResponsePassword(data) {
          var response = _sessionResponse(data);
          if (!response.error && data.weak_password && _typeof2(data.weak_password) === 'object' && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === 'string' && data.weak_password.reasons.reduce(function (a, i) {
            return a && typeof i === 'string';
          }, true)) {
            response.data.weak_password = data.weak_password;
          }
          return response;
        }
        function _userResponse(data) {
          var _a;
          var user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
          return {
            data: {
              user: user
            },
            error: null
          };
        }
        function _ssoResponse(data) {
          return {
            data: data,
            error: null
          };
        }
        function _generateLinkResponse(data) {
          var action_link = data.action_link,
            email_otp = data.email_otp,
            hashed_token = data.hashed_token,
            redirect_to = data.redirect_to,
            verification_type = data.verification_type,
            rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
          var properties = {
            action_link: action_link,
            email_otp: email_otp,
            hashed_token: hashed_token,
            redirect_to: redirect_to,
            verification_type: verification_type
          };
          var user = Object.assign({}, rest);
          return {
            data: {
              properties: properties,
              user: user
            },
            error: null
          };
        }
        function _noResolveJsonResponse(data) {
          return data;
        }
        /**
         * hasSession checks if the response object contains a valid session
         * @param data A response object
         * @returns true if a session is in the response
         */
        function hasSession(data) {
          return data.access_token && data.refresh_token && data.expires_in;
        }
        var SIGN_OUT_SCOPES = ['global', 'local', 'others'];
        var GoTrueAdminApi = /*#__PURE__*/function () {
          /**
           * Creates an admin API client that can be used to manage users and OAuth clients.
           *
           * @example
           * ```ts
           * import { GoTrueAdminApi } from '@supabase/auth-js'
           *
           * const admin = new GoTrueAdminApi({
           *   url: 'https://xyzcompany.supabase.co/auth/v1',
           *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },
           * })
           * ```
           */
          function GoTrueAdminApi(_ref210) {
            var _ref210$url = _ref210.url,
              url = _ref210$url === void 0 ? "" : _ref210$url,
              _ref210$headers = _ref210.headers,
              headers = _ref210$headers === void 0 ? {} : _ref210$headers,
              fetch = _ref210.fetch;
            _classCallCheck(this, GoTrueAdminApi);
            this.url = url;
            this.headers = headers;
            this.fetch = resolveFetch$1(fetch);
            this.mfa = {
              listFactors: this._listFactors.bind(this),
              deleteFactor: this._deleteFactor.bind(this)
            };
            this.oauth = {
              listClients: this._listOAuthClients.bind(this),
              createClient: this._createOAuthClient.bind(this),
              getClient: this._getOAuthClient.bind(this),
              updateClient: this._updateOAuthClient.bind(this),
              deleteClient: this._deleteOAuthClient.bind(this),
              regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
            };
          }
          /**
           * Removes a logged-in session.
           * @param jwt A valid, logged-in JWT.
           * @param scope The logout sope.
           */
          return _createClass(GoTrueAdminApi, [{
            key: "signOut",
            value: (function () {
              var _signOut = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee104(jwt) {
                var scope,
                  _args104 = arguments,
                  _t91;
                return _regenerator().w(function (_context105) {
                  while (1) switch (_context105.p = _context105.n) {
                    case 0:
                      scope = _args104.length > 1 && _args104[1] !== undefined ? _args104[1] : SIGN_OUT_SCOPES[0];
                      if (!(SIGN_OUT_SCOPES.indexOf(scope) < 0)) {
                        _context105.n = 1;
                        break;
                      }
                      throw new Error("@supabase/auth-js: Parameter scope must be one of ".concat(SIGN_OUT_SCOPES.join(", ")));
                    case 1:
                      _context105.p = 1;
                      _context105.n = 2;
                      return _request(this.fetch, "POST", "".concat(this.url, "/logout?scope=").concat(scope), {
                        headers: this.headers,
                        jwt: jwt,
                        noResolveJson: true
                      });
                    case 2:
                      return _context105.a(2, {
                        data: null,
                        error: null
                      });
                    case 3:
                      _context105.p = 3;
                      _t91 = _context105.v;
                      if (!isAuthError(_t91)) {
                        _context105.n = 4;
                        break;
                      }
                      return _context105.a(2, {
                        data: null,
                        error: _t91
                      });
                    case 4:
                      throw _t91;
                    case 5:
                      return _context105.a(2);
                  }
                }, _callee104, this, [[1, 3]]);
              }));
              function signOut(_x194) {
                return _signOut.apply(this, arguments);
              }
              return signOut;
            }()
            /**
             * Sends an invite link to an email address.
             * @param email The email address of the user.
             * @param options Additional options to be included when inviting.
             */
            )
          }, {
            key: "inviteUserByEmail",
            value: (function () {
              var _inviteUserByEmail = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee105(email) {
                var options,
                  _args105 = arguments,
                  _t92;
                return _regenerator().w(function (_context106) {
                  while (1) switch (_context106.p = _context106.n) {
                    case 0:
                      options = _args105.length > 1 && _args105[1] !== undefined ? _args105[1] : {};
                      _context106.p = 1;
                      _context106.n = 2;
                      return _request(this.fetch, "POST", "".concat(this.url, "/invite"), {
                        body: {
                          email: email,
                          data: options.data
                        },
                        headers: this.headers,
                        redirectTo: options.redirectTo,
                        xform: _userResponse
                      });
                    case 2:
                      return _context106.a(2, _context106.v);
                    case 3:
                      _context106.p = 3;
                      _t92 = _context106.v;
                      if (!isAuthError(_t92)) {
                        _context106.n = 4;
                        break;
                      }
                      return _context106.a(2, {
                        data: {
                          user: null
                        },
                        error: _t92
                      });
                    case 4:
                      throw _t92;
                    case 5:
                      return _context106.a(2);
                  }
                }, _callee105, this, [[1, 3]]);
              }));
              function inviteUserByEmail(_x195) {
                return _inviteUserByEmail.apply(this, arguments);
              }
              return inviteUserByEmail;
            }()
            /**
             * Generates email links and OTPs to be sent via a custom email provider.
             * @param email The user's email.
             * @param options.password User password. For signup only.
             * @param options.data Optional user metadata. For signup only.
             * @param options.redirectTo The redirect url which should be appended to the generated link
             */
            )
          }, {
            key: "generateLink",
            value: (function () {
              var _generateLink = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee106(params) {
                var options, rest, body, _t93;
                return _regenerator().w(function (_context107) {
                  while (1) switch (_context107.p = _context107.n) {
                    case 0:
                      _context107.p = 0;
                      options = params.options, rest = __rest(params, ["options"]);
                      body = Object.assign(Object.assign({}, rest), options);
                      if ("newEmail" in rest) {
                        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
                        delete body["newEmail"];
                      }
                      _context107.n = 1;
                      return _request(this.fetch, "POST", "".concat(this.url, "/admin/generate_link"), {
                        body: body,
                        headers: this.headers,
                        xform: _generateLinkResponse,
                        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
                      });
                    case 1:
                      return _context107.a(2, _context107.v);
                    case 2:
                      _context107.p = 2;
                      _t93 = _context107.v;
                      if (!isAuthError(_t93)) {
                        _context107.n = 3;
                        break;
                      }
                      return _context107.a(2, {
                        data: {
                          properties: null,
                          user: null
                        },
                        error: _t93
                      });
                    case 3:
                      throw _t93;
                    case 4:
                      return _context107.a(2);
                  }
                }, _callee106, this, [[0, 2]]);
              }));
              function generateLink(_x196) {
                return _generateLink.apply(this, arguments);
              }
              return generateLink;
            }() // User Admin API
            /**
             * Creates a new user.
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "createUser",
            value: function () {
              var _createUser = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee107(attributes) {
                var _t94;
                return _regenerator().w(function (_context108) {
                  while (1) switch (_context108.p = _context108.n) {
                    case 0:
                      _context108.p = 0;
                      _context108.n = 1;
                      return _request(this.fetch, "POST", "".concat(this.url, "/admin/users"), {
                        body: attributes,
                        headers: this.headers,
                        xform: _userResponse
                      });
                    case 1:
                      return _context108.a(2, _context108.v);
                    case 2:
                      _context108.p = 2;
                      _t94 = _context108.v;
                      if (!isAuthError(_t94)) {
                        _context108.n = 3;
                        break;
                      }
                      return _context108.a(2, {
                        data: {
                          user: null
                        },
                        error: _t94
                      });
                    case 3:
                      throw _t94;
                    case 4:
                      return _context108.a(2);
                  }
                }, _callee107, this, [[0, 2]]);
              }));
              function createUser(_x197) {
                return _createUser.apply(this, arguments);
              }
              return createUser;
            }()
            /**
             * Get a list of users.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
             */
          }, {
            key: "listUsers",
            value: (function () {
              var _listUsers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee108(params) {
                var _a, _b, _c, _d, _e, _f, _g, pagination, response, users, total, links, _t95;
                return _regenerator().w(function (_context109) {
                  while (1) switch (_context109.p = _context109.n) {
                    case 0:
                      _context109.p = 0;
                      pagination = {
                        nextPage: null,
                        lastPage: 0,
                        total: 0
                      };
                      _context109.n = 1;
                      return _request(this.fetch, "GET", "".concat(this.url, "/admin/users"), {
                        headers: this.headers,
                        noResolveJson: true,
                        query: {
                          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
                          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
                        },
                        xform: _noResolveJsonResponse
                      });
                    case 1:
                      response = _context109.v;
                      if (!response.error) {
                        _context109.n = 2;
                        break;
                      }
                      throw response.error;
                    case 2:
                      _context109.n = 3;
                      return response.json();
                    case 3:
                      users = _context109.v;
                      total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
                      links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
                      if (links.length > 0) {
                        links.forEach(function (link) {
                          var page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
                          var rel = JSON.parse(link.split(";")[1].split("=")[1]);
                          pagination["".concat(rel, "Page")] = page;
                        });
                        pagination.total = parseInt(total);
                      }
                      return _context109.a(2, {
                        data: Object.assign(Object.assign({}, users), pagination),
                        error: null
                      });
                    case 4:
                      _context109.p = 4;
                      _t95 = _context109.v;
                      if (!isAuthError(_t95)) {
                        _context109.n = 5;
                        break;
                      }
                      return _context109.a(2, {
                        data: {
                          users: []
                        },
                        error: _t95
                      });
                    case 5:
                      throw _t95;
                    case 6:
                      return _context109.a(2);
                  }
                }, _callee108, this, [[0, 4]]);
              }));
              function listUsers(_x198) {
                return _listUsers.apply(this, arguments);
              }
              return listUsers;
            }()
            /**
             * Get user by id.
             *
             * @param uid The user's unique identifier
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "getUserById",
            value: (function () {
              var _getUserById = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee109(uid) {
                var _t96;
                return _regenerator().w(function (_context110) {
                  while (1) switch (_context110.p = _context110.n) {
                    case 0:
                      validateUUID(uid);
                      _context110.p = 1;
                      _context110.n = 2;
                      return _request(this.fetch, "GET", "".concat(this.url, "/admin/users/").concat(uid), {
                        headers: this.headers,
                        xform: _userResponse
                      });
                    case 2:
                      return _context110.a(2, _context110.v);
                    case 3:
                      _context110.p = 3;
                      _t96 = _context110.v;
                      if (!isAuthError(_t96)) {
                        _context110.n = 4;
                        break;
                      }
                      return _context110.a(2, {
                        data: {
                          user: null
                        },
                        error: _t96
                      });
                    case 4:
                      throw _t96;
                    case 5:
                      return _context110.a(2);
                  }
                }, _callee109, this, [[1, 3]]);
              }));
              function getUserById(_x199) {
                return _getUserById.apply(this, arguments);
              }
              return getUserById;
            }()
            /**
             * Updates the user data.
             *
             * @param attributes The data you want to update.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "updateUserById",
            value: (function () {
              var _updateUserById = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee110(uid, attributes) {
                var _t97;
                return _regenerator().w(function (_context111) {
                  while (1) switch (_context111.p = _context111.n) {
                    case 0:
                      validateUUID(uid);
                      _context111.p = 1;
                      _context111.n = 2;
                      return _request(this.fetch, "PUT", "".concat(this.url, "/admin/users/").concat(uid), {
                        body: attributes,
                        headers: this.headers,
                        xform: _userResponse
                      });
                    case 2:
                      return _context111.a(2, _context111.v);
                    case 3:
                      _context111.p = 3;
                      _t97 = _context111.v;
                      if (!isAuthError(_t97)) {
                        _context111.n = 4;
                        break;
                      }
                      return _context111.a(2, {
                        data: {
                          user: null
                        },
                        error: _t97
                      });
                    case 4:
                      throw _t97;
                    case 5:
                      return _context111.a(2);
                  }
                }, _callee110, this, [[1, 3]]);
              }));
              function updateUserById(_x200, _x201) {
                return _updateUserById.apply(this, arguments);
              }
              return updateUserById;
            }()
            /**
             * Delete a user. Requires a `service_role` key.
             *
             * @param id The user id you want to remove.
             * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
             * Defaults to false for backward compatibility.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "deleteUser",
            value: (function () {
              var _deleteUser = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee111(id) {
                var shouldSoftDelete,
                  _args111 = arguments,
                  _t98;
                return _regenerator().w(function (_context112) {
                  while (1) switch (_context112.p = _context112.n) {
                    case 0:
                      shouldSoftDelete = _args111.length > 1 && _args111[1] !== undefined ? _args111[1] : false;
                      validateUUID(id);
                      _context112.p = 1;
                      _context112.n = 2;
                      return _request(this.fetch, "DELETE", "".concat(this.url, "/admin/users/").concat(id), {
                        headers: this.headers,
                        body: {
                          should_soft_delete: shouldSoftDelete
                        },
                        xform: _userResponse
                      });
                    case 2:
                      return _context112.a(2, _context112.v);
                    case 3:
                      _context112.p = 3;
                      _t98 = _context112.v;
                      if (!isAuthError(_t98)) {
                        _context112.n = 4;
                        break;
                      }
                      return _context112.a(2, {
                        data: {
                          user: null
                        },
                        error: _t98
                      });
                    case 4:
                      throw _t98;
                    case 5:
                      return _context112.a(2);
                  }
                }, _callee111, this, [[1, 3]]);
              }));
              function deleteUser(_x202) {
                return _deleteUser.apply(this, arguments);
              }
              return deleteUser;
            }())
          }, {
            key: "_listFactors",
            value: function () {
              var _listFactors2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee112(params) {
                var _yield$_request, data, error, _t99;
                return _regenerator().w(function (_context113) {
                  while (1) switch (_context113.p = _context113.n) {
                    case 0:
                      validateUUID(params.userId);
                      _context113.p = 1;
                      _context113.n = 2;
                      return _request(this.fetch, "GET", "".concat(this.url, "/admin/users/").concat(params.userId, "/factors"), {
                        headers: this.headers,
                        xform: function xform(factors) {
                          return {
                            data: {
                              factors: factors
                            },
                            error: null
                          };
                        }
                      });
                    case 2:
                      _yield$_request = _context113.v;
                      data = _yield$_request.data;
                      error = _yield$_request.error;
                      return _context113.a(2, {
                        data: data,
                        error: error
                      });
                    case 3:
                      _context113.p = 3;
                      _t99 = _context113.v;
                      if (!isAuthError(_t99)) {
                        _context113.n = 4;
                        break;
                      }
                      return _context113.a(2, {
                        data: null,
                        error: _t99
                      });
                    case 4:
                      throw _t99;
                    case 5:
                      return _context113.a(2);
                  }
                }, _callee112, this, [[1, 3]]);
              }));
              function _listFactors(_x203) {
                return _listFactors2.apply(this, arguments);
              }
              return _listFactors;
            }()
          }, {
            key: "_deleteFactor",
            value: function () {
              var _deleteFactor2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee113(params) {
                var data, _t100;
                return _regenerator().w(function (_context114) {
                  while (1) switch (_context114.p = _context114.n) {
                    case 0:
                      validateUUID(params.userId);
                      validateUUID(params.id);
                      _context114.p = 1;
                      _context114.n = 2;
                      return _request(this.fetch, "DELETE", "".concat(this.url, "/admin/users/").concat(params.userId, "/factors/").concat(params.id), {
                        headers: this.headers
                      });
                    case 2:
                      data = _context114.v;
                      return _context114.a(2, {
                        data: data,
                        error: null
                      });
                    case 3:
                      _context114.p = 3;
                      _t100 = _context114.v;
                      if (!isAuthError(_t100)) {
                        _context114.n = 4;
                        break;
                      }
                      return _context114.a(2, {
                        data: null,
                        error: _t100
                      });
                    case 4:
                      throw _t100;
                    case 5:
                      return _context114.a(2);
                  }
                }, _callee113, this, [[1, 3]]);
              }));
              function _deleteFactor(_x204) {
                return _deleteFactor2.apply(this, arguments);
              }
              return _deleteFactor;
            }()
            /**
             * Lists all OAuth clients with optional pagination.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
          }, {
            key: "_listOAuthClients",
            value: (function () {
              var _listOAuthClients2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee114(params) {
                var _a, _b, _c, _d, _e, _f, _g, pagination, response, clients, total, links, _t101;
                return _regenerator().w(function (_context115) {
                  while (1) switch (_context115.p = _context115.n) {
                    case 0:
                      _context115.p = 0;
                      pagination = {
                        nextPage: null,
                        lastPage: 0,
                        total: 0
                      };
                      _context115.n = 1;
                      return _request(this.fetch, "GET", "".concat(this.url, "/admin/oauth/clients"), {
                        headers: this.headers,
                        noResolveJson: true,
                        query: {
                          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
                          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
                        },
                        xform: _noResolveJsonResponse
                      });
                    case 1:
                      response = _context115.v;
                      if (!response.error) {
                        _context115.n = 2;
                        break;
                      }
                      throw response.error;
                    case 2:
                      _context115.n = 3;
                      return response.json();
                    case 3:
                      clients = _context115.v;
                      total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
                      links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
                      if (links.length > 0) {
                        links.forEach(function (link) {
                          var page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
                          var rel = JSON.parse(link.split(";")[1].split("=")[1]);
                          pagination["".concat(rel, "Page")] = page;
                        });
                        pagination.total = parseInt(total);
                      }
                      return _context115.a(2, {
                        data: Object.assign(Object.assign({}, clients), pagination),
                        error: null
                      });
                    case 4:
                      _context115.p = 4;
                      _t101 = _context115.v;
                      if (!isAuthError(_t101)) {
                        _context115.n = 5;
                        break;
                      }
                      return _context115.a(2, {
                        data: {
                          clients: []
                        },
                        error: _t101
                      });
                    case 5:
                      throw _t101;
                    case 6:
                      return _context115.a(2);
                  }
                }, _callee114, this, [[0, 4]]);
              }));
              function _listOAuthClients(_x205) {
                return _listOAuthClients2.apply(this, arguments);
              }
              return _listOAuthClients;
            }()
            /**
             * Creates a new OAuth client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "_createOAuthClient",
            value: (function () {
              var _createOAuthClient2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee115(params) {
                var _t102;
                return _regenerator().w(function (_context116) {
                  while (1) switch (_context116.p = _context116.n) {
                    case 0:
                      _context116.p = 0;
                      _context116.n = 1;
                      return _request(this.fetch, "POST", "".concat(this.url, "/admin/oauth/clients"), {
                        body: params,
                        headers: this.headers,
                        xform: function xform(client) {
                          return {
                            data: client,
                            error: null
                          };
                        }
                      });
                    case 1:
                      return _context116.a(2, _context116.v);
                    case 2:
                      _context116.p = 2;
                      _t102 = _context116.v;
                      if (!isAuthError(_t102)) {
                        _context116.n = 3;
                        break;
                      }
                      return _context116.a(2, {
                        data: null,
                        error: _t102
                      });
                    case 3:
                      throw _t102;
                    case 4:
                      return _context116.a(2);
                  }
                }, _callee115, this, [[0, 2]]);
              }));
              function _createOAuthClient(_x206) {
                return _createOAuthClient2.apply(this, arguments);
              }
              return _createOAuthClient;
            }()
            /**
             * Gets details of a specific OAuth client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "_getOAuthClient",
            value: (function () {
              var _getOAuthClient2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee116(clientId) {
                var _t103;
                return _regenerator().w(function (_context117) {
                  while (1) switch (_context117.p = _context117.n) {
                    case 0:
                      _context117.p = 0;
                      _context117.n = 1;
                      return _request(this.fetch, "GET", "".concat(this.url, "/admin/oauth/clients/").concat(clientId), {
                        headers: this.headers,
                        xform: function xform(client) {
                          return {
                            data: client,
                            error: null
                          };
                        }
                      });
                    case 1:
                      return _context117.a(2, _context117.v);
                    case 2:
                      _context117.p = 2;
                      _t103 = _context117.v;
                      if (!isAuthError(_t103)) {
                        _context117.n = 3;
                        break;
                      }
                      return _context117.a(2, {
                        data: null,
                        error: _t103
                      });
                    case 3:
                      throw _t103;
                    case 4:
                      return _context117.a(2);
                  }
                }, _callee116, this, [[0, 2]]);
              }));
              function _getOAuthClient(_x207) {
                return _getOAuthClient2.apply(this, arguments);
              }
              return _getOAuthClient;
            }()
            /**
             * Updates an existing OAuth client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "_updateOAuthClient",
            value: (function () {
              var _updateOAuthClient2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee117(clientId, params) {
                var _t104;
                return _regenerator().w(function (_context118) {
                  while (1) switch (_context118.p = _context118.n) {
                    case 0:
                      _context118.p = 0;
                      _context118.n = 1;
                      return _request(this.fetch, "PUT", "".concat(this.url, "/admin/oauth/clients/").concat(clientId), {
                        body: params,
                        headers: this.headers,
                        xform: function xform(client) {
                          return {
                            data: client,
                            error: null
                          };
                        }
                      });
                    case 1:
                      return _context118.a(2, _context118.v);
                    case 2:
                      _context118.p = 2;
                      _t104 = _context118.v;
                      if (!isAuthError(_t104)) {
                        _context118.n = 3;
                        break;
                      }
                      return _context118.a(2, {
                        data: null,
                        error: _t104
                      });
                    case 3:
                      throw _t104;
                    case 4:
                      return _context118.a(2);
                  }
                }, _callee117, this, [[0, 2]]);
              }));
              function _updateOAuthClient(_x208, _x209) {
                return _updateOAuthClient2.apply(this, arguments);
              }
              return _updateOAuthClient;
            }()
            /**
             * Deletes an OAuth client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "_deleteOAuthClient",
            value: (function () {
              var _deleteOAuthClient2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee118(clientId) {
                var _t105;
                return _regenerator().w(function (_context119) {
                  while (1) switch (_context119.p = _context119.n) {
                    case 0:
                      _context119.p = 0;
                      _context119.n = 1;
                      return _request(this.fetch, "DELETE", "".concat(this.url, "/admin/oauth/clients/").concat(clientId), {
                        headers: this.headers,
                        noResolveJson: true
                      });
                    case 1:
                      return _context119.a(2, {
                        data: null,
                        error: null
                      });
                    case 2:
                      _context119.p = 2;
                      _t105 = _context119.v;
                      if (!isAuthError(_t105)) {
                        _context119.n = 3;
                        break;
                      }
                      return _context119.a(2, {
                        data: null,
                        error: _t105
                      });
                    case 3:
                      throw _t105;
                    case 4:
                      return _context119.a(2);
                  }
                }, _callee118, this, [[0, 2]]);
              }));
              function _deleteOAuthClient(_x210) {
                return _deleteOAuthClient2.apply(this, arguments);
              }
              return _deleteOAuthClient;
            }()
            /**
             * Regenerates the secret for an OAuth client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * This function should only be called on a server. Never expose your `service_role` key in the browser.
             */
            )
          }, {
            key: "_regenerateOAuthClientSecret",
            value: (function () {
              var _regenerateOAuthClientSecret2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee119(clientId) {
                var _t106;
                return _regenerator().w(function (_context120) {
                  while (1) switch (_context120.p = _context120.n) {
                    case 0:
                      _context120.p = 0;
                      _context120.n = 1;
                      return _request(this.fetch, "POST", "".concat(this.url, "/admin/oauth/clients/").concat(clientId, "/regenerate_secret"), {
                        headers: this.headers,
                        xform: function xform(client) {
                          return {
                            data: client,
                            error: null
                          };
                        }
                      });
                    case 1:
                      return _context120.a(2, _context120.v);
                    case 2:
                      _context120.p = 2;
                      _t106 = _context120.v;
                      if (!isAuthError(_t106)) {
                        _context120.n = 3;
                        break;
                      }
                      return _context120.a(2, {
                        data: null,
                        error: _t106
                      });
                    case 3:
                      throw _t106;
                    case 4:
                      return _context120.a(2);
                  }
                }, _callee119, this, [[0, 2]]);
              }));
              function _regenerateOAuthClientSecret(_x211) {
                return _regenerateOAuthClientSecret2.apply(this, arguments);
              }
              return _regenerateOAuthClientSecret;
            }())
          }]);
        }();
        /**
         * Returns a localStorage-like object that stores the key-value pairs in
         * memory.
         */
        function memoryLocalStorageAdapter() {
          var store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return {
            getItem: function getItem(key) {
              return store[key] || null;
            },
            setItem: function setItem(key, value) {
              store[key] = value;
            },
            removeItem: function removeItem(key) {
              delete store[key];
            }
          };
        }

        /**
         * @experimental
         */
        var internals = {
          /**
           * @experimental
           */
          debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')
        };
        /**
         * An error thrown when a lock cannot be acquired after some amount of time.
         *
         * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.
         *
         * @example
         * ```ts
         * import { LockAcquireTimeoutError } from '@supabase/auth-js'
         *
         * class CustomLockError extends LockAcquireTimeoutError {
         *   constructor() {
         *     super('Lock timed out')
         *   }
         * }
         * ```
         */
        var LockAcquireTimeoutError = /*#__PURE__*/function (_Error8) {
          function LockAcquireTimeoutError(message) {
            var _this119;
            _classCallCheck(this, LockAcquireTimeoutError);
            _this119 = _callSuper(this, LockAcquireTimeoutError, [message]);
            _this119.isAcquireTimeout = true;
            return _this119;
          }
          _inherits(LockAcquireTimeoutError, _Error8);
          return _createClass(LockAcquireTimeoutError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        /**
         * Error thrown when the browser Navigator Lock API fails to acquire a lock.
         *
         * @example
         * ```ts
         * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'
         *
         * throw new NavigatorLockAcquireTimeoutError('Lock timed out')
         * ```
         */
        var NavigatorLockAcquireTimeoutError = /*#__PURE__*/function (_LockAcquireTimeoutEr) {
          function NavigatorLockAcquireTimeoutError() {
            _classCallCheck(this, NavigatorLockAcquireTimeoutError);
            return _callSuper(this, NavigatorLockAcquireTimeoutError, arguments);
          }
          _inherits(NavigatorLockAcquireTimeoutError, _LockAcquireTimeoutEr);
          return _createClass(NavigatorLockAcquireTimeoutError);
        }(LockAcquireTimeoutError);
        /**
         * Implements a global exclusive lock using the Navigator LockManager API. It
         * is available on all browsers released after 2022-03-15 with Safari being the
         * last one to release support. If the API is not available, this function will
         * throw. Make sure you check availablility before configuring {@link
         * GoTrueClient}.
         *
         * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`
         * local storage item to `true`.
         *
         * Internals:
         *
         * Since the LockManager API does not preserve stack traces for the async
         * function passed in the `request` method, a trick is used where acquiring the
         * lock releases a previously started promise to run the operation in the `fn`
         * function. The lock waits for that promise to finish (with or without error),
         * while the function will finally wait for the result anyway.
         *
         * @param name Name of the lock to be acquired.
         * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if
         *                       the lock can't be acquired without waiting. If positive, the lock acquire
         *                       will time out after so many milliseconds. An error is
         *                       a timeout if it has `isAcquireTimeout` set to true.
         * @param fn The operation to run once the lock is acquired.
         * @example
         * ```ts
         * await navigatorLock('sync-user', 1000, async () => {
         *   await refreshSession()
         * })
         * ```
         */
        function navigatorLock(_x212, _x213, _x214) {
          return _navigatorLock.apply(this, arguments);
        }
        /**
         * https://mathiasbynens.be/notes/globalthis
         */
        function _navigatorLock() {
          _navigatorLock = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee275(name, acquireTimeout, fn) {
            var abortController;
            return _regenerator().w(function (_context276) {
              while (1) switch (_context276.n) {
                case 0:
                  if (internals.debug) {
                    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);
                  }
                  abortController = new globalThis.AbortController();
                  if (acquireTimeout > 0) {
                    setTimeout(function () {
                      abortController.abort();
                      if (internals.debug) {
                        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);
                      }
                    }, acquireTimeout);
                  }
                  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request
                  // Wrapping navigator.locks.request() with a plain Promise is done as some
                  // libraries like zone.js patch the Promise object to track the execution
                  // context. However, it appears that most browsers use an internal promise
                  // implementation when using the navigator.locks.request() API causing them
                  // to lose context and emit confusing log messages or break certain features.
                  // This wrapping is believed to help zone.js track the execution context
                  // better.
                  _context276.n = 1;
                  return Promise.resolve().then(function () {
                    return globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
                      mode: 'exclusive',
                      ifAvailable: true
                    } : {
                      mode: 'exclusive',
                      signal: abortController.signal
                    }, /*#__PURE__*/function () {
                      var _ref285 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee274(lock) {
                        var result, _t169;
                        return _regenerator().w(function (_context275) {
                          while (1) switch (_context275.p = _context275.n) {
                            case 0:
                              if (!lock) {
                                _context275.n = 5;
                                break;
                              }
                              if (internals.debug) {
                                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);
                              }
                              _context275.p = 1;
                              _context275.n = 2;
                              return fn();
                            case 2:
                              return _context275.a(2, _context275.v);
                            case 3:
                              _context275.p = 3;
                              if (internals.debug) {
                                console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);
                              }
                              return _context275.f(3);
                            case 4:
                              _context275.n = 12;
                              break;
                            case 5:
                              if (!(acquireTimeout === 0)) {
                                _context275.n = 6;
                                break;
                              }
                              if (internals.debug) {
                                console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);
                              }
                              throw new NavigatorLockAcquireTimeoutError("Acquiring an exclusive Navigator LockManager lock \"".concat(name, "\" immediately failed"));
                            case 6:
                              if (!internals.debug) {
                                _context275.n = 10;
                                break;
                              }
                              _context275.p = 7;
                              _context275.n = 8;
                              return globalThis.navigator.locks.query();
                            case 8:
                              result = _context275.v;
                              console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));
                              _context275.n = 10;
                              break;
                            case 9:
                              _context275.p = 9;
                              _t169 = _context275.v;
                              console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', _t169);
                            case 10:
                              // Browser is not following the Navigator LockManager spec, it
                              // returned a null lock when we didn't use ifAvailable. So we can
                              // pretend the lock is acquired in the name of backward compatibility
                              // and user experience and just run the function.
                              console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');
                              _context275.n = 11;
                              return fn();
                            case 11:
                              return _context275.a(2, _context275.v);
                            case 12:
                              return _context275.a(2);
                          }
                        }, _callee274, null, [[7, 9], [1,, 3, 4]]);
                      }));
                      return function (_x329) {
                        return _ref285.apply(this, arguments);
                      };
                    }());
                  });
                case 1:
                  return _context276.a(2, _context276.v);
              }
            }, _callee275);
          }));
          return _navigatorLock.apply(this, arguments);
        }
        function polyfillGlobalThis() {
          if ((typeof globalThis === "undefined" ? "undefined" : _typeof2(globalThis)) === 'object') return;
          try {
            Object.defineProperty(Object.prototype, '__magic__', {
              get: function get() {
                return this;
              },
              configurable: true
            });
            // @ts-expect-error 'Allow access to magic'
            __magic__.globalThis = __magic__;
            // @ts-expect-error 'Allow access to magic'
            delete Object.prototype.__magic__;
          } catch (e) {
            if (typeof self !== 'undefined') {
              // @ts-expect-error 'Allow access to globals'
              self.globalThis = self;
            }
          }
        }

        // types and functions copied over from viem so this library doesn't depend on it
        function getAddress(address) {
          if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            throw new Error("@supabase/auth-js: Address \"".concat(address, "\" is invalid."));
          }
          return address.toLowerCase();
        }
        function fromHex(hex) {
          return parseInt(hex, 16);
        }
        function toHex(value) {
          var bytes = new TextEncoder().encode(value);
          var hex = Array.from(bytes, function (byte) {
            return byte.toString(16).padStart(2, '0');
          }).join('');
          return '0x' + hex;
        }
        /**
         * Creates EIP-4361 formatted message.
         */
        function createSiweMessage(parameters) {
          var _a;
          var chainId = parameters.chainId,
            domain = parameters.domain,
            expirationTime = parameters.expirationTime,
            _parameters$issuedAt = parameters.issuedAt,
            issuedAt = _parameters$issuedAt === void 0 ? new Date() : _parameters$issuedAt,
            nonce = parameters.nonce,
            notBefore = parameters.notBefore,
            requestId = parameters.requestId,
            resources = parameters.resources,
            scheme = parameters.scheme,
            uri = parameters.uri,
            version = parameters.version;
          // Validate fields
          {
            if (!Number.isInteger(chainId)) throw new Error("@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ".concat(chainId));
            if (!domain) throw new Error("@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.");
            if (nonce && nonce.length < 8) throw new Error("@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ".concat(nonce));
            if (!uri) throw new Error("@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.");
            if (version !== '1') throw new Error("@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ".concat(version));
            if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes('\n')) throw new Error("@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\n'. Provided value: ".concat(parameters.statement));
          }
          // Construct message
          var address = getAddress(parameters.address);
          var origin = scheme ? "".concat(scheme, "://").concat(domain) : domain;
          var statement = parameters.statement ? "".concat(parameters.statement, "\n") : '';
          var prefix = "".concat(origin, " wants you to sign in with your Ethereum account:\n").concat(address, "\n\n").concat(statement);
          var suffix = "URI: ".concat(uri, "\nVersion: ").concat(version, "\nChain ID: ").concat(chainId).concat(nonce ? "\nNonce: ".concat(nonce) : '', "\nIssued At: ").concat(issuedAt.toISOString());
          if (expirationTime) suffix += "\nExpiration Time: ".concat(expirationTime.toISOString());
          if (notBefore) suffix += "\nNot Before: ".concat(notBefore.toISOString());
          if (requestId) suffix += "\nRequest ID: ".concat(requestId);
          if (resources) {
            var content = '\nResources:';
            var _iterator11 = _createForOfIteratorHelper(resources),
              _step11;
            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var resource = _step11.value;
                if (!resource || typeof resource !== 'string') throw new Error("@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ".concat(resource));
                content += "\n- ".concat(resource);
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
            suffix += content;
          }
          return "".concat(prefix, "\n").concat(suffix);
        }

        /* eslint-disable @typescript-eslint/ban-ts-comment */
        /**
         * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented
         * errors in the spec was raised after calling `navigator.credentials.create()` or
         * `navigator.credentials.get()`:
         *
         * - `AbortError`
         * - `ConstraintError`
         * - `InvalidStateError`
         * - `NotAllowedError`
         * - `NotSupportedError`
         * - `SecurityError`
         * - `TypeError`
         * - `UnknownError`
         *
         * Error messages were determined through investigation of the spec to determine under which
         * scenarios a given error would be raised.
         */
        var WebAuthnError = /*#__PURE__*/function (_Error9) {
          function WebAuthnError(_ref211) {
            var _this120;
            var message = _ref211.message,
              code = _ref211.code,
              cause = _ref211.cause,
              name = _ref211.name;
            _classCallCheck(this, WebAuthnError);
            var _a;
            // @ts-ignore: help Rollup understand that `cause` is okay to set
            _this120 = _callSuper(this, WebAuthnError, [message, {
              cause: cause
            }]);
            _this120.__isWebAuthnError = true;
            _this120.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : 'Unknown Error';
            _this120.code = code;
            return _this120;
          }
          _inherits(WebAuthnError, _Error9);
          return _createClass(WebAuthnError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        /**
         * Error class for unknown WebAuthn errors.
         * Wraps unexpected errors that don't match known WebAuthn error conditions.
         */
        var WebAuthnUnknownError = /*#__PURE__*/function (_WebAuthnError) {
          function WebAuthnUnknownError(message, originalError) {
            var _this121;
            _classCallCheck(this, WebAuthnUnknownError);
            _this121 = _callSuper(this, WebAuthnUnknownError, [{
              code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
              cause: originalError,
              message: message
            }]);
            _this121.name = 'WebAuthnUnknownError';
            _this121.originalError = originalError;
            return _this121;
          }
          _inherits(WebAuthnUnknownError, _WebAuthnError);
          return _createClass(WebAuthnUnknownError);
        }(WebAuthnError);
        /**
         * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.
         * Maps browser errors to specific WebAuthn error codes for better debugging.
         * @param {Object} params - Error identification parameters
         * @param {Error} params.error - The error thrown by the browser
         * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()
         * @returns {WebAuthnError} A WebAuthnError with a specific error code
         * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}
         */
        function identifyRegistrationError(_ref212) {
          var error = _ref212.error,
            options = _ref212.options;
          var _a, _b, _c;
          var publicKey = options.publicKey;
          if (!publicKey) {
            throw Error('options was missing required publicKey property');
          }
          if (error.name === 'AbortError') {
            if (options.signal instanceof AbortSignal) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)
              return new WebAuthnError({
                message: 'Registration ceremony was sent an abort signal',
                code: 'ERROR_CEREMONY_ABORTED',
                cause: error
              });
            }
          } else if (error.name === 'ConstraintError') {
            if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {
              // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)
              return new WebAuthnError({
                message: 'Discoverable credentials were required but no available authenticator supported it',
                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',
                cause: error
              });
            } else if (
            // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
            options.mediation === 'conditional' && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {
              // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)
              return new WebAuthnError({
                message: 'User verification was required during automatic registration but it could not be performed',
                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',
                cause: error
              });
            } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === 'required') {
              // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)
              return new WebAuthnError({
                message: 'User verification was required but no available authenticator supported it',
                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',
                cause: error
              });
            }
          } else if (error.name === 'InvalidStateError') {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)
            return new WebAuthnError({
              message: 'The authenticator was previously registered',
              code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',
              cause: error
            });
          } else if (error.name === 'NotAllowedError') {
            /**
             * Pass the error directly through. Platforms are overloading this error beyond what the spec
             * defines and we don't want to overwrite potentially useful error messages.
             */
            return new WebAuthnError({
              message: error.message,
              code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
              cause: error
            });
          } else if (error.name === 'NotSupportedError') {
            var validPubKeyCredParams = publicKey.pubKeyCredParams.filter(function (param) {
              return param.type === 'public-key';
            });
            if (validPubKeyCredParams.length === 0) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)
              return new WebAuthnError({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',
                cause: error
              });
            }
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)
            return new WebAuthnError({
              message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',
              code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',
              cause: error
            });
          } else if (error.name === 'SecurityError') {
            var effectiveDomain = window.location.hostname;
            if (!isValidDomain(effectiveDomain)) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)
              return new WebAuthnError({
                message: "".concat(window.location.hostname, " is an invalid domain"),
                code: 'ERROR_INVALID_DOMAIN',
                cause: error
              });
            } else if (publicKey.rp.id !== effectiveDomain) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)
              return new WebAuthnError({
                message: "The RP ID \"".concat(publicKey.rp.id, "\" is invalid for this domain"),
                code: 'ERROR_INVALID_RP_ID',
                cause: error
              });
            }
          } else if (error.name === 'TypeError') {
            if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)
              return new WebAuthnError({
                message: 'User ID was not between 1 and 64 characters',
                code: 'ERROR_INVALID_USER_ID_LENGTH',
                cause: error
              });
            }
          } else if (error.name === 'UnknownError') {
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)
            return new WebAuthnError({
              message: 'The authenticator was unable to process the specified options, or could not create a new credential',
              code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
              cause: error
            });
          }
          return new WebAuthnError({
            message: 'a Non-Webauthn related error has occurred',
            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
            cause: error
          });
        }
        /**
         * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.
         * Maps browser errors to specific WebAuthn error codes for better debugging.
         * @param {Object} params - Error identification parameters
         * @param {Error} params.error - The error thrown by the browser
         * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()
         * @returns {WebAuthnError} A WebAuthnError with a specific error code
         * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}
         */
        function identifyAuthenticationError(_ref213) {
          var error = _ref213.error,
            options = _ref213.options;
          var publicKey = options.publicKey;
          if (!publicKey) {
            throw Error('options was missing required publicKey property');
          }
          if (error.name === 'AbortError') {
            if (options.signal instanceof AbortSignal) {
              // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)
              return new WebAuthnError({
                message: 'Authentication ceremony was sent an abort signal',
                code: 'ERROR_CEREMONY_ABORTED',
                cause: error
              });
            }
          } else if (error.name === 'NotAllowedError') {
            /**
             * Pass the error directly through. Platforms are overloading this error beyond what the spec
             * defines and we don't want to overwrite potentially useful error messages.
             */
            return new WebAuthnError({
              message: error.message,
              code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
              cause: error
            });
          } else if (error.name === 'SecurityError') {
            var effectiveDomain = window.location.hostname;
            if (!isValidDomain(effectiveDomain)) {
              // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)
              return new WebAuthnError({
                message: "".concat(window.location.hostname, " is an invalid domain"),
                code: 'ERROR_INVALID_DOMAIN',
                cause: error
              });
            } else if (publicKey.rpId !== effectiveDomain) {
              // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)
              return new WebAuthnError({
                message: "The RP ID \"".concat(publicKey.rpId, "\" is invalid for this domain"),
                code: 'ERROR_INVALID_RP_ID',
                cause: error
              });
            }
          } else if (error.name === 'UnknownError') {
            // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)
            // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)
            return new WebAuthnError({
              message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',
              code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
              cause: error
            });
          }
          return new WebAuthnError({
            message: 'a Non-Webauthn related error has occurred',
            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
            cause: error
          });
        }

        /**
         * WebAuthn abort service to manage ceremony cancellation.
         * Ensures only one WebAuthn ceremony is active at a time to prevent "operation already in progress" errors.
         *
         * @experimental This class is experimental and may change in future releases
         * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}
         */
        var WebAuthnAbortService = /*#__PURE__*/function () {
          function WebAuthnAbortService() {
            _classCallCheck(this, WebAuthnAbortService);
          }
          return _createClass(WebAuthnAbortService, [{
            key: "createNewAbortSignal",
            value:
            /**
             * Create an abort signal for a new WebAuthn operation.
             * Automatically cancels any existing operation.
             *
             * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
             * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
             */
            function createNewAbortSignal() {
              // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()
              if (this.controller) {
                var abortError = new Error('Cancelling existing WebAuthn API call for new one');
                abortError.name = 'AbortError';
                this.controller.abort(abortError);
              }
              var newController = new AbortController();
              this.controller = newController;
              return newController.signal;
            }
            /**
             * Manually cancel the current WebAuthn operation.
             * Useful for cleaning up when user cancels or navigates away.
             *
             * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
             */
          }, {
            key: "cancelCeremony",
            value: function cancelCeremony() {
              if (this.controller) {
                var abortError = new Error('Manually cancelling existing WebAuthn API call');
                abortError.name = 'AbortError';
                this.controller.abort(abortError);
                this.controller = undefined;
              }
            }
          }]);
        }();
        /**
         * Singleton instance to ensure only one WebAuthn ceremony is active at a time.
         * This prevents "operation already in progress" errors when retrying WebAuthn operations.
         *
         * @experimental This instance is experimental and may change in future releases
         */
        var webAuthnAbortService = new WebAuthnAbortService();
        /**
         * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers
         * as required by the WebAuthn browser API.
         * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.
         *
         * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields
         * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()
         * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}
         */
        function deserializeCredentialCreationOptions(options) {
          if (!options) {
            throw new Error('Credential creation options are required');
          }
          // Check if the native parseCreationOptionsFromJSON method is available
          if (typeof PublicKeyCredential !== 'undefined' && 'parseCreationOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === 'function') {
            // Use the native WebAuthn Level 3 method
            return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */
            options);
          }
          // Fallback to manual parsing for browsers that don't support the native method
          // Destructure to separate fields that need transformation
          var challengeStr = options.challenge,
            userOpts = options.user,
            excludeCredentials = options.excludeCredentials,
            restOptions = __rest(options
            // Convert challenge from base64url to ArrayBuffer
            , ["challenge", "user", "excludeCredentials"]);
          // Convert challenge from base64url to ArrayBuffer
          var challenge = base64UrlToUint8Array(challengeStr).buffer;
          // Convert user.id from base64url to ArrayBuffer
          var user = Object.assign(Object.assign({}, userOpts), {
            id: base64UrlToUint8Array(userOpts.id).buffer
          });
          // Build the result object
          var result = Object.assign(Object.assign({}, restOptions), {
            challenge: challenge,
            user: user
          });
          // Only add excludeCredentials if it exists
          if (excludeCredentials && excludeCredentials.length > 0) {
            result.excludeCredentials = new Array(excludeCredentials.length);
            for (var i = 0; i < excludeCredentials.length; i++) {
              var cred = excludeCredentials[i];
              result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
                id: base64UrlToUint8Array(cred.id).buffer,
                type: cred.type || 'public-key',
                // Cast transports to handle future transport types like "cable"
                transports: cred.transports
              });
            }
          }
          return result;
        }
        /**
         * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers
         * as required by the WebAuthn browser API.
         * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.
         *
         * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields
         * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()
         * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}
         */
        function deserializeCredentialRequestOptions(options) {
          if (!options) {
            throw new Error('Credential request options are required');
          }
          // Check if the native parseRequestOptionsFromJSON method is available
          if (typeof PublicKeyCredential !== 'undefined' && 'parseRequestOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === 'function') {
            // Use the native WebAuthn Level 3 method
            return PublicKeyCredential.parseRequestOptionsFromJSON(options);
          }
          // Fallback to manual parsing for browsers that don't support the native method
          // Destructure to separate fields that need transformation
          var challengeStr = options.challenge,
            allowCredentials = options.allowCredentials,
            restOptions = __rest(options
            // Convert challenge from base64url to ArrayBuffer
            , ["challenge", "allowCredentials"]);
          // Convert challenge from base64url to ArrayBuffer
          var challenge = base64UrlToUint8Array(challengeStr).buffer;
          // Build the result object
          var result = Object.assign(Object.assign({}, restOptions), {
            challenge: challenge
          });
          // Only add allowCredentials if it exists
          if (allowCredentials && allowCredentials.length > 0) {
            result.allowCredentials = new Array(allowCredentials.length);
            for (var i = 0; i < allowCredentials.length; i++) {
              var cred = allowCredentials[i];
              result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
                id: base64UrlToUint8Array(cred.id).buffer,
                type: cred.type || 'public-key',
                // Cast transports to handle future transport types like "cable"
                transports: cred.transports
              });
            }
          }
          return result;
        }
        /**
         * Convert a registration/enrollment credential response to server format.
         * Serializes binary fields to base64url for JSON transmission.
         * Supports both native WebAuthn Level 3 toJSON and manual fallback.
         *
         * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()
         * @returns {RegistrationResponseJSON} JSON-serializable credential for server
         * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}
         */
        function serializeCredentialCreationResponse(credential) {
          var _a;
          // Check if the credential instance has the toJSON method
          if ('toJSON' in credential && typeof credential.toJSON === 'function') {
            // Use the native WebAuthn Level 3 method
            return credential.toJSON();
          }
          var credentialWithAttachment = credential;
          return {
            id: credential.id,
            rawId: credential.id,
            response: {
              attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
              clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
            },
            type: 'public-key',
            clientExtensionResults: credential.getClientExtensionResults(),
            // Convert null to undefined and cast to AuthenticatorAttachment type
            authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined
          };
        }
        /**
         * Convert an authentication/verification credential response to server format.
         * Serializes binary fields to base64url for JSON transmission.
         * Supports both native WebAuthn Level 3 toJSON and manual fallback.
         *
         * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()
         * @returns {AuthenticationResponseJSON} JSON-serializable credential for server
         * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}
         */
        function serializeCredentialRequestResponse(credential) {
          var _a;
          // Check if the credential instance has the toJSON method
          if ('toJSON' in credential && typeof credential.toJSON === 'function') {
            // Use the native WebAuthn Level 3 method
            return credential.toJSON();
          }
          // Fallback to manual conversion for browsers that don't support toJSON
          // Access authenticatorAttachment via type assertion to handle TypeScript version differences
          // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't
          var credentialWithAttachment = credential;
          var clientExtensionResults = credential.getClientExtensionResults();
          var assertionResponse = credential.response;
          return {
            id: credential.id,
            rawId: credential.id,
            // W3C spec expects rawId to match id for JSON format
            response: {
              authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
              clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
              signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
              userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : undefined
            },
            type: 'public-key',
            clientExtensionResults: clientExtensionResults,
            // Convert null to undefined and cast to AuthenticatorAttachment type
            authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined
          };
        }
        /**
         * A simple test to determine if a hostname is a properly-formatted domain name.
         * Considers localhost valid for development environments.
         *
         * A "valid domain" is defined here: https://url.spec.whatwg.org/#valid-domain
         *
         * Regex sourced from here:
         * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html
         *
         * @param {string} hostname - The hostname to validate
         * @returns {boolean} True if valid domain or localhost
         * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}
         */
        function isValidDomain(hostname) {
          return (
            // Consider localhost valid as well since it's okay wrt Secure Contexts
            hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
          );
        }
        /**
         * Determine if the browser is capable of WebAuthn.
         * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.
         *
         * @returns {boolean} True if browser supports WebAuthn
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}
         */
        function browserSupportsWebAuthn() {
          var _a, _b;
          return !!(isBrowser() && 'PublicKeyCredential' in window && window.PublicKeyCredential && 'credentials' in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');
        }
        /**
         * Create a WebAuthn credential using the browser's credentials API.
         * Wraps navigator.credentials.create() with error handling.
         *
         * @param {CredentialCreationOptions} options - Options including publicKey parameters
         * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error
         * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}
         */
        function createCredential(_x215) {
          return _createCredential.apply(this, arguments);
        }
        /**
         * Get a WebAuthn credential using the browser's credentials API.
         * Wraps navigator.credentials.get() with error handling.
         *
         * @param {CredentialRequestOptions} options - Options including publicKey parameters
         * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error
         * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}
         */
        function _createCredential() {
          _createCredential = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee276(options) {
            var response, _t170;
            return _regenerator().w(function (_context277) {
              while (1) switch (_context277.p = _context277.n) {
                case 0:
                  _context277.p = 0;
                  _context277.n = 1;
                  return navigator.credentials.create(/** we assert the type here until typescript types are updated */
                  options);
                case 1:
                  response = _context277.v;
                  if (response) {
                    _context277.n = 2;
                    break;
                  }
                  return _context277.a(2, {
                    data: null,
                    error: new WebAuthnUnknownError('Empty credential response', response)
                  });
                case 2:
                  if (response instanceof PublicKeyCredential) {
                    _context277.n = 3;
                    break;
                  }
                  return _context277.a(2, {
                    data: null,
                    error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)
                  });
                case 3:
                  return _context277.a(2, {
                    data: response,
                    error: null
                  });
                case 4:
                  _context277.p = 4;
                  _t170 = _context277.v;
                  return _context277.a(2, {
                    data: null,
                    error: identifyRegistrationError({
                      error: _t170,
                      options: options
                    })
                  });
              }
            }, _callee276, null, [[0, 4]]);
          }));
          return _createCredential.apply(this, arguments);
        }
        function getCredential(_x216) {
          return _getCredential.apply(this, arguments);
        }
        function _getCredential() {
          _getCredential = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee277(options) {
            var response, _t171;
            return _regenerator().w(function (_context278) {
              while (1) switch (_context278.p = _context278.n) {
                case 0:
                  _context278.p = 0;
                  _context278.n = 1;
                  return navigator.credentials.get(/** we assert the type here until typescript types are updated */
                  options);
                case 1:
                  response = _context278.v;
                  if (response) {
                    _context278.n = 2;
                    break;
                  }
                  return _context278.a(2, {
                    data: null,
                    error: new WebAuthnUnknownError('Empty credential response', response)
                  });
                case 2:
                  if (response instanceof PublicKeyCredential) {
                    _context278.n = 3;
                    break;
                  }
                  return _context278.a(2, {
                    data: null,
                    error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)
                  });
                case 3:
                  return _context278.a(2, {
                    data: response,
                    error: null
                  });
                case 4:
                  _context278.p = 4;
                  _t171 = _context278.v;
                  return _context278.a(2, {
                    data: null,
                    error: identifyAuthenticationError({
                      error: _t171,
                      options: options
                    })
                  });
              }
            }, _callee277, null, [[0, 4]]);
          }));
          return _getCredential.apply(this, arguments);
        }
        var DEFAULT_CREATION_OPTIONS = {
          hints: ['security-key'],
          authenticatorSelection: {
            authenticatorAttachment: 'cross-platform',
            requireResidentKey: false,
            /** set to preferred because older yubikeys don't have PIN/Biometric */
            userVerification: 'preferred',
            residentKey: 'discouraged'
          },
          attestation: 'direct'
        };
        var DEFAULT_REQUEST_OPTIONS = {
          /** set to preferred because older yubikeys don't have PIN/Biometric */
          userVerification: 'preferred',
          hints: ['security-key'],
          attestation: 'direct'
        };
        function deepMerge() {
          var isObject = function isObject(val) {
            return val !== null && _typeof2(val) === 'object' && !Array.isArray(val);
          };
          var isArrayBufferLike = function isArrayBufferLike(val) {
            return val instanceof ArrayBuffer || ArrayBuffer.isView(val);
          };
          var result = {};
          for (var _len40 = arguments.length, sources = new Array(_len40), _key71 = 0; _key71 < _len40; _key71++) {
            sources[_key71] = arguments[_key71];
          }
          for (var _i11 = 0, _sources2 = sources; _i11 < _sources2.length; _i11++) {
            var source = _sources2[_i11];
            if (!source) continue;
            for (var _key72 in source) {
              var value = source[_key72];
              if (value === undefined) continue;
              if (Array.isArray(value)) {
                // preserve array reference, including unions like AuthenticatorTransport[]
                result[_key72] = value;
              } else if (isArrayBufferLike(value)) {
                result[_key72] = value;
              } else if (isObject(value)) {
                var existing = result[_key72];
                if (isObject(existing)) {
                  result[_key72] = deepMerge(existing, value);
                } else {
                  result[_key72] = deepMerge(value);
                }
              } else {
                result[_key72] = value;
              }
            }
          }
          return result;
        }
        /**
         * Merges WebAuthn credential creation options with overrides.
         * Sets sensible defaults for authenticator selection and extensions.
         *
         * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server
         * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply
         * @param {string} friendlyName - Optional friendly name for the credential
         * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options
         * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}
         */
        function mergeCredentialCreationOptions(baseOptions, overrides) {
          return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
        }
        /**
         * Merges WebAuthn credential request options with overrides.
         * Sets sensible defaults for user verification and hints.
         *
         * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server
         * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply
         * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options
         * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}
         */
        function mergeCredentialRequestOptions(baseOptions, overrides) {
          return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
        }
        /**
         * WebAuthn API wrapper for Supabase Auth.
         * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.
         *
         * @experimental This API is experimental and may change in future releases
         * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}
         */
        var WebAuthnApi = /*#__PURE__*/function () {
          function WebAuthnApi(client) {
            _classCallCheck(this, WebAuthnApi);
            this.client = client;
            // Bind all methods so they can be destructured
            this.enroll = this._enroll.bind(this);
            this.challenge = this._challenge.bind(this);
            this.verify = this._verify.bind(this);
            this.authenticate = this._authenticate.bind(this);
            this.register = this._register.bind(this);
          }
          /**
           * Enroll a new WebAuthn factor.
           * Creates an unverified WebAuthn factor that must be verified with a credential.
           *
           * @experimental This method is experimental and may change in future releases
           * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
           * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
           * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
           */
          return _createClass(WebAuthnApi, [{
            key: "_enroll",
            value: (function () {
              var _enroll2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee120(params) {
                return _regenerator().w(function (_context121) {
                  while (1) switch (_context121.n) {
                    case 0:
                      return _context121.a(2, this.client.mfa.enroll(Object.assign(Object.assign({}, params), {
                        factorType: 'webauthn'
                      })));
                  }
                }, _callee120, this);
              }));
              function _enroll(_x217) {
                return _enroll2.apply(this, arguments);
              }
              return _enroll;
            }()
            /**
             * Challenge for WebAuthn credential creation or authentication.
             * Combines server challenge with browser credential operations.
             * Handles both registration (create) and authentication (request) flows.
             *
             * @experimental This method is experimental and may change in future releases
             * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
             * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
             * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
             * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
             * @returns {Promise<RequestResult>} Challenge response with credential or error
             * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
             * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
             */
            )
          }, {
            key: "_challenge",
            value: (function () {
              var _challenge2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee121(_ref214, overrides) {
                var factorId, webauthn, friendlyName, signal, _yield$this$client$mf, challengeResponse, challengeError, abortSignal, user, options, _yield$createCredenti, data, error, _options5, _yield$getCredential, _data, _error, _t107, _t108;
                return _regenerator().w(function (_context122) {
                  while (1) switch (_context122.p = _context122.n) {
                    case 0:
                      factorId = _ref214.factorId, webauthn = _ref214.webauthn, friendlyName = _ref214.friendlyName, signal = _ref214.signal;
                      _context122.p = 1;
                      _context122.n = 2;
                      return this.client.mfa.challenge({
                        factorId: factorId,
                        webauthn: webauthn
                      });
                    case 2:
                      _yield$this$client$mf = _context122.v;
                      challengeResponse = _yield$this$client$mf.data;
                      challengeError = _yield$this$client$mf.error;
                      if (challengeResponse) {
                        _context122.n = 3;
                        break;
                      }
                      return _context122.a(2, {
                        data: null,
                        error: challengeError
                      });
                    case 3:
                      abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
                      /** webauthn will fail if either of the name/displayname are blank */
                      if (challengeResponse.webauthn.type === 'create') {
                        user = challengeResponse.webauthn.credential_options.publicKey.user;
                        if (!user.name) {
                          user.name = "".concat(user.id, ":").concat(friendlyName);
                        }
                        if (!user.displayName) {
                          user.displayName = user.name;
                        }
                      }
                      _t107 = challengeResponse.webauthn.type;
                      _context122.n = _t107 === 'create' ? 4 : _t107 === 'request' ? 7 : 10;
                      break;
                    case 4:
                      options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
                      _context122.n = 5;
                      return createCredential({
                        publicKey: options,
                        signal: abortSignal
                      });
                    case 5:
                      _yield$createCredenti = _context122.v;
                      data = _yield$createCredenti.data;
                      error = _yield$createCredenti.error;
                      if (!data) {
                        _context122.n = 6;
                        break;
                      }
                      return _context122.a(2, {
                        data: {
                          factorId: factorId,
                          challengeId: challengeResponse.id,
                          webauthn: {
                            type: challengeResponse.webauthn.type,
                            credential_response: data
                          }
                        },
                        error: null
                      });
                    case 6:
                      return _context122.a(2, {
                        data: null,
                        error: error
                      });
                    case 7:
                      _options5 = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
                      _context122.n = 8;
                      return getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {
                        publicKey: _options5,
                        signal: abortSignal
                      }));
                    case 8:
                      _yield$getCredential = _context122.v;
                      _data = _yield$getCredential.data;
                      _error = _yield$getCredential.error;
                      if (!_data) {
                        _context122.n = 9;
                        break;
                      }
                      return _context122.a(2, {
                        data: {
                          factorId: factorId,
                          challengeId: challengeResponse.id,
                          webauthn: {
                            type: challengeResponse.webauthn.type,
                            credential_response: _data
                          }
                        },
                        error: null
                      });
                    case 9:
                      return _context122.a(2, {
                        data: null,
                        error: _error
                      });
                    case 10:
                      _context122.n = 13;
                      break;
                    case 11:
                      _context122.p = 11;
                      _t108 = _context122.v;
                      if (!isAuthError(_t108)) {
                        _context122.n = 12;
                        break;
                      }
                      return _context122.a(2, {
                        data: null,
                        error: _t108
                      });
                    case 12:
                      return _context122.a(2, {
                        data: null,
                        error: new AuthUnknownError('Unexpected error in challenge', _t108)
                      });
                    case 13:
                      return _context122.a(2);
                  }
                }, _callee121, this, [[1, 11]]);
              }));
              function _challenge(_x218, _x219) {
                return _challenge2.apply(this, arguments);
              }
              return _challenge;
            }()
            /**
             * Verify a WebAuthn credential with the server.
             * Completes the WebAuthn ceremony by sending the credential to the server for verification.
             *
             * @experimental This method is experimental and may change in future releases
             * @param {Object} params - Verification parameters
             * @param {string} params.challengeId - ID of the challenge being verified
             * @param {string} params.factorId - ID of the WebAuthn factor
             * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
             * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
             * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
             * */
            )
          }, {
            key: "_verify",
            value: (function () {
              var _verify2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee122(_ref215) {
                var challengeId, factorId, webauthn;
                return _regenerator().w(function (_context123) {
                  while (1) switch (_context123.n) {
                    case 0:
                      challengeId = _ref215.challengeId, factorId = _ref215.factorId, webauthn = _ref215.webauthn;
                      return _context123.a(2, this.client.mfa.verify({
                        factorId: factorId,
                        challengeId: challengeId,
                        webauthn: webauthn
                      }));
                  }
                }, _callee122, this);
              }));
              function _verify(_x220) {
                return _verify2.apply(this, arguments);
              }
              return _verify;
            }()
            /**
             * Complete WebAuthn authentication flow.
             * Performs challenge and verification in a single operation for existing credentials.
             *
             * @experimental This method is experimental and may change in future releases
             * @param {Object} params - Authentication parameters
             * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
             * @param {Object} params.webauthn - WebAuthn configuration
             * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
             * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
             * @param {AbortSignal} params.webauthn.signal - Optional abort signal
             * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
             * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
             * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
             * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
             */
            )
          }, {
            key: "_authenticate",
            value: (function () {
              var _authenticate2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee123(_ref216, overrides) {
                var factorId, _ref216$webauthn, _ref216$webauthn2, _ref216$webauthn2$rpI, rpId, _ref216$webauthn2$rpO, rpOrigins, signal, _yield$this$challenge, challengeResponse, challengeError, webauthn, _t109;
                return _regenerator().w(function (_context124) {
                  while (1) switch (_context124.p = _context124.n) {
                    case 0:
                      factorId = _ref216.factorId, _ref216$webauthn = _ref216.webauthn, _ref216$webauthn2 = _ref216$webauthn === void 0 ? {} : _ref216$webauthn, _ref216$webauthn2$rpI = _ref216$webauthn2.rpId, rpId = _ref216$webauthn2$rpI === void 0 ? typeof window !== 'undefined' ? window.location.hostname : undefined : _ref216$webauthn2$rpI, _ref216$webauthn2$rpO = _ref216$webauthn2.rpOrigins, rpOrigins = _ref216$webauthn2$rpO === void 0 ? typeof window !== 'undefined' ? [window.location.origin] : undefined : _ref216$webauthn2$rpO, signal = _ref216$webauthn2.signal;
                      if (rpId) {
                        _context124.n = 1;
                        break;
                      }
                      return _context124.a(2, {
                        data: null,
                        error: new AuthError('rpId is required for WebAuthn authentication')
                      });
                    case 1:
                      _context124.p = 1;
                      if (browserSupportsWebAuthn()) {
                        _context124.n = 2;
                        break;
                      }
                      return _context124.a(2, {
                        data: null,
                        error: new AuthUnknownError('Browser does not support WebAuthn', null)
                      });
                    case 2:
                      _context124.n = 3;
                      return this.challenge({
                        factorId: factorId,
                        webauthn: {
                          rpId: rpId,
                          rpOrigins: rpOrigins
                        },
                        signal: signal
                      }, {
                        request: overrides
                      });
                    case 3:
                      _yield$this$challenge = _context124.v;
                      challengeResponse = _yield$this$challenge.data;
                      challengeError = _yield$this$challenge.error;
                      if (challengeResponse) {
                        _context124.n = 4;
                        break;
                      }
                      return _context124.a(2, {
                        data: null,
                        error: challengeError
                      });
                    case 4:
                      webauthn = challengeResponse.webauthn; // Verify credential
                      return _context124.a(2, this._verify({
                        factorId: factorId,
                        challengeId: challengeResponse.challengeId,
                        webauthn: {
                          type: webauthn.type,
                          rpId: rpId,
                          rpOrigins: rpOrigins,
                          credential_response: webauthn.credential_response
                        }
                      }));
                    case 5:
                      _context124.p = 5;
                      _t109 = _context124.v;
                      if (!isAuthError(_t109)) {
                        _context124.n = 6;
                        break;
                      }
                      return _context124.a(2, {
                        data: null,
                        error: _t109
                      });
                    case 6:
                      return _context124.a(2, {
                        data: null,
                        error: new AuthUnknownError('Unexpected error in authenticate', _t109)
                      });
                  }
                }, _callee123, this, [[1, 5]]);
              }));
              function _authenticate(_x221, _x222) {
                return _authenticate2.apply(this, arguments);
              }
              return _authenticate;
            }()
            /**
             * Complete WebAuthn registration flow.
             * Performs enrollment, challenge, and verification in a single operation for new credentials.
             *
             * @experimental This method is experimental and may change in future releases
             * @param {Object} params - Registration parameters
             * @param {string} params.friendlyName - User-friendly name for the credential
             * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
             * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
             * @param {AbortSignal} params.signal - Optional abort signal
             * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
             * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
             * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
             * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
             */
            )
          }, {
            key: "_register",
            value: (function () {
              var _register2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee124(_ref217, overrides) {
                var _this122 = this;
                var friendlyName, _ref217$webauthn, _ref217$webauthn2, _ref217$webauthn2$rpI, rpId, _ref217$webauthn2$rpO, rpOrigins, signal, _yield$this$_enroll, factor, enrollError, _yield$this$_challeng, challengeResponse, challengeError, _t110;
                return _regenerator().w(function (_context125) {
                  while (1) switch (_context125.p = _context125.n) {
                    case 0:
                      friendlyName = _ref217.friendlyName, _ref217$webauthn = _ref217.webauthn, _ref217$webauthn2 = _ref217$webauthn === void 0 ? {} : _ref217$webauthn, _ref217$webauthn2$rpI = _ref217$webauthn2.rpId, rpId = _ref217$webauthn2$rpI === void 0 ? typeof window !== 'undefined' ? window.location.hostname : undefined : _ref217$webauthn2$rpI, _ref217$webauthn2$rpO = _ref217$webauthn2.rpOrigins, rpOrigins = _ref217$webauthn2$rpO === void 0 ? typeof window !== 'undefined' ? [window.location.origin] : undefined : _ref217$webauthn2$rpO, signal = _ref217$webauthn2.signal;
                      if (rpId) {
                        _context125.n = 1;
                        break;
                      }
                      return _context125.a(2, {
                        data: null,
                        error: new AuthError('rpId is required for WebAuthn registration')
                      });
                    case 1:
                      _context125.p = 1;
                      if (browserSupportsWebAuthn()) {
                        _context125.n = 2;
                        break;
                      }
                      return _context125.a(2, {
                        data: null,
                        error: new AuthUnknownError('Browser does not support WebAuthn', null)
                      });
                    case 2:
                      _context125.n = 3;
                      return this._enroll({
                        friendlyName: friendlyName
                      });
                    case 3:
                      _yield$this$_enroll = _context125.v;
                      factor = _yield$this$_enroll.data;
                      enrollError = _yield$this$_enroll.error;
                      if (factor) {
                        _context125.n = 5;
                        break;
                      }
                      _context125.n = 4;
                      return this.client.mfa.listFactors().then(function (factors) {
                        var _a;
                        return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(function (v) {
                          return v.factor_type === 'webauthn' && v.friendly_name === friendlyName && v.status !== 'unverified';
                        });
                      }).then(function (factor) {
                        return factor ? _this122.client.mfa.unenroll({
                          factorId: factor === null || factor === void 0 ? void 0 : factor.id
                        }) : void 0;
                      });
                    case 4:
                      return _context125.a(2, {
                        data: null,
                        error: enrollError
                      });
                    case 5:
                      _context125.n = 6;
                      return this._challenge({
                        factorId: factor.id,
                        friendlyName: factor.friendly_name,
                        webauthn: {
                          rpId: rpId,
                          rpOrigins: rpOrigins
                        },
                        signal: signal
                      }, {
                        create: overrides
                      });
                    case 6:
                      _yield$this$_challeng = _context125.v;
                      challengeResponse = _yield$this$_challeng.data;
                      challengeError = _yield$this$_challeng.error;
                      if (challengeResponse) {
                        _context125.n = 7;
                        break;
                      }
                      return _context125.a(2, {
                        data: null,
                        error: challengeError
                      });
                    case 7:
                      return _context125.a(2, this._verify({
                        factorId: factor.id,
                        challengeId: challengeResponse.challengeId,
                        webauthn: {
                          rpId: rpId,
                          rpOrigins: rpOrigins,
                          type: challengeResponse.webauthn.type,
                          credential_response: challengeResponse.webauthn.credential_response
                        }
                      }));
                    case 8:
                      _context125.p = 8;
                      _t110 = _context125.v;
                      if (!isAuthError(_t110)) {
                        _context125.n = 9;
                        break;
                      }
                      return _context125.a(2, {
                        data: null,
                        error: _t110
                      });
                    case 9:
                      return _context125.a(2, {
                        data: null,
                        error: new AuthUnknownError('Unexpected error in register', _t110)
                      });
                  }
                }, _callee124, this, [[1, 8]]);
              }));
              function _register(_x223, _x224) {
                return _register2.apply(this, arguments);
              }
              return _register;
            }())
          }]);
        }();
        polyfillGlobalThis(); // Make "globalThis" available
        var DEFAULT_OPTIONS = {
          url: GOTRUE_URL,
          storageKey: STORAGE_KEY,
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true,
          headers: DEFAULT_HEADERS$1,
          flowType: 'implicit',
          debug: false,
          hasCustomAuthorizationHeader: false,
          throwOnError: false,
          lockAcquireTimeout: 10000 // 10 seconds
        };
        function lockNoOp(_x225, _x226, _x227) {
          return _lockNoOp.apply(this, arguments);
        }
        /**
         * Caches JWKS values for all clients created in the same environment. This is
         * especially useful for shared-memory execution environments such as Vercel's
         * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how
         * many clients are created, if they share the same storage key they will use
         * the same JWKS cache, significantly speeding up getClaims() with asymmetric
         * JWTs.
         */
        function _lockNoOp() {
          _lockNoOp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee278(name, acquireTimeout, fn) {
            return _regenerator().w(function (_context279) {
              while (1) switch (_context279.n) {
                case 0:
                  _context279.n = 1;
                  return fn();
                case 1:
                  return _context279.a(2, _context279.v);
              }
            }, _callee278);
          }));
          return _lockNoOp.apply(this, arguments);
        }
        var GLOBAL_JWKS = {};
        var GoTrueClient = /*#__PURE__*/function () {
          /**
           * Create a new client for use in the browser.
           *
           * @example
           * ```ts
           * import { GoTrueClient } from '@supabase/auth-js'
           *
           * const auth = new GoTrueClient({
           *   url: 'https://xyzcompany.supabase.co/auth/v1',
           *   headers: { apikey: 'public-anon-key' },
           *   storageKey: 'supabase-auth',
           * })
           * ```
           */
          function GoTrueClient(options) {
            var _this123 = this;
            _classCallCheck(this, GoTrueClient);
            var _a, _b, _c;
            /**
             * @experimental
             */
            this.userStorage = null;
            this.memoryStorage = null;
            this.stateChangeEmitters = new Map();
            this.autoRefreshTicker = null;
            this.autoRefreshTickTimeout = null;
            this.visibilityChangedCallback = null;
            this.refreshingDeferred = null;
            /**
             * Keeps track of the async client initialization.
             * When null or not yet resolved the auth state is `unknown`
             * Once resolved the auth state is known and it's safe to call any further client methods.
             * Keep extra care to never reject or throw uncaught errors
             */
            this.initializePromise = null;
            this.detectSessionInUrl = true;
            this.hasCustomAuthorizationHeader = false;
            this.suppressGetSessionWarning = false;
            this.lockAcquired = false;
            this.pendingInLock = [];
            /**
             * Used to broadcast state change events to other tabs listening.
             */
            this.broadcastChannel = null;
            this.logger = console.log;
            var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
            this.storageKey = settings.storageKey;
            this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;
            GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
            this.logDebugMessages = !!settings.debug;
            if (typeof settings.debug === 'function') {
              this.logger = settings.debug;
            }
            if (this.instanceID > 0 && isBrowser()) {
              var message = "".concat(this._logPrefix(), " Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
              console.warn(message);
              if (this.logDebugMessages) {
                console.trace(message);
              }
            }
            this.persistSession = settings.persistSession;
            this.autoRefreshToken = settings.autoRefreshToken;
            this.admin = new GoTrueAdminApi({
              url: settings.url,
              headers: settings.headers,
              fetch: settings.fetch
            });
            this.url = settings.url;
            this.headers = settings.headers;
            this.fetch = resolveFetch$1(settings.fetch);
            this.lock = settings.lock || lockNoOp;
            this.detectSessionInUrl = settings.detectSessionInUrl;
            this.flowType = settings.flowType;
            this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
            this.throwOnError = settings.throwOnError;
            this.lockAcquireTimeout = settings.lockAcquireTimeout;
            if (settings.lock) {
              this.lock = settings.lock;
            } else if (this.persistSession && isBrowser() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {
              this.lock = navigatorLock;
            } else {
              this.lock = lockNoOp;
            }
            if (!this.jwks) {
              this.jwks = {
                keys: []
              };
              this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
            }
            this.mfa = {
              verify: this._verify.bind(this),
              enroll: this._enroll.bind(this),
              unenroll: this._unenroll.bind(this),
              challenge: this._challenge.bind(this),
              listFactors: this._listFactors.bind(this),
              challengeAndVerify: this._challengeAndVerify.bind(this),
              getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
              webauthn: new WebAuthnApi(this)
            };
            this.oauth = {
              getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
              approveAuthorization: this._approveAuthorization.bind(this),
              denyAuthorization: this._denyAuthorization.bind(this),
              listGrants: this._listOAuthGrants.bind(this),
              revokeGrant: this._revokeOAuthGrant.bind(this)
            };
            if (this.persistSession) {
              if (settings.storage) {
                this.storage = settings.storage;
              } else {
                if (supportsLocalStorage()) {
                  this.storage = globalThis.localStorage;
                } else {
                  this.memoryStorage = {};
                  this.storage = memoryLocalStorageAdapter(this.memoryStorage);
                }
              }
              if (settings.userStorage) {
                this.userStorage = settings.userStorage;
              }
            } else {
              this.memoryStorage = {};
              this.storage = memoryLocalStorageAdapter(this.memoryStorage);
            }
            if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
              try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
              } catch (e) {
                console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);
              }
              (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener('message', /*#__PURE__*/function () {
                var _ref218 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee125(event) {
                  return _regenerator().w(function (_context126) {
                    while (1) switch (_context126.n) {
                      case 0:
                        _this123._debug('received broadcast notification from other tab or client', event);
                        _context126.n = 1;
                        return _this123._notifyAllSubscribers(event.data.event, event.data.session, false);
                      case 1:
                        return _context126.a(2);
                    }
                  }, _callee125);
                }));
                return function (_x228) {
                  return _ref218.apply(this, arguments);
                };
              }());
            }
            this.initialize();
          }
          /**
           * Returns whether error throwing mode is enabled for this client.
           */
          return _createClass(GoTrueClient, [{
            key: "jwks",
            get:
            /**
             * The JWKS used for verifying asymmetric JWTs
             */
            function get() {
              var _a, _b;
              return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {
                keys: []
              };
            },
            set: function set(value) {
              GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {
                jwks: value
              });
            }
          }, {
            key: "jwks_cached_at",
            get: function get() {
              var _a, _b;
              return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
            },
            set: function set(value) {
              GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {
                cachedAt: value
              });
            }
          }, {
            key: "isThrowOnErrorEnabled",
            value: function isThrowOnErrorEnabled() {
              return this.throwOnError;
            }
            /**
             * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
             * and the provided result contains a non-nullish error, the error is thrown instead of
             * being returned. This ensures consistent behavior across all public API methods.
             */
          }, {
            key: "_returnResult",
            value: function _returnResult(result) {
              if (this.throwOnError && result && result.error) {
                throw result.error;
              }
              return result;
            }
          }, {
            key: "_logPrefix",
            value: function _logPrefix() {
              return 'GoTrueClient@' + "".concat(this.storageKey, ":").concat(this.instanceID, " (").concat(version$1, ") ").concat(new Date().toISOString());
            }
          }, {
            key: "_debug",
            value: function _debug() {
              if (this.logDebugMessages) {
                for (var _len41 = arguments.length, args = new Array(_len41), _key73 = 0; _key73 < _len41; _key73++) {
                  args[_key73] = arguments[_key73];
                }
                this.logger.apply(this, [this._logPrefix()].concat(args));
              }
              return this;
            }
            /**
             * Initializes the client session either from the url or from storage.
             * This method is automatically called when instantiating the client, but should also be called
             * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
             */
          }, {
            key: "initialize",
            value: (function () {
              var _initialize2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee128() {
                var _this124 = this;
                return _regenerator().w(function (_context129) {
                  while (1) switch (_context129.n) {
                    case 0:
                      if (!this.initializePromise) {
                        _context129.n = 2;
                        break;
                      }
                      _context129.n = 1;
                      return this.initializePromise;
                    case 1:
                      return _context129.a(2, _context129.v);
                    case 2:
                      this.initializePromise = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee127() {
                        return _regenerator().w(function (_context128) {
                          while (1) switch (_context128.n) {
                            case 0:
                              _context128.n = 1;
                              return _this124._acquireLock(_this124.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee126() {
                                return _regenerator().w(function (_context127) {
                                  while (1) switch (_context127.n) {
                                    case 0:
                                      _context127.n = 1;
                                      return _this124._initialize();
                                    case 1:
                                      return _context127.a(2, _context127.v);
                                  }
                                }, _callee126);
                              })));
                            case 1:
                              return _context128.a(2, _context128.v);
                          }
                        }, _callee127);
                      }))();
                      _context129.n = 3;
                      return this.initializePromise;
                    case 3:
                      return _context129.a(2, _context129.v);
                  }
                }, _callee128, this);
              }));
              function initialize() {
                return _initialize2.apply(this, arguments);
              }
              return initialize;
            }()
            /**
             * IMPORTANT:
             * 1. Never throw in this method, as it is called from the constructor
             * 2. Never return a session from this method as it would be cached over
             *    the whole lifetime of the client
             */
            )
          }, {
            key: "_initialize",
            value: (function () {
              var _initialize3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee130() {
                var _this125 = this;
                var _a, params, callbackUrlType, _yield$this$_getSessi, data, error, errorCode, session, redirectType, _t111;
                return _regenerator().w(function (_context131) {
                  while (1) switch (_context131.p = _context131.n) {
                    case 0:
                      _context131.p = 0;
                      params = {};
                      callbackUrlType = 'none';
                      if (!isBrowser()) {
                        _context131.n = 3;
                        break;
                      }
                      params = parseParametersFromURL(window.location.href);
                      if (!this._isImplicitGrantCallback(params)) {
                        _context131.n = 1;
                        break;
                      }
                      callbackUrlType = 'implicit';
                      _context131.n = 3;
                      break;
                    case 1:
                      _context131.n = 2;
                      return this._isPKCECallback(params);
                    case 2:
                      if (!_context131.v) {
                        _context131.n = 3;
                        break;
                      }
                      callbackUrlType = 'pkce';
                    case 3:
                      if (!(isBrowser() && this.detectSessionInUrl && callbackUrlType !== 'none')) {
                        _context131.n = 8;
                        break;
                      }
                      _context131.n = 4;
                      return this._getSessionFromURL(params, callbackUrlType);
                    case 4:
                      _yield$this$_getSessi = _context131.v;
                      data = _yield$this$_getSessi.data;
                      error = _yield$this$_getSessi.error;
                      if (!error) {
                        _context131.n = 6;
                        break;
                      }
                      this._debug('#_initialize()', 'error detecting session from URL', error);
                      if (!isAuthImplicitGrantRedirectError(error)) {
                        _context131.n = 5;
                        break;
                      }
                      errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;
                      if (!(errorCode === 'identity_already_exists' || errorCode === 'identity_not_found' || errorCode === 'single_identity_not_deletable')) {
                        _context131.n = 5;
                        break;
                      }
                      return _context131.a(2, {
                        error: error
                      });
                    case 5:
                      return _context131.a(2, {
                        error: error
                      });
                    case 6:
                      session = data.session, redirectType = data.redirectType;
                      this._debug('#_initialize()', 'detected session in URL', session, 'redirect type', redirectType);
                      _context131.n = 7;
                      return this._saveSession(session);
                    case 7:
                      setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee129() {
                        return _regenerator().w(function (_context130) {
                          while (1) switch (_context130.n) {
                            case 0:
                              if (!(redirectType === 'recovery')) {
                                _context130.n = 2;
                                break;
                              }
                              _context130.n = 1;
                              return _this125._notifyAllSubscribers('PASSWORD_RECOVERY', session);
                            case 1:
                              _context130.n = 3;
                              break;
                            case 2:
                              _context130.n = 3;
                              return _this125._notifyAllSubscribers('SIGNED_IN', session);
                            case 3:
                              return _context130.a(2);
                          }
                        }, _callee129);
                      })), 0);
                      return _context131.a(2, {
                        error: null
                      });
                    case 8:
                      _context131.n = 9;
                      return this._recoverAndRefresh();
                    case 9:
                      return _context131.a(2, {
                        error: null
                      });
                    case 10:
                      _context131.p = 10;
                      _t111 = _context131.v;
                      if (!isAuthError(_t111)) {
                        _context131.n = 11;
                        break;
                      }
                      return _context131.a(2, this._returnResult({
                        error: _t111
                      }));
                    case 11:
                      return _context131.a(2, this._returnResult({
                        error: new AuthUnknownError('Unexpected error during initialization', _t111)
                      }));
                    case 12:
                      _context131.p = 12;
                      _context131.n = 13;
                      return this._handleVisibilityChange();
                    case 13:
                      this._debug('#_initialize()', 'end');
                      return _context131.f(12);
                    case 14:
                      return _context131.a(2);
                  }
                }, _callee130, this, [[0, 10, 12, 14]]);
              }));
              function _initialize() {
                return _initialize3.apply(this, arguments);
              }
              return _initialize;
            }()
            /**
             * Creates a new anonymous user.
             *
             * @returns A session where the is_anonymous claim in the access token JWT set to true
             */
            )
          }, {
            key: "signInAnonymously",
            value: (function () {
              var _signInAnonymously = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee131(credentials) {
                var _a, _b, _c, res, data, error, session, user, _t112;
                return _regenerator().w(function (_context132) {
                  while (1) switch (_context132.p = _context132.n) {
                    case 0:
                      _context132.p = 0;
                      _context132.n = 1;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/signup"), {
                        headers: this.headers,
                        body: {
                          data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},
                          gotrue_meta_security: {
                            captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken
                          }
                        },
                        xform: _sessionResponse
                      });
                    case 1:
                      res = _context132.v;
                      data = res.data, error = res.error;
                      if (!(error || !data)) {
                        _context132.n = 2;
                        break;
                      }
                      return _context132.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 2:
                      session = data.session;
                      user = data.user;
                      if (!data.session) {
                        _context132.n = 4;
                        break;
                      }
                      _context132.n = 3;
                      return this._saveSession(data.session);
                    case 3:
                      _context132.n = 4;
                      return this._notifyAllSubscribers('SIGNED_IN', session);
                    case 4:
                      return _context132.a(2, this._returnResult({
                        data: {
                          user: user,
                          session: session
                        },
                        error: null
                      }));
                    case 5:
                      _context132.p = 5;
                      _t112 = _context132.v;
                      if (!isAuthError(_t112)) {
                        _context132.n = 6;
                        break;
                      }
                      return _context132.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t112
                      }));
                    case 6:
                      throw _t112;
                    case 7:
                      return _context132.a(2);
                  }
                }, _callee131, this, [[0, 5]]);
              }));
              function signInAnonymously(_x229) {
                return _signInAnonymously.apply(this, arguments);
              }
              return signInAnonymously;
            }()
            /**
             * Creates a new user.
             *
             * Be aware that if a user account exists in the system you may get back an
             * error message that attempts to hide this information from the user.
             * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
             *
             * @returns A logged-in session if the server has "autoconfirm" ON
             * @returns A user if the server has "autoconfirm" OFF
             */
            )
          }, {
            key: "signUp",
            value: (function () {
              var _signUp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee132(credentials) {
                var _a, _b, _c, res, email, password, options, codeChallenge, codeChallengeMethod, _yield$getCodeChallen, _yield$getCodeChallen2, phone, _password, _options6, _res, data, error, session, user, _t113;
                return _regenerator().w(function (_context133) {
                  while (1) switch (_context133.p = _context133.n) {
                    case 0:
                      _context133.p = 0;
                      if (!('email' in credentials)) {
                        _context133.n = 4;
                        break;
                      }
                      email = credentials.email, password = credentials.password, options = credentials.options;
                      codeChallenge = null;
                      codeChallengeMethod = null;
                      if (!(this.flowType === 'pkce')) {
                        _context133.n = 2;
                        break;
                      }
                      ;
                      _context133.n = 1;
                      return getCodeChallengeAndMethod(this.storage, this.storageKey);
                    case 1:
                      _yield$getCodeChallen = _context133.v;
                      _yield$getCodeChallen2 = _slicedToArray(_yield$getCodeChallen, 2);
                      codeChallenge = _yield$getCodeChallen2[0];
                      codeChallengeMethod = _yield$getCodeChallen2[1];
                    case 2:
                      _context133.n = 3;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/signup"), {
                        headers: this.headers,
                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
                        body: {
                          email: email,
                          password: password,
                          data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                          gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                          },
                          code_challenge: codeChallenge,
                          code_challenge_method: codeChallengeMethod
                        },
                        xform: _sessionResponse
                      });
                    case 3:
                      res = _context133.v;
                      _context133.n = 7;
                      break;
                    case 4:
                      if (!('phone' in credentials)) {
                        _context133.n = 6;
                        break;
                      }
                      phone = credentials.phone, _password = credentials.password, _options6 = credentials.options;
                      _context133.n = 5;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/signup"), {
                        headers: this.headers,
                        body: {
                          phone: phone,
                          password: _password,
                          data: (_b = _options6 === null || _options6 === void 0 ? void 0 : _options6.data) !== null && _b !== void 0 ? _b : {},
                          channel: (_c = _options6 === null || _options6 === void 0 ? void 0 : _options6.channel) !== null && _c !== void 0 ? _c : 'sms',
                          gotrue_meta_security: {
                            captcha_token: _options6 === null || _options6 === void 0 ? void 0 : _options6.captchaToken
                          }
                        },
                        xform: _sessionResponse
                      });
                    case 5:
                      res = _context133.v;
                      _context133.n = 7;
                      break;
                    case 6:
                      throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
                    case 7:
                      _res = res, data = _res.data, error = _res.error;
                      if (!(error || !data)) {
                        _context133.n = 9;
                        break;
                      }
                      _context133.n = 8;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 8:
                      return _context133.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 9:
                      session = data.session;
                      user = data.user;
                      if (!data.session) {
                        _context133.n = 11;
                        break;
                      }
                      _context133.n = 10;
                      return this._saveSession(data.session);
                    case 10:
                      _context133.n = 11;
                      return this._notifyAllSubscribers('SIGNED_IN', session);
                    case 11:
                      return _context133.a(2, this._returnResult({
                        data: {
                          user: user,
                          session: session
                        },
                        error: null
                      }));
                    case 12:
                      _context133.p = 12;
                      _t113 = _context133.v;
                      _context133.n = 13;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 13:
                      if (!isAuthError(_t113)) {
                        _context133.n = 14;
                        break;
                      }
                      return _context133.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t113
                      }));
                    case 14:
                      throw _t113;
                    case 15:
                      return _context133.a(2);
                  }
                }, _callee132, this, [[0, 12]]);
              }));
              function signUp(_x230) {
                return _signUp.apply(this, arguments);
              }
              return signUp;
            }()
            /**
             * Log in an existing user with an email and password or phone and password.
             *
             * Be aware that you may get back an error message that will not distinguish
             * between the cases where the account does not exist or that the
             * email/phone and password combination is wrong or that the account can only
             * be accessed via social login.
             */
            )
          }, {
            key: "signInWithPassword",
            value: (function () {
              var _signInWithPassword = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee133(credentials) {
                var res, email, password, options, phone, _password2, _options7, _res2, data, error, invalidTokenError, _t114;
                return _regenerator().w(function (_context134) {
                  while (1) switch (_context134.p = _context134.n) {
                    case 0:
                      _context134.p = 0;
                      if (!('email' in credentials)) {
                        _context134.n = 2;
                        break;
                      }
                      email = credentials.email, password = credentials.password, options = credentials.options;
                      _context134.n = 1;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=password"), {
                        headers: this.headers,
                        body: {
                          email: email,
                          password: password,
                          gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                          }
                        },
                        xform: _sessionResponsePassword
                      });
                    case 1:
                      res = _context134.v;
                      _context134.n = 5;
                      break;
                    case 2:
                      if (!('phone' in credentials)) {
                        _context134.n = 4;
                        break;
                      }
                      phone = credentials.phone, _password2 = credentials.password, _options7 = credentials.options;
                      _context134.n = 3;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=password"), {
                        headers: this.headers,
                        body: {
                          phone: phone,
                          password: _password2,
                          gotrue_meta_security: {
                            captcha_token: _options7 === null || _options7 === void 0 ? void 0 : _options7.captchaToken
                          }
                        },
                        xform: _sessionResponsePassword
                      });
                    case 3:
                      res = _context134.v;
                      _context134.n = 5;
                      break;
                    case 4:
                      throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
                    case 5:
                      _res2 = res, data = _res2.data, error = _res2.error;
                      if (!error) {
                        _context134.n = 6;
                        break;
                      }
                      return _context134.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 6:
                      if (!(!data || !data.session || !data.user)) {
                        _context134.n = 7;
                        break;
                      }
                      invalidTokenError = new AuthInvalidTokenResponseError();
                      return _context134.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: invalidTokenError
                      }));
                    case 7:
                      if (!data.session) {
                        _context134.n = 9;
                        break;
                      }
                      _context134.n = 8;
                      return this._saveSession(data.session);
                    case 8:
                      _context134.n = 9;
                      return this._notifyAllSubscribers('SIGNED_IN', data.session);
                    case 9:
                      return _context134.a(2, this._returnResult({
                        data: Object.assign({
                          user: data.user,
                          session: data.session
                        }, data.weak_password ? {
                          weakPassword: data.weak_password
                        } : null),
                        error: error
                      }));
                    case 10:
                      _context134.p = 10;
                      _t114 = _context134.v;
                      if (!isAuthError(_t114)) {
                        _context134.n = 11;
                        break;
                      }
                      return _context134.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t114
                      }));
                    case 11:
                      throw _t114;
                    case 12:
                      return _context134.a(2);
                  }
                }, _callee133, this, [[0, 10]]);
              }));
              function signInWithPassword(_x231) {
                return _signInWithPassword.apply(this, arguments);
              }
              return signInWithPassword;
            }()
            /**
             * Log in an existing user via a third-party provider.
             * This method supports the PKCE flow.
             */
            )
          }, {
            key: "signInWithOAuth",
            value: (function () {
              var _signInWithOAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee134(credentials) {
                var _a, _b, _c, _d;
                return _regenerator().w(function (_context135) {
                  while (1) switch (_context135.n) {
                    case 0:
                      _context135.n = 1;
                      return this._handleProviderSignIn(credentials.provider, {
                        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
                        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
                        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
                        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
                      });
                    case 1:
                      return _context135.a(2, _context135.v);
                  }
                }, _callee134, this);
              }));
              function signInWithOAuth(_x232) {
                return _signInWithOAuth.apply(this, arguments);
              }
              return signInWithOAuth;
            }()
            /**
             * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
             */
            )
          }, {
            key: "exchangeCodeForSession",
            value: (function () {
              var _exchangeCodeForSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee136(authCode) {
                var _this126 = this;
                return _regenerator().w(function (_context137) {
                  while (1) switch (_context137.n) {
                    case 0:
                      _context137.n = 1;
                      return this.initializePromise;
                    case 1:
                      return _context137.a(2, this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee135() {
                        return _regenerator().w(function (_context136) {
                          while (1) switch (_context136.n) {
                            case 0:
                              return _context136.a(2, _this126._exchangeCodeForSession(authCode));
                          }
                        }, _callee135);
                      }))));
                  }
                }, _callee136, this);
              }));
              function exchangeCodeForSession(_x233) {
                return _exchangeCodeForSession2.apply(this, arguments);
              }
              return exchangeCodeForSession;
            }()
            /**
             * Signs in a user by verifying a message signed by the user's private key.
             * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
             * both of which derive from the EIP-4361 standard
             * With slight variation on Solana's side.
             * @reference https://eips.ethereum.org/EIPS/eip-4361
             */
            )
          }, {
            key: "signInWithWeb3",
            value: (function () {
              var _signInWithWeb = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee137(credentials) {
                var chain, _t115;
                return _regenerator().w(function (_context138) {
                  while (1) switch (_context138.n) {
                    case 0:
                      chain = credentials.chain;
                      _t115 = chain;
                      _context138.n = _t115 === 'ethereum' ? 1 : _t115 === 'solana' ? 3 : 5;
                      break;
                    case 1:
                      _context138.n = 2;
                      return this.signInWithEthereum(credentials);
                    case 2:
                      return _context138.a(2, _context138.v);
                    case 3:
                      _context138.n = 4;
                      return this.signInWithSolana(credentials);
                    case 4:
                      return _context138.a(2, _context138.v);
                    case 5:
                      throw new Error("@supabase/auth-js: Unsupported chain \"".concat(chain, "\""));
                    case 6:
                      return _context138.a(2);
                  }
                }, _callee137, this);
              }));
              function signInWithWeb3(_x234) {
                return _signInWithWeb.apply(this, arguments);
              }
              return signInWithWeb3;
            }())
          }, {
            key: "signInWithEthereum",
            value: function () {
              var _signInWithEthereum = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee138(credentials) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, message, signature, chain, wallet, statement, options, resolvedWallet, windowAny, url, accounts, address, chainId, chainIdHex, siweMessage, _yield$_request2, data, error, invalidTokenError, _t116;
                return _regenerator().w(function (_context139) {
                  while (1) switch (_context139.p = _context139.n) {
                    case 0:
                      if (!('message' in credentials)) {
                        _context139.n = 1;
                        break;
                      }
                      message = credentials.message;
                      signature = credentials.signature;
                      _context139.n = 12;
                      break;
                    case 1:
                      chain = credentials.chain, wallet = credentials.wallet, statement = credentials.statement, options = credentials.options;
                      if (isBrowser()) {
                        _context139.n = 3;
                        break;
                      }
                      if (!(_typeof2(wallet) !== 'object' || !(options === null || options === void 0 ? void 0 : options.url))) {
                        _context139.n = 2;
                        break;
                      }
                      throw new Error('@supabase/auth-js: Both wallet and url must be specified in non-browser environments.');
                    case 2:
                      resolvedWallet = wallet;
                      _context139.n = 6;
                      break;
                    case 3:
                      if (!(_typeof2(wallet) === 'object')) {
                        _context139.n = 4;
                        break;
                      }
                      resolvedWallet = wallet;
                      _context139.n = 6;
                      break;
                    case 4:
                      windowAny = window;
                      if (!('ethereum' in windowAny && _typeof2(windowAny.ethereum) === 'object' && 'request' in windowAny.ethereum && typeof windowAny.ethereum.request === 'function')) {
                        _context139.n = 5;
                        break;
                      }
                      resolvedWallet = windowAny.ethereum;
                      _context139.n = 6;
                      break;
                    case 5:
                      throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.");
                    case 6:
                      url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
                      _context139.n = 7;
                      return resolvedWallet.request({
                        method: 'eth_requestAccounts'
                      }).then(function (accs) {
                        return accs;
                      }).catch(function () {
                        throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid");
                      });
                    case 7:
                      accounts = _context139.v;
                      if (!(!accounts || accounts.length === 0)) {
                        _context139.n = 8;
                        break;
                      }
                      throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
                    case 8:
                      address = getAddress(accounts[0]);
                      chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
                      if (chainId) {
                        _context139.n = 10;
                        break;
                      }
                      _context139.n = 9;
                      return resolvedWallet.request({
                        method: 'eth_chainId'
                      });
                    case 9:
                      chainIdHex = _context139.v;
                      chainId = fromHex(chainIdHex);
                    case 10:
                      siweMessage = {
                        domain: url.host,
                        address: address,
                        statement: statement,
                        uri: url.href,
                        version: '1',
                        chainId: chainId,
                        nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
                        issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),
                        expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
                        notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
                        requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
                        resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
                      };
                      message = createSiweMessage(siweMessage);
                      // Sign message
                      _context139.n = 11;
                      return resolvedWallet.request({
                        method: 'personal_sign',
                        params: [toHex(message), address]
                      });
                    case 11:
                      signature = _context139.v;
                    case 12:
                      _context139.p = 12;
                      _context139.n = 13;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=web3"), {
                        headers: this.headers,
                        body: Object.assign({
                          chain: 'ethereum',
                          message: message,
                          signature: signature
                        }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {
                          gotrue_meta_security: {
                            captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken
                          }
                        } : null),
                        xform: _sessionResponse
                      });
                    case 13:
                      _yield$_request2 = _context139.v;
                      data = _yield$_request2.data;
                      error = _yield$_request2.error;
                      if (!error) {
                        _context139.n = 14;
                        break;
                      }
                      throw error;
                    case 14:
                      if (!(!data || !data.session || !data.user)) {
                        _context139.n = 15;
                        break;
                      }
                      invalidTokenError = new AuthInvalidTokenResponseError();
                      return _context139.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: invalidTokenError
                      }));
                    case 15:
                      if (!data.session) {
                        _context139.n = 17;
                        break;
                      }
                      _context139.n = 16;
                      return this._saveSession(data.session);
                    case 16:
                      _context139.n = 17;
                      return this._notifyAllSubscribers('SIGNED_IN', data.session);
                    case 17:
                      return _context139.a(2, this._returnResult({
                        data: Object.assign({}, data),
                        error: error
                      }));
                    case 18:
                      _context139.p = 18;
                      _t116 = _context139.v;
                      if (!isAuthError(_t116)) {
                        _context139.n = 19;
                        break;
                      }
                      return _context139.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t116
                      }));
                    case 19:
                      throw _t116;
                    case 20:
                      return _context139.a(2);
                  }
                }, _callee138, this, [[12, 18]]);
              }));
              function signInWithEthereum(_x235) {
                return _signInWithEthereum.apply(this, arguments);
              }
              return signInWithEthereum;
            }()
          }, {
            key: "signInWithSolana",
            value: function () {
              var _signInWithSolana = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee139(credentials) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, message, signature, chain, wallet, statement, options, resolvedWallet, windowAny, url, output, outputToProcess, maybeSignature, _yield$_request3, data, error, invalidTokenError, _t117;
                return _regenerator().w(function (_context140) {
                  while (1) switch (_context140.p = _context140.n) {
                    case 0:
                      if (!('message' in credentials)) {
                        _context140.n = 1;
                        break;
                      }
                      message = credentials.message;
                      signature = credentials.signature;
                      _context140.n = 17;
                      break;
                    case 1:
                      chain = credentials.chain, wallet = credentials.wallet, statement = credentials.statement, options = credentials.options;
                      if (isBrowser()) {
                        _context140.n = 3;
                        break;
                      }
                      if (!(_typeof2(wallet) !== 'object' || !(options === null || options === void 0 ? void 0 : options.url))) {
                        _context140.n = 2;
                        break;
                      }
                      throw new Error('@supabase/auth-js: Both wallet and url must be specified in non-browser environments.');
                    case 2:
                      resolvedWallet = wallet;
                      _context140.n = 6;
                      break;
                    case 3:
                      if (!(_typeof2(wallet) === 'object')) {
                        _context140.n = 4;
                        break;
                      }
                      resolvedWallet = wallet;
                      _context140.n = 6;
                      break;
                    case 4:
                      windowAny = window;
                      if (!('solana' in windowAny && _typeof2(windowAny.solana) === 'object' && ('signIn' in windowAny.solana && typeof windowAny.solana.signIn === 'function' || 'signMessage' in windowAny.solana && typeof windowAny.solana.signMessage === 'function'))) {
                        _context140.n = 5;
                        break;
                      }
                      resolvedWallet = windowAny.solana;
                      _context140.n = 6;
                      break;
                    case 5:
                      throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.");
                    case 6:
                      url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
                      if (!('signIn' in resolvedWallet && resolvedWallet.signIn)) {
                        _context140.n = 13;
                        break;
                      }
                      _context140.n = 7;
                      return resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({
                        issuedAt: new Date().toISOString()
                      }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
                        // non-overridable properties
                        version: '1',
                        domain: url.host,
                        uri: url.href
                      }), statement ? {
                        statement: statement
                      } : null));
                    case 7:
                      output = _context140.v;
                      if (!(Array.isArray(output) && output[0] && _typeof2(output[0]) === 'object')) {
                        _context140.n = 8;
                        break;
                      }
                      outputToProcess = output[0];
                      _context140.n = 10;
                      break;
                    case 8:
                      if (!(output && _typeof2(output) === 'object' && 'signedMessage' in output && 'signature' in output)) {
                        _context140.n = 9;
                        break;
                      }
                      outputToProcess = output;
                      _context140.n = 10;
                      break;
                    case 9:
                      throw new Error('@supabase/auth-js: Wallet method signIn() returned unrecognized value');
                    case 10:
                      if (!('signedMessage' in outputToProcess && 'signature' in outputToProcess && (typeof outputToProcess.signedMessage === 'string' || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array)) {
                        _context140.n = 11;
                        break;
                      }
                      message = typeof outputToProcess.signedMessage === 'string' ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
                      signature = outputToProcess.signature;
                      _context140.n = 12;
                      break;
                    case 11:
                      throw new Error('@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields');
                    case 12:
                      _context140.n = 17;
                      break;
                    case 13:
                      if (!(!('signMessage' in resolvedWallet) || typeof resolvedWallet.signMessage !== 'function' || !('publicKey' in resolvedWallet) || _typeof2(resolvedWallet) !== 'object' || !resolvedWallet.publicKey || !('toBase58' in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== 'function')) {
                        _context140.n = 14;
                        break;
                      }
                      throw new Error('@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API');
                    case 14:
                      message = ["".concat(url.host, " wants you to sign in with your Solana account:"), resolvedWallet.publicKey.toBase58()].concat(_toConsumableArray(statement ? ['', statement, ''] : ['']), ['Version: 1', "URI: ".concat(url.href), "Issued At: ".concat((_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString())], _toConsumableArray(((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? ["Not Before: ".concat(options.signInWithSolana.notBefore)] : []), _toConsumableArray(((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? ["Expiration Time: ".concat(options.signInWithSolana.expirationTime)] : []), _toConsumableArray(((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? ["Chain ID: ".concat(options.signInWithSolana.chainId)] : []), _toConsumableArray(((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? ["Nonce: ".concat(options.signInWithSolana.nonce)] : []), _toConsumableArray(((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? ["Request ID: ".concat(options.signInWithSolana.requestId)] : []), _toConsumableArray(((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? ['Resources'].concat(_toConsumableArray(options.signInWithSolana.resources.map(function (resource) {
                        return "- ".concat(resource);
                      }))) : [])).join('\n');
                      _context140.n = 15;
                      return resolvedWallet.signMessage(new TextEncoder().encode(message), 'utf8');
                    case 15:
                      maybeSignature = _context140.v;
                      if (!(!maybeSignature || !(maybeSignature instanceof Uint8Array))) {
                        _context140.n = 16;
                        break;
                      }
                      throw new Error('@supabase/auth-js: Wallet signMessage() API returned an recognized value');
                    case 16:
                      signature = maybeSignature;
                    case 17:
                      _context140.p = 17;
                      _context140.n = 18;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=web3"), {
                        headers: this.headers,
                        body: Object.assign({
                          chain: 'solana',
                          message: message,
                          signature: bytesToBase64URL(signature)
                        }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {
                          gotrue_meta_security: {
                            captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken
                          }
                        } : null),
                        xform: _sessionResponse
                      });
                    case 18:
                      _yield$_request3 = _context140.v;
                      data = _yield$_request3.data;
                      error = _yield$_request3.error;
                      if (!error) {
                        _context140.n = 19;
                        break;
                      }
                      throw error;
                    case 19:
                      if (!(!data || !data.session || !data.user)) {
                        _context140.n = 20;
                        break;
                      }
                      invalidTokenError = new AuthInvalidTokenResponseError();
                      return _context140.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: invalidTokenError
                      }));
                    case 20:
                      if (!data.session) {
                        _context140.n = 22;
                        break;
                      }
                      _context140.n = 21;
                      return this._saveSession(data.session);
                    case 21:
                      _context140.n = 22;
                      return this._notifyAllSubscribers('SIGNED_IN', data.session);
                    case 22:
                      return _context140.a(2, this._returnResult({
                        data: Object.assign({}, data),
                        error: error
                      }));
                    case 23:
                      _context140.p = 23;
                      _t117 = _context140.v;
                      if (!isAuthError(_t117)) {
                        _context140.n = 24;
                        break;
                      }
                      return _context140.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t117
                      }));
                    case 24:
                      throw _t117;
                    case 25:
                      return _context140.a(2);
                  }
                }, _callee139, this, [[17, 23]]);
              }));
              function signInWithSolana(_x236) {
                return _signInWithSolana.apply(this, arguments);
              }
              return signInWithSolana;
            }()
          }, {
            key: "_exchangeCodeForSession",
            value: function () {
              var _exchangeCodeForSession3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee140(authCode) {
                var storageItem, _split3, _split4, codeVerifier, redirectType, _yield$_request4, data, error, invalidTokenError, _t118;
                return _regenerator().w(function (_context141) {
                  while (1) switch (_context141.p = _context141.n) {
                    case 0:
                      _context141.n = 1;
                      return getItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 1:
                      storageItem = _context141.v;
                      _split3 = (storageItem !== null && storageItem !== void 0 ? storageItem : '').split('/'), _split4 = _slicedToArray(_split3, 2), codeVerifier = _split4[0], redirectType = _split4[1];
                      _context141.p = 2;
                      if (!(!codeVerifier && this.flowType === 'pkce')) {
                        _context141.n = 3;
                        break;
                      }
                      throw new AuthPKCECodeVerifierMissingError();
                    case 3:
                      _context141.n = 4;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=pkce"), {
                        headers: this.headers,
                        body: {
                          auth_code: authCode,
                          code_verifier: codeVerifier
                        },
                        xform: _sessionResponse
                      });
                    case 4:
                      _yield$_request4 = _context141.v;
                      data = _yield$_request4.data;
                      error = _yield$_request4.error;
                      _context141.n = 5;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 5:
                      if (!error) {
                        _context141.n = 6;
                        break;
                      }
                      throw error;
                    case 6:
                      if (!(!data || !data.session || !data.user)) {
                        _context141.n = 7;
                        break;
                      }
                      invalidTokenError = new AuthInvalidTokenResponseError();
                      return _context141.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null,
                          redirectType: null
                        },
                        error: invalidTokenError
                      }));
                    case 7:
                      if (!data.session) {
                        _context141.n = 9;
                        break;
                      }
                      _context141.n = 8;
                      return this._saveSession(data.session);
                    case 8:
                      _context141.n = 9;
                      return this._notifyAllSubscribers('SIGNED_IN', data.session);
                    case 9:
                      return _context141.a(2, this._returnResult({
                        data: Object.assign(Object.assign({}, data), {
                          redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null
                        }),
                        error: error
                      }));
                    case 10:
                      _context141.p = 10;
                      _t118 = _context141.v;
                      _context141.n = 11;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 11:
                      if (!isAuthError(_t118)) {
                        _context141.n = 12;
                        break;
                      }
                      return _context141.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null,
                          redirectType: null
                        },
                        error: _t118
                      }));
                    case 12:
                      throw _t118;
                    case 13:
                      return _context141.a(2);
                  }
                }, _callee140, this, [[2, 10]]);
              }));
              function _exchangeCodeForSession(_x237) {
                return _exchangeCodeForSession3.apply(this, arguments);
              }
              return _exchangeCodeForSession;
            }()
            /**
             * Allows signing in with an OIDC ID token. The authentication provider used
             * should be enabled and configured.
             */
          }, {
            key: "signInWithIdToken",
            value: (function () {
              var _signInWithIdToken = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee141(credentials) {
                var options, provider, token, access_token, nonce, res, data, error, invalidTokenError, _t119;
                return _regenerator().w(function (_context142) {
                  while (1) switch (_context142.p = _context142.n) {
                    case 0:
                      _context142.p = 0;
                      options = credentials.options, provider = credentials.provider, token = credentials.token, access_token = credentials.access_token, nonce = credentials.nonce;
                      _context142.n = 1;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=id_token"), {
                        headers: this.headers,
                        body: {
                          provider: provider,
                          id_token: token,
                          access_token: access_token,
                          nonce: nonce,
                          gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                          }
                        },
                        xform: _sessionResponse
                      });
                    case 1:
                      res = _context142.v;
                      data = res.data, error = res.error;
                      if (!error) {
                        _context142.n = 2;
                        break;
                      }
                      return _context142.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 2:
                      if (!(!data || !data.session || !data.user)) {
                        _context142.n = 3;
                        break;
                      }
                      invalidTokenError = new AuthInvalidTokenResponseError();
                      return _context142.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: invalidTokenError
                      }));
                    case 3:
                      if (!data.session) {
                        _context142.n = 5;
                        break;
                      }
                      _context142.n = 4;
                      return this._saveSession(data.session);
                    case 4:
                      _context142.n = 5;
                      return this._notifyAllSubscribers('SIGNED_IN', data.session);
                    case 5:
                      return _context142.a(2, this._returnResult({
                        data: data,
                        error: error
                      }));
                    case 6:
                      _context142.p = 6;
                      _t119 = _context142.v;
                      if (!isAuthError(_t119)) {
                        _context142.n = 7;
                        break;
                      }
                      return _context142.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t119
                      }));
                    case 7:
                      throw _t119;
                    case 8:
                      return _context142.a(2);
                  }
                }, _callee141, this, [[0, 6]]);
              }));
              function signInWithIdToken(_x238) {
                return _signInWithIdToken.apply(this, arguments);
              }
              return signInWithIdToken;
            }()
            /**
             * Log in a user using magiclink or a one-time password (OTP).
             *
             * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
             * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
             * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
             *
             * Be aware that you may get back an error message that will not distinguish
             * between the cases where the account does not exist or, that the account
             * can only be accessed via social login.
             *
             * Do note that you will need to configure a Whatsapp sender on Twilio
             * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
             * channel is not supported on other providers
             * at this time.
             * This method supports PKCE when an email is passed.
             */
            )
          }, {
            key: "signInWithOtp",
            value: (function () {
              var _signInWithOtp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee142(credentials) {
                var _a, _b, _c, _d, _e, email, options, codeChallenge, codeChallengeMethod, _yield$getCodeChallen3, _yield$getCodeChallen4, _yield$_request5, error, phone, _options8, _yield$_request6, data, _error2, _t120;
                return _regenerator().w(function (_context143) {
                  while (1) switch (_context143.p = _context143.n) {
                    case 0:
                      _context143.p = 0;
                      if (!('email' in credentials)) {
                        _context143.n = 4;
                        break;
                      }
                      email = credentials.email, options = credentials.options;
                      codeChallenge = null;
                      codeChallengeMethod = null;
                      if (!(this.flowType === 'pkce')) {
                        _context143.n = 2;
                        break;
                      }
                      ;
                      _context143.n = 1;
                      return getCodeChallengeAndMethod(this.storage, this.storageKey);
                    case 1:
                      _yield$getCodeChallen3 = _context143.v;
                      _yield$getCodeChallen4 = _slicedToArray(_yield$getCodeChallen3, 2);
                      codeChallenge = _yield$getCodeChallen4[0];
                      codeChallengeMethod = _yield$getCodeChallen4[1];
                    case 2:
                      _context143.n = 3;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/otp"), {
                        headers: this.headers,
                        body: {
                          email: email,
                          data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                          create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
                          gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                          },
                          code_challenge: codeChallenge,
                          code_challenge_method: codeChallengeMethod
                        },
                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
                      });
                    case 3:
                      _yield$_request5 = _context143.v;
                      error = _yield$_request5.error;
                      return _context143.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 4:
                      if (!('phone' in credentials)) {
                        _context143.n = 6;
                        break;
                      }
                      phone = credentials.phone, _options8 = credentials.options;
                      _context143.n = 5;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/otp"), {
                        headers: this.headers,
                        body: {
                          phone: phone,
                          data: (_c = _options8 === null || _options8 === void 0 ? void 0 : _options8.data) !== null && _c !== void 0 ? _c : {},
                          create_user: (_d = _options8 === null || _options8 === void 0 ? void 0 : _options8.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
                          gotrue_meta_security: {
                            captcha_token: _options8 === null || _options8 === void 0 ? void 0 : _options8.captchaToken
                          },
                          channel: (_e = _options8 === null || _options8 === void 0 ? void 0 : _options8.channel) !== null && _e !== void 0 ? _e : 'sms'
                        }
                      });
                    case 5:
                      _yield$_request6 = _context143.v;
                      data = _yield$_request6.data;
                      _error2 = _yield$_request6.error;
                      return _context143.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null,
                          messageId: data === null || data === void 0 ? void 0 : data.message_id
                        },
                        error: _error2
                      }));
                    case 6:
                      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');
                    case 7:
                      _context143.p = 7;
                      _t120 = _context143.v;
                      _context143.n = 8;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 8:
                      if (!isAuthError(_t120)) {
                        _context143.n = 9;
                        break;
                      }
                      return _context143.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t120
                      }));
                    case 9:
                      throw _t120;
                    case 10:
                      return _context143.a(2);
                  }
                }, _callee142, this, [[0, 7]]);
              }));
              function signInWithOtp(_x239) {
                return _signInWithOtp.apply(this, arguments);
              }
              return signInWithOtp;
            }()
            /**
             * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
             */
            )
          }, {
            key: "verifyOtp",
            value: (function () {
              var _verifyOtp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee143(params) {
                var _a, _b, redirectTo, captchaToken, _yield$_request7, data, error, tokenVerificationError, session, user, _t121;
                return _regenerator().w(function (_context144) {
                  while (1) switch (_context144.p = _context144.n) {
                    case 0:
                      _context144.p = 0;
                      redirectTo = undefined;
                      captchaToken = undefined;
                      if ('options' in params) {
                        redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
                        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
                      }
                      _context144.n = 1;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/verify"), {
                        headers: this.headers,
                        body: Object.assign(Object.assign({}, params), {
                          gotrue_meta_security: {
                            captcha_token: captchaToken
                          }
                        }),
                        redirectTo: redirectTo,
                        xform: _sessionResponse
                      });
                    case 1:
                      _yield$_request7 = _context144.v;
                      data = _yield$_request7.data;
                      error = _yield$_request7.error;
                      if (!error) {
                        _context144.n = 2;
                        break;
                      }
                      throw error;
                    case 2:
                      if (data) {
                        _context144.n = 3;
                        break;
                      }
                      tokenVerificationError = new Error('An error occurred on token verification.');
                      throw tokenVerificationError;
                    case 3:
                      session = data.session;
                      user = data.user;
                      if (!(session === null || session === void 0 ? void 0 : session.access_token)) {
                        _context144.n = 5;
                        break;
                      }
                      _context144.n = 4;
                      return this._saveSession(session);
                    case 4:
                      _context144.n = 5;
                      return this._notifyAllSubscribers(params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN', session);
                    case 5:
                      return _context144.a(2, this._returnResult({
                        data: {
                          user: user,
                          session: session
                        },
                        error: null
                      }));
                    case 6:
                      _context144.p = 6;
                      _t121 = _context144.v;
                      if (!isAuthError(_t121)) {
                        _context144.n = 7;
                        break;
                      }
                      return _context144.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t121
                      }));
                    case 7:
                      throw _t121;
                    case 8:
                      return _context144.a(2);
                  }
                }, _callee143, this, [[0, 6]]);
              }));
              function verifyOtp(_x240) {
                return _verifyOtp.apply(this, arguments);
              }
              return verifyOtp;
            }()
            /**
             * Attempts a single-sign on using an enterprise Identity Provider. A
             * successful SSO attempt will redirect the current page to the identity
             * provider authorization page. The redirect URL is implementation and SSO
             * protocol specific.
             *
             * You can use it by providing a SSO domain. Typically you can extract this
             * domain by asking users for their email address. If this domain is
             * registered on the Auth instance the redirect will use that organization's
             * currently active SSO Identity Provider for the login.
             *
             * If you have built an organization-specific login page, you can use the
             * organization's SSO Identity Provider UUID directly instead.
             */
            )
          }, {
            key: "signInWithSSO",
            value: (function () {
              var _signInWithSSO = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee144(params) {
                var _a, _b, _c, _d, _e, codeChallenge, codeChallengeMethod, _yield$getCodeChallen5, _yield$getCodeChallen6, result, _t122;
                return _regenerator().w(function (_context145) {
                  while (1) switch (_context145.p = _context145.n) {
                    case 0:
                      _context145.p = 0;
                      codeChallenge = null;
                      codeChallengeMethod = null;
                      if (!(this.flowType === 'pkce')) {
                        _context145.n = 2;
                        break;
                      }
                      ;
                      _context145.n = 1;
                      return getCodeChallengeAndMethod(this.storage, this.storageKey);
                    case 1:
                      _yield$getCodeChallen5 = _context145.v;
                      _yield$getCodeChallen6 = _slicedToArray(_yield$getCodeChallen5, 2);
                      codeChallenge = _yield$getCodeChallen6[0];
                      codeChallengeMethod = _yield$getCodeChallen6[1];
                    case 2:
                      _context145.n = 3;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/sso"), {
                        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {
                          provider_id: params.providerId
                        } : null), 'domain' in params ? {
                          domain: params.domain
                        } : null), {
                          redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined
                        }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {
                          gotrue_meta_security: {
                            captcha_token: params.options.captchaToken
                          }
                        } : null), {
                          skip_http_redirect: true,
                          code_challenge: codeChallenge,
                          code_challenge_method: codeChallengeMethod
                        }),
                        headers: this.headers,
                        xform: _ssoResponse
                      });
                    case 3:
                      result = _context145.v;
                      // Automatically redirect in browser unless skipBrowserRedirect is true
                      if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && isBrowser() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {
                        window.location.assign(result.data.url);
                      }
                      return _context145.a(2, this._returnResult(result));
                    case 4:
                      _context145.p = 4;
                      _t122 = _context145.v;
                      _context145.n = 5;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 5:
                      if (!isAuthError(_t122)) {
                        _context145.n = 6;
                        break;
                      }
                      return _context145.a(2, this._returnResult({
                        data: null,
                        error: _t122
                      }));
                    case 6:
                      throw _t122;
                    case 7:
                      return _context145.a(2);
                  }
                }, _callee144, this, [[0, 4]]);
              }));
              function signInWithSSO(_x241) {
                return _signInWithSSO.apply(this, arguments);
              }
              return signInWithSSO;
            }()
            /**
             * Sends a reauthentication OTP to the user's email or phone number.
             * Requires the user to be signed-in.
             */
            )
          }, {
            key: "reauthenticate",
            value: (function () {
              var _reauthenticate2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee146() {
                var _this127 = this;
                return _regenerator().w(function (_context147) {
                  while (1) switch (_context147.n) {
                    case 0:
                      _context147.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context147.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee145() {
                        return _regenerator().w(function (_context146) {
                          while (1) switch (_context146.n) {
                            case 0:
                              _context146.n = 1;
                              return _this127._reauthenticate();
                            case 1:
                              return _context146.a(2, _context146.v);
                          }
                        }, _callee145);
                      })));
                    case 2:
                      return _context147.a(2, _context147.v);
                  }
                }, _callee146, this);
              }));
              function reauthenticate() {
                return _reauthenticate2.apply(this, arguments);
              }
              return reauthenticate;
            }())
          }, {
            key: "_reauthenticate",
            value: function () {
              var _reauthenticate3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee148() {
                var _this128 = this;
                var _t123;
                return _regenerator().w(function (_context149) {
                  while (1) switch (_context149.p = _context149.n) {
                    case 0:
                      _context149.p = 0;
                      _context149.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref224 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee147(result) {
                          var session, sessionError, _yield$_request8, error;
                          return _regenerator().w(function (_context148) {
                            while (1) switch (_context148.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context148.n = 1;
                                  break;
                                }
                                throw sessionError;
                              case 1:
                                if (session) {
                                  _context148.n = 2;
                                  break;
                                }
                                throw new AuthSessionMissingError();
                              case 2:
                                _context148.n = 3;
                                return _request(_this128.fetch, 'GET', "".concat(_this128.url, "/reauthenticate"), {
                                  headers: _this128.headers,
                                  jwt: session.access_token
                                });
                              case 3:
                                _yield$_request8 = _context148.v;
                                error = _yield$_request8.error;
                                return _context148.a(2, _this128._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: error
                                }));
                            }
                          }, _callee147);
                        }));
                        return function (_x242) {
                          return _ref224.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context149.a(2, _context149.v);
                    case 2:
                      _context149.p = 2;
                      _t123 = _context149.v;
                      if (!isAuthError(_t123)) {
                        _context149.n = 3;
                        break;
                      }
                      return _context149.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t123
                      }));
                    case 3:
                      throw _t123;
                    case 4:
                      return _context149.a(2);
                  }
                }, _callee148, this, [[0, 2]]);
              }));
              function _reauthenticate() {
                return _reauthenticate3.apply(this, arguments);
              }
              return _reauthenticate;
            }()
            /**
             * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
             */
          }, {
            key: "resend",
            value: (function () {
              var _resend = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee149(credentials) {
                var endpoint, email, type, options, _yield$_request9, error, phone, _type3, _options9, _yield$_request0, data, _error3, _t124;
                return _regenerator().w(function (_context150) {
                  while (1) switch (_context150.p = _context150.n) {
                    case 0:
                      _context150.p = 0;
                      endpoint = "".concat(this.url, "/resend");
                      if (!('email' in credentials)) {
                        _context150.n = 2;
                        break;
                      }
                      email = credentials.email, type = credentials.type, options = credentials.options;
                      _context150.n = 1;
                      return _request(this.fetch, 'POST', endpoint, {
                        headers: this.headers,
                        body: {
                          email: email,
                          type: type,
                          gotrue_meta_security: {
                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                          }
                        },
                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
                      });
                    case 1:
                      _yield$_request9 = _context150.v;
                      error = _yield$_request9.error;
                      return _context150.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 2:
                      if (!('phone' in credentials)) {
                        _context150.n = 4;
                        break;
                      }
                      phone = credentials.phone, _type3 = credentials.type, _options9 = credentials.options;
                      _context150.n = 3;
                      return _request(this.fetch, 'POST', endpoint, {
                        headers: this.headers,
                        body: {
                          phone: phone,
                          type: _type3,
                          gotrue_meta_security: {
                            captcha_token: _options9 === null || _options9 === void 0 ? void 0 : _options9.captchaToken
                          }
                        }
                      });
                    case 3:
                      _yield$_request0 = _context150.v;
                      data = _yield$_request0.data;
                      _error3 = _yield$_request0.error;
                      return _context150.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null,
                          messageId: data === null || data === void 0 ? void 0 : data.message_id
                        },
                        error: _error3
                      }));
                    case 4:
                      throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a type');
                    case 5:
                      _context150.p = 5;
                      _t124 = _context150.v;
                      if (!isAuthError(_t124)) {
                        _context150.n = 6;
                        break;
                      }
                      return _context150.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t124
                      }));
                    case 6:
                      throw _t124;
                    case 7:
                      return _context150.a(2);
                  }
                }, _callee149, this, [[0, 5]]);
              }));
              function resend(_x243) {
                return _resend.apply(this, arguments);
              }
              return resend;
            }()
            /**
             * Returns the session, refreshing it if necessary.
             *
             * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
             *
             * **IMPORTANT:** This method loads values directly from the storage attached
             * to the client. If that storage is based on request cookies for example,
             * the values in it may not be authentic and therefore it's strongly advised
             * against using this method and its results in such circumstances. A warning
             * will be emitted if this is detected. Use {@link #getUser()} instead.
             */
            )
          }, {
            key: "getSession",
            value: (function () {
              var _getSession = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee152() {
                var _this129 = this;
                var result;
                return _regenerator().w(function (_context153) {
                  while (1) switch (_context153.n) {
                    case 0:
                      _context153.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context153.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee151() {
                        return _regenerator().w(function (_context152) {
                          while (1) switch (_context152.n) {
                            case 0:
                              return _context152.a(2, _this129._useSession(/*#__PURE__*/function () {
                                var _ref226 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee150(result) {
                                  return _regenerator().w(function (_context151) {
                                    while (1) switch (_context151.n) {
                                      case 0:
                                        return _context151.a(2, result);
                                    }
                                  }, _callee150);
                                }));
                                return function (_x244) {
                                  return _ref226.apply(this, arguments);
                                };
                              }()));
                          }
                        }, _callee151);
                      })));
                    case 2:
                      result = _context153.v;
                      return _context153.a(2, result);
                  }
                }, _callee152, this);
              }));
              function getSession() {
                return _getSession.apply(this, arguments);
              }
              return getSession;
            }()
            /**
             * Acquires a global lock based on the storage key.
             */
            )
          }, {
            key: "_acquireLock",
            value: (function () {
              var _acquireLock2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee157(acquireTimeout, fn) {
                var _this130 = this;
                var last, result;
                return _regenerator().w(function (_context158) {
                  while (1) switch (_context158.p = _context158.n) {
                    case 0:
                      this._debug('#_acquireLock', 'begin', acquireTimeout);
                      _context158.p = 1;
                      if (!this.lockAcquired) {
                        _context158.n = 2;
                        break;
                      }
                      last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
                      result = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee153() {
                        return _regenerator().w(function (_context154) {
                          while (1) switch (_context154.n) {
                            case 0:
                              _context154.n = 1;
                              return last;
                            case 1:
                              _context154.n = 2;
                              return fn();
                            case 2:
                              return _context154.a(2, _context154.v);
                          }
                        }, _callee153);
                      }))();
                      this.pendingInLock.push(_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee154() {
                        var _t125;
                        return _regenerator().w(function (_context155) {
                          while (1) switch (_context155.p = _context155.n) {
                            case 0:
                              _context155.p = 0;
                              _context155.n = 1;
                              return result;
                            case 1:
                              _context155.n = 3;
                              break;
                            case 2:
                              _context155.p = 2;
                              _t125 = _context155.v;
                            case 3:
                              return _context155.a(2);
                          }
                        }, _callee154, null, [[0, 2]]);
                      }))());
                      return _context158.a(2, result);
                    case 2:
                      _context158.n = 3;
                      return this.lock("lock:".concat(this.storageKey), acquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee156() {
                        var _result, waitOn;
                        return _regenerator().w(function (_context157) {
                          while (1) switch (_context157.p = _context157.n) {
                            case 0:
                              _this130._debug('#_acquireLock', 'lock acquired for storage key', _this130.storageKey);
                              _context157.p = 1;
                              _this130.lockAcquired = true;
                              _result = fn();
                              _this130.pendingInLock.push(_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee155() {
                                var _t126;
                                return _regenerator().w(function (_context156) {
                                  while (1) switch (_context156.p = _context156.n) {
                                    case 0:
                                      _context156.p = 0;
                                      _context156.n = 1;
                                      return _result;
                                    case 1:
                                      _context156.n = 3;
                                      break;
                                    case 2:
                                      _context156.p = 2;
                                      _t126 = _context156.v;
                                    case 3:
                                      return _context156.a(2);
                                  }
                                }, _callee155, null, [[0, 2]]);
                              }))());
                              _context157.n = 2;
                              return _result;
                            case 2:
                              if (!_this130.pendingInLock.length) {
                                _context157.n = 4;
                                break;
                              }
                              waitOn = _toConsumableArray(_this130.pendingInLock);
                              _context157.n = 3;
                              return Promise.all(waitOn);
                            case 3:
                              _this130.pendingInLock.splice(0, waitOn.length);
                              _context157.n = 2;
                              break;
                            case 4:
                              _context157.n = 5;
                              return _result;
                            case 5:
                              return _context157.a(2, _context157.v);
                            case 6:
                              _context157.p = 6;
                              _this130._debug('#_acquireLock', 'lock released for storage key', _this130.storageKey);
                              _this130.lockAcquired = false;
                              return _context157.f(6);
                            case 7:
                              return _context157.a(2);
                          }
                        }, _callee156, null, [[1,, 6, 7]]);
                      })));
                    case 3:
                      return _context158.a(2, _context158.v);
                    case 4:
                      _context158.p = 4;
                      this._debug('#_acquireLock', 'end');
                      return _context158.f(4);
                    case 5:
                      return _context158.a(2);
                  }
                }, _callee157, this, [[1,, 4, 5]]);
              }));
              function _acquireLock(_x245, _x246) {
                return _acquireLock2.apply(this, arguments);
              }
              return _acquireLock;
            }()
            /**
             * Use instead of {@link #getSession} inside the library. It is
             * semantically usually what you want, as getting a session involves some
             * processing afterwards that requires only one client operating on the
             * session at once across multiple tabs or processes.
             */
            )
          }, {
            key: "_useSession",
            value: (function () {
              var _useSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee158(fn) {
                var result;
                return _regenerator().w(function (_context159) {
                  while (1) switch (_context159.p = _context159.n) {
                    case 0:
                      this._debug('#_useSession', 'begin');
                      _context159.p = 1;
                      _context159.n = 2;
                      return this.__loadSession();
                    case 2:
                      result = _context159.v;
                      _context159.n = 3;
                      return fn(result);
                    case 3:
                      return _context159.a(2, _context159.v);
                    case 4:
                      _context159.p = 4;
                      this._debug('#_useSession', 'end');
                      return _context159.f(4);
                    case 5:
                      return _context159.a(2);
                  }
                }, _callee158, this, [[1,, 4, 5]]);
              }));
              function _useSession(_x247) {
                return _useSession2.apply(this, arguments);
              }
              return _useSession;
            }()
            /**
             * NEVER USE DIRECTLY!
             *
             * Always use {@link #_useSession}.
             */
            )
          }, {
            key: "__loadSession",
            value: (function () {
              var _loadSession = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee159() {
                var currentSession, maybeSession, hasExpired, maybeUser, suppressWarningRef, _yield$this$_callRefr, session, error;
                return _regenerator().w(function (_context160) {
                  while (1) switch (_context160.p = _context160.n) {
                    case 0:
                      this._debug('#__loadSession()', 'begin');
                      if (!this.lockAcquired) {
                        this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack);
                      }
                      _context160.p = 1;
                      currentSession = null;
                      _context160.n = 2;
                      return getItemAsync(this.storage, this.storageKey);
                    case 2:
                      maybeSession = _context160.v;
                      this._debug('#getSession()', 'session from storage', maybeSession);
                      if (!(maybeSession !== null)) {
                        _context160.n = 4;
                        break;
                      }
                      if (!this._isValidSession(maybeSession)) {
                        _context160.n = 3;
                        break;
                      }
                      currentSession = maybeSession;
                      _context160.n = 4;
                      break;
                    case 3:
                      this._debug('#getSession()', 'session from storage is not valid');
                      _context160.n = 4;
                      return this._removeSession();
                    case 4:
                      if (currentSession) {
                        _context160.n = 5;
                        break;
                      }
                      return _context160.a(2, {
                        data: {
                          session: null
                        },
                        error: null
                      });
                    case 5:
                      // A session is considered expired before the access token _actually_
                      // expires. When the autoRefreshToken option is off (or when the tab is
                      // in the background), very eager users of getSession() -- like
                      // realtime-js -- might send a valid JWT which will expire by the time it
                      // reaches the server.
                      hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < EXPIRY_MARGIN_MS : false;
                      this._debug('#__loadSession()', "session has".concat(hasExpired ? '' : ' not', " expired"), 'expires_at', currentSession.expires_at);
                      if (hasExpired) {
                        _context160.n = 8;
                        break;
                      }
                      if (!this.userStorage) {
                        _context160.n = 7;
                        break;
                      }
                      _context160.n = 6;
                      return getItemAsync(this.userStorage, this.storageKey + '-user');
                    case 6:
                      maybeUser = _context160.v;
                      if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
                        currentSession.user = maybeUser.user;
                      } else {
                        currentSession.user = userNotAvailableProxy();
                      }
                    case 7:
                      // Wrap the user object with a warning proxy on the server
                      // This warns when properties of the user are accessed, not when session.user itself is accessed
                      if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
                        suppressWarningRef = {
                          value: this.suppressGetSessionWarning
                        };
                        currentSession.user = insecureUserWarningProxy(currentSession.user, suppressWarningRef);
                        // Update the client-level suppression flag when the proxy suppresses the warning
                        if (suppressWarningRef.value) {
                          this.suppressGetSessionWarning = true;
                        }
                      }
                      return _context160.a(2, {
                        data: {
                          session: currentSession
                        },
                        error: null
                      });
                    case 8:
                      _context160.n = 9;
                      return this._callRefreshToken(currentSession.refresh_token);
                    case 9:
                      _yield$this$_callRefr = _context160.v;
                      session = _yield$this$_callRefr.data;
                      error = _yield$this$_callRefr.error;
                      if (!error) {
                        _context160.n = 10;
                        break;
                      }
                      return _context160.a(2, this._returnResult({
                        data: {
                          session: null
                        },
                        error: error
                      }));
                    case 10:
                      return _context160.a(2, this._returnResult({
                        data: {
                          session: session
                        },
                        error: null
                      }));
                    case 11:
                      _context160.p = 11;
                      this._debug('#__loadSession()', 'end');
                      return _context160.f(11);
                    case 12:
                      return _context160.a(2);
                  }
                }, _callee159, this, [[1,, 11, 12]]);
              }));
              function __loadSession() {
                return _loadSession.apply(this, arguments);
              }
              return __loadSession;
            }()
            /**
             * Gets the current user details if there is an existing session. This method
             * performs a network request to the Supabase Auth server, so the returned
             * value is authentic and can be used to base authorization rules on.
             *
             * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
             */
            )
          }, {
            key: "getUser",
            value: (function () {
              var _getUser2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee161(jwt) {
                var _this131 = this;
                var result;
                return _regenerator().w(function (_context162) {
                  while (1) switch (_context162.n) {
                    case 0:
                      if (!jwt) {
                        _context162.n = 2;
                        break;
                      }
                      _context162.n = 1;
                      return this._getUser(jwt);
                    case 1:
                      return _context162.a(2, _context162.v);
                    case 2:
                      _context162.n = 3;
                      return this.initializePromise;
                    case 3:
                      _context162.n = 4;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee160() {
                        return _regenerator().w(function (_context161) {
                          while (1) switch (_context161.n) {
                            case 0:
                              _context161.n = 1;
                              return _this131._getUser();
                            case 1:
                              return _context161.a(2, _context161.v);
                          }
                        }, _callee160);
                      })));
                    case 4:
                      result = _context162.v;
                      if (result.data.user) {
                        this.suppressGetSessionWarning = true;
                      }
                      return _context162.a(2, result);
                  }
                }, _callee161, this);
              }));
              function getUser(_x248) {
                return _getUser2.apply(this, arguments);
              }
              return getUser;
            }())
          }, {
            key: "_getUser",
            value: function () {
              var _getUser3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee163(jwt) {
                var _this132 = this;
                var _t127;
                return _regenerator().w(function (_context164) {
                  while (1) switch (_context164.p = _context164.n) {
                    case 0:
                      _context164.p = 0;
                      if (!jwt) {
                        _context164.n = 2;
                        break;
                      }
                      _context164.n = 1;
                      return _request(this.fetch, 'GET', "".concat(this.url, "/user"), {
                        headers: this.headers,
                        jwt: jwt,
                        xform: _userResponse
                      });
                    case 1:
                      return _context164.a(2, _context164.v);
                    case 2:
                      _context164.n = 3;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref232 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee162(result) {
                          var _a, _b, _c, data, error;
                          return _regenerator().w(function (_context163) {
                            while (1) switch (_context163.n) {
                              case 0:
                                data = result.data, error = result.error;
                                if (!error) {
                                  _context163.n = 1;
                                  break;
                                }
                                throw error;
                              case 1:
                                if (!(!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !_this132.hasCustomAuthorizationHeader)) {
                                  _context163.n = 2;
                                  break;
                                }
                                return _context163.a(2, {
                                  data: {
                                    user: null
                                  },
                                  error: new AuthSessionMissingError()
                                });
                              case 2:
                                _context163.n = 3;
                                return _request(_this132.fetch, 'GET', "".concat(_this132.url, "/user"), {
                                  headers: _this132.headers,
                                  jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,
                                  xform: _userResponse
                                });
                              case 3:
                                return _context163.a(2, _context163.v);
                            }
                          }, _callee162);
                        }));
                        return function (_x250) {
                          return _ref232.apply(this, arguments);
                        };
                      }());
                    case 3:
                      return _context164.a(2, _context164.v);
                    case 4:
                      _context164.p = 4;
                      _t127 = _context164.v;
                      if (!isAuthError(_t127)) {
                        _context164.n = 7;
                        break;
                      }
                      if (!isAuthSessionMissingError(_t127)) {
                        _context164.n = 6;
                        break;
                      }
                      _context164.n = 5;
                      return this._removeSession();
                    case 5:
                      _context164.n = 6;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 6:
                      return _context164.a(2, this._returnResult({
                        data: {
                          user: null
                        },
                        error: _t127
                      }));
                    case 7:
                      throw _t127;
                    case 8:
                      return _context164.a(2);
                  }
                }, _callee163, this, [[0, 4]]);
              }));
              function _getUser(_x249) {
                return _getUser3.apply(this, arguments);
              }
              return _getUser;
            }()
            /**
             * Updates user data for a logged in user.
             */
          }, {
            key: "updateUser",
            value: (function () {
              var _updateUser2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee165(attributes) {
                var _this133 = this;
                var options,
                  _args165 = arguments;
                return _regenerator().w(function (_context166) {
                  while (1) switch (_context166.n) {
                    case 0:
                      options = _args165.length > 1 && _args165[1] !== undefined ? _args165[1] : {};
                      _context166.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context166.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee164() {
                        return _regenerator().w(function (_context165) {
                          while (1) switch (_context165.n) {
                            case 0:
                              _context165.n = 1;
                              return _this133._updateUser(attributes, options);
                            case 1:
                              return _context165.a(2, _context165.v);
                          }
                        }, _callee164);
                      })));
                    case 2:
                      return _context166.a(2, _context166.v);
                  }
                }, _callee165, this);
              }));
              function updateUser(_x251) {
                return _updateUser2.apply(this, arguments);
              }
              return updateUser;
            }())
          }, {
            key: "_updateUser",
            value: function () {
              var _updateUser3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee167(attributes) {
                var _this134 = this;
                var options,
                  _args167 = arguments,
                  _t128;
                return _regenerator().w(function (_context168) {
                  while (1) switch (_context168.p = _context168.n) {
                    case 0:
                      options = _args167.length > 1 && _args167[1] !== undefined ? _args167[1] : {};
                      _context168.p = 1;
                      _context168.n = 2;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref234 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee166(result) {
                          var sessionData, sessionError, session, codeChallenge, codeChallengeMethod, _yield$getCodeChallen7, _yield$getCodeChallen8, _yield$_request1, data, userError;
                          return _regenerator().w(function (_context167) {
                            while (1) switch (_context167.n) {
                              case 0:
                                sessionData = result.data, sessionError = result.error;
                                if (!sessionError) {
                                  _context167.n = 1;
                                  break;
                                }
                                throw sessionError;
                              case 1:
                                if (sessionData.session) {
                                  _context167.n = 2;
                                  break;
                                }
                                throw new AuthSessionMissingError();
                              case 2:
                                session = sessionData.session;
                                codeChallenge = null;
                                codeChallengeMethod = null;
                                if (!(_this134.flowType === 'pkce' && attributes.email != null)) {
                                  _context167.n = 4;
                                  break;
                                }
                                ;
                                _context167.n = 3;
                                return getCodeChallengeAndMethod(_this134.storage, _this134.storageKey);
                              case 3:
                                _yield$getCodeChallen7 = _context167.v;
                                _yield$getCodeChallen8 = _slicedToArray(_yield$getCodeChallen7, 2);
                                codeChallenge = _yield$getCodeChallen8[0];
                                codeChallengeMethod = _yield$getCodeChallen8[1];
                              case 4:
                                _context167.n = 5;
                                return _request(_this134.fetch, 'PUT', "".concat(_this134.url, "/user"), {
                                  headers: _this134.headers,
                                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
                                  body: Object.assign(Object.assign({}, attributes), {
                                    code_challenge: codeChallenge,
                                    code_challenge_method: codeChallengeMethod
                                  }),
                                  jwt: session.access_token,
                                  xform: _userResponse
                                });
                              case 5:
                                _yield$_request1 = _context167.v;
                                data = _yield$_request1.data;
                                userError = _yield$_request1.error;
                                if (!userError) {
                                  _context167.n = 6;
                                  break;
                                }
                                throw userError;
                              case 6:
                                session.user = data.user;
                                _context167.n = 7;
                                return _this134._saveSession(session);
                              case 7:
                                _context167.n = 8;
                                return _this134._notifyAllSubscribers('USER_UPDATED', session);
                              case 8:
                                return _context167.a(2, _this134._returnResult({
                                  data: {
                                    user: session.user
                                  },
                                  error: null
                                }));
                            }
                          }, _callee166);
                        }));
                        return function (_x253) {
                          return _ref234.apply(this, arguments);
                        };
                      }());
                    case 2:
                      return _context168.a(2, _context168.v);
                    case 3:
                      _context168.p = 3;
                      _t128 = _context168.v;
                      _context168.n = 4;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 4:
                      if (!isAuthError(_t128)) {
                        _context168.n = 5;
                        break;
                      }
                      return _context168.a(2, this._returnResult({
                        data: {
                          user: null
                        },
                        error: _t128
                      }));
                    case 5:
                      throw _t128;
                    case 6:
                      return _context168.a(2);
                  }
                }, _callee167, this, [[1, 3]]);
              }));
              function _updateUser(_x252) {
                return _updateUser3.apply(this, arguments);
              }
              return _updateUser;
            }()
            /**
             * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
             * If the refresh token or access token in the current session is invalid, an error will be thrown.
             * @param currentSession The current session that minimally contains an access token and refresh token.
             */
          }, {
            key: "setSession",
            value: (function () {
              var _setSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee169(currentSession) {
                var _this135 = this;
                return _regenerator().w(function (_context170) {
                  while (1) switch (_context170.n) {
                    case 0:
                      _context170.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context170.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee168() {
                        return _regenerator().w(function (_context169) {
                          while (1) switch (_context169.n) {
                            case 0:
                              _context169.n = 1;
                              return _this135._setSession(currentSession);
                            case 1:
                              return _context169.a(2, _context169.v);
                          }
                        }, _callee168);
                      })));
                    case 2:
                      return _context170.a(2, _context170.v);
                  }
                }, _callee169, this);
              }));
              function setSession(_x254) {
                return _setSession2.apply(this, arguments);
              }
              return setSession;
            }())
          }, {
            key: "_setSession",
            value: function () {
              var _setSession3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee170(currentSession) {
                var timeNow, _expiresAt, hasExpired, session, _decodeJWT, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$_getUser, data, _error4, _t129;
                return _regenerator().w(function (_context171) {
                  while (1) switch (_context171.p = _context171.n) {
                    case 0:
                      _context171.p = 0;
                      if (!(!currentSession.access_token || !currentSession.refresh_token)) {
                        _context171.n = 1;
                        break;
                      }
                      throw new AuthSessionMissingError();
                    case 1:
                      timeNow = Date.now() / 1000;
                      _expiresAt = timeNow;
                      hasExpired = true;
                      session = null;
                      _decodeJWT = decodeJWT(currentSession.access_token), payload = _decodeJWT.payload;
                      if (payload.exp) {
                        _expiresAt = payload.exp;
                        hasExpired = _expiresAt <= timeNow;
                      }
                      if (!hasExpired) {
                        _context171.n = 5;
                        break;
                      }
                      _context171.n = 2;
                      return this._callRefreshToken(currentSession.refresh_token);
                    case 2:
                      _yield$this$_callRefr2 = _context171.v;
                      refreshedSession = _yield$this$_callRefr2.data;
                      error = _yield$this$_callRefr2.error;
                      if (!error) {
                        _context171.n = 3;
                        break;
                      }
                      return _context171.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: error
                      }));
                    case 3:
                      if (refreshedSession) {
                        _context171.n = 4;
                        break;
                      }
                      return _context171.a(2, {
                        data: {
                          user: null,
                          session: null
                        },
                        error: null
                      });
                    case 4:
                      session = refreshedSession;
                      _context171.n = 9;
                      break;
                    case 5:
                      _context171.n = 6;
                      return this._getUser(currentSession.access_token);
                    case 6:
                      _yield$this$_getUser = _context171.v;
                      data = _yield$this$_getUser.data;
                      _error4 = _yield$this$_getUser.error;
                      if (!_error4) {
                        _context171.n = 7;
                        break;
                      }
                      throw _error4;
                    case 7:
                      session = {
                        access_token: currentSession.access_token,
                        refresh_token: currentSession.refresh_token,
                        user: data.user,
                        token_type: 'bearer',
                        expires_in: _expiresAt - timeNow,
                        expires_at: _expiresAt
                      };
                      _context171.n = 8;
                      return this._saveSession(session);
                    case 8:
                      _context171.n = 9;
                      return this._notifyAllSubscribers('SIGNED_IN', session);
                    case 9:
                      return _context171.a(2, this._returnResult({
                        data: {
                          user: session.user,
                          session: session
                        },
                        error: null
                      }));
                    case 10:
                      _context171.p = 10;
                      _t129 = _context171.v;
                      if (!isAuthError(_t129)) {
                        _context171.n = 11;
                        break;
                      }
                      return _context171.a(2, this._returnResult({
                        data: {
                          session: null,
                          user: null
                        },
                        error: _t129
                      }));
                    case 11:
                      throw _t129;
                    case 12:
                      return _context171.a(2);
                  }
                }, _callee170, this, [[0, 10]]);
              }));
              function _setSession(_x255) {
                return _setSession3.apply(this, arguments);
              }
              return _setSession;
            }()
            /**
             * Returns a new session, regardless of expiry status.
             * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
             * If the current session's refresh token is invalid, an error will be thrown.
             * @param currentSession The current session. If passed in, it must contain a refresh token.
             */
          }, {
            key: "refreshSession",
            value: (function () {
              var _refreshSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee172(currentSession) {
                var _this136 = this;
                return _regenerator().w(function (_context173) {
                  while (1) switch (_context173.n) {
                    case 0:
                      _context173.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context173.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee171() {
                        return _regenerator().w(function (_context172) {
                          while (1) switch (_context172.n) {
                            case 0:
                              _context172.n = 1;
                              return _this136._refreshSession(currentSession);
                            case 1:
                              return _context172.a(2, _context172.v);
                          }
                        }, _callee171);
                      })));
                    case 2:
                      return _context173.a(2, _context173.v);
                  }
                }, _callee172, this);
              }));
              function refreshSession(_x256) {
                return _refreshSession2.apply(this, arguments);
              }
              return refreshSession;
            }())
          }, {
            key: "_refreshSession",
            value: function () {
              var _refreshSession3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee174(currentSession) {
                var _this137 = this;
                var _t130;
                return _regenerator().w(function (_context175) {
                  while (1) switch (_context175.p = _context175.n) {
                    case 0:
                      _context175.p = 0;
                      _context175.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref237 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee173(result) {
                          var _a, data, _error5, _yield$_this137$_call, session, error;
                          return _regenerator().w(function (_context174) {
                            while (1) switch (_context174.n) {
                              case 0:
                                if (currentSession) {
                                  _context174.n = 2;
                                  break;
                                }
                                data = result.data, _error5 = result.error;
                                if (!_error5) {
                                  _context174.n = 1;
                                  break;
                                }
                                throw _error5;
                              case 1:
                                currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;
                              case 2:
                                if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {
                                  _context174.n = 3;
                                  break;
                                }
                                throw new AuthSessionMissingError();
                              case 3:
                                _context174.n = 4;
                                return _this137._callRefreshToken(currentSession.refresh_token);
                              case 4:
                                _yield$_this137$_call = _context174.v;
                                session = _yield$_this137$_call.data;
                                error = _yield$_this137$_call.error;
                                if (!error) {
                                  _context174.n = 5;
                                  break;
                                }
                                return _context174.a(2, _this137._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: error
                                }));
                              case 5:
                                if (session) {
                                  _context174.n = 6;
                                  break;
                                }
                                return _context174.a(2, _this137._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: null
                                }));
                              case 6:
                                return _context174.a(2, _this137._returnResult({
                                  data: {
                                    user: session.user,
                                    session: session
                                  },
                                  error: null
                                }));
                            }
                          }, _callee173);
                        }));
                        return function (_x258) {
                          return _ref237.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context175.a(2, _context175.v);
                    case 2:
                      _context175.p = 2;
                      _t130 = _context175.v;
                      if (!isAuthError(_t130)) {
                        _context175.n = 3;
                        break;
                      }
                      return _context175.a(2, this._returnResult({
                        data: {
                          user: null,
                          session: null
                        },
                        error: _t130
                      }));
                    case 3:
                      throw _t130;
                    case 4:
                      return _context175.a(2);
                  }
                }, _callee174, this, [[0, 2]]);
              }));
              function _refreshSession(_x257) {
                return _refreshSession3.apply(this, arguments);
              }
              return _refreshSession;
            }()
            /**
             * Gets the session data from a URL string
             */
          }, {
            key: "_getSessionFromURL",
            value: (function () {
              var _getSessionFromURL2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee175(params, callbackUrlType) {
                var _yield$this$_exchange, _data2, _error6, url, provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type, timeNow, expiresIn, _expiresAt2, actuallyExpiresIn, issuedAt, _yield$this$_getUser2, data, error, session, _t131, _t132;
                return _regenerator().w(function (_context176) {
                  while (1) switch (_context176.p = _context176.n) {
                    case 0:
                      _context176.p = 0;
                      if (isBrowser()) {
                        _context176.n = 1;
                        break;
                      }
                      throw new AuthImplicitGrantRedirectError('No browser detected.');
                    case 1:
                      if (!(params.error || params.error_description || params.error_code)) {
                        _context176.n = 2;
                        break;
                      }
                      throw new AuthImplicitGrantRedirectError(params.error_description || 'Error in URL with unspecified error_description', {
                        error: params.error || 'unspecified_error',
                        code: params.error_code || 'unspecified_code'
                      });
                    case 2:
                      _t131 = callbackUrlType;
                      _context176.n = _t131 === 'implicit' ? 3 : _t131 === 'pkce' ? 5 : 7;
                      break;
                    case 3:
                      if (!(this.flowType === 'pkce')) {
                        _context176.n = 4;
                        break;
                      }
                      throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');
                    case 4:
                      return _context176.a(3, 7);
                    case 5:
                      if (!(this.flowType === 'implicit')) {
                        _context176.n = 6;
                        break;
                      }
                      throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');
                    case 6:
                      return _context176.a(3, 7);
                    case 7:
                      if (!(callbackUrlType === 'pkce')) {
                        _context176.n = 11;
                        break;
                      }
                      this._debug('#_initialize()', 'begin', 'is PKCE flow', true);
                      if (params.code) {
                        _context176.n = 8;
                        break;
                      }
                      throw new AuthPKCEGrantCodeExchangeError('No code detected.');
                    case 8:
                      _context176.n = 9;
                      return this._exchangeCodeForSession(params.code);
                    case 9:
                      _yield$this$_exchange = _context176.v;
                      _data2 = _yield$this$_exchange.data;
                      _error6 = _yield$this$_exchange.error;
                      if (!_error6) {
                        _context176.n = 10;
                        break;
                      }
                      throw _error6;
                    case 10:
                      url = new URL(window.location.href);
                      url.searchParams.delete('code');
                      window.history.replaceState(window.history.state, '', url.toString());
                      return _context176.a(2, {
                        data: {
                          session: _data2.session,
                          redirectType: null
                        },
                        error: null
                      });
                    case 11:
                      provider_token = params.provider_token, provider_refresh_token = params.provider_refresh_token, access_token = params.access_token, refresh_token = params.refresh_token, expires_in = params.expires_in, expires_at = params.expires_at, token_type = params.token_type;
                      if (!(!access_token || !expires_in || !refresh_token || !token_type)) {
                        _context176.n = 12;
                        break;
                      }
                      throw new AuthImplicitGrantRedirectError('No session defined in URL');
                    case 12:
                      timeNow = Math.round(Date.now() / 1000);
                      expiresIn = parseInt(expires_in);
                      _expiresAt2 = timeNow + expiresIn;
                      if (expires_at) {
                        _expiresAt2 = parseInt(expires_at);
                      }
                      actuallyExpiresIn = _expiresAt2 - timeNow;
                      if (actuallyExpiresIn * 1000 <= AUTO_REFRESH_TICK_DURATION_MS) {
                        console.warn("@supabase/gotrue-js: Session as retrieved from URL expires in ".concat(actuallyExpiresIn, "s, should have been closer to ").concat(expiresIn, "s"));
                      }
                      issuedAt = _expiresAt2 - expiresIn;
                      if (timeNow - issuedAt >= 120) {
                        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale', issuedAt, _expiresAt2, timeNow);
                      } else if (timeNow - issuedAt < 0) {
                        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew', issuedAt, _expiresAt2, timeNow);
                      }
                      _context176.n = 13;
                      return this._getUser(access_token);
                    case 13:
                      _yield$this$_getUser2 = _context176.v;
                      data = _yield$this$_getUser2.data;
                      error = _yield$this$_getUser2.error;
                      if (!error) {
                        _context176.n = 14;
                        break;
                      }
                      throw error;
                    case 14:
                      session = {
                        provider_token: provider_token,
                        provider_refresh_token: provider_refresh_token,
                        access_token: access_token,
                        expires_in: expiresIn,
                        expires_at: _expiresAt2,
                        refresh_token: refresh_token,
                        token_type: token_type,
                        user: data.user
                      }; // Remove tokens from URL
                      window.location.hash = '';
                      this._debug('#_getSessionFromURL()', 'clearing window.location.hash');
                      return _context176.a(2, this._returnResult({
                        data: {
                          session: session,
                          redirectType: params.type
                        },
                        error: null
                      }));
                    case 15:
                      _context176.p = 15;
                      _t132 = _context176.v;
                      if (!isAuthError(_t132)) {
                        _context176.n = 16;
                        break;
                      }
                      return _context176.a(2, this._returnResult({
                        data: {
                          session: null,
                          redirectType: null
                        },
                        error: _t132
                      }));
                    case 16:
                      throw _t132;
                    case 17:
                      return _context176.a(2);
                  }
                }, _callee175, this, [[0, 15]]);
              }));
              function _getSessionFromURL(_x259, _x260) {
                return _getSessionFromURL2.apply(this, arguments);
              }
              return _getSessionFromURL;
            }()
            /**
             * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
             *
             * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine
             * if the URL should be processed as a Supabase auth callback. This allows users to exclude
             * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.
             */
            )
          }, {
            key: "_isImplicitGrantCallback",
            value: function _isImplicitGrantCallback(params) {
              if (typeof this.detectSessionInUrl === 'function') {
                return this.detectSessionInUrl(new URL(window.location.href), params);
              }
              return Boolean(params.access_token || params.error_description);
            }
            /**
             * Checks if the current URL and backing storage contain parameters given by a PKCE flow
             */
          }, {
            key: "_isPKCECallback",
            value: (function () {
              var _isPKCECallback2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee176(params) {
                var currentStorageContent;
                return _regenerator().w(function (_context177) {
                  while (1) switch (_context177.n) {
                    case 0:
                      _context177.n = 1;
                      return getItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 1:
                      currentStorageContent = _context177.v;
                      return _context177.a(2, !!(params.code && currentStorageContent));
                  }
                }, _callee176, this);
              }));
              function _isPKCECallback(_x261) {
                return _isPKCECallback2.apply(this, arguments);
              }
              return _isPKCECallback;
            }()
            /**
             * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
             *
             * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
             * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
             *
             * If using `others` scope, no `SIGNED_OUT` event is fired!
             */
            )
          }, {
            key: "signOut",
            value: (function () {
              var _signOut2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee178() {
                var _this138 = this;
                var options,
                  _args178 = arguments;
                return _regenerator().w(function (_context179) {
                  while (1) switch (_context179.n) {
                    case 0:
                      options = _args178.length > 0 && _args178[0] !== undefined ? _args178[0] : {
                        scope: 'global'
                      };
                      _context179.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context179.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee177() {
                        return _regenerator().w(function (_context178) {
                          while (1) switch (_context178.n) {
                            case 0:
                              _context178.n = 1;
                              return _this138._signOut(options);
                            case 1:
                              return _context178.a(2, _context178.v);
                          }
                        }, _callee177);
                      })));
                    case 2:
                      return _context179.a(2, _context179.v);
                  }
                }, _callee178, this);
              }));
              function signOut() {
                return _signOut2.apply(this, arguments);
              }
              return signOut;
            }())
          }, {
            key: "_signOut",
            value: function () {
              var _signOut3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee180() {
                var _this139 = this;
                var _ref239,
                  scope,
                  _args180 = arguments;
                return _regenerator().w(function (_context181) {
                  while (1) switch (_context181.n) {
                    case 0:
                      _ref239 = _args180.length > 0 && _args180[0] !== undefined ? _args180[0] : {
                        scope: 'global'
                      }, scope = _ref239.scope;
                      _context181.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref240 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee179(result) {
                          var _a, data, sessionError, accessToken, _yield$_this139$admin, error;
                          return _regenerator().w(function (_context180) {
                            while (1) switch (_context180.n) {
                              case 0:
                                data = result.data, sessionError = result.error;
                                if (!sessionError) {
                                  _context180.n = 1;
                                  break;
                                }
                                return _context180.a(2, _this139._returnResult({
                                  error: sessionError
                                }));
                              case 1:
                                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
                                if (!accessToken) {
                                  _context180.n = 3;
                                  break;
                                }
                                _context180.n = 2;
                                return _this139.admin.signOut(accessToken, scope);
                              case 2:
                                _yield$_this139$admin = _context180.v;
                                error = _yield$_this139$admin.error;
                                if (!error) {
                                  _context180.n = 3;
                                  break;
                                }
                                if (isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403)) {
                                  _context180.n = 3;
                                  break;
                                }
                                return _context180.a(2, _this139._returnResult({
                                  error: error
                                }));
                              case 3:
                                if (!(scope !== 'others')) {
                                  _context180.n = 5;
                                  break;
                                }
                                _context180.n = 4;
                                return _this139._removeSession();
                              case 4:
                                _context180.n = 5;
                                return removeItemAsync(_this139.storage, "".concat(_this139.storageKey, "-code-verifier"));
                              case 5:
                                return _context180.a(2, _this139._returnResult({
                                  error: null
                                }));
                            }
                          }, _callee179);
                        }));
                        return function (_x262) {
                          return _ref240.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context181.a(2, _context181.v);
                  }
                }, _callee180, this);
              }));
              function _signOut() {
                return _signOut3.apply(this, arguments);
              }
              return _signOut;
            }()
          }, {
            key: "onAuthStateChange",
            value: function onAuthStateChange(callback) {
              var _this140 = this;
              var id = generateCallbackId();
              var subscription = {
                id: id,
                callback: callback,
                unsubscribe: function unsubscribe() {
                  _this140._debug('#unsubscribe()', 'state change callback with id removed', id);
                  _this140.stateChangeEmitters.delete(id);
                }
              };
              this._debug('#onAuthStateChange()', 'registered callback with id', id);
              this.stateChangeEmitters.set(id, subscription);
              _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee182() {
                return _regenerator().w(function (_context183) {
                  while (1) switch (_context183.n) {
                    case 0:
                      _context183.n = 1;
                      return _this140.initializePromise;
                    case 1:
                      _context183.n = 2;
                      return _this140._acquireLock(_this140.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee181() {
                        return _regenerator().w(function (_context182) {
                          while (1) switch (_context182.n) {
                            case 0:
                              _this140._emitInitialSession(id);
                            case 1:
                              return _context182.a(2);
                          }
                        }, _callee181);
                      })));
                    case 2:
                      return _context183.a(2);
                  }
                }, _callee182);
              }))();
              return {
                data: {
                  subscription: subscription
                }
              };
            }
          }, {
            key: "_emitInitialSession",
            value: function () {
              var _emitInitialSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee184(id) {
                var _this141 = this;
                return _regenerator().w(function (_context185) {
                  while (1) switch (_context185.n) {
                    case 0:
                      _context185.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref243 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee183(result) {
                          var _a, _b, session, error, _t133;
                          return _regenerator().w(function (_context184) {
                            while (1) switch (_context184.p = _context184.n) {
                              case 0:
                                _context184.p = 0;
                                session = result.data.session, error = result.error;
                                if (!error) {
                                  _context184.n = 1;
                                  break;
                                }
                                throw error;
                              case 1:
                                _context184.n = 2;
                                return (_a = _this141.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);
                              case 2:
                                _this141._debug('INITIAL_SESSION', 'callback id', id, 'session', session);
                                _context184.n = 5;
                                break;
                              case 3:
                                _context184.p = 3;
                                _t133 = _context184.v;
                                _context184.n = 4;
                                return (_b = _this141.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);
                              case 4:
                                _this141._debug('INITIAL_SESSION', 'callback id', id, 'error', _t133);
                                console.error(_t133);
                              case 5:
                                return _context184.a(2);
                            }
                          }, _callee183, null, [[0, 3]]);
                        }));
                        return function (_x264) {
                          return _ref243.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context185.a(2, _context185.v);
                  }
                }, _callee184, this);
              }));
              function _emitInitialSession(_x263) {
                return _emitInitialSession2.apply(this, arguments);
              }
              return _emitInitialSession;
            }()
            /**
             * Sends a password reset request to an email address. This method supports the PKCE flow.
             *
             * @param email The email address of the user.
             * @param options.redirectTo The URL to send the user to after they click the password reset link.
             * @param options.captchaToken Verification token received when the user completes the captcha on the site.
             */
          }, {
            key: "resetPasswordForEmail",
            value: (function () {
              var _resetPasswordForEmail = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee185(email) {
                var options,
                  codeChallenge,
                  codeChallengeMethod,
                  _yield$getCodeChallen9,
                  _yield$getCodeChallen0,
                  _args185 = arguments,
                  _t134;
                return _regenerator().w(function (_context186) {
                  while (1) switch (_context186.p = _context186.n) {
                    case 0:
                      options = _args185.length > 1 && _args185[1] !== undefined ? _args185[1] : {};
                      codeChallenge = null;
                      codeChallengeMethod = null;
                      if (!(this.flowType === 'pkce')) {
                        _context186.n = 2;
                        break;
                      }
                      _context186.n = 1;
                      return getCodeChallengeAndMethod(this.storage, this.storageKey, true // isPasswordRecovery
                      );
                    case 1:
                      _yield$getCodeChallen9 = _context186.v;
                      _yield$getCodeChallen0 = _slicedToArray(_yield$getCodeChallen9, 2);
                      codeChallenge = _yield$getCodeChallen0[0];
                      codeChallengeMethod = _yield$getCodeChallen0[1];
                    case 2:
                      _context186.p = 2;
                      _context186.n = 3;
                      return _request(this.fetch, 'POST', "".concat(this.url, "/recover"), {
                        body: {
                          email: email,
                          code_challenge: codeChallenge,
                          code_challenge_method: codeChallengeMethod,
                          gotrue_meta_security: {
                            captcha_token: options.captchaToken
                          }
                        },
                        headers: this.headers,
                        redirectTo: options.redirectTo
                      });
                    case 3:
                      return _context186.a(2, _context186.v);
                    case 4:
                      _context186.p = 4;
                      _t134 = _context186.v;
                      _context186.n = 5;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 5:
                      if (!isAuthError(_t134)) {
                        _context186.n = 6;
                        break;
                      }
                      return _context186.a(2, this._returnResult({
                        data: null,
                        error: _t134
                      }));
                    case 6:
                      throw _t134;
                    case 7:
                      return _context186.a(2);
                  }
                }, _callee185, this, [[2, 4]]);
              }));
              function resetPasswordForEmail(_x265) {
                return _resetPasswordForEmail.apply(this, arguments);
              }
              return resetPasswordForEmail;
            }()
            /**
             * Gets all the identities linked to a user.
             */
            )
          }, {
            key: "getUserIdentities",
            value: (function () {
              var _getUserIdentities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee186() {
                var _a, _yield$this$getUser, data, error, _t135;
                return _regenerator().w(function (_context187) {
                  while (1) switch (_context187.p = _context187.n) {
                    case 0:
                      _context187.p = 0;
                      _context187.n = 1;
                      return this.getUser();
                    case 1:
                      _yield$this$getUser = _context187.v;
                      data = _yield$this$getUser.data;
                      error = _yield$this$getUser.error;
                      if (!error) {
                        _context187.n = 2;
                        break;
                      }
                      throw error;
                    case 2:
                      return _context187.a(2, this._returnResult({
                        data: {
                          identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []
                        },
                        error: null
                      }));
                    case 3:
                      _context187.p = 3;
                      _t135 = _context187.v;
                      if (!isAuthError(_t135)) {
                        _context187.n = 4;
                        break;
                      }
                      return _context187.a(2, this._returnResult({
                        data: null,
                        error: _t135
                      }));
                    case 4:
                      throw _t135;
                    case 5:
                      return _context187.a(2);
                  }
                }, _callee186, this, [[0, 3]]);
              }));
              function getUserIdentities() {
                return _getUserIdentities.apply(this, arguments);
              }
              return getUserIdentities;
            }())
          }, {
            key: "linkIdentity",
            value: function () {
              var _linkIdentity = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee187(credentials) {
                return _regenerator().w(function (_context188) {
                  while (1) switch (_context188.n) {
                    case 0:
                      if (!('token' in credentials)) {
                        _context188.n = 1;
                        break;
                      }
                      return _context188.a(2, this.linkIdentityIdToken(credentials));
                    case 1:
                      return _context188.a(2, this.linkIdentityOAuth(credentials));
                  }
                }, _callee187, this);
              }));
              function linkIdentity(_x266) {
                return _linkIdentity.apply(this, arguments);
              }
              return linkIdentity;
            }()
          }, {
            key: "linkIdentityOAuth",
            value: function () {
              var _linkIdentityOAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee189(credentials) {
                var _this142 = this;
                var _a, _yield$this$_useSessi, data, error, _t136;
                return _regenerator().w(function (_context190) {
                  while (1) switch (_context190.p = _context190.n) {
                    case 0:
                      _context190.p = 0;
                      _context190.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref244 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee188(result) {
                          var _a, _b, _c, _d, _e, data, error, url;
                          return _regenerator().w(function (_context189) {
                            while (1) switch (_context189.n) {
                              case 0:
                                data = result.data, error = result.error;
                                if (!error) {
                                  _context189.n = 1;
                                  break;
                                }
                                throw error;
                              case 1:
                                _context189.n = 2;
                                return _this142._getUrlForProvider("".concat(_this142.url, "/user/identities/authorize"), credentials.provider, {
                                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
                                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
                                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
                                  skipBrowserRedirect: true
                                });
                              case 2:
                                url = _context189.v;
                                _context189.n = 3;
                                return _request(_this142.fetch, 'GET', url, {
                                  headers: _this142.headers,
                                  jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined
                                });
                              case 3:
                                return _context189.a(2, _context189.v);
                            }
                          }, _callee188);
                        }));
                        return function (_x268) {
                          return _ref244.apply(this, arguments);
                        };
                      }());
                    case 1:
                      _yield$this$_useSessi = _context190.v;
                      data = _yield$this$_useSessi.data;
                      error = _yield$this$_useSessi.error;
                      if (!error) {
                        _context190.n = 2;
                        break;
                      }
                      throw error;
                    case 2:
                      if (isBrowser() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {
                        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
                      }
                      return _context190.a(2, this._returnResult({
                        data: {
                          provider: credentials.provider,
                          url: data === null || data === void 0 ? void 0 : data.url
                        },
                        error: null
                      }));
                    case 3:
                      _context190.p = 3;
                      _t136 = _context190.v;
                      if (!isAuthError(_t136)) {
                        _context190.n = 4;
                        break;
                      }
                      return _context190.a(2, this._returnResult({
                        data: {
                          provider: credentials.provider,
                          url: null
                        },
                        error: _t136
                      }));
                    case 4:
                      throw _t136;
                    case 5:
                      return _context190.a(2);
                  }
                }, _callee189, this, [[0, 3]]);
              }));
              function linkIdentityOAuth(_x267) {
                return _linkIdentityOAuth.apply(this, arguments);
              }
              return linkIdentityOAuth;
            }()
          }, {
            key: "linkIdentityIdToken",
            value: function () {
              var _linkIdentityIdToken = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee191(credentials) {
                var _this143 = this;
                return _regenerator().w(function (_context192) {
                  while (1) switch (_context192.n) {
                    case 0:
                      _context192.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref245 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee190(result) {
                          var _a, sessionError, session, options, provider, token, access_token, nonce, res, data, error, _t137;
                          return _regenerator().w(function (_context191) {
                            while (1) switch (_context191.p = _context191.n) {
                              case 0:
                                _context191.p = 0;
                                sessionError = result.error, session = result.data.session;
                                if (!sessionError) {
                                  _context191.n = 1;
                                  break;
                                }
                                throw sessionError;
                              case 1:
                                options = credentials.options, provider = credentials.provider, token = credentials.token, access_token = credentials.access_token, nonce = credentials.nonce;
                                _context191.n = 2;
                                return _request(_this143.fetch, 'POST', "".concat(_this143.url, "/token?grant_type=id_token"), {
                                  headers: _this143.headers,
                                  jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,
                                  body: {
                                    provider: provider,
                                    id_token: token,
                                    access_token: access_token,
                                    nonce: nonce,
                                    link_identity: true,
                                    gotrue_meta_security: {
                                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                                    }
                                  },
                                  xform: _sessionResponse
                                });
                              case 2:
                                res = _context191.v;
                                data = res.data, error = res.error;
                                if (!error) {
                                  _context191.n = 3;
                                  break;
                                }
                                return _context191.a(2, _this143._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: error
                                }));
                              case 3:
                                if (!(!data || !data.session || !data.user)) {
                                  _context191.n = 4;
                                  break;
                                }
                                return _context191.a(2, _this143._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: new AuthInvalidTokenResponseError()
                                }));
                              case 4:
                                if (!data.session) {
                                  _context191.n = 6;
                                  break;
                                }
                                _context191.n = 5;
                                return _this143._saveSession(data.session);
                              case 5:
                                _context191.n = 6;
                                return _this143._notifyAllSubscribers('USER_UPDATED', data.session);
                              case 6:
                                return _context191.a(2, _this143._returnResult({
                                  data: data,
                                  error: error
                                }));
                              case 7:
                                _context191.p = 7;
                                _t137 = _context191.v;
                                _context191.n = 8;
                                return removeItemAsync(_this143.storage, "".concat(_this143.storageKey, "-code-verifier"));
                              case 8:
                                if (!isAuthError(_t137)) {
                                  _context191.n = 9;
                                  break;
                                }
                                return _context191.a(2, _this143._returnResult({
                                  data: {
                                    user: null,
                                    session: null
                                  },
                                  error: _t137
                                }));
                              case 9:
                                throw _t137;
                              case 10:
                                return _context191.a(2);
                            }
                          }, _callee190, null, [[0, 7]]);
                        }));
                        return function (_x270) {
                          return _ref245.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context192.a(2, _context192.v);
                  }
                }, _callee191, this);
              }));
              function linkIdentityIdToken(_x269) {
                return _linkIdentityIdToken.apply(this, arguments);
              }
              return linkIdentityIdToken;
            }()
            /**
             * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
             */
          }, {
            key: "unlinkIdentity",
            value: (function () {
              var _unlinkIdentity = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee193(identity) {
                var _this144 = this;
                var _t138;
                return _regenerator().w(function (_context194) {
                  while (1) switch (_context194.p = _context194.n) {
                    case 0:
                      _context194.p = 0;
                      _context194.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref246 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee192(result) {
                          var _a, _b, data, error;
                          return _regenerator().w(function (_context193) {
                            while (1) switch (_context193.n) {
                              case 0:
                                data = result.data, error = result.error;
                                if (!error) {
                                  _context193.n = 1;
                                  break;
                                }
                                throw error;
                              case 1:
                                _context193.n = 2;
                                return _request(_this144.fetch, 'DELETE', "".concat(_this144.url, "/user/identities/").concat(identity.identity_id), {
                                  headers: _this144.headers,
                                  jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined
                                });
                              case 2:
                                return _context193.a(2, _context193.v);
                            }
                          }, _callee192);
                        }));
                        return function (_x272) {
                          return _ref246.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context194.a(2, _context194.v);
                    case 2:
                      _context194.p = 2;
                      _t138 = _context194.v;
                      if (!isAuthError(_t138)) {
                        _context194.n = 3;
                        break;
                      }
                      return _context194.a(2, this._returnResult({
                        data: null,
                        error: _t138
                      }));
                    case 3:
                      throw _t138;
                    case 4:
                      return _context194.a(2);
                  }
                }, _callee193, this, [[0, 2]]);
              }));
              function unlinkIdentity(_x271) {
                return _unlinkIdentity.apply(this, arguments);
              }
              return unlinkIdentity;
            }()
            /**
             * Generates a new JWT.
             * @param refreshToken A valid refresh token that was returned on login.
             */
            )
          }, {
            key: "_refreshAccessToken",
            value: (function () {
              var _refreshAccessToken2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee195(refreshToken) {
                var _this145 = this;
                var debugName, startedAt, _t139;
                return _regenerator().w(function (_context196) {
                  while (1) switch (_context196.p = _context196.n) {
                    case 0:
                      debugName = "#_refreshAccessToken(".concat(refreshToken.substring(0, 5), "...)");
                      this._debug(debugName, 'begin');
                      _context196.p = 1;
                      startedAt = Date.now(); // will attempt to refresh the token with exponential backoff
                      _context196.n = 2;
                      return retryable(/*#__PURE__*/function () {
                        var _ref247 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee194(attempt) {
                          return _regenerator().w(function (_context195) {
                            while (1) switch (_context195.n) {
                              case 0:
                                if (!(attempt > 0)) {
                                  _context195.n = 1;
                                  break;
                                }
                                _context195.n = 1;
                                return sleep(200 * Math.pow(2, attempt - 1));
                              case 1:
                                _this145._debug(debugName, 'refreshing attempt', attempt);
                                _context195.n = 2;
                                return _request(_this145.fetch, 'POST', "".concat(_this145.url, "/token?grant_type=refresh_token"), {
                                  body: {
                                    refresh_token: refreshToken
                                  },
                                  headers: _this145.headers,
                                  xform: _sessionResponse
                                });
                              case 2:
                                return _context195.a(2, _context195.v);
                            }
                          }, _callee194);
                        }));
                        return function (_x274) {
                          return _ref247.apply(this, arguments);
                        };
                      }(), function (attempt, error) {
                        var nextBackOffInterval = 200 * Math.pow(2, attempt);
                        return error && isAuthRetryableFetchError(error) &&
                        // retryable only if the request can be sent before the backoff overflows the tick duration
                        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
                      });
                    case 2:
                      return _context196.a(2, _context196.v);
                    case 3:
                      _context196.p = 3;
                      _t139 = _context196.v;
                      this._debug(debugName, 'error', _t139);
                      if (!isAuthError(_t139)) {
                        _context196.n = 4;
                        break;
                      }
                      return _context196.a(2, this._returnResult({
                        data: {
                          session: null,
                          user: null
                        },
                        error: _t139
                      }));
                    case 4:
                      throw _t139;
                    case 5:
                      _context196.p = 5;
                      this._debug(debugName, 'end');
                      return _context196.f(5);
                    case 6:
                      return _context196.a(2);
                  }
                }, _callee195, this, [[1, 3, 5, 6]]);
              }));
              function _refreshAccessToken(_x273) {
                return _refreshAccessToken2.apply(this, arguments);
              }
              return _refreshAccessToken;
            }())
          }, {
            key: "_isValidSession",
            value: function _isValidSession(maybeSession) {
              var isValidSession = _typeof2(maybeSession) === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;
              return isValidSession;
            }
          }, {
            key: "_handleProviderSignIn",
            value: function () {
              var _handleProviderSignIn2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee196(provider, options) {
                var url;
                return _regenerator().w(function (_context197) {
                  while (1) switch (_context197.n) {
                    case 0:
                      _context197.n = 1;
                      return this._getUrlForProvider("".concat(this.url, "/authorize"), provider, {
                        redirectTo: options.redirectTo,
                        scopes: options.scopes,
                        queryParams: options.queryParams
                      });
                    case 1:
                      url = _context197.v;
                      this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url);
                      // try to open on the browser
                      if (isBrowser() && !options.skipBrowserRedirect) {
                        window.location.assign(url);
                      }
                      return _context197.a(2, {
                        data: {
                          provider: provider,
                          url: url
                        },
                        error: null
                      });
                  }
                }, _callee196, this);
              }));
              function _handleProviderSignIn(_x275, _x276) {
                return _handleProviderSignIn2.apply(this, arguments);
              }
              return _handleProviderSignIn;
            }()
            /**
             * Recovers the session from LocalStorage and refreshes the token
             * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
             */
          }, {
            key: "_recoverAndRefresh",
            value: (function () {
              var _recoverAndRefresh2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee197() {
                var _a, _b, debugName, currentSession, maybeUser, separateUser, expiresWithMargin, _yield$this$_callRefr3, error, _yield$this$_getUser3, data, userError, _t140, _t141;
                return _regenerator().w(function (_context198) {
                  while (1) switch (_context198.p = _context198.n) {
                    case 0:
                      debugName = '#_recoverAndRefresh()';
                      this._debug(debugName, 'begin');
                      _context198.p = 1;
                      _context198.n = 2;
                      return getItemAsync(this.storage, this.storageKey);
                    case 2:
                      currentSession = _context198.v;
                      if (!(currentSession && this.userStorage)) {
                        _context198.n = 5;
                        break;
                      }
                      _context198.n = 3;
                      return getItemAsync(this.userStorage, this.storageKey + '-user');
                    case 3:
                      maybeUser = _context198.v;
                      if (!(!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser)) {
                        _context198.n = 4;
                        break;
                      }
                      // storage and userStorage are the same storage medium, for example
                      // window.localStorage if userStorage does not have the user from
                      // storage stored, store it first thereby migrating the user object
                      // from storage -> userStorage
                      maybeUser = {
                        user: currentSession.user
                      };
                      _context198.n = 4;
                      return setItemAsync(this.userStorage, this.storageKey + '-user', maybeUser);
                    case 4:
                      currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : userNotAvailableProxy();
                      _context198.n = 10;
                      break;
                    case 5:
                      if (!(currentSession && !currentSession.user)) {
                        _context198.n = 10;
                        break;
                      }
                      if (currentSession.user) {
                        _context198.n = 10;
                        break;
                      }
                      _context198.n = 6;
                      return getItemAsync(this.storage, this.storageKey + '-user');
                    case 6:
                      separateUser = _context198.v;
                      if (!(separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user))) {
                        _context198.n = 9;
                        break;
                      }
                      currentSession.user = separateUser.user;
                      _context198.n = 7;
                      return removeItemAsync(this.storage, this.storageKey + '-user');
                    case 7:
                      _context198.n = 8;
                      return setItemAsync(this.storage, this.storageKey, currentSession);
                    case 8:
                      _context198.n = 10;
                      break;
                    case 9:
                      currentSession.user = userNotAvailableProxy();
                    case 10:
                      this._debug(debugName, 'session from storage', currentSession);
                      if (this._isValidSession(currentSession)) {
                        _context198.n = 12;
                        break;
                      }
                      this._debug(debugName, 'session is not valid');
                      if (!(currentSession !== null)) {
                        _context198.n = 11;
                        break;
                      }
                      _context198.n = 11;
                      return this._removeSession();
                    case 11:
                      return _context198.a(2);
                    case 12:
                      expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < EXPIRY_MARGIN_MS;
                      this._debug(debugName, "session has".concat(expiresWithMargin ? '' : ' not', " expired with margin of ").concat(EXPIRY_MARGIN_MS, "s"));
                      if (!expiresWithMargin) {
                        _context198.n = 15;
                        break;
                      }
                      if (!(this.autoRefreshToken && currentSession.refresh_token)) {
                        _context198.n = 14;
                        break;
                      }
                      _context198.n = 13;
                      return this._callRefreshToken(currentSession.refresh_token);
                    case 13:
                      _yield$this$_callRefr3 = _context198.v;
                      error = _yield$this$_callRefr3.error;
                      if (!error) {
                        _context198.n = 14;
                        break;
                      }
                      console.error(error);
                      if (isAuthRetryableFetchError(error)) {
                        _context198.n = 14;
                        break;
                      }
                      this._debug(debugName, 'refresh failed with a non-retryable error, removing the session', error);
                      _context198.n = 14;
                      return this._removeSession();
                    case 14:
                      _context198.n = 25;
                      break;
                    case 15:
                      if (!(currentSession.user && currentSession.user.__isUserNotAvailableProxy === true)) {
                        _context198.n = 24;
                        break;
                      }
                      _context198.p = 16;
                      _context198.n = 17;
                      return this._getUser(currentSession.access_token);
                    case 17:
                      _yield$this$_getUser3 = _context198.v;
                      data = _yield$this$_getUser3.data;
                      userError = _yield$this$_getUser3.error;
                      if (!(!userError && (data === null || data === void 0 ? void 0 : data.user))) {
                        _context198.n = 20;
                        break;
                      }
                      currentSession.user = data.user;
                      _context198.n = 18;
                      return this._saveSession(currentSession);
                    case 18:
                      _context198.n = 19;
                      return this._notifyAllSubscribers('SIGNED_IN', currentSession);
                    case 19:
                      _context198.n = 21;
                      break;
                    case 20:
                      this._debug(debugName, 'could not get user data, skipping SIGNED_IN notification');
                    case 21:
                      _context198.n = 23;
                      break;
                    case 22:
                      _context198.p = 22;
                      _t140 = _context198.v;
                      console.error('Error getting user data:', _t140);
                      this._debug(debugName, 'error getting user data, skipping SIGNED_IN notification', _t140);
                    case 23:
                      _context198.n = 25;
                      break;
                    case 24:
                      _context198.n = 25;
                      return this._notifyAllSubscribers('SIGNED_IN', currentSession);
                    case 25:
                      _context198.n = 27;
                      break;
                    case 26:
                      _context198.p = 26;
                      _t141 = _context198.v;
                      this._debug(debugName, 'error', _t141);
                      console.error(_t141);
                      return _context198.a(2);
                    case 27:
                      _context198.p = 27;
                      this._debug(debugName, 'end');
                      return _context198.f(27);
                    case 28:
                      return _context198.a(2);
                  }
                }, _callee197, this, [[16, 22], [1, 26, 27, 28]]);
              }));
              function _recoverAndRefresh() {
                return _recoverAndRefresh2.apply(this, arguments);
              }
              return _recoverAndRefresh;
            }())
          }, {
            key: "_callRefreshToken",
            value: function () {
              var _callRefreshToken2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee198(refreshToken) {
                var _a, _b, debugName, _yield$this$_refreshA, data, error, result, _result2, _t142;
                return _regenerator().w(function (_context199) {
                  while (1) switch (_context199.p = _context199.n) {
                    case 0:
                      if (refreshToken) {
                        _context199.n = 1;
                        break;
                      }
                      throw new AuthSessionMissingError();
                    case 1:
                      if (!this.refreshingDeferred) {
                        _context199.n = 2;
                        break;
                      }
                      return _context199.a(2, this.refreshingDeferred.promise);
                    case 2:
                      debugName = "#_callRefreshToken(".concat(refreshToken.substring(0, 5), "...)");
                      this._debug(debugName, 'begin');
                      _context199.p = 3;
                      this.refreshingDeferred = new Deferred();
                      _context199.n = 4;
                      return this._refreshAccessToken(refreshToken);
                    case 4:
                      _yield$this$_refreshA = _context199.v;
                      data = _yield$this$_refreshA.data;
                      error = _yield$this$_refreshA.error;
                      if (!error) {
                        _context199.n = 5;
                        break;
                      }
                      throw error;
                    case 5:
                      if (data.session) {
                        _context199.n = 6;
                        break;
                      }
                      throw new AuthSessionMissingError();
                    case 6:
                      _context199.n = 7;
                      return this._saveSession(data.session);
                    case 7:
                      _context199.n = 8;
                      return this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);
                    case 8:
                      result = {
                        data: data.session,
                        error: null
                      };
                      this.refreshingDeferred.resolve(result);
                      return _context199.a(2, result);
                    case 9:
                      _context199.p = 9;
                      _t142 = _context199.v;
                      this._debug(debugName, 'error', _t142);
                      if (!isAuthError(_t142)) {
                        _context199.n = 11;
                        break;
                      }
                      _result2 = {
                        data: null,
                        error: _t142
                      };
                      if (isAuthRetryableFetchError(_t142)) {
                        _context199.n = 10;
                        break;
                      }
                      _context199.n = 10;
                      return this._removeSession();
                    case 10:
                      (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result2);
                      return _context199.a(2, _result2);
                    case 11:
                      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_t142);
                      throw _t142;
                    case 12:
                      _context199.p = 12;
                      this.refreshingDeferred = null;
                      this._debug(debugName, 'end');
                      return _context199.f(12);
                    case 13:
                      return _context199.a(2);
                  }
                }, _callee198, this, [[3, 9, 12, 13]]);
              }));
              function _callRefreshToken(_x277) {
                return _callRefreshToken2.apply(this, arguments);
              }
              return _callRefreshToken;
            }()
          }, {
            key: "_notifyAllSubscribers",
            value: function () {
              var _notifyAllSubscribers2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee200(event, session) {
                var broadcast,
                  debugName,
                  errors,
                  promises,
                  i,
                  _args200 = arguments;
                return _regenerator().w(function (_context201) {
                  while (1) switch (_context201.p = _context201.n) {
                    case 0:
                      broadcast = _args200.length > 2 && _args200[2] !== undefined ? _args200[2] : true;
                      debugName = "#_notifyAllSubscribers(".concat(event, ")");
                      this._debug(debugName, 'begin', session, "broadcast = ".concat(broadcast));
                      _context201.p = 1;
                      if (this.broadcastChannel && broadcast) {
                        this.broadcastChannel.postMessage({
                          event: event,
                          session: session
                        });
                      }
                      errors = [];
                      promises = Array.from(this.stateChangeEmitters.values()).map(/*#__PURE__*/function () {
                        var _ref248 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee199(x) {
                          var _t143;
                          return _regenerator().w(function (_context200) {
                            while (1) switch (_context200.p = _context200.n) {
                              case 0:
                                _context200.p = 0;
                                _context200.n = 1;
                                return x.callback(event, session);
                              case 1:
                                _context200.n = 3;
                                break;
                              case 2:
                                _context200.p = 2;
                                _t143 = _context200.v;
                                errors.push(_t143);
                              case 3:
                                return _context200.a(2);
                            }
                          }, _callee199, null, [[0, 2]]);
                        }));
                        return function (_x280) {
                          return _ref248.apply(this, arguments);
                        };
                      }());
                      _context201.n = 2;
                      return Promise.all(promises);
                    case 2:
                      if (!(errors.length > 0)) {
                        _context201.n = 3;
                        break;
                      }
                      for (i = 0; i < errors.length; i += 1) {
                        console.error(errors[i]);
                      }
                      throw errors[0];
                    case 3:
                      _context201.p = 3;
                      this._debug(debugName, 'end');
                      return _context201.f(3);
                    case 4:
                      return _context201.a(2);
                  }
                }, _callee200, this, [[1,, 3, 4]]);
              }));
              function _notifyAllSubscribers(_x278, _x279) {
                return _notifyAllSubscribers2.apply(this, arguments);
              }
              return _notifyAllSubscribers;
            }()
            /**
             * set currentSession and currentUser
             * process to _startAutoRefreshToken if possible
             */
          }, {
            key: "_saveSession",
            value: (function () {
              var _saveSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee201(session) {
                var sessionToProcess, userIsProxy, mainSessionData, clonedMainSessionData, clonedSession;
                return _regenerator().w(function (_context202) {
                  while (1) switch (_context202.n) {
                    case 0:
                      this._debug('#_saveSession()', session);
                      // _saveSession is always called whenever a new session has been acquired
                      // so we can safely suppress the warning returned by future getSession calls
                      this.suppressGetSessionWarning = true;
                      _context202.n = 1;
                      return removeItemAsync(this.storage, "".concat(this.storageKey, "-code-verifier"));
                    case 1:
                      // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere
                      sessionToProcess = Object.assign({}, session);
                      userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
                      if (!this.userStorage) {
                        _context202.n = 4;
                        break;
                      }
                      if (!(!userIsProxy && sessionToProcess.user)) {
                        _context202.n = 2;
                        break;
                      }
                      _context202.n = 2;
                      return setItemAsync(this.userStorage, this.storageKey + '-user', {
                        user: sessionToProcess.user
                      });
                    case 2:
                      // Prepare the main session data for primary storage: remove the user property before cloning
                      // This is important because the original session.user might be the proxy
                      mainSessionData = Object.assign({}, sessionToProcess);
                      delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage
                      clonedMainSessionData = deepClone(mainSessionData);
                      _context202.n = 3;
                      return setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
                    case 3:
                      _context202.n = 5;
                      break;
                    case 4:
                      // No userStorage is configured.
                      // In this case, session.user should ideally not be a proxy.
                      // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here
                      clonedSession = deepClone(sessionToProcess); // sessionToProcess still has its original user property
                      _context202.n = 5;
                      return setItemAsync(this.storage, this.storageKey, clonedSession);
                    case 5:
                      return _context202.a(2);
                  }
                }, _callee201, this);
              }));
              function _saveSession(_x281) {
                return _saveSession2.apply(this, arguments);
              }
              return _saveSession;
            }())
          }, {
            key: "_removeSession",
            value: function () {
              var _removeSession2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee202() {
                return _regenerator().w(function (_context203) {
                  while (1) switch (_context203.n) {
                    case 0:
                      this._debug('#_removeSession()');
                      this.suppressGetSessionWarning = false;
                      _context203.n = 1;
                      return removeItemAsync(this.storage, this.storageKey);
                    case 1:
                      _context203.n = 2;
                      return removeItemAsync(this.storage, this.storageKey + '-code-verifier');
                    case 2:
                      _context203.n = 3;
                      return removeItemAsync(this.storage, this.storageKey + '-user');
                    case 3:
                      if (!this.userStorage) {
                        _context203.n = 4;
                        break;
                      }
                      _context203.n = 4;
                      return removeItemAsync(this.userStorage, this.storageKey + '-user');
                    case 4:
                      _context203.n = 5;
                      return this._notifyAllSubscribers('SIGNED_OUT', null);
                    case 5:
                      return _context203.a(2);
                  }
                }, _callee202, this);
              }));
              function _removeSession() {
                return _removeSession2.apply(this, arguments);
              }
              return _removeSession;
            }()
            /**
             * Removes any registered visibilitychange callback.
             *
             * {@see #startAutoRefresh}
             * {@see #stopAutoRefresh}
             */
          }, {
            key: "_removeVisibilityChangedCallback",
            value: function _removeVisibilityChangedCallback() {
              this._debug('#_removeVisibilityChangedCallback()');
              var callback = this.visibilityChangedCallback;
              this.visibilityChangedCallback = null;
              try {
                if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
                  window.removeEventListener('visibilitychange', callback);
                }
              } catch (e) {
                console.error('removing visibilitychange callback failed', e);
              }
            }
            /**
             * This is the private implementation of {@link #startAutoRefresh}. Use this
             * within the library.
             */
          }, {
            key: "_startAutoRefresh",
            value: (function () {
              var _startAutoRefresh2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee204() {
                var _this146 = this;
                var ticker, timeout;
                return _regenerator().w(function (_context205) {
                  while (1) switch (_context205.n) {
                    case 0:
                      _context205.n = 1;
                      return this._stopAutoRefresh();
                    case 1:
                      this._debug('#_startAutoRefresh()');
                      ticker = setInterval(function () {
                        return _this146._autoRefreshTokenTick();
                      }, AUTO_REFRESH_TICK_DURATION_MS);
                      this.autoRefreshTicker = ticker;
                      if (ticker && _typeof2(ticker) === 'object' && typeof ticker.unref === 'function') {
                        // ticker is a NodeJS Timeout object that has an `unref` method
                        // https://nodejs.org/api/timers.html#timeoutunref
                        // When auto refresh is used in NodeJS (like for testing) the
                        // `setInterval` is preventing the process from being marked as
                        // finished and tests run endlessly. This can be prevented by calling
                        // `unref()` on the returned object.
                        ticker.unref();
                        // @ts-expect-error TS has no context of Deno
                      } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {
                        // similar like for NodeJS, but with the Deno API
                        // https://deno.land/api@latest?unstable&s=Deno.unrefTimer
                        // @ts-expect-error TS has no context of Deno
                        Deno.unrefTimer(ticker);
                      }
                      // run the tick immediately, but in the next pass of the event loop so that
                      // #_initialize can be allowed to complete without recursively waiting on
                      // itself
                      timeout = setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee203() {
                        return _regenerator().w(function (_context204) {
                          while (1) switch (_context204.n) {
                            case 0:
                              _context204.n = 1;
                              return _this146.initializePromise;
                            case 1:
                              _context204.n = 2;
                              return _this146._autoRefreshTokenTick();
                            case 2:
                              return _context204.a(2);
                          }
                        }, _callee203);
                      })), 0);
                      this.autoRefreshTickTimeout = timeout;
                      if (timeout && _typeof2(timeout) === 'object' && typeof timeout.unref === 'function') {
                        timeout.unref();
                        // @ts-expect-error TS has no context of Deno
                      } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {
                        // @ts-expect-error TS has no context of Deno
                        Deno.unrefTimer(timeout);
                      }
                    case 2:
                      return _context205.a(2);
                  }
                }, _callee204, this);
              }));
              function _startAutoRefresh() {
                return _startAutoRefresh2.apply(this, arguments);
              }
              return _startAutoRefresh;
            }()
            /**
             * This is the private implementation of {@link #stopAutoRefresh}. Use this
             * within the library.
             */
            )
          }, {
            key: "_stopAutoRefresh",
            value: (function () {
              var _stopAutoRefresh2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee205() {
                var ticker, timeout;
                return _regenerator().w(function (_context206) {
                  while (1) switch (_context206.n) {
                    case 0:
                      this._debug('#_stopAutoRefresh()');
                      ticker = this.autoRefreshTicker;
                      this.autoRefreshTicker = null;
                      if (ticker) {
                        clearInterval(ticker);
                      }
                      timeout = this.autoRefreshTickTimeout;
                      this.autoRefreshTickTimeout = null;
                      if (timeout) {
                        clearTimeout(timeout);
                      }
                    case 1:
                      return _context206.a(2);
                  }
                }, _callee205, this);
              }));
              function _stopAutoRefresh() {
                return _stopAutoRefresh2.apply(this, arguments);
              }
              return _stopAutoRefresh;
            }()
            /**
             * Starts an auto-refresh process in the background. The session is checked
             * every few seconds. Close to the time of expiration a process is started to
             * refresh the session. If refreshing fails it will be retried for as long as
             * necessary.
             *
             * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
             * to call this function, it will be called for you.
             *
             * On browsers the refresh process works only when the tab/window is in the
             * foreground to conserve resources as well as prevent race conditions and
             * flooding auth with requests. If you call this method any managed
             * visibility change callback will be removed and you must manage visibility
             * changes on your own.
             *
             * On non-browser platforms the refresh process works *continuously* in the
             * background, which may not be desirable. You should hook into your
             * platform's foreground indication mechanism and call these methods
             * appropriately to conserve resources.
             *
             * {@see #stopAutoRefresh}
             */
            )
          }, {
            key: "startAutoRefresh",
            value: (function () {
              var _startAutoRefresh3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee206() {
                return _regenerator().w(function (_context207) {
                  while (1) switch (_context207.n) {
                    case 0:
                      this._removeVisibilityChangedCallback();
                      _context207.n = 1;
                      return this._startAutoRefresh();
                    case 1:
                      return _context207.a(2);
                  }
                }, _callee206, this);
              }));
              function startAutoRefresh() {
                return _startAutoRefresh3.apply(this, arguments);
              }
              return startAutoRefresh;
            }()
            /**
             * Stops an active auto refresh process running in the background (if any).
             *
             * If you call this method any managed visibility change callback will be
             * removed and you must manage visibility changes on your own.
             *
             * See {@link #startAutoRefresh} for more details.
             */
            )
          }, {
            key: "stopAutoRefresh",
            value: (function () {
              var _stopAutoRefresh3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee207() {
                return _regenerator().w(function (_context208) {
                  while (1) switch (_context208.n) {
                    case 0:
                      this._removeVisibilityChangedCallback();
                      _context208.n = 1;
                      return this._stopAutoRefresh();
                    case 1:
                      return _context208.a(2);
                  }
                }, _callee207, this);
              }));
              function stopAutoRefresh() {
                return _stopAutoRefresh3.apply(this, arguments);
              }
              return stopAutoRefresh;
            }()
            /**
             * Runs the auto refresh token tick.
             */
            )
          }, {
            key: "_autoRefreshTokenTick",
            value: (function () {
              var _autoRefreshTokenTick2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee210() {
                var _this147 = this;
                var _t145;
                return _regenerator().w(function (_context211) {
                  while (1) switch (_context211.p = _context211.n) {
                    case 0:
                      this._debug('#_autoRefreshTokenTick()', 'begin');
                      _context211.p = 1;
                      _context211.n = 2;
                      return this._acquireLock(0, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee209() {
                        var now, _t144;
                        return _regenerator().w(function (_context210) {
                          while (1) switch (_context210.p = _context210.n) {
                            case 0:
                              _context210.p = 0;
                              now = Date.now();
                              _context210.p = 1;
                              _context210.n = 2;
                              return _this147._useSession(/*#__PURE__*/function () {
                                var _ref251 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee208(result) {
                                  var session, expiresInTicks;
                                  return _regenerator().w(function (_context209) {
                                    while (1) switch (_context209.n) {
                                      case 0:
                                        session = result.data.session;
                                        if (!(!session || !session.refresh_token || !session.expires_at)) {
                                          _context209.n = 1;
                                          break;
                                        }
                                        _this147._debug('#_autoRefreshTokenTick()', 'no session');
                                        return _context209.a(2);
                                      case 1:
                                        // session will expire in this many ticks (or has already expired if <= 0)
                                        expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION_MS);
                                        _this147._debug('#_autoRefreshTokenTick()', "access token expires in ".concat(expiresInTicks, " ticks, a tick lasts ").concat(AUTO_REFRESH_TICK_DURATION_MS, "ms, refresh threshold is ").concat(AUTO_REFRESH_TICK_THRESHOLD, " ticks"));
                                        if (!(expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD)) {
                                          _context209.n = 2;
                                          break;
                                        }
                                        _context209.n = 2;
                                        return _this147._callRefreshToken(session.refresh_token);
                                      case 2:
                                        return _context209.a(2);
                                    }
                                  }, _callee208);
                                }));
                                return function (_x282) {
                                  return _ref251.apply(this, arguments);
                                };
                              }());
                            case 2:
                              return _context210.a(2, _context210.v);
                            case 3:
                              _context210.p = 3;
                              _t144 = _context210.v;
                              console.error('Auto refresh tick failed with error. This is likely a transient error.', _t144);
                            case 4:
                              _context210.p = 4;
                              _this147._debug('#_autoRefreshTokenTick()', 'end');
                              return _context210.f(4);
                            case 5:
                              return _context210.a(2);
                          }
                        }, _callee209, null, [[1, 3], [0,, 4, 5]]);
                      })));
                    case 2:
                      _context211.n = 5;
                      break;
                    case 3:
                      _context211.p = 3;
                      _t145 = _context211.v;
                      if (!(_t145.isAcquireTimeout || _t145 instanceof LockAcquireTimeoutError)) {
                        _context211.n = 4;
                        break;
                      }
                      this._debug('auto refresh token tick lock not available');
                      _context211.n = 5;
                      break;
                    case 4:
                      throw _t145;
                    case 5:
                      return _context211.a(2);
                  }
                }, _callee210, this, [[1, 3]]);
              }));
              function _autoRefreshTokenTick() {
                return _autoRefreshTokenTick2.apply(this, arguments);
              }
              return _autoRefreshTokenTick;
            }()
            /**
             * Registers callbacks on the browser / platform, which in-turn run
             * algorithms when the browser window/tab are in foreground. On non-browser
             * platforms it assumes always foreground.
             */
            )
          }, {
            key: "_handleVisibilityChange",
            value: (function () {
              var _handleVisibilityChange2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee212() {
                var _this148 = this;
                var _t146;
                return _regenerator().w(function (_context213) {
                  while (1) switch (_context213.p = _context213.n) {
                    case 0:
                      this._debug('#_handleVisibilityChange()');
                      if (!(!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener))) {
                        _context213.n = 1;
                        break;
                      }
                      if (this.autoRefreshToken) {
                        // in non-browser environments the refresh token ticker runs always
                        this.startAutoRefresh();
                      }
                      return _context213.a(2, false);
                    case 1:
                      _context213.p = 1;
                      this.visibilityChangedCallback = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee211() {
                        return _regenerator().w(function (_context212) {
                          while (1) switch (_context212.n) {
                            case 0:
                              _context212.n = 1;
                              return _this148._onVisibilityChanged(false);
                            case 1:
                              return _context212.a(2, _context212.v);
                          }
                        }, _callee211);
                      }));
                      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);
                      // now immediately call the visbility changed callback to setup with the
                      // current visbility state
                      _context213.n = 2;
                      return this._onVisibilityChanged(true);
                    case 2:
                      _context213.n = 4;
                      break;
                    case 3:
                      _context213.p = 3;
                      _t146 = _context213.v;
                      console.error('_handleVisibilityChange', _t146);
                    case 4:
                      return _context213.a(2);
                  }
                }, _callee212, this, [[1, 3]]);
              }));
              function _handleVisibilityChange() {
                return _handleVisibilityChange2.apply(this, arguments);
              }
              return _handleVisibilityChange;
            }()
            /**
             * Callback registered with `window.addEventListener('visibilitychange')`.
             */
            )
          }, {
            key: "_onVisibilityChanged",
            value: (function () {
              var _onVisibilityChanged2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee214(calledFromInitialize) {
                var _this149 = this;
                var methodName;
                return _regenerator().w(function (_context215) {
                  while (1) switch (_context215.n) {
                    case 0:
                      methodName = "#_onVisibilityChanged(".concat(calledFromInitialize, ")");
                      this._debug(methodName, 'visibilityState', document.visibilityState);
                      if (!(document.visibilityState === 'visible')) {
                        _context215.n = 3;
                        break;
                      }
                      if (this.autoRefreshToken) {
                        // in browser environments the refresh token ticker runs only on focused tabs
                        // which prevents race conditions
                        this._startAutoRefresh();
                      }
                      if (calledFromInitialize) {
                        _context215.n = 2;
                        break;
                      }
                      _context215.n = 1;
                      return this.initializePromise;
                    case 1:
                      _context215.n = 2;
                      return this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee213() {
                        return _regenerator().w(function (_context214) {
                          while (1) switch (_context214.n) {
                            case 0:
                              if (!(document.visibilityState !== 'visible')) {
                                _context214.n = 1;
                                break;
                              }
                              _this149._debug(methodName, 'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting');
                              // visibility has changed while waiting for the lock, abort
                              return _context214.a(2);
                            case 1:
                              _context214.n = 2;
                              return _this149._recoverAndRefresh();
                            case 2:
                              return _context214.a(2);
                          }
                        }, _callee213);
                      })));
                    case 2:
                      _context215.n = 4;
                      break;
                    case 3:
                      if (document.visibilityState === 'hidden') {
                        if (this.autoRefreshToken) {
                          this._stopAutoRefresh();
                        }
                      }
                    case 4:
                      return _context215.a(2);
                  }
                }, _callee214, this);
              }));
              function _onVisibilityChanged(_x283) {
                return _onVisibilityChanged2.apply(this, arguments);
              }
              return _onVisibilityChanged;
            }()
            /**
             * Generates the relevant login URL for a third-party provider.
             * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
             * @param options.scopes A space-separated list of scopes granted to the OAuth application.
             * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
             */
            )
          }, {
            key: "_getUrlForProvider",
            value: (function () {
              var _getUrlForProvider2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee215(url, provider, options) {
                var urlParams, _yield$getCodeChallen1, _yield$getCodeChallen10, codeChallenge, codeChallengeMethod, flowParams, query;
                return _regenerator().w(function (_context216) {
                  while (1) switch (_context216.n) {
                    case 0:
                      urlParams = ["provider=".concat(encodeURIComponent(provider))];
                      if (options === null || options === void 0 ? void 0 : options.redirectTo) {
                        urlParams.push("redirect_to=".concat(encodeURIComponent(options.redirectTo)));
                      }
                      if (options === null || options === void 0 ? void 0 : options.scopes) {
                        urlParams.push("scopes=".concat(encodeURIComponent(options.scopes)));
                      }
                      if (!(this.flowType === 'pkce')) {
                        _context216.n = 2;
                        break;
                      }
                      _context216.n = 1;
                      return getCodeChallengeAndMethod(this.storage, this.storageKey);
                    case 1:
                      _yield$getCodeChallen1 = _context216.v;
                      _yield$getCodeChallen10 = _slicedToArray(_yield$getCodeChallen1, 2);
                      codeChallenge = _yield$getCodeChallen10[0];
                      codeChallengeMethod = _yield$getCodeChallen10[1];
                      flowParams = new URLSearchParams({
                        code_challenge: "".concat(encodeURIComponent(codeChallenge)),
                        code_challenge_method: "".concat(encodeURIComponent(codeChallengeMethod))
                      });
                      urlParams.push(flowParams.toString());
                    case 2:
                      if (options === null || options === void 0 ? void 0 : options.queryParams) {
                        query = new URLSearchParams(options.queryParams);
                        urlParams.push(query.toString());
                      }
                      if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
                        urlParams.push("skip_http_redirect=".concat(options.skipBrowserRedirect));
                      }
                      return _context216.a(2, "".concat(url, "?").concat(urlParams.join('&')));
                  }
                }, _callee215, this);
              }));
              function _getUrlForProvider(_x284, _x285, _x286) {
                return _getUrlForProvider2.apply(this, arguments);
              }
              return _getUrlForProvider;
            }())
          }, {
            key: "_unenroll",
            value: function () {
              var _unenroll2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee217(params) {
                var _this150 = this;
                var _t147;
                return _regenerator().w(function (_context218) {
                  while (1) switch (_context218.p = _context218.n) {
                    case 0:
                      _context218.p = 0;
                      _context218.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref254 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee216(result) {
                          var _a, sessionData, sessionError;
                          return _regenerator().w(function (_context217) {
                            while (1) switch (_context217.n) {
                              case 0:
                                sessionData = result.data, sessionError = result.error;
                                if (!sessionError) {
                                  _context217.n = 1;
                                  break;
                                }
                                return _context217.a(2, _this150._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                _context217.n = 2;
                                return _request(_this150.fetch, 'DELETE', "".concat(_this150.url, "/factors/").concat(params.factorId), {
                                  headers: _this150.headers,
                                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                                });
                              case 2:
                                return _context217.a(2, _context217.v);
                            }
                          }, _callee216);
                        }));
                        return function (_x288) {
                          return _ref254.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context218.a(2, _context218.v);
                    case 2:
                      _context218.p = 2;
                      _t147 = _context218.v;
                      if (!isAuthError(_t147)) {
                        _context218.n = 3;
                        break;
                      }
                      return _context218.a(2, this._returnResult({
                        data: null,
                        error: _t147
                      }));
                    case 3:
                      throw _t147;
                    case 4:
                      return _context218.a(2);
                  }
                }, _callee217, this, [[0, 2]]);
              }));
              function _unenroll(_x287) {
                return _unenroll2.apply(this, arguments);
              }
              return _unenroll;
            }()
          }, {
            key: "_enroll",
            value: function () {
              var _enroll3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee219(params) {
                var _this151 = this;
                var _t148;
                return _regenerator().w(function (_context220) {
                  while (1) switch (_context220.p = _context220.n) {
                    case 0:
                      _context220.p = 0;
                      _context220.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref255 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee218(result) {
                          var _a, _b, sessionData, sessionError, body, _yield$_request10, data, error;
                          return _regenerator().w(function (_context219) {
                            while (1) switch (_context219.n) {
                              case 0:
                                sessionData = result.data, sessionError = result.error;
                                if (!sessionError) {
                                  _context219.n = 1;
                                  break;
                                }
                                return _context219.a(2, _this151._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                body = Object.assign({
                                  friendly_name: params.friendlyName,
                                  factor_type: params.factorType
                                }, params.factorType === 'phone' ? {
                                  phone: params.phone
                                } : params.factorType === 'totp' ? {
                                  issuer: params.issuer
                                } : {});
                                _context219.n = 2;
                                return _request(_this151.fetch, 'POST', "".concat(_this151.url, "/factors"), {
                                  body: body,
                                  headers: _this151.headers,
                                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                                });
                              case 2:
                                _yield$_request10 = _context219.v;
                                data = _yield$_request10.data;
                                error = _yield$_request10.error;
                                if (!error) {
                                  _context219.n = 3;
                                  break;
                                }
                                return _context219.a(2, _this151._returnResult({
                                  data: null,
                                  error: error
                                }));
                              case 3:
                                if (params.factorType === 'totp' && data.type === 'totp' && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
                                  data.totp.qr_code = "data:image/svg+xml;utf-8,".concat(data.totp.qr_code);
                                }
                                return _context219.a(2, _this151._returnResult({
                                  data: data,
                                  error: null
                                }));
                            }
                          }, _callee218);
                        }));
                        return function (_x290) {
                          return _ref255.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context220.a(2, _context220.v);
                    case 2:
                      _context220.p = 2;
                      _t148 = _context220.v;
                      if (!isAuthError(_t148)) {
                        _context220.n = 3;
                        break;
                      }
                      return _context220.a(2, this._returnResult({
                        data: null,
                        error: _t148
                      }));
                    case 3:
                      throw _t148;
                    case 4:
                      return _context220.a(2);
                  }
                }, _callee219, this, [[0, 2]]);
              }));
              function _enroll(_x289) {
                return _enroll3.apply(this, arguments);
              }
              return _enroll;
            }()
          }, {
            key: "_verify",
            value: function () {
              var _verify3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee222(params) {
                var _this152 = this;
                return _regenerator().w(function (_context223) {
                  while (1) switch (_context223.n) {
                    case 0:
                      return _context223.a(2, this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee221() {
                        var _t149;
                        return _regenerator().w(function (_context222) {
                          while (1) switch (_context222.p = _context222.n) {
                            case 0:
                              _context222.p = 0;
                              _context222.n = 1;
                              return _this152._useSession(/*#__PURE__*/function () {
                                var _ref257 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee220(result) {
                                  var _a, sessionData, sessionError, body, _yield$_request11, data, error;
                                  return _regenerator().w(function (_context221) {
                                    while (1) switch (_context221.n) {
                                      case 0:
                                        sessionData = result.data, sessionError = result.error;
                                        if (!sessionError) {
                                          _context221.n = 1;
                                          break;
                                        }
                                        return _context221.a(2, _this152._returnResult({
                                          data: null,
                                          error: sessionError
                                        }));
                                      case 1:
                                        body = Object.assign({
                                          challenge_id: params.challengeId
                                        }, 'webauthn' in params ? {
                                          webauthn: Object.assign(Object.assign({}, params.webauthn), {
                                            credential_response: params.webauthn.type === 'create' ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response)
                                          })
                                        } : {
                                          code: params.code
                                        });
                                        _context221.n = 2;
                                        return _request(_this152.fetch, 'POST', "".concat(_this152.url, "/factors/").concat(params.factorId, "/verify"), {
                                          body: body,
                                          headers: _this152.headers,
                                          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                                        });
                                      case 2:
                                        _yield$_request11 = _context221.v;
                                        data = _yield$_request11.data;
                                        error = _yield$_request11.error;
                                        if (!error) {
                                          _context221.n = 3;
                                          break;
                                        }
                                        return _context221.a(2, _this152._returnResult({
                                          data: null,
                                          error: error
                                        }));
                                      case 3:
                                        _context221.n = 4;
                                        return _this152._saveSession(Object.assign({
                                          expires_at: Math.round(Date.now() / 1000) + data.expires_in
                                        }, data));
                                      case 4:
                                        _context221.n = 5;
                                        return _this152._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);
                                      case 5:
                                        return _context221.a(2, _this152._returnResult({
                                          data: data,
                                          error: error
                                        }));
                                    }
                                  }, _callee220);
                                }));
                                return function (_x292) {
                                  return _ref257.apply(this, arguments);
                                };
                              }());
                            case 1:
                              return _context222.a(2, _context222.v);
                            case 2:
                              _context222.p = 2;
                              _t149 = _context222.v;
                              if (!isAuthError(_t149)) {
                                _context222.n = 3;
                                break;
                              }
                              return _context222.a(2, _this152._returnResult({
                                data: null,
                                error: _t149
                              }));
                            case 3:
                              throw _t149;
                            case 4:
                              return _context222.a(2);
                          }
                        }, _callee221, null, [[0, 2]]);
                      }))));
                  }
                }, _callee222, this);
              }));
              function _verify(_x291) {
                return _verify3.apply(this, arguments);
              }
              return _verify;
            }()
          }, {
            key: "_challenge",
            value: function () {
              var _challenge3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee225(params) {
                var _this153 = this;
                return _regenerator().w(function (_context226) {
                  while (1) switch (_context226.n) {
                    case 0:
                      return _context226.a(2, this._acquireLock(this.lockAcquireTimeout, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee224() {
                        var _t151;
                        return _regenerator().w(function (_context225) {
                          while (1) switch (_context225.p = _context225.n) {
                            case 0:
                              _context225.p = 0;
                              _context225.n = 1;
                              return _this153._useSession(/*#__PURE__*/function () {
                                var _ref259 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee223(result) {
                                  var _a, sessionData, sessionError, response, data, _t150;
                                  return _regenerator().w(function (_context224) {
                                    while (1) switch (_context224.n) {
                                      case 0:
                                        sessionData = result.data, sessionError = result.error;
                                        if (!sessionError) {
                                          _context224.n = 1;
                                          break;
                                        }
                                        return _context224.a(2, _this153._returnResult({
                                          data: null,
                                          error: sessionError
                                        }));
                                      case 1:
                                        _context224.n = 2;
                                        return _request(_this153.fetch, 'POST', "".concat(_this153.url, "/factors/").concat(params.factorId, "/challenge"), {
                                          body: params,
                                          headers: _this153.headers,
                                          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
                                        });
                                      case 2:
                                        response = _context224.v;
                                        if (!response.error) {
                                          _context224.n = 3;
                                          break;
                                        }
                                        return _context224.a(2, response);
                                      case 3:
                                        data = response.data;
                                        if (!(data.type !== 'webauthn')) {
                                          _context224.n = 4;
                                          break;
                                        }
                                        return _context224.a(2, {
                                          data: data,
                                          error: null
                                        });
                                      case 4:
                                        _t150 = data.webauthn.type;
                                        _context224.n = _t150 === 'create' ? 5 : _t150 === 'request' ? 6 : 7;
                                        break;
                                      case 5:
                                        return _context224.a(2, {
                                          data: Object.assign(Object.assign({}, data), {
                                            webauthn: Object.assign(Object.assign({}, data.webauthn), {
                                              credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {
                                                publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey)
                                              })
                                            })
                                          }),
                                          error: null
                                        });
                                      case 6:
                                        return _context224.a(2, {
                                          data: Object.assign(Object.assign({}, data), {
                                            webauthn: Object.assign(Object.assign({}, data.webauthn), {
                                              credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {
                                                publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey)
                                              })
                                            })
                                          }),
                                          error: null
                                        });
                                      case 7:
                                        return _context224.a(2);
                                    }
                                  }, _callee223);
                                }));
                                return function (_x294) {
                                  return _ref259.apply(this, arguments);
                                };
                              }());
                            case 1:
                              return _context225.a(2, _context225.v);
                            case 2:
                              _context225.p = 2;
                              _t151 = _context225.v;
                              if (!isAuthError(_t151)) {
                                _context225.n = 3;
                                break;
                              }
                              return _context225.a(2, _this153._returnResult({
                                data: null,
                                error: _t151
                              }));
                            case 3:
                              throw _t151;
                            case 4:
                              return _context225.a(2);
                          }
                        }, _callee224, null, [[0, 2]]);
                      }))));
                  }
                }, _callee225, this);
              }));
              function _challenge(_x293) {
                return _challenge3.apply(this, arguments);
              }
              return _challenge;
            }()
            /**
             * {@see GoTrueMFAApi#challengeAndVerify}
             */
          }, {
            key: "_challengeAndVerify",
            value: (function () {
              var _challengeAndVerify2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee226(params) {
                var _yield$this$_challeng2, challengeData, challengeError;
                return _regenerator().w(function (_context227) {
                  while (1) switch (_context227.n) {
                    case 0:
                      _context227.n = 1;
                      return this._challenge({
                        factorId: params.factorId
                      });
                    case 1:
                      _yield$this$_challeng2 = _context227.v;
                      challengeData = _yield$this$_challeng2.data;
                      challengeError = _yield$this$_challeng2.error;
                      if (!challengeError) {
                        _context227.n = 2;
                        break;
                      }
                      return _context227.a(2, this._returnResult({
                        data: null,
                        error: challengeError
                      }));
                    case 2:
                      _context227.n = 3;
                      return this._verify({
                        factorId: params.factorId,
                        challengeId: challengeData.id,
                        code: params.code
                      });
                    case 3:
                      return _context227.a(2, _context227.v);
                  }
                }, _callee226, this);
              }));
              function _challengeAndVerify(_x295) {
                return _challengeAndVerify2.apply(this, arguments);
              }
              return _challengeAndVerify;
            }()
            /**
             * {@see GoTrueMFAApi#listFactors}
             */
            )
          }, {
            key: "_listFactors",
            value: (function () {
              var _listFactors3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee227() {
                var _a, _yield$this$getUser2, user, userError, data, _iterator12, _step12, factor;
                return _regenerator().w(function (_context228) {
                  while (1) switch (_context228.n) {
                    case 0:
                      _context228.n = 1;
                      return this.getUser();
                    case 1:
                      _yield$this$getUser2 = _context228.v;
                      user = _yield$this$getUser2.data.user;
                      userError = _yield$this$getUser2.error;
                      if (!userError) {
                        _context228.n = 2;
                        break;
                      }
                      return _context228.a(2, {
                        data: null,
                        error: userError
                      });
                    case 2:
                      data = {
                        all: [],
                        phone: [],
                        totp: [],
                        webauthn: []
                      }; // loop over the factors ONCE
                      _iterator12 = _createForOfIteratorHelper((_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []);
                      try {
                        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                          factor = _step12.value;
                          data.all.push(factor);
                          if (factor.status === 'verified') {
                            data[factor.factor_type].push(factor);
                          }
                        }
                      } catch (err) {
                        _iterator12.e(err);
                      } finally {
                        _iterator12.f();
                      }
                      return _context228.a(2, {
                        data: data,
                        error: null
                      });
                  }
                }, _callee227, this);
              }));
              function _listFactors() {
                return _listFactors3.apply(this, arguments);
              }
              return _listFactors;
            }()
            /**
             * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
             */
            )
          }, {
            key: "_getAuthenticatorAssuranceLevel",
            value: (function () {
              var _getAuthenticatorAssuranceLevel2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee228() {
                var _a, _b, _yield$this$getSessio, session, sessionError, _decodeJWT2, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;
                return _regenerator().w(function (_context229) {
                  while (1) switch (_context229.n) {
                    case 0:
                      _context229.n = 1;
                      return this.getSession();
                    case 1:
                      _yield$this$getSessio = _context229.v;
                      session = _yield$this$getSessio.data.session;
                      sessionError = _yield$this$getSessio.error;
                      if (!sessionError) {
                        _context229.n = 2;
                        break;
                      }
                      return _context229.a(2, this._returnResult({
                        data: null,
                        error: sessionError
                      }));
                    case 2:
                      if (session) {
                        _context229.n = 3;
                        break;
                      }
                      return _context229.a(2, {
                        data: {
                          currentLevel: null,
                          nextLevel: null,
                          currentAuthenticationMethods: []
                        },
                        error: null
                      });
                    case 3:
                      _decodeJWT2 = decodeJWT(session.access_token), payload = _decodeJWT2.payload;
                      currentLevel = null;
                      if (payload.aal) {
                        currentLevel = payload.aal;
                      }
                      nextLevel = currentLevel;
                      verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {
                        return factor.status === 'verified';
                      })) !== null && _b !== void 0 ? _b : [];
                      if (verifiedFactors.length > 0) {
                        nextLevel = 'aal2';
                      }
                      currentAuthenticationMethods = payload.amr || [];
                      return _context229.a(2, {
                        data: {
                          currentLevel: currentLevel,
                          nextLevel: nextLevel,
                          currentAuthenticationMethods: currentAuthenticationMethods
                        },
                        error: null
                      });
                  }
                }, _callee228, this);
              }));
              function _getAuthenticatorAssuranceLevel() {
                return _getAuthenticatorAssuranceLevel2.apply(this, arguments);
              }
              return _getAuthenticatorAssuranceLevel;
            }()
            /**
             * Retrieves details about an OAuth authorization request.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             *
             * Returns authorization details including client info, scopes, and user information.
             * If the API returns a redirect_uri, it means consent was already given - the caller
             * should handle the redirect manually if needed.
             */
            )
          }, {
            key: "_getAuthorizationDetails",
            value: (function () {
              var _getAuthorizationDetails2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee230(authorizationId) {
                var _this154 = this;
                var _t152;
                return _regenerator().w(function (_context231) {
                  while (1) switch (_context231.p = _context231.n) {
                    case 0:
                      _context231.p = 0;
                      _context231.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref260 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee229(result) {
                          var session, sessionError;
                          return _regenerator().w(function (_context230) {
                            while (1) switch (_context230.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context230.n = 1;
                                  break;
                                }
                                return _context230.a(2, _this154._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                if (session) {
                                  _context230.n = 2;
                                  break;
                                }
                                return _context230.a(2, _this154._returnResult({
                                  data: null,
                                  error: new AuthSessionMissingError()
                                }));
                              case 2:
                                _context230.n = 3;
                                return _request(_this154.fetch, 'GET', "".concat(_this154.url, "/oauth/authorizations/").concat(authorizationId), {
                                  headers: _this154.headers,
                                  jwt: session.access_token,
                                  xform: function xform(data) {
                                    return {
                                      data: data,
                                      error: null
                                    };
                                  }
                                });
                              case 3:
                                return _context230.a(2, _context230.v);
                            }
                          }, _callee229);
                        }));
                        return function (_x297) {
                          return _ref260.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context231.a(2, _context231.v);
                    case 2:
                      _context231.p = 2;
                      _t152 = _context231.v;
                      if (!isAuthError(_t152)) {
                        _context231.n = 3;
                        break;
                      }
                      return _context231.a(2, this._returnResult({
                        data: null,
                        error: _t152
                      }));
                    case 3:
                      throw _t152;
                    case 4:
                      return _context231.a(2);
                  }
                }, _callee230, this, [[0, 2]]);
              }));
              function _getAuthorizationDetails(_x296) {
                return _getAuthorizationDetails2.apply(this, arguments);
              }
              return _getAuthorizationDetails;
            }()
            /**
             * Approves an OAuth authorization request.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             */
            )
          }, {
            key: "_approveAuthorization",
            value: (function () {
              var _approveAuthorization2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee232(authorizationId, options) {
                var _this155 = this;
                var _t153;
                return _regenerator().w(function (_context233) {
                  while (1) switch (_context233.p = _context233.n) {
                    case 0:
                      _context233.p = 0;
                      _context233.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref261 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee231(result) {
                          var session, sessionError, response;
                          return _regenerator().w(function (_context232) {
                            while (1) switch (_context232.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context232.n = 1;
                                  break;
                                }
                                return _context232.a(2, _this155._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                if (session) {
                                  _context232.n = 2;
                                  break;
                                }
                                return _context232.a(2, _this155._returnResult({
                                  data: null,
                                  error: new AuthSessionMissingError()
                                }));
                              case 2:
                                _context232.n = 3;
                                return _request(_this155.fetch, 'POST', "".concat(_this155.url, "/oauth/authorizations/").concat(authorizationId, "/consent"), {
                                  headers: _this155.headers,
                                  jwt: session.access_token,
                                  body: {
                                    action: 'approve'
                                  },
                                  xform: function xform(data) {
                                    return {
                                      data: data,
                                      error: null
                                    };
                                  }
                                });
                              case 3:
                                response = _context232.v;
                                if (response.data && response.data.redirect_url) {
                                  // Automatically redirect in browser unless skipBrowserRedirect is true
                                  if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
                                    window.location.assign(response.data.redirect_url);
                                  }
                                }
                                return _context232.a(2, response);
                            }
                          }, _callee231);
                        }));
                        return function (_x300) {
                          return _ref261.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context233.a(2, _context233.v);
                    case 2:
                      _context233.p = 2;
                      _t153 = _context233.v;
                      if (!isAuthError(_t153)) {
                        _context233.n = 3;
                        break;
                      }
                      return _context233.a(2, this._returnResult({
                        data: null,
                        error: _t153
                      }));
                    case 3:
                      throw _t153;
                    case 4:
                      return _context233.a(2);
                  }
                }, _callee232, this, [[0, 2]]);
              }));
              function _approveAuthorization(_x298, _x299) {
                return _approveAuthorization2.apply(this, arguments);
              }
              return _approveAuthorization;
            }()
            /**
             * Denies an OAuth authorization request.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             */
            )
          }, {
            key: "_denyAuthorization",
            value: (function () {
              var _denyAuthorization2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee234(authorizationId, options) {
                var _this156 = this;
                var _t154;
                return _regenerator().w(function (_context235) {
                  while (1) switch (_context235.p = _context235.n) {
                    case 0:
                      _context235.p = 0;
                      _context235.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref262 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee233(result) {
                          var session, sessionError, response;
                          return _regenerator().w(function (_context234) {
                            while (1) switch (_context234.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context234.n = 1;
                                  break;
                                }
                                return _context234.a(2, _this156._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                if (session) {
                                  _context234.n = 2;
                                  break;
                                }
                                return _context234.a(2, _this156._returnResult({
                                  data: null,
                                  error: new AuthSessionMissingError()
                                }));
                              case 2:
                                _context234.n = 3;
                                return _request(_this156.fetch, 'POST', "".concat(_this156.url, "/oauth/authorizations/").concat(authorizationId, "/consent"), {
                                  headers: _this156.headers,
                                  jwt: session.access_token,
                                  body: {
                                    action: 'deny'
                                  },
                                  xform: function xform(data) {
                                    return {
                                      data: data,
                                      error: null
                                    };
                                  }
                                });
                              case 3:
                                response = _context234.v;
                                if (response.data && response.data.redirect_url) {
                                  // Automatically redirect in browser unless skipBrowserRedirect is true
                                  if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
                                    window.location.assign(response.data.redirect_url);
                                  }
                                }
                                return _context234.a(2, response);
                            }
                          }, _callee233);
                        }));
                        return function (_x303) {
                          return _ref262.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context235.a(2, _context235.v);
                    case 2:
                      _context235.p = 2;
                      _t154 = _context235.v;
                      if (!isAuthError(_t154)) {
                        _context235.n = 3;
                        break;
                      }
                      return _context235.a(2, this._returnResult({
                        data: null,
                        error: _t154
                      }));
                    case 3:
                      throw _t154;
                    case 4:
                      return _context235.a(2);
                  }
                }, _callee234, this, [[0, 2]]);
              }));
              function _denyAuthorization(_x301, _x302) {
                return _denyAuthorization2.apply(this, arguments);
              }
              return _denyAuthorization;
            }()
            /**
             * Lists all OAuth grants that the authenticated user has authorized.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             */
            )
          }, {
            key: "_listOAuthGrants",
            value: (function () {
              var _listOAuthGrants2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee236() {
                var _this157 = this;
                var _t155;
                return _regenerator().w(function (_context237) {
                  while (1) switch (_context237.p = _context237.n) {
                    case 0:
                      _context237.p = 0;
                      _context237.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref263 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee235(result) {
                          var session, sessionError;
                          return _regenerator().w(function (_context236) {
                            while (1) switch (_context236.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context236.n = 1;
                                  break;
                                }
                                return _context236.a(2, _this157._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                if (session) {
                                  _context236.n = 2;
                                  break;
                                }
                                return _context236.a(2, _this157._returnResult({
                                  data: null,
                                  error: new AuthSessionMissingError()
                                }));
                              case 2:
                                _context236.n = 3;
                                return _request(_this157.fetch, 'GET', "".concat(_this157.url, "/user/oauth/grants"), {
                                  headers: _this157.headers,
                                  jwt: session.access_token,
                                  xform: function xform(data) {
                                    return {
                                      data: data,
                                      error: null
                                    };
                                  }
                                });
                              case 3:
                                return _context236.a(2, _context236.v);
                            }
                          }, _callee235);
                        }));
                        return function (_x304) {
                          return _ref263.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context237.a(2, _context237.v);
                    case 2:
                      _context237.p = 2;
                      _t155 = _context237.v;
                      if (!isAuthError(_t155)) {
                        _context237.n = 3;
                        break;
                      }
                      return _context237.a(2, this._returnResult({
                        data: null,
                        error: _t155
                      }));
                    case 3:
                      throw _t155;
                    case 4:
                      return _context237.a(2);
                  }
                }, _callee236, this, [[0, 2]]);
              }));
              function _listOAuthGrants() {
                return _listOAuthGrants2.apply(this, arguments);
              }
              return _listOAuthGrants;
            }()
            /**
             * Revokes a user's OAuth grant for a specific client.
             * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
             */
            )
          }, {
            key: "_revokeOAuthGrant",
            value: (function () {
              var _revokeOAuthGrant2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee238(options) {
                var _this158 = this;
                var _t156;
                return _regenerator().w(function (_context239) {
                  while (1) switch (_context239.p = _context239.n) {
                    case 0:
                      _context239.p = 0;
                      _context239.n = 1;
                      return this._useSession(/*#__PURE__*/function () {
                        var _ref264 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee237(result) {
                          var session, sessionError;
                          return _regenerator().w(function (_context238) {
                            while (1) switch (_context238.n) {
                              case 0:
                                session = result.data.session, sessionError = result.error;
                                if (!sessionError) {
                                  _context238.n = 1;
                                  break;
                                }
                                return _context238.a(2, _this158._returnResult({
                                  data: null,
                                  error: sessionError
                                }));
                              case 1:
                                if (session) {
                                  _context238.n = 2;
                                  break;
                                }
                                return _context238.a(2, _this158._returnResult({
                                  data: null,
                                  error: new AuthSessionMissingError()
                                }));
                              case 2:
                                _context238.n = 3;
                                return _request(_this158.fetch, 'DELETE', "".concat(_this158.url, "/user/oauth/grants"), {
                                  headers: _this158.headers,
                                  jwt: session.access_token,
                                  query: {
                                    client_id: options.clientId
                                  },
                                  noResolveJson: true
                                });
                              case 3:
                                return _context238.a(2, {
                                  data: {},
                                  error: null
                                });
                            }
                          }, _callee237);
                        }));
                        return function (_x306) {
                          return _ref264.apply(this, arguments);
                        };
                      }());
                    case 1:
                      return _context239.a(2, _context239.v);
                    case 2:
                      _context239.p = 2;
                      _t156 = _context239.v;
                      if (!isAuthError(_t156)) {
                        _context239.n = 3;
                        break;
                      }
                      return _context239.a(2, this._returnResult({
                        data: null,
                        error: _t156
                      }));
                    case 3:
                      throw _t156;
                    case 4:
                      return _context239.a(2);
                  }
                }, _callee238, this, [[0, 2]]);
              }));
              function _revokeOAuthGrant(_x305) {
                return _revokeOAuthGrant2.apply(this, arguments);
              }
              return _revokeOAuthGrant;
            }())
          }, {
            key: "fetchJwk",
            value: function () {
              var _fetchJwk = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee239(kid) {
                var jwks,
                  jwk,
                  now,
                  _yield$_request12,
                  data,
                  error,
                  _args239 = arguments;
                return _regenerator().w(function (_context240) {
                  while (1) switch (_context240.n) {
                    case 0:
                      jwks = _args239.length > 1 && _args239[1] !== undefined ? _args239[1] : {
                        keys: []
                      };
                      // try fetching from the supplied jwks
                      jwk = jwks.keys.find(function (key) {
                        return key.kid === kid;
                      });
                      if (!jwk) {
                        _context240.n = 1;
                        break;
                      }
                      return _context240.a(2, jwk);
                    case 1:
                      now = Date.now(); // try fetching from cache
                      jwk = this.jwks.keys.find(function (key) {
                        return key.kid === kid;
                      });
                      // jwk exists and jwks isn't stale
                      if (!(jwk && this.jwks_cached_at + JWKS_TTL > now)) {
                        _context240.n = 2;
                        break;
                      }
                      return _context240.a(2, jwk);
                    case 2:
                      _context240.n = 3;
                      return _request(this.fetch, 'GET', "".concat(this.url, "/.well-known/jwks.json"), {
                        headers: this.headers
                      });
                    case 3:
                      _yield$_request12 = _context240.v;
                      data = _yield$_request12.data;
                      error = _yield$_request12.error;
                      if (!error) {
                        _context240.n = 4;
                        break;
                      }
                      throw error;
                    case 4:
                      if (!(!data.keys || data.keys.length === 0)) {
                        _context240.n = 5;
                        break;
                      }
                      return _context240.a(2, null);
                    case 5:
                      this.jwks = data;
                      this.jwks_cached_at = now;
                      // Find the signing key
                      jwk = data.keys.find(function (key) {
                        return key.kid === kid;
                      });
                      if (jwk) {
                        _context240.n = 6;
                        break;
                      }
                      return _context240.a(2, null);
                    case 6:
                      return _context240.a(2, jwk);
                  }
                }, _callee239, this);
              }));
              function fetchJwk(_x307) {
                return _fetchJwk.apply(this, arguments);
              }
              return fetchJwk;
            }()
            /**
             * Extracts the JWT claims present in the access token by first verifying the
             * JWT against the server's JSON Web Key Set endpoint
             * `/.well-known/jwks.json` which is often cached, resulting in significantly
             * faster responses. Prefer this method over {@link #getUser} which always
             * sends a request to the Auth server for each JWT.
             *
             * If the project is not using an asymmetric JWT signing key (like ECC or
             * RSA) it always sends a request to the Auth server (similar to {@link
             * #getUser}) to verify the JWT.
             *
             * @param jwt An optional specific JWT you wish to verify, not the one you
             *            can obtain from {@link #getSession}.
             * @param options Various additional options that allow you to customize the
             *                behavior of this method.
             */
          }, {
            key: "getClaims",
            value: (function () {
              var _getClaims = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee240(jwt) {
                var options,
                  token,
                  _yield$this$getSessio2,
                  data,
                  error,
                  _decodeJWT3,
                  header,
                  payload,
                  signature,
                  _decodeJWT3$raw,
                  rawHeader,
                  rawPayload,
                  signingKey,
                  _yield$this$getUser3,
                  _error7,
                  algorithm,
                  publicKey,
                  isValid,
                  _args240 = arguments,
                  _t157,
                  _t158;
                return _regenerator().w(function (_context241) {
                  while (1) switch (_context241.p = _context241.n) {
                    case 0:
                      options = _args240.length > 1 && _args240[1] !== undefined ? _args240[1] : {};
                      _context241.p = 1;
                      token = jwt;
                      if (token) {
                        _context241.n = 4;
                        break;
                      }
                      _context241.n = 2;
                      return this.getSession();
                    case 2:
                      _yield$this$getSessio2 = _context241.v;
                      data = _yield$this$getSessio2.data;
                      error = _yield$this$getSessio2.error;
                      if (!(error || !data.session)) {
                        _context241.n = 3;
                        break;
                      }
                      return _context241.a(2, this._returnResult({
                        data: null,
                        error: error
                      }));
                    case 3:
                      token = data.session.access_token;
                    case 4:
                      _decodeJWT3 = decodeJWT(token), header = _decodeJWT3.header, payload = _decodeJWT3.payload, signature = _decodeJWT3.signature, _decodeJWT3$raw = _decodeJWT3.raw, rawHeader = _decodeJWT3$raw.header, rawPayload = _decodeJWT3$raw.payload;
                      if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
                        // Reject expired JWTs should only happen if jwt argument was passed
                        validateExp(payload.exp);
                      }
                      if (!(!header.alg || header.alg.startsWith('HS') || !header.kid || !('crypto' in globalThis && 'subtle' in globalThis.crypto))) {
                        _context241.n = 5;
                        break;
                      }
                      _t157 = null;
                      _context241.n = 7;
                      break;
                    case 5:
                      _context241.n = 6;
                      return this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {
                        keys: options.keys
                      } : options === null || options === void 0 ? void 0 : options.jwks);
                    case 6:
                      _t157 = _context241.v;
                    case 7:
                      signingKey = _t157;
                      if (signingKey) {
                        _context241.n = 10;
                        break;
                      }
                      _context241.n = 8;
                      return this.getUser(token);
                    case 8:
                      _yield$this$getUser3 = _context241.v;
                      _error7 = _yield$this$getUser3.error;
                      if (!_error7) {
                        _context241.n = 9;
                        break;
                      }
                      throw _error7;
                    case 9:
                      return _context241.a(2, {
                        data: {
                          claims: payload,
                          header: header,
                          signature: signature
                        },
                        error: null
                      });
                    case 10:
                      algorithm = getAlgorithm(header.alg); // Convert JWK to CryptoKey
                      _context241.n = 11;
                      return crypto.subtle.importKey('jwk', signingKey, algorithm, true, ['verify']);
                    case 11:
                      publicKey = _context241.v;
                      _context241.n = 12;
                      return crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array("".concat(rawHeader, ".").concat(rawPayload)));
                    case 12:
                      isValid = _context241.v;
                      if (isValid) {
                        _context241.n = 13;
                        break;
                      }
                      throw new AuthInvalidJwtError('Invalid JWT signature');
                    case 13:
                      return _context241.a(2, {
                        data: {
                          claims: payload,
                          header: header,
                          signature: signature
                        },
                        error: null
                      });
                    case 14:
                      _context241.p = 14;
                      _t158 = _context241.v;
                      if (!isAuthError(_t158)) {
                        _context241.n = 15;
                        break;
                      }
                      return _context241.a(2, this._returnResult({
                        data: null,
                        error: _t158
                      }));
                    case 15:
                      throw _t158;
                    case 16:
                      return _context241.a(2);
                  }
                }, _callee240, this, [[1, 14]]);
              }));
              function getClaims(_x308) {
                return _getClaims.apply(this, arguments);
              }
              return getClaims;
            }())
          }]);
        }();
        GoTrueClient.nextInstanceID = {};
        var AuthClient = GoTrueClient;

        //#region src/lib/version.ts
        var version = "2.90.1";

        //#endregion
        //#region src/lib/constants.ts
        var JS_ENV = "";
        if (typeof Deno !== "undefined") JS_ENV = "deno";else if (typeof document !== "undefined") JS_ENV = "web";else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") JS_ENV = "react-native";else JS_ENV = "node";
        var DEFAULT_HEADERS = {
          "X-Client-Info": "supabase-js-".concat(JS_ENV, "/").concat(version)
        };
        var DEFAULT_GLOBAL_OPTIONS = {
          headers: DEFAULT_HEADERS
        };
        var DEFAULT_DB_OPTIONS = {
          schema: "public"
        };
        var DEFAULT_AUTH_OPTIONS = {
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true,
          flowType: "implicit"
        };
        var DEFAULT_REALTIME_OPTIONS = {};

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/typeof.js
        function _typeof(o) {
          "@babel/helpers - typeof";

          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o$1) {
            return typeof o$1;
          } : function (o$1) {
            return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
          }, _typeof(o);
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js
        function toPrimitive(t, r) {
          if ("object" != _typeof(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != _typeof(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js
        function toPropertyKey(t) {
          var i = toPrimitive(t, "string");
          return "symbol" == _typeof(i) ? i : i + "";
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/defineProperty.js
        function _defineProperty$1(e, r, t) {
          return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }

        //#endregion
        //#region \0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js
        function ownKeys$1(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r$1) {
              return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread2(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys$1(Object(t), true).forEach(function (r$1) {
              _defineProperty$1(e, r$1, t[r$1]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r$1) {
              Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
            });
          }
          return e;
        }

        //#endregion
        //#region src/lib/fetch.ts
        var resolveFetch = function resolveFetch(customFetch) {
          if (customFetch) return function () {
            return customFetch.apply(void 0, arguments);
          };
          return function () {
            return fetch.apply(void 0, arguments);
          };
        };
        var resolveHeadersConstructor = function resolveHeadersConstructor() {
          return Headers;
        };
        var fetchWithAuth = function fetchWithAuth(supabaseKey, getAccessToken, customFetch) {
          var fetch$1 = resolveFetch(customFetch);
          var HeadersConstructor = resolveHeadersConstructor();
          return /*#__PURE__*/function () {
            var _ref265 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee241(input, init) {
              var _await$getAccessToken, accessToken, headers, _t159, _t160, _t161;
              return _regenerator().w(function (_context242) {
                while (1) switch (_context242.n) {
                  case 0:
                    _context242.n = 1;
                    return getAccessToken();
                  case 1:
                    _t160 = _await$getAccessToken = _context242.v;
                    _t159 = _t160 !== null;
                    if (!_t159) {
                      _context242.n = 2;
                      break;
                    }
                    _t159 = _await$getAccessToken !== void 0;
                  case 2:
                    if (!_t159) {
                      _context242.n = 3;
                      break;
                    }
                    _t161 = _await$getAccessToken;
                    _context242.n = 4;
                    break;
                  case 3:
                    _t161 = supabaseKey;
                  case 4:
                    accessToken = _t161;
                    headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
                    if (!headers.has("apikey")) headers.set("apikey", supabaseKey);
                    if (!headers.has("Authorization")) headers.set("Authorization", "Bearer ".concat(accessToken));
                    return _context242.a(2, fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {
                      headers: headers
                    })));
                }
              }, _callee241);
            }));
            return function (_x309, _x310) {
              return _ref265.apply(this, arguments);
            };
          }();
        };

        //#endregion
        //#region src/lib/helpers.ts
        function ensureTrailingSlash(url) {
          return url.endsWith("/") ? url : url + "/";
        }
        function applySettingDefaults(options, defaults) {
          var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;
          var dbOptions = options.db,
            authOptions = options.auth,
            realtimeOptions = options.realtime,
            globalOptions = options.global;
          var DEFAULT_DB_OPTIONS$1 = defaults.db,
            DEFAULT_AUTH_OPTIONS$1 = defaults.auth,
            DEFAULT_REALTIME_OPTIONS$1 = defaults.realtime,
            DEFAULT_GLOBAL_OPTIONS$1 = defaults.global;
          var result = {
            db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),
            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),
            realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),
            storage: {},
            global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {
              headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})
            }),
            accessToken: function () {
              var _accessToken = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee242() {
                return _regenerator().w(function (_context243) {
                  while (1) switch (_context243.n) {
                    case 0:
                      return _context243.a(2, "");
                  }
                }, _callee242);
              }));
              function accessToken() {
                return _accessToken.apply(this, arguments);
              }
              return accessToken;
            }()
          };
          if (options.accessToken) result.accessToken = options.accessToken;else delete result.accessToken;
          return result;
        }
        /**
        * Validates a Supabase client URL
        *
        * @param {string} supabaseUrl - The Supabase client URL string.
        * @returns {URL} - The validated base URL.
        * @throws {Error}
        */
        function validateSupabaseUrl(supabaseUrl) {
          var trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
          if (!trimmedUrl) throw new Error("supabaseUrl is required.");
          if (!trimmedUrl.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
          try {
            return new URL(ensureTrailingSlash(trimmedUrl));
          } catch (_unused) {
            throw Error("Invalid supabaseUrl: Provided URL is malformed.");
          }
        }

        //#endregion
        //#region src/lib/SupabaseAuthClient.ts
        var SupabaseAuthClient = /*#__PURE__*/function (_AuthClient) {
          function SupabaseAuthClient(options) {
            _classCallCheck(this, SupabaseAuthClient);
            return _callSuper(this, SupabaseAuthClient, [options]);
          }
          _inherits(SupabaseAuthClient, _AuthClient);
          return _createClass(SupabaseAuthClient);
        }(AuthClient);

        //#endregion
        //#region src/SupabaseClient.ts
        /**
        * Supabase Client.
        *
        * An isomorphic Javascript client for interacting with Postgres.
        */
        var SupabaseClient = /*#__PURE__*/function () {
          /**
          * Create a new client for use in the browser.
          * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
          * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
          * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
          * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
          * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
          * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
          * @param options.realtime Options passed along to realtime-js constructor.
          * @param options.storage Options passed along to the storage-js constructor.
          * @param options.global.fetch A custom fetch implementation.
          * @param options.global.headers Any additional headers to send with each network request.
          * @example
          * ```ts
          * import { createClient } from '@supabase/supabase-js'
          *
          * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
          * const { data } = await supabase.from('profiles').select('*')
          * ```
          */
          function SupabaseClient(supabaseUrl, supabaseKey, options) {
            var _this159 = this;
            _classCallCheck(this, SupabaseClient);
            var _settings$auth$storag, _settings$global$head;
            this.supabaseUrl = supabaseUrl;
            this.supabaseKey = supabaseKey;
            var baseUrl = validateSupabaseUrl(supabaseUrl);
            if (!supabaseKey) throw new Error("supabaseKey is required.");
            this.realtimeUrl = new URL("realtime/v1", baseUrl);
            this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
            this.authUrl = new URL("auth/v1", baseUrl);
            this.storageUrl = new URL("storage/v1", baseUrl);
            this.functionsUrl = new URL("functions/v1", baseUrl);
            var defaultStorageKey = "sb-".concat(baseUrl.hostname.split(".")[0], "-auth-token");
            var DEFAULTS = {
              db: DEFAULT_DB_OPTIONS,
              realtime: DEFAULT_REALTIME_OPTIONS,
              auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {
                storageKey: defaultStorageKey
              }),
              global: DEFAULT_GLOBAL_OPTIONS
            };
            var settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
            this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : "";
            this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};
            if (!settings.accessToken) {
              var _settings$auth;
              this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);
            } else {
              this.accessToken = settings.accessToken;
              this.auth = new Proxy({}, {
                get: function get(_, prop) {
                  throw new Error("@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.".concat(String(prop), " is not possible"));
                }
              });
            }
            this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
            this.realtime = this._initRealtimeClient(_objectSpread2({
              headers: this.headers,
              accessToken: this._getAccessToken.bind(this)
            }, settings.realtime));
            if (this.accessToken) this.accessToken().then(function (token) {
              return _this159.realtime.setAuth(token);
            }).catch(function (e) {
              return console.warn("Failed to set initial Realtime auth token:", e);
            });
            this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
              headers: this.headers,
              schema: settings.db.schema,
              fetch: this.fetch
            });
            this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
            if (!settings.accessToken) this._listenForAuthEvents();
          }
          /**
          * Supabase Functions allows you to deploy and invoke edge functions.
          */
          return _createClass(SupabaseClient, [{
            key: "functions",
            get: function get() {
              return new FunctionsClient(this.functionsUrl.href, {
                headers: this.headers,
                customFetch: this.fetch
              });
            }
            /**
            * Perform a query on a table or a view.
            *
            * @param relation - The table or view name to query
            */
          }, {
            key: "from",
            value: function from(relation) {
              return this.rest.from(relation);
            }
            /**
            * Select a schema to query or perform an function (rpc) call.
            *
            * The schema needs to be on the list of exposed schemas inside Supabase.
            *
            * @param schema - The schema to query
            */
          }, {
            key: "schema",
            value: function schema(_schema2) {
              return this.rest.schema(_schema2);
            }
            /**
            * Perform a function call.
            *
            * @param fn - The function name to call
            * @param args - The arguments to pass to the function call
            * @param options - Named parameters
            * @param options.head - When set to `true`, `data` will not be returned.
            * Useful if you only need the count.
            * @param options.get - When set to `true`, the function will be called with
            * read-only access mode.
            * @param options.count - Count algorithm to use to count rows returned by the
            * function. Only applicable for [set-returning
            * functions](https://www.postgresql.org/docs/current/functions-srf.html).
            *
            * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
            * hood.
            *
            * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
            * statistics under the hood.
            *
            * `"estimated"`: Uses exact count for low numbers and planned count for high
            * numbers.
            */
          }, {
            key: "rpc",
            value: function rpc(fn) {
              var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
                head: false,
                get: false,
                count: void 0
              };
              return this.rest.rpc(fn, args, options);
            }
            /**
            * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
            *
            * @param {string} name - The name of the Realtime channel.
            * @param {Object} opts - The options to pass to the Realtime channel.
            *
            */
          }, {
            key: "channel",
            value: function channel(name) {
              var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                config: {}
              };
              return this.realtime.channel(name, opts);
            }
            /**
            * Returns all Realtime channels.
            */
          }, {
            key: "getChannels",
            value: function getChannels() {
              return this.realtime.getChannels();
            }
            /**
            * Unsubscribes and removes Realtime channel from Realtime client.
            *
            * @param {RealtimeChannel} channel - The name of the Realtime channel.
            *
            */
          }, {
            key: "removeChannel",
            value: function removeChannel(channel) {
              return this.realtime.removeChannel(channel);
            }
            /**
            * Unsubscribes and removes all Realtime channels from Realtime client.
            */
          }, {
            key: "removeAllChannels",
            value: function removeAllChannels() {
              return this.realtime.removeAllChannels();
            }
          }, {
            key: "_getAccessToken",
            value: function () {
              var _getAccessToken2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee243() {
                var _this, _data$session$access_, _data$session, _yield$_this$auth$get, data;
                return _regenerator().w(function (_context244) {
                  while (1) switch (_context244.n) {
                    case 0:
                      _this = this;
                      if (!_this.accessToken) {
                        _context244.n = 2;
                        break;
                      }
                      _context244.n = 1;
                      return _this.accessToken();
                    case 1:
                      return _context244.a(2, _context244.v);
                    case 2:
                      _context244.n = 3;
                      return _this.auth.getSession();
                    case 3:
                      _yield$_this$auth$get = _context244.v;
                      data = _yield$_this$auth$get.data;
                      return _context244.a(2, (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey);
                  }
                }, _callee243, this);
              }));
              function _getAccessToken() {
                return _getAccessToken2.apply(this, arguments);
              }
              return _getAccessToken;
            }()
          }, {
            key: "_initSupabaseAuthClient",
            value: function _initSupabaseAuthClient(_ref266, headers, fetch$1) {
              var autoRefreshToken = _ref266.autoRefreshToken,
                persistSession = _ref266.persistSession,
                detectSessionInUrl = _ref266.detectSessionInUrl,
                storage = _ref266.storage,
                userStorage = _ref266.userStorage,
                storageKey = _ref266.storageKey,
                flowType = _ref266.flowType,
                lock = _ref266.lock,
                debug = _ref266.debug,
                throwOnError = _ref266.throwOnError;
              var authHeaders = {
                Authorization: "Bearer ".concat(this.supabaseKey),
                apikey: "".concat(this.supabaseKey)
              };
              return new SupabaseAuthClient({
                url: this.authUrl.href,
                headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),
                storageKey: storageKey,
                autoRefreshToken: autoRefreshToken,
                persistSession: persistSession,
                detectSessionInUrl: detectSessionInUrl,
                storage: storage,
                userStorage: userStorage,
                flowType: flowType,
                lock: lock,
                debug: debug,
                throwOnError: throwOnError,
                fetch: fetch$1,
                hasCustomAuthorizationHeader: Object.keys(this.headers).some(function (key) {
                  return key.toLowerCase() === "authorization";
                })
              });
            }
          }, {
            key: "_initRealtimeClient",
            value: function _initRealtimeClient(options) {
              return new RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {
                params: _objectSpread2(_objectSpread2({}, {
                  apikey: this.supabaseKey
                }), options === null || options === void 0 ? void 0 : options.params)
              }));
            }
          }, {
            key: "_listenForAuthEvents",
            value: function _listenForAuthEvents() {
              var _this160 = this;
              return this.auth.onAuthStateChange(function (event, session) {
                _this160._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
              });
            }
          }, {
            key: "_handleTokenChanged",
            value: function _handleTokenChanged(event, source, token) {
              if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
                this.changedAccessToken = token;
                this.realtime.setAuth(token);
              } else if (event === "SIGNED_OUT") {
                this.realtime.setAuth();
                if (source == "STORAGE") this.auth.signOut();
                this.changedAccessToken = void 0;
              }
            }
          }]);
        }();

        //#endregion
        //#region src/index.ts
        /**
        * Creates a new Supabase Client.
        *
        * @example
        * ```ts
        * import { createClient } from '@supabase/supabase-js'
        *
        * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
        * const { data, error } = await supabase.from('profiles').select('*')
        * ```
        */
        var createClient = function createClient(supabaseUrl, supabaseKey, options) {
          return new SupabaseClient(supabaseUrl, supabaseKey, options);
        };
        function shouldShowDeprecationWarning() {
          if (typeof window !== "undefined") return false;
          var _process = globalThis["process"];
          if (!_process) return false;
          var processVersion = _process["version"];
          if (processVersion === void 0 || processVersion === null) return false;
          var versionMatch = processVersion.match(/^v(\d+)\./);
          if (!versionMatch) return false;
          return parseInt(versionMatch[1], 10) <= 18;
        }
        if (shouldShowDeprecationWarning()) console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
        var supabaseUrl$1 = 'https://bufakaksnwpcljmyrohj.supabase.co';
        var supabaseAnonKey$1 = 'sb_publishable_QCE5SPvtTWqf7vz8oU6K_A_EVGNTd21';
        var supabase$1 = createClient(supabaseUrl$1, supabaseAnonKey$1);
        function useContent() {
          var _reactExports$useStat53 = reactExports.useState(treatiesData),
            _reactExports$useStat54 = _slicedToArray(_reactExports$useStat53, 2),
            treaties = _reactExports$useStat54[0],
            setTreaties = _reactExports$useStat54[1];
          var _reactExports$useStat55 = reactExports.useState(casesData),
            _reactExports$useStat56 = _slicedToArray(_reactExports$useStat55, 2),
            cases = _reactExports$useStat56[0],
            setCases = _reactExports$useStat56[1];
          var _reactExports$useStat57 = reactExports.useState([]),
            _reactExports$useStat58 = _slicedToArray(_reactExports$useStat57, 2),
            resolutions = _reactExports$useStat58[0],
            setResolutions = _reactExports$useStat58[1];
          var _reactExports$useStat59 = reactExports.useState(true),
            _reactExports$useStat60 = _slicedToArray(_reactExports$useStat59, 2),
            loading = _reactExports$useStat60[0],
            setLoading = _reactExports$useStat60[1];
          reactExports.useEffect(function () {
            var fetchData = /*#__PURE__*/function () {
              var _ref267 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee244() {
                var _yield$supabase$1$fro, remoteTreaties, treatiesError, _yield$supabase$1$fro2, remoteCases, casesError, _yield$supabase$1$fro3, remoteResolutions, resolutionsError, _t162;
                return _regenerator().w(function (_context245) {
                  while (1) switch (_context245.p = _context245.n) {
                    case 0:
                      _context245.p = 0;
                      _context245.n = 1;
                      return supabase$1.from('treaties').select('*').order('created_at', {
                        ascending: false
                      });
                    case 1:
                      _yield$supabase$1$fro = _context245.v;
                      remoteTreaties = _yield$supabase$1$fro.data;
                      treatiesError = _yield$supabase$1$fro.error;
                      if (!treatiesError && remoteTreaties.length > 0) {
                        // Combine Static + Remote (or replace, depending on strategy)
                        // Here we append remote ones to static ones for now
                        // Or simpler: We prefer remote if available, but to keep static data visible without migration:
                        setTreaties([].concat(_toConsumableArray(remoteTreaties), treatiesData));
                      }

                      // Fetch Cases
                      _context245.n = 2;
                      return supabase$1.from('cases').select('*').order('created_at', {
                        ascending: false
                      });
                    case 2:
                      _yield$supabase$1$fro2 = _context245.v;
                      remoteCases = _yield$supabase$1$fro2.data;
                      casesError = _yield$supabase$1$fro2.error;
                      if (!casesError && remoteCases.length > 0) {
                        setCases([].concat(_toConsumableArray(remoteCases), casesData));
                      }

                      // Fetch Resolutions
                      _context245.n = 3;
                      return supabase$1.from('resolutions').select('*').order('created_at', {
                        ascending: false
                      });
                    case 3:
                      _yield$supabase$1$fro3 = _context245.v;
                      remoteResolutions = _yield$supabase$1$fro3.data;
                      resolutionsError = _yield$supabase$1$fro3.error;
                      if (!resolutionsError && remoteResolutions.length > 0) {
                        setResolutions(remoteResolutions);
                      }
                      _context245.n = 5;
                      break;
                    case 4:
                      _context245.p = 4;
                      _t162 = _context245.v;
                      console.error("Error fetching content:", _t162);
                    case 5:
                      _context245.p = 5;
                      setLoading(false);
                      return _context245.f(5);
                    case 6:
                      return _context245.a(2);
                  }
                }, _callee244, null, [[0, 4, 5, 6]]);
              }));
              return function fetchData() {
                return _ref267.apply(this, arguments);
              };
            }();
            fetchData();

            // Realtime Subscriptions
            var treatiesSub = supabase$1.channel('public:treaties').on('postgres_changes', {
              event: 'INSERT',
              schema: 'public',
              table: 'treaties'
            }, function (payload) {
              setTreaties(function (prev) {
                return [payload.new].concat(_toConsumableArray(prev));
              });
            }).subscribe();
            var casesSub = supabase$1.channel('public:cases').on('postgres_changes', {
              event: 'INSERT',
              schema: 'public',
              table: 'cases'
            }, function (payload) {
              setCases(function (prev) {
                return [payload.new].concat(_toConsumableArray(prev));
              });
            }).subscribe();
            var resolutionsSub = supabase$1.channel('public:resolutions').on('postgres_changes', {
              event: 'INSERT',
              schema: 'public',
              table: 'resolutions'
            }, function (payload) {
              setResolutions(function (prev) {
                return [payload.new].concat(_toConsumableArray(prev));
              });
            }).subscribe();
            return function () {
              supabase$1.removeChannel(treatiesSub);
              supabase$1.removeChannel(casesSub);
              supabase$1.removeChannel(resolutionsSub);
            };
          }, []);
          var isNew = function isNew(dateString) {
            if (!dateString) return false;
            var date = new Date(dateString);
            var now = new Date();
            var diffTime = Math.abs(now - date);
            var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays <= 30;
          };
          return {
            treaties: treaties,
            cases: cases,
            resolutions: resolutions,
            loading: loading,
            isNew: isNew
          };
        }
        var navItems = [{
          id: "treaties",
          label: " ",
          icon: ""
        }, {
          id: "cases",
          label: " ",
          icon: ""
        }, {
          id: "resolutions",
          label: " ",
          icon: ""
        }, {
          id: "resources",
          label: " ",
          icon: ""
        }];
        function Sidebar(_ref268) {
          var activeTab = _ref268.activeTab,
            setActiveTab = _ref268.setActiveTab,
            onClose = _ref268.onClose;
          var activeBg = useColorModeValue("brand.600", "brand.400");
          var hoverBg = useColorModeValue("gray.100", "gray.700");
          return /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
            align: "stretch",
            spacing: 2,
            p: 4,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              textAlign: "center",
              py: 4,
              mb: 4,
              borderBottom: "1px",
              borderColor: useColorModeValue("gray.200", "gray.700"),
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                size: "md",
                color: "brand.600",
                children: "  "
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                fontSize: "xs",
                color: "gray.500",
                mt: 1,
                children: "  "
              })]
            }), navItems.map(function (item) {
              return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                as: "button",
                onClick: function onClick() {
                  setActiveTab(item.id);
                  onClose && onClose();
                },
                display: "flex",
                alignItems: "center",
                gap: 3,
                px: 4,
                py: 3,
                borderRadius: "lg",
                fontWeight: "600",
                bg: activeTab === item.id ? activeBg : "transparent",
                color: activeTab === item.id ? "white" : useColorModeValue("gray.600", "gray.400"),
                _hover: {
                  bg: activeTab === item.id ? activeBg : hoverBg
                },
                transition: "all 0.2s",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  fontSize: "xl",
                  children: item.icon
                }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  children: item.label
                })]
              }, item.id);
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              pt: 4,
              mt: 4,
              borderTop: "1px",
              borderColor: useColorModeValue("gray.200", "gray.700"),
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                spacing: 2,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/ai-search",
                  colorScheme: "purple",
                  size: "sm",
                  width: "100%",
                  variant: "outline",
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/compare",
                  colorScheme: "teal",
                  size: "sm",
                  width: "100%",
                  variant: "outline",
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/world-map",
                  colorScheme: "blue",
                  size: "sm",
                  width: "100%",
                  variant: "outline",
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/country-compare",
                  colorScheme: "orange",
                  size: "sm",
                  width: "100%",
                  variant: "outline",
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/news",
                  colorScheme: "red",
                  size: "sm",
                  width: "100%",
                  variant: "outline",
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: Link$1,
                  to: "/contribute",
                  colorScheme: "brand",
                  size: "sm",
                  width: "100%",
                  children: "+  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  as: "a",
                  href: "https://github.com/bssoof/international-law-reference/raw/main/law-observatory-v1.0.0.apk",
                  download: true,
                  colorScheme: "green",
                  size: "sm",
                  width: "100%",
                  leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: ""
                  }),
                  children: " "
                })]
              })
            })]
          });
        }
        function TopicBadge(_ref269) {
          var topic = _ref269.topic;
          var colorMap = {
            " ": "blue",
            " ": "purple",
            " ": "red",
            " ": "orange",
            "": "green",
            " ": "cyan"
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
            colorScheme: colorMap[topic] || "gray",
            borderRadius: "full",
            px: 2,
            children: topic
          });
        }
        function usePagination(data) {
          var itemsPerPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
          var _reactExports$useStat61 = reactExports.useState(1),
            _reactExports$useStat62 = _slicedToArray(_reactExports$useStat61, 2),
            currentPage = _reactExports$useStat62[0],
            setCurrentPage = _reactExports$useStat62[1];
          var maxPage = Math.ceil(data.length / itemsPerPage);
          var currentData = reactExports.useMemo(function () {
            var begin = (currentPage - 1) * itemsPerPage;
            var end = begin + itemsPerPage;
            return data.slice(begin, end);
          }, [data, currentPage, itemsPerPage]);
          reactExports.useEffect(function () {
            return setCurrentPage(1);
          }, [data.length]);
          var next = function next() {
            return setCurrentPage(function (p) {
              return Math.min(p + 1, maxPage);
            });
          };
          var prev = function prev() {
            return setCurrentPage(function (p) {
              return Math.max(p - 1, 1);
            });
          };
          return {
            next: next,
            prev: prev,
            jump: setCurrentPage,
            currentData: currentData,
            currentPage: currentPage,
            maxPage: maxPage
          };
        }
        function App() {
          var _navItems$find;
          var _useDisclosure2 = useDisclosure(),
            isOpen = _useDisclosure2.isOpen,
            onOpen = _useDisclosure2.onOpen,
            onClose = _useDisclosure2.onClose;
          var _useColorMode4 = useColorMode(),
            colorMode = _useColorMode4.colorMode,
            toggleColorMode = _useColorMode4.toggleColorMode;
          var _reactExports$useStat63 = reactExports.useState("treaties"),
            _reactExports$useStat64 = _slicedToArray(_reactExports$useStat63, 2),
            activeTab = _reactExports$useStat64[0],
            setActiveTab = _reactExports$useStat64[1];
          var _reactExports$useStat65 = reactExports.useState(""),
            _reactExports$useStat66 = _slicedToArray(_reactExports$useStat65, 2),
            searchQuery = _reactExports$useStat66[0],
            setSearchQuery = _reactExports$useStat66[1];
          var _useContent = useContent(),
            isNew = _useContent.isNew;
          var filterData = function filterData(data) {
            return data.filter(function (item) {
              var _item$description;
              return item.name.includes(searchQuery) || ((_item$description = item.description) === null || _item$description === void 0 ? void 0 : _item$description.includes(searchQuery)) || item.topic.includes(searchQuery);
            });
          };
          var filteredData = reactExports.useMemo(function () {
            switch (activeTab) {
              case "treaties":
                return filterData(treatiesData);
              case "cases":
                return filterData(casesData);
              case "resolutions":
                return filterData(resolutionsData);
              case "resources":
                return resourcesData;
              default:
                return [];
            }
          }, [activeTab, searchQuery]);
          var _usePagination = usePagination(filteredData),
            next = _usePagination.next,
            prev = _usePagination.prev,
            currentData = _usePagination.currentData,
            currentPage = _usePagination.currentPage,
            maxPage = _usePagination.maxPage;
          var cardBg = useColorModeValue("white", "gray.800");
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            minH: "100vh",
            bg: useColorModeValue("gray.50", "gray.900"),
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Flex, {
              as: "nav",
              align: "center",
              justify: "space-between",
              wrap: "wrap",
              padding: "1rem",
              bg: useColorModeValue("white", "gray.800"),
              color: useColorModeValue("gray.600", "white"),
              borderBottom: "1px",
              borderColor: useColorModeValue("gray.200", "gray.700"),
              position: "sticky",
              top: "0",
              zIndex: "sticky",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Flex, {
                align: "center",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  display: {
                    base: "flex",
                    md: "none"
                  },
                  onClick: onOpen,
                  icon: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: ""
                  }),
                  variant: "ghost",
                  "aria-label": "Open Menu",
                  mr: 2
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                  size: "md",
                  display: {
                    base: "none",
                    md: "block"
                  },
                  children: " "
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(InputGroup, {
                  maxW: "400px",
                  mr: 8,
                  display: {
                    base: "none",
                    md: "block"
                  },
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLeftElement, {
                    pointerEvents: "none",
                    children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                      children: ""
                    })
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                    placeholder: " ...",
                    value: searchQuery,
                    onChange: function onChange(e) {
                      return setSearchQuery(e.target.value);
                    },
                    borderRadius: "full"
                  })]
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Flex, {
                align: "center",
                gap: 2,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: toggleColorMode,
                  icon: colorMode === "light" ? /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: ""
                  }) : /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: ""
                  }),
                  variant: "ghost",
                  isRound: true,
                  "aria-label": "Toggle Theme"
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Flex, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                display: {
                  base: "none",
                  md: "block"
                },
                w: "280px",
                minH: "calc(100vh - 73px)",
                bg: useColorModeValue("white", "gray.800"),
                borderLeft: "1px",
                borderColor: useColorModeValue("gray.200", "gray.700"),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Sidebar, {
                  activeTab: activeTab,
                  setActiveTab: setActiveTab
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(Drawer, {
                isOpen: isOpen,
                placement: "right",
                onClose: onClose,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ModalOverlay, {}), /* @__PURE__ */jsxRuntimeExports.jsxs(DrawerContent, {
                  bg: useColorModeValue("white", "gray.800"),
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(ModalCloseButton, {}), /* @__PURE__ */jsxRuntimeExports.jsx(ModalHeader, {
                    borderBottomWidth: "1px",
                    children: ""
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(ModalBody, {
                    p: 0,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(Sidebar, {
                      activeTab: activeTab,
                      setActiveTab: setActiveTab,
                      onClose: onClose
                    })
                  })]
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                flex: "1",
                p: {
                  base: 4,
                  md: 8
                },
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                  display: {
                    base: "block",
                    md: "none"
                  },
                  mb: 6,
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(InputGroup, {
                    size: "lg",
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLeftElement, {
                      pointerEvents: "none",
                      children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                        children: ""
                      })
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                      placeholder: "...",
                      value: searchQuery,
                      onChange: function onChange(e) {
                        return setSearchQuery(e.target.value);
                      },
                      borderRadius: "full",
                      bg: useColorModeValue("white", "gray.700")
                    })]
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Flex, {
                  justify: "space-between",
                  align: "center",
                  mb: 6,
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(Heading, {
                    size: "lg",
                    children: [(_navItems$find = navItems.find(function (i) {
                      return i.id === activeTab;
                    })) === null || _navItems$find === void 0 ? void 0 : _navItems$find.label, /* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                      ml: 2,
                      colorScheme: "brand",
                      fontSize: "md",
                      borderRadius: "full",
                      children: filteredData.length
                    })]
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(SimpleGrid, {
                  columns: {
                    base: 1,
                    md: 2,
                    lg: 3,
                    xl: 4
                  },
                  spacing: 6,
                  children: currentData.map(function (item) {
                    return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                      bg: cardBg,
                      shadow: "sm",
                      _hover: {
                        shadow: "md",
                        transform: "translateY(-2px)"
                      },
                      transition: "all 0.2s",
                      as: activeTab !== "resources" ? Link$1 : Link,
                      to: activeTab !== "resources" ? "/".concat(activeTab.slice(0, -1), "/").concat(item.id) : void 0,
                      href: activeTab === "resources" ? item.url : void 0,
                      isExternal: activeTab === "resources",
                      children: /* @__PURE__ */jsxRuntimeExports.jsx(CardBody, {
                        children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                          align: "start",
                          spacing: 3,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(TopicBadge, {
                            topic: item.topic || item.category || ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                            size: "md",
                            noOfLines: 2,
                            children: item.name || item.title
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                            fontSize: "sm",
                            color: "gray.500",
                            noOfLines: 3,
                            children: item.description || item.summary || " ..."
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                            pt: 2,
                            w: "100%",
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                              fontSize: "xs",
                              color: "gray.400",
                              children: item.date || item.year
                            }), isNew(item.date) && /* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                              colorScheme: "green",
                              variant: "subtle",
                              children: ""
                            })]
                          })]
                        })
                      })
                    }, item.id);
                  })
                }), filteredData.length === 0 && /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                  textAlign: "center",
                  py: 10,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    fontSize: "lg",
                    color: "gray.500",
                    children: "    ."
                  })
                }), filteredData.length > 8 && /* @__PURE__ */jsxRuntimeExports.jsxs(Flex, {
                  justify: "center",
                  align: "center",
                  mt: 8,
                  gap: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    icon: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                      children: ""
                    }),
                    onClick: prev,
                    isDisabled: currentPage === 1,
                    isRound: true,
                    variant: "outline"
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                    fontWeight: "bold",
                    children: [" ", currentPage, "  ", maxPage]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    icon: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                      children: ""
                    }),
                    onClick: next,
                    isDisabled: currentPage === maxPage,
                    isRound: true,
                    variant: "outline"
                  })]
                })]
              })]
            })]
          });
        }
        var DefaultContext = {
          color: undefined,
          size: undefined,
          className: undefined,
          style: undefined,
          attr: undefined
        };
        var IconContext = React.createContext && /*#__PURE__*/React.createContext(DefaultContext);
        var _excluded = ["attr", "size", "title"];
        function _objectWithoutProperties(source, excluded) {
          if (source == null) return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0; i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              if (excluded.indexOf(key) >= 0) continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _extends() {
          _extends = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        function ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
              _defineProperty(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
          }
          return e;
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _toPropertyKey(t) {
          var i = _toPrimitive(t, "string");
          return "symbol" == _typeof2(i) ? i : i + "";
        }
        function _toPrimitive(t, r) {
          if ("object" != _typeof2(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r);
            if ("object" != _typeof2(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        function Tree2Element(tree) {
          return tree && tree.map(function (node, i) {
            return /*#__PURE__*/React.createElement(node.tag, _objectSpread({
              key: i
            }, node.attr), Tree2Element(node.child));
          });
        }
        function GenIcon(data) {
          return function (props) {
            return /*#__PURE__*/React.createElement(IconBase, _extends({
              attr: _objectSpread({}, data.attr)
            }, props), Tree2Element(data.child));
          };
        }
        function IconBase(props) {
          var elem = function elem(conf) {
            var attr = props.attr,
              size = props.size,
              title = props.title,
              svgProps = _objectWithoutProperties(props, _excluded);
            var computedSize = size || conf.size || "1em";
            var className;
            if (conf.className) className = conf.className;
            if (props.className) className = (className ? className + " " : "") + props.className;
            return /*#__PURE__*/React.createElement("svg", _extends({
              stroke: "currentColor",
              fill: "currentColor",
              strokeWidth: "0"
            }, conf.attr, attr, svgProps, {
              className: className,
              style: _objectSpread(_objectSpread({
                color: props.color || conf.color
              }, conf.style), props.style),
              height: computedSize,
              width: computedSize,
              xmlns: "http://www.w3.org/2000/svg"
            }), title && /*#__PURE__*/React.createElement("title", null, title), props.children);
          };
          return IconContext !== undefined ? /*#__PURE__*/React.createElement(IconContext.Consumer, null, function (conf) {
            return elem(conf);
          }) : elem(DefaultContext);
        }

        // THIS FILE IS AUTO GENERATED
        function FiArrowRight(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "line",
              "attr": {
                "x1": "5",
                "y1": "12",
                "x2": "19",
                "y2": "12"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "12 5 19 12 12 19"
              },
              "child": []
            }]
          })(props);
        }
        function FiAward(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "circle",
              "attr": {
                "cx": "12",
                "cy": "8",
                "r": "7"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "8.21 13.89 7 23 12 20 17 23 15.79 13.88"
              },
              "child": []
            }]
          })(props);
        }
        function FiCalendar(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "rect",
              "attr": {
                "x": "3",
                "y": "4",
                "width": "18",
                "height": "18",
                "rx": "2",
                "ry": "2"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "16",
                "y1": "2",
                "x2": "16",
                "y2": "6"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "8",
                "y1": "2",
                "x2": "8",
                "y2": "6"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "3",
                "y1": "10",
                "x2": "21",
                "y2": "10"
              },
              "child": []
            }]
          })(props);
        }
        function FiClock(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "circle",
              "attr": {
                "cx": "12",
                "cy": "12",
                "r": "10"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "12 6 12 12 16 14"
              },
              "child": []
            }]
          })(props);
        }
        function FiColumns(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "path",
              "attr": {
                "d": "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"
              },
              "child": []
            }]
          })(props);
        }
        function FiExternalLink(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "path",
              "attr": {
                "d": "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "15 3 21 3 21 9"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "10",
                "y1": "14",
                "x2": "21",
                "y2": "3"
              },
              "child": []
            }]
          })(props);
        }
        function FiFileText(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "path",
              "attr": {
                "d": "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "14 2 14 8 20 8"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "16",
                "y1": "13",
                "x2": "8",
                "y2": "13"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "16",
                "y1": "17",
                "x2": "8",
                "y2": "17"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "10 9 9 9 8 9"
              },
              "child": []
            }]
          })(props);
        }
        function FiGlobe(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "circle",
              "attr": {
                "cx": "12",
                "cy": "12",
                "r": "10"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "2",
                "y1": "12",
                "x2": "22",
                "y2": "12"
              },
              "child": []
            }, {
              "tag": "path",
              "attr": {
                "d": "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"
              },
              "child": []
            }]
          })(props);
        }
        function FiHeart(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "path",
              "attr": {
                "d": "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
              },
              "child": []
            }]
          })(props);
        }
        function FiInfo(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "circle",
              "attr": {
                "cx": "12",
                "cy": "12",
                "r": "10"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "12",
                "y1": "16",
                "x2": "12",
                "y2": "12"
              },
              "child": []
            }, {
              "tag": "line",
              "attr": {
                "x1": "12",
                "y1": "8",
                "x2": "12.01",
                "y2": "8"
              },
              "child": []
            }]
          })(props);
        }
        function FiRefreshCw(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "polyline",
              "attr": {
                "points": "23 4 23 10 17 10"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "1 20 1 14 7 14"
              },
              "child": []
            }, {
              "tag": "path",
              "attr": {
                "d": "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"
              },
              "child": []
            }]
          })(props);
        }
        function FiSend(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "line",
              "attr": {
                "x1": "22",
                "y1": "2",
                "x2": "11",
                "y2": "13"
              },
              "child": []
            }, {
              "tag": "polygon",
              "attr": {
                "points": "22 2 15 22 11 13 2 9 22 2"
              },
              "child": []
            }]
          })(props);
        }
        function FiTrendingUp(props) {
          return GenIcon({
            "attr": {
              "viewBox": "0 0 24 24",
              "fill": "none",
              "stroke": "currentColor",
              "strokeWidth": "2",
              "strokeLinecap": "round",
              "strokeLinejoin": "round"
            },
            "child": [{
              "tag": "polyline",
              "attr": {
                "points": "23 6 13.5 15.5 8.5 10.5 1 18"
              },
              "child": []
            }, {
              "tag": "polyline",
              "attr": {
                "points": "17 6 23 6 23 12"
              },
              "child": []
            }]
          })(props);
        }
        var UserContext = reactExports.createContext();
        var useUser = function useUser() {
          return reactExports.useContext(UserContext);
        };
        function FavoriteButton(_ref270) {
          var item = _ref270.item,
            type = _ref270.type;
          var _useUser = useUser(),
            toggleFavorite = _useUser.toggleFavorite,
            isFavorite = _useUser.isFavorite;
          var isFav = isFavorite(item.id, type);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip, {
            label: isFav ? "  " : " ",
            children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              icon: /* @__PURE__ */jsxRuntimeExports.jsx(FiHeart, {
                fill: isFav ? "red" : "none",
                color: isFav ? "red" : "gray"
              }),
              onClick: function onClick() {
                return toggleFavorite(_objectSpread3(_objectSpread3({}, item), {}, {
                  type: type
                }));
              },
              variant: "ghost",
              borderRadius: "full",
              "aria-label": "Toggle Favorite",
              size: "md"
            })
          });
        }
        function Comments(_ref271) {
          var itemId = _ref271.itemId,
            type = _ref271.type;
          var _useUser2 = useUser(),
            user = _useUser2.user;
          var _reactExports$useStat67 = reactExports.useState([]),
            _reactExports$useStat68 = _slicedToArray(_reactExports$useStat67, 2),
            comments = _reactExports$useStat68[0],
            setComments = _reactExports$useStat68[1];
          var _reactExports$useStat69 = reactExports.useState(""),
            _reactExports$useStat70 = _slicedToArray(_reactExports$useStat69, 2),
            newComment = _reactExports$useStat70[0],
            setNewComment = _reactExports$useStat70[1];
          var _reactExports$useStat71 = reactExports.useState(false),
            _reactExports$useStat72 = _slicedToArray(_reactExports$useStat71, 2),
            loading = _reactExports$useStat72[0],
            setLoading = _reactExports$useStat72[1];
          var toast = useToast();
          reactExports.useEffect(function () {
            fetchComments();
            var channel = supabase$1.channel("public:comments").on("postgres_changes", {
              event: "INSERT",
              schema: "public",
              table: "comments"
            }, function (payload) {
              if (payload.new.item_id === itemId.toString() && payload.new.item_type === type) {
                setComments(function (prev) {
                  return [payload.new].concat(_toConsumableArray(prev));
                });
              }
            }).subscribe();
            return function () {
              return supabase$1.removeChannel(channel);
            };
          }, [itemId, type]);
          var fetchComments = /*#__PURE__*/function () {
            var _ref272 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee245() {
              var _yield$supabase$1$fro4, data, error;
              return _regenerator().w(function (_context246) {
                while (1) switch (_context246.n) {
                  case 0:
                    _context246.n = 1;
                    return supabase$1.from("comments").select("*").eq("item_id", itemId.toString()).eq("item_type", type).order("created_at", {
                      ascending: false
                    });
                  case 1:
                    _yield$supabase$1$fro4 = _context246.v;
                    data = _yield$supabase$1$fro4.data;
                    error = _yield$supabase$1$fro4.error;
                    if (error) console.error("Error fetching comments:", error);else setComments(data || []);
                  case 2:
                    return _context246.a(2);
                }
              }, _callee245);
            }));
            return function fetchComments() {
              return _ref272.apply(this, arguments);
            };
          }();
          var handleAddComment = /*#__PURE__*/function () {
            var _ref273 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee246() {
              var _user$user_metadata;
              var comment, _yield$supabase$1$fro5, error;
              return _regenerator().w(function (_context247) {
                while (1) switch (_context247.n) {
                  case 0:
                    if (user) {
                      _context247.n = 1;
                      break;
                    }
                    toast({
                      title: "   ",
                      status: "warning"
                    });
                    return _context247.a(2);
                  case 1:
                    if (newComment.trim()) {
                      _context247.n = 2;
                      break;
                    }
                    return _context247.a(2);
                  case 2:
                    setLoading(true);
                    comment = {
                      item_id: itemId.toString(),
                      item_type: type,
                      content: newComment,
                      author_name: user.name,
                      author_avatar: (_user$user_metadata = user.user_metadata) === null || _user$user_metadata === void 0 ? void 0 : _user$user_metadata.avatar_url,
                      user_id: user.id
                    };
                    _context247.n = 3;
                    return supabase$1.from("comments").insert([comment]);
                  case 3:
                    _yield$supabase$1$fro5 = _context247.v;
                    error = _yield$supabase$1$fro5.error;
                    if (error) {
                      toast({
                        title: "   ",
                        description: error.message,
                        status: "error"
                      });
                    } else {
                      setNewComment("");
                      toast({
                        title: "  ",
                        status: "success"
                      });
                    }
                    setLoading(false);
                  case 4:
                    return _context247.a(2);
                }
              }, _callee246);
            }));
            return function handleAddComment() {
              return _ref273.apply(this, arguments);
            };
          }();
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            mt: 8,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Heading, {
              size: "md",
              mb: 6,
              children: [" (", comments.length, ")"]
            }), user ? /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
              align: "stretch",
              mb: 8,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                value: newComment,
                onChange: function onChange(e) {
                  return setNewComment(e.target.value);
                },
                placeholder: "  ...",
                rows: 3,
                isDisabled: loading
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                colorScheme: "brand",
                onClick: handleAddComment,
                alignSelf: "flex-end",
                isDisabled: !newComment.trim(),
                isLoading: loading,
                children: " "
              })]
            }) : /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              p: 4,
              bg: "gray.50",
              borderRadius: "md",
              textAlign: "center",
              mb: 6,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                color: "gray.500",
                children: "    "
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
              align: "stretch",
              spacing: 4,
              children: [comments.map(function (comment) {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                  variant: "outline",
                  size: "sm",
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                      mb: 2,
                      spacing: 3,
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Avatar, {
                        size: "sm",
                        name: comment.author_name,
                        src: comment.author_avatar
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                          fontWeight: "bold",
                          fontSize: "sm",
                          children: comment.author_name
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                          fontSize: "xs",
                          color: "gray.500",
                          children: new Date(comment.created_at).toLocaleDateString("ar-EG")
                        })]
                      })]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      color: "gray.700",
                      children: comment.content
                    })]
                  })
                }, comment.id);
              }), comments.length === 0 && /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                textAlign: "center",
                color: "gray.400",
                py: 4,
                children: "   .    !"
              })]
            })]
          });
        }
        function TreatyDetail() {
          var _useParams = useParams(),
            id = _useParams.id;
          var _useContent2 = useContent(),
            treaties = _useContent2.treaties;
          var treaty = treaties.find(function (t) {
            return t.id === parseInt(id);
          }) || treaties.find(function (t) {
            return t.id.toString() === id;
          });
          var cardBg = useColorModeValue("white", "gray.800");
          if (!treaty) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              p: 8,
              textAlign: "center",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                size: "lg",
                mb: 4,
                children: "  "
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                colorScheme: "brand",
                children: " "
              })]
            });
          }
          var colorMap = {
            " ": "blue",
            " ": "purple",
            " ": "red",
            " ": "orange",
            "": "green",
            " ": "cyan"
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            maxW: "900px",
            mx: "auto",
            p: {
              base: 4,
              md: 8
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Breadcrumb, {
              mb: 6,
              fontSize: "sm",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbLink, {
                  as: Link$1,
                  to: "/",
                  children: ""
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbLink, {
                  as: Link$1,
                  to: "/?tab=treaties",
                  children: ""
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                isCurrentPage: true,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  color: "gray.500",
                  noOfLines: 1,
                  maxW: "200px",
                  children: treaty.name
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
              bg: cardBg,
              mb: 6,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                  colorScheme: colorMap[treaty.topic] || "gray",
                  mb: 4,
                  fontSize: "sm",
                  children: treaty.topic
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                  justify: "space-between",
                  align: "start",
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "lg",
                    lineHeight: "tall",
                    children: treaty.name
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(FavoriteButton, {
                    item: treaty,
                    type: "treaty"
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(SimpleGrid, {
                  columns: {
                    base: 2,
                    md: 4
                  },
                  spacing: 4,
                  mb: 6,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Stat, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(StatLabel, {
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiCalendar,
                        mr: 2
                      }), " "]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(StatNumber, {
                      fontSize: "xl",
                      children: treaty.date
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stat, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(StatLabel, {
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiGlobe,
                        mr: 2
                      }), " "]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(StatNumber, {
                      fontSize: "xl",
                      children: treaty.states
                    })]
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {
                  mb: 6
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                  align: "stretch",
                  spacing: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                      mb: 2,
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiInfo,
                        color: "brand.600"
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                        size: "sm",
                        children: "  "
                      })]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      color: "gray.600",
                      lineHeight: "tall",
                      children: treaty.description || "    ."
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Comments, {
                    itemId: treaty.id,
                    type: "treaty"
                  })]
                })]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
              spacing: 4,
              flexWrap: "wrap",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link,
                href: treaty.link,
                isExternal: true,
                colorScheme: "brand",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiExternalLink, {}),
                children: "  "
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                variant: "outline",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiArrowRight, {}),
                children: " "
              })]
            })]
          });
        }
        function CaseDetail() {
          var _useParams2 = useParams(),
            id = _useParams2.id;
          var _useContent3 = useContent(),
            cases = _useContent3.cases;
          var caseData = cases.find(function (c) {
            return c.id === parseInt(id);
          }) || cases.find(function (c) {
            return c.id.toString() === id;
          });
          var cardBg = useColorModeValue("white", "gray.800");
          if (!caseData) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              p: 8,
              textAlign: "center",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                size: "lg",
                mb: 4,
                children: "  "
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                colorScheme: "brand",
                children: " "
              })]
            });
          }
          var courtColors = {
            "ICJ": "blue",
            "ICC": "red",
            "ECHR": "purple"
          };
          var courtNames = {
            "ICJ": "  ",
            "ICC": "  ",
            "ECHR": "   "
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            maxW: "900px",
            mx: "auto",
            p: {
              base: 4,
              md: 8
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Breadcrumb, {
              mb: 6,
              fontSize: "sm",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbLink, {
                  as: Link$1,
                  to: "/",
                  children: ""
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbLink, {
                  as: Link$1,
                  to: "/?tab=cases",
                  children: " "
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(BreadcrumbItem, {
                isCurrentPage: true,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  color: "gray.500",
                  noOfLines: 1,
                  maxW: "200px",
                  children: caseData.name
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
              bg: cardBg,
              mb: 6,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                    colorScheme: courtColors[caseData.court],
                    fontSize: "sm",
                    children: caseData.court
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    fontSize: "sm",
                    color: "gray.500",
                    children: courtNames[caseData.court]
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                  justify: "space-between",
                  align: "start",
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "lg",
                    lineHeight: "tall",
                    children: caseData.name
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(FavoriteButton, {
                    item: caseData,
                    type: "case"
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(SimpleGrid, {
                  columns: {
                    base: 1,
                    md: 2
                  },
                  spacing: 4,
                  mb: 6,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Stat, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(StatLabel, {
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiCalendar,
                        mr: 2
                      }), " /"]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(StatNumber, {
                      fontSize: "xl",
                      children: caseData.year
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(Stat, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(StatLabel, {
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiFileText,
                        mr: 2
                      }), ""]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(StatNumber, {
                      fontSize: "xl",
                      children: courtNames[caseData.court]
                    })]
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {
                  mb: 6
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                  align: "stretch",
                  spacing: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                      mb: 2,
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                        as: FiInfo,
                        color: "brand.600"
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                        size: "sm",
                        children: " "
                      })]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      color: "gray.600",
                      lineHeight: "tall",
                      fontSize: "lg",
                      children: caseData.summary
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {}), /* @__PURE__ */jsxRuntimeExports.jsx(Comments, {
                    itemId: caseData.id,
                    type: "case"
                  })]
                })]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
              spacing: 4,
              flexWrap: "wrap",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link,
                href: caseData.link,
                isExternal: true,
                colorScheme: "brand",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiExternalLink, {}),
                children: "  "
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                variant: "outline",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiArrowRight, {}),
                children: " "
              })]
            })]
          });
        }
        var supabaseUrl = "https://bufakaksnwpcljmyrohj.supabase.co";
        var supabaseAnonKey = "sb_publishable_QCE5SPvtTWqf7vz8oU6K_A_EVGNTd21";
        var supabase = createClient(supabaseUrl, supabaseAnonKey);
        var isSupabaseEnabled = function isSupabaseEnabled() {
          return supabase !== null;
        };

        // Submit a new contribution (unapproved by default)
        function submitContribution(_x311, _x312) {
          return _submitContribution.apply(this, arguments);
        }
        function _submitContribution() {
          _submitContribution = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee279(table, data) {
            var _yield$supabase$from$, result, error;
            return _regenerator().w(function (_context280) {
              while (1) switch (_context280.n) {
                case 0:
                  if (isSupabaseEnabled()) {
                    _context280.n = 1;
                    break;
                  }
                  return _context280.a(2, {
                    error: new Error('Supabase not configured')
                  });
                case 1:
                  _context280.n = 2;
                  return supabase.from(table).insert([_objectSpread3(_objectSpread3({}, data), {}, {
                    approved: false
                  })]).select();
                case 2:
                  _yield$supabase$from$ = _context280.v;
                  result = _yield$supabase$from$.data;
                  error = _yield$supabase$from$.error;
                  return _context280.a(2, {
                    data: result,
                    error: error
                  });
              }
            }, _callee279);
          }));
          return _submitContribution.apply(this, arguments);
        }
        var topics = [" ", " ", " ", " ", "", " "];
        function ContributePage() {
          var _reactExports$useStat73 = reactExports.useState("treaty"),
            _reactExports$useStat74 = _slicedToArray(_reactExports$useStat73, 2),
            type = _reactExports$useStat74[0],
            setType = _reactExports$useStat74[1];
          var _reactExports$useStat75 = reactExports.useState({}),
            _reactExports$useStat76 = _slicedToArray(_reactExports$useStat75, 2),
            formData = _reactExports$useStat76[0],
            setFormData = _reactExports$useStat76[1];
          var _reactExports$useStat77 = reactExports.useState(false),
            _reactExports$useStat78 = _slicedToArray(_reactExports$useStat77, 2),
            loading = _reactExports$useStat78[0],
            setLoading = _reactExports$useStat78[1];
          var _reactExports$useStat79 = reactExports.useState(false),
            _reactExports$useStat80 = _slicedToArray(_reactExports$useStat79, 2),
            submitted = _reactExports$useStat80[0],
            setSubmitted = _reactExports$useStat80[1];
          var toast = useToast();
          var cardBg = useColorModeValue("white", "gray.800");
          var handleSubmit = /*#__PURE__*/function () {
            var _ref274 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee247(e) {
              var tableMap, _yield$submitContribu, error;
              return _regenerator().w(function (_context248) {
                while (1) switch (_context248.n) {
                  case 0:
                    e.preventDefault();
                    setLoading(true);
                    tableMap = {
                      treaty: "treaties",
                      case: "cases",
                      resolution: "resolutions"
                    };
                    _context248.n = 1;
                    return submitContribution(tableMap[type], formData);
                  case 1:
                    _yield$submitContribu = _context248.v;
                    error = _yield$submitContribu.error;
                    setLoading(false);
                    if (error) {
                      toast({
                        title: " ",
                        description: error.message,
                        status: "error",
                        duration: 5e3
                      });
                    } else {
                      setSubmitted(true);
                      toast({
                        title: "  ",
                        description: " !   .",
                        status: "success",
                        duration: 5e3
                      });
                    }
                  case 2:
                    return _context248.a(2);
                }
              }, _callee247);
            }));
            return function handleSubmit(_x313) {
              return _ref274.apply(this, arguments);
            };
          }();
          if (submitted) {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              maxW: "600px",
              mx: "auto",
              p: 8,
              textAlign: "center",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
                status: "success",
                borderRadius: "lg",
                mb: 6,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(AlertIcon, {}), "   !     ."]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                colorScheme: "brand",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiArrowRight, {}),
                children: " "
              })]
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            maxW: "700px",
            mx: "auto",
            p: {
              base: 4,
              md: 8
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
              align: "stretch",
              spacing: 6,
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                  size: "lg",
                  mb: 2,
                  children: "  "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  color: "gray.500",
                  children: "        "
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                bg: cardBg,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(CardBody, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx("form", {
                    onSubmit: handleSubmit,
                    children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                      spacing: 4,
                      align: "stretch",
                      children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: " "
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                          value: type,
                          onChange: function onChange(e) {
                            setType(e.target.value);
                            setFormData({});
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "treaty",
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "case",
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "resolution",
                            children: " "
                          })]
                        })]
                      }), type === "treaty" && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          isRequired: true,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            placeholder: ":    ",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                name: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "number",
                            placeholder: "1961",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                date: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                            placeholder: " ",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                topic: e.target.value
                              }));
                            },
                            children: topics.map(function (t) {
                              return /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                                value: t,
                                children: t
                              }, t);
                            })
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: "  "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "number",
                            placeholder: "193",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                states: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: "  "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "url",
                            placeholder: "https://...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                link: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                            placeholder: "  ...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                description: e.target.value
                              }));
                            }
                          })]
                        })]
                      }), type === "case" && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          isRequired: true,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            placeholder: ":    ",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                name: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                            placeholder: " ",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                court: e.target.value
                              }));
                            },
                            children: [/* @__PURE__ */jsxRuntimeExports.jsx("option", {
                              value: "ICJ",
                              children: "   (ICJ)"
                            }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                              value: "ICC",
                              children: "   (ICC)"
                            }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                              value: "ECHR",
                              children: "   "
                            })]
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "number",
                            placeholder: "2024",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                year: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                            placeholder: " ...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                summary: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "url",
                            placeholder: "https://...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                link: e.target.value
                              }));
                            }
                          })]
                        })]
                      }), type === "resolution" && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          isRequired: true,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            placeholder: ": S/RES/2728",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                number: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                            placeholder: " ",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                type: e.target.value
                              }));
                            },
                            children: [/* @__PURE__ */jsxRuntimeExports.jsx("option", {
                              value: " ",
                              children: " "
                            }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                              value: " ",
                              children: " "
                            })]
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "number",
                            placeholder: "2024",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                year: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                            placeholder: " ...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                subject: e.target.value
                              }));
                            }
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                            type: "url",
                            placeholder: "https://undocs.org/...",
                            onChange: function onChange(e) {
                              return setFormData(_objectSpread3(_objectSpread3({}, formData), {}, {
                                link: e.target.value
                              }));
                            }
                          })]
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                        type: "submit",
                        colorScheme: "brand",
                        size: "lg",
                        leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiSend, {}),
                        isLoading: loading,
                        children: " "
                      })]
                    })
                  })
                })
              })]
            })
          });
        }
        var API_KEY = "AIzaSyDGolA-v_tL7vrQ2AkGkruUrvKIQH6VZlQ";
        var aiSearch = /*#__PURE__*/function () {
          var _ref275 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee248(query, treaties, cases, resolutions) {
            return _regenerator().w(function (_context249) {
              while (1) switch (_context249.n) {
                case 0:
                  _context249.n = 1;
                  return geminiRealSearch(query, treaties, cases);
                case 1:
                  return _context249.a(2, _context249.v);
              }
            }, _callee248);
          }));
          return function aiSearch(_x314, _x315, _x316, _x317) {
            return _ref275.apply(this, arguments);
          };
        }();
        var geminiRealSearch = /*#__PURE__*/function () {
          var _ref276 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee250(query, treaties, cases, resolutions) {
            var _yield$__vitePreload, GoogleGenerativeAI, genAI, model, context, result, response, _t163;
            return _regenerator().w(function (_context251) {
              while (1) switch (_context251.p = _context251.n) {
                case 0:
                  _context251.p = 0;
                  _context251.n = 1;
                  return __vitePreload(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee249() {
                    var _yield$module$import, GoogleGenerativeAI;
                    return _regenerator().w(function (_context250) {
                      while (1) switch (_context250.n) {
                        case 0:
                          _context250.n = 1;
                          return module.import('./index-legacy-DI-N5uYW.js');
                        case 1:
                          _yield$module$import = _context250.v;
                          GoogleGenerativeAI = _yield$module$import.GoogleGenerativeAI;
                          return _context250.a(2, {
                            GoogleGenerativeAI: GoogleGenerativeAI
                          });
                      }
                    }, _callee249);
                  })), false ? __VITE_PRELOAD__ : void 0);
                case 1:
                  _yield$__vitePreload = _context251.v;
                  GoogleGenerativeAI = _yield$__vitePreload.GoogleGenerativeAI;
                  genAI = new GoogleGenerativeAI(API_KEY);
                  model = genAI.getGenerativeModel({
                    model: "gemini-pro"
                  });
                  context = "\n        \u0623\u0646\u062A \u0645\u0633\u0627\u0639\u062F \u0642\u0627\u0646\u0648\u0646\u064A \u0630\u0643\u064A \u0645\u062A\u062E\u0635\u0635 \u0641\u064A \u0627\u0644\u0642\u0627\u0646\u0648\u0646 \u0627\u0644\u062F\u0648\u0644\u064A.\n        \u0644\u062F\u064A\u0643 \u0647\u0630\u0647 \u0627\u0644\u0628\u064A\u0627\u0646\u0627\u062A:\n        - \u0627\u0644\u0627\u062A\u0641\u0627\u0642\u064A\u0627\u062A: ".concat(treaties.map(function (t) {
                    return t.name;
                  }).join(", "), "\n        - \u0627\u0644\u0642\u0636\u0627\u064A\u0627: ").concat(cases.map(function (c) {
                    return c.name;
                  }).join(", "), "\n        \n        \u0623\u062C\u0628 \u0639\u0646 \u0633\u0624\u0627\u0644 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645 \u0628\u0646\u0627\u0621\u064B \u0639\u0644\u0649 \u0647\u0630\u0647 \u0627\u0644\u0628\u064A\u0627\u0646\u0627\u062A \u0648\u0645\u0639\u0631\u0641\u062A\u0643 \u0627\u0644\u0639\u0627\u0645\u0629 \u0628\u0627\u0644\u0642\u0627\u0646\u0648\u0646 \u0627\u0644\u062F\u0648\u0644\u064A.\n        \u0627\u062C\u0639\u0644 \u0627\u0644\u0625\u062C\u0627\u0628\u0629 \u0645\u062E\u062A\u0635\u0631\u0629 \u0648\u0645\u0641\u064A\u062F\u0629 \u0648\u0628\u0627\u0644\u0644\u063A\u0629 \u0627\u0644\u0639\u0631\u0628\u064A\u0629.\n        \u0627\u0644\u0633\u0624\u0627\u0644: ").concat(query, "\n        ");
                  _context251.n = 2;
                  return model.generateContent(context);
                case 2:
                  result = _context251.v;
                  _context251.n = 3;
                  return result.response;
                case 3:
                  response = _context251.v;
                  return _context251.a(2, response.text());
                case 4:
                  _context251.p = 4;
                  _t163 = _context251.v;
                  console.error("Gemini Error:", _t163);
                  throw new Error("    . " + _t163.message);
                case 5:
                  return _context251.a(2);
              }
            }, _callee250, null, [[0, 4]]);
          }));
          return function geminiRealSearch(_x318, _x319, _x320, _x321) {
            return _ref276.apply(this, arguments);
          };
        }();
        var semanticSearch = /*#__PURE__*/function () {
          var _ref278 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee251(query, treaties, cases, resolutions) {
            return _regenerator().w(function (_context252) {
              while (1) switch (_context252.n) {
                case 0:
                  return _context252.a(2, {
                    treaties: treaties.filter(function (t) {
                      return t.name.includes(query) || t.topic.includes(query);
                    }),
                    cases: cases.filter(function (c) {
                      return c.name.includes(query) || c.court.includes(query);
                    }),
                    resolutions: resolutions.filter(function (r) {
                      return r.number.includes(query) || r.topic.includes(query);
                    })
                  });
              }
            }, _callee251);
          }));
          return function semanticSearch(_x322, _x323, _x324, _x325) {
            return _ref278.apply(this, arguments);
          };
        }();
        function AISearchPage() {
          var _reactExports$useStat81 = reactExports.useState(""),
            _reactExports$useStat82 = _slicedToArray(_reactExports$useStat81, 2),
            query = _reactExports$useStat82[0],
            setQuery = _reactExports$useStat82[1];
          var _reactExports$useStat83 = reactExports.useState(false),
            _reactExports$useStat84 = _slicedToArray(_reactExports$useStat83, 2),
            loading = _reactExports$useStat84[0],
            setLoading = _reactExports$useStat84[1];
          var _reactExports$useStat85 = reactExports.useState(""),
            _reactExports$useStat86 = _slicedToArray(_reactExports$useStat85, 2),
            answer = _reactExports$useStat86[0],
            setAnswer = _reactExports$useStat86[1];
          var _reactExports$useStat87 = reactExports.useState(null),
            _reactExports$useStat88 = _slicedToArray(_reactExports$useStat87, 2),
            results = _reactExports$useStat88[0],
            setResults = _reactExports$useStat88[1];
          var _reactExports$useStat89 = reactExports.useState(""),
            _reactExports$useStat90 = _slicedToArray(_reactExports$useStat89, 2),
            error = _reactExports$useStat90[0],
            setError = _reactExports$useStat90[1];
          var cardBg = useColorModeValue("white", "gray.800");
          var handleSearch = /*#__PURE__*/function () {
            var _ref279 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee252() {
              var aiAnswer, relevant, _t164;
              return _regenerator().w(function (_context253) {
                while (1) switch (_context253.p = _context253.n) {
                  case 0:
                    if (query.trim()) {
                      _context253.n = 1;
                      break;
                    }
                    return _context253.a(2);
                  case 1:
                    setLoading(true);
                    setError("");
                    setAnswer("");
                    setResults(null);
                    _context253.p = 2;
                    _context253.n = 3;
                    return aiSearch(query, treatiesData, casesData, resolutionsData);
                  case 3:
                    aiAnswer = _context253.v;
                    setAnswer(aiAnswer);
                    _context253.n = 4;
                    return semanticSearch(query, treatiesData, casesData, resolutionsData);
                  case 4:
                    relevant = _context253.v;
                    setResults(relevant);
                    _context253.n = 6;
                    break;
                  case 5:
                    _context253.p = 5;
                    _t164 = _context253.v;
                    setError(_t164.message);
                  case 6:
                    _context253.p = 6;
                    setLoading(false);
                    return _context253.f(6);
                  case 7:
                    return _context253.a(2);
                }
              }, _callee252, null, [[2, 5, 6, 7]]);
            }));
            return function handleSearch() {
              return _ref279.apply(this, arguments);
            };
          }();
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            maxW: "900px",
            mx: "auto",
            p: {
              base: 4,
              md: 8
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
              align: "stretch",
              spacing: 6,
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                textAlign: "center",
                mb: 4,
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                  justify: "center",
                  mb: 2,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    fontSize: "3xl",
                    children: ""
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "lg",
                    children: " "
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  color: "gray.500",
                  children: "       "
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                bg: cardBg,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(CardBody, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                    spacing: 4,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsxs(InputGroup, {
                      size: "lg",
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(InputLeftElement, {
                        pointerEvents: "none",
                        children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                          children: ""
                        })
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                        placeholder: ":         ",
                        value: query,
                        onChange: function onChange(e) {
                          return setQuery(e.target.value);
                        },
                        onKeyPress: function onKeyPress(e) {
                          return e.key === "Enter" && handleSearch();
                        },
                        borderRadius: "lg"
                      })]
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                      colorScheme: "brand",
                      size: "lg",
                      width: "100%",
                      onClick: handleSearch,
                      isLoading: loading,
                      loadingText: " ...",
                      children: "  "
                    })]
                  })
                })
              }), loading && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                textAlign: "center",
                py: 8,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Spinner, {
                  size: "xl",
                  color: "brand.600"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  mt: 4,
                  color: "gray.500",
                  children: "  ..."
                })]
              }), error && /* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
                status: "error",
                borderRadius: "lg",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(AlertIcon, {}), error]
              }), answer && /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                bg: cardBg,
                borderColor: "brand.500",
                borderWidth: 2,
                children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(HStack, {
                    mb: 3,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                      colorScheme: "brand",
                      fontSize: "sm",
                      children: "   "
                    })
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    whiteSpace: "pre-wrap",
                    lineHeight: "tall",
                    children: answer
                  })]
                })
              }), results && (results.treaties.length > 0 || results.cases.length > 0 || results.resolutions.length > 0) && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                  size: "md",
                  mb: 4,
                  children: "   "
                }), results.treaties.length > 0 && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    mb: 2,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      children: ""
                    }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                      fontWeight: "bold",
                      children: [" (", results.treaties.length, ")"]
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(VStack, {
                    align: "stretch",
                    spacing: 2,
                    children: results.treaties.map(function (t) {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                        size: "sm",
                        variant: "outline",
                        as: Link$1,
                        to: "/treaty/".concat(t.id),
                        _hover: {
                          borderColor: "brand.500"
                        },
                        children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                          py: 2,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                            fontWeight: "600",
                            color: "brand.600",
                            children: t.name
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                            fontSize: "sm",
                            color: "gray.500",
                            children: [t.date, "  ", t.topic]
                          })]
                        })
                      }, t.id);
                    })
                  })]
                }), results.cases.length > 0 && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    mb: 2,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      children: ""
                    }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                      fontWeight: "bold",
                      children: [" (", results.cases.length, ")"]
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(VStack, {
                    align: "stretch",
                    spacing: 2,
                    children: results.cases.map(function (c) {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                        size: "sm",
                        variant: "outline",
                        as: Link$1,
                        to: "/case/".concat(c.id),
                        _hover: {
                          borderColor: "brand.500"
                        },
                        children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                          py: 2,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                            fontWeight: "600",
                            color: "brand.600",
                            children: c.name
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                            fontSize: "sm",
                            color: "gray.500",
                            children: [c.court, "  ", c.year]
                          })]
                        })
                      }, c.id);
                    })
                  })]
                }), results.resolutions.length > 0 && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  mb: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    mb: 2,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      children: ""
                    }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                      fontWeight: "bold",
                      children: [" (", results.resolutions.length, ")"]
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(VStack, {
                    align: "stretch",
                    spacing: 2,
                    children: results.resolutions.map(function (r) {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                        size: "sm",
                        variant: "outline",
                        _hover: {
                          borderColor: "brand.500"
                        },
                        children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                          py: 2,
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                            fontWeight: "600",
                            fontFamily: "mono",
                            color: "brand.600",
                            children: r.number
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs(Text, {
                            fontSize: "sm",
                            color: "gray.500",
                            children: [r.type, "  ", r.year]
                          })]
                        })
                      }, r.id);
                    })
                  })]
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                variant: "outline",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  children: ""
                }),
                children: " "
              })]
            })
          });
        }
        function ComparePage() {
          var _useContent4 = useContent(),
            treaties = _useContent4.treaties;
          var _reactExports$useStat91 = reactExports.useState(""),
            _reactExports$useStat92 = _slicedToArray(_reactExports$useStat91, 2),
            treaty1Id = _reactExports$useStat92[0],
            setTreaty1Id = _reactExports$useStat92[1];
          var _reactExports$useStat93 = reactExports.useState(""),
            _reactExports$useStat94 = _slicedToArray(_reactExports$useStat93, 2),
            treaty2Id = _reactExports$useStat94[0],
            setTreaty2Id = _reactExports$useStat94[1];
          var cardBg = useColorModeValue("white", "gray.800");
          var borderColor = useColorModeValue("gray.200", "gray.600");
          var treaty1 = reactExports.useMemo(function () {
            return treaties.find(function (t) {
              return t.id == treaty1Id;
            });
          }, [treaty1Id, treaties]);
          var treaty2 = reactExports.useMemo(function () {
            return treaties.find(function (t) {
              return t.id == treaty2Id;
            });
          }, [treaty2Id, treaties]);
          var CompareCard = function CompareCard(_ref280) {
            var treaty = _ref280.treaty,
              label = _ref280.label,
              color = _ref280.color;
            return /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
              bg: cardBg,
              borderTop: "4px solid",
              borderColor: color,
              h: "100%",
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CardBody, {
                children: treaty ? /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                  align: "stretch",
                  spacing: 4,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                    colorScheme: color === "blue.500" ? "blue" : "purple",
                    alignSelf: "start",
                    children: label
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "md",
                    color: "brand.600",
                    children: treaty.name
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {}), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                      as: FiCalendar,
                      color: "gray.500"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      fontWeight: "600",
                      children: " :"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      children: treaty.date
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                      as: FiGlobe,
                      color: "gray.500"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      fontWeight: "600",
                      children: " :"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      children: treaty.states
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                      as: FiFileText,
                      color: "gray.500"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      fontWeight: "600",
                      children: ":"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Badge, {
                      colorScheme: "brand",
                      children: treaty.topic
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {}), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      fontWeight: "600",
                      mb: 2,
                      children: " :"
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                      color: "gray.600",
                      lineHeight: "tall",
                      children: treaty.description
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    as: "a",
                    href: treaty.link,
                    target: "_blank",
                    colorScheme: "brand",
                    variant: "outline",
                    leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiExternalLink, {}),
                    mt: "auto",
                    children: "  "
                  })]
                }) : /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                  justify: "center",
                  h: "300px",
                  color: "gray.400",
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                    as: FiFileText,
                    boxSize: 12
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    children: "  "
                  })]
                })
              })
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            maxW: "1200px",
            mx: "auto",
            p: {
              base: 4,
              md: 8
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
              align: "stretch",
              spacing: 6,
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                textAlign: "center",
                mb: 4,
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
                  justify: "center",
                  mb: 2,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Icon, {
                    as: FiColumns,
                    boxSize: 8,
                    color: "brand.600"
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "lg",
                    children: " "
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  color: "gray.500",
                  children: "     "
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(SimpleGrid, {
                columns: {
                  base: 1,
                  md: 2
                },
                spacing: 4,
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    mb: 2,
                    fontWeight: "600",
                    children: "  :"
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                    placeholder: " ...",
                    value: treaty1Id,
                    onChange: function onChange(e) {
                      return setTreaty1Id(e.target.value);
                    },
                    bg: cardBg,
                    children: treaties.filter(function (t) {
                      return t.id != treaty2Id;
                    }).map(function (t) {
                      return /* @__PURE__ */jsxRuntimeExports.jsxs("option", {
                        value: t.id,
                        children: [t.name, " (", t.date, ")"]
                      }, t.id);
                    })
                  })]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                    mb: 2,
                    fontWeight: "600",
                    children: "  :"
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                    placeholder: " ...",
                    value: treaty2Id,
                    onChange: function onChange(e) {
                      return setTreaty2Id(e.target.value);
                    },
                    bg: cardBg,
                    children: treaties.filter(function (t) {
                      return t.id != treaty1Id;
                    }).map(function (t) {
                      return /* @__PURE__ */jsxRuntimeExports.jsxs("option", {
                        value: t.id,
                        children: [t.name, " (", t.date, ")"]
                      }, t.id);
                    })
                  })]
                })]
              }), !treaty1 && !treaty2 && /* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
                status: "info",
                borderRadius: "lg",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(AlertIcon, {}), "      "]
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(SimpleGrid, {
                columns: {
                  base: 1,
                  md: 2
                },
                spacing: 6,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(CompareCard, {
                  treaty: treaty1,
                  label: " ",
                  color: "blue.500"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(CompareCard, {
                  treaty: treaty2,
                  label: " ",
                  color: "purple.500"
                })]
              }), treaty1 && treaty2 && /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
                bg: cardBg,
                children: /* @__PURE__ */jsxRuntimeExports.jsxs(CardBody, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                    size: "sm",
                    mb: 4,
                    children: "   "
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                    overflowX: "auto",
                    children: /* @__PURE__ */jsxRuntimeExports.jsxs("table", {
                      style: {
                        width: "100%",
                        borderCollapse: "collapse"
                      },
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx("thead", {
                        children: /* @__PURE__ */jsxRuntimeExports.jsxs("tr", {
                          style: {
                            borderBottom: "2px solid",
                            borderColor: borderColor
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("th", {
                            style: {
                              padding: "12px",
                              textAlign: "right"
                            },
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("th", {
                            style: {
                              padding: "12px",
                              textAlign: "center",
                              color: "#3182ce"
                            },
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("th", {
                            style: {
                              padding: "12px",
                              textAlign: "center",
                              color: "#805ad5"
                            },
                            children: " "
                          })]
                        })
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs("tbody", {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsxs("tr", {
                          style: {
                            borderBottom: "1px solid",
                            borderColor: borderColor
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px"
                            },
                            children: "  "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty1.date
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty2.date
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs("tr", {
                          style: {
                            borderBottom: "1px solid",
                            borderColor: borderColor
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px"
                            },
                            children: "  "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty1.states
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty2.states
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs("tr", {
                          style: {
                            borderBottom: "1px solid",
                            borderColor: borderColor
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px"
                            },
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty1.topic
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px",
                              textAlign: "center"
                            },
                            children: treaty2.topic
                          })]
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs("tr", {
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("td", {
                            style: {
                              padding: "12px"
                            },
                            children: "  "
                          }), /* @__PURE__ */jsxRuntimeExports.jsxs("td", {
                            colSpan: 2,
                            style: {
                              padding: "12px",
                              textAlign: "center",
                              fontWeight: "bold"
                            },
                            children: [Math.abs(parseInt(treaty1.date) - parseInt(treaty2.date)), " "]
                          })]
                        })]
                      })]
                    })
                  })]
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                as: Link$1,
                to: "/",
                variant: "outline",
                leftIcon: /* @__PURE__ */jsxRuntimeExports.jsx(FiArrowRight, {}),
                children: " "
              })]
            })
          });
        }
        function AdminPage() {
          var _useUser3 = useUser(),
            user = _useUser3.user;
          var toast = useToast();
          var _reactExports$useStat95 = reactExports.useState(false),
            _reactExports$useStat96 = _slicedToArray(_reactExports$useStat95, 2),
            loading = _reactExports$useStat96[0],
            setLoading = _reactExports$useStat96[1];
          var _reactExports$useStat97 = reactExports.useState({
              name: "",
              date: "",
              topic: " ",
              states: "",
              link: "",
              description: ""
            }),
            _reactExports$useStat98 = _slicedToArray(_reactExports$useStat97, 2),
            treaty = _reactExports$useStat98[0],
            setTreaty = _reactExports$useStat98[1];
          var _reactExports$useStat99 = reactExports.useState({
              name: "",
              year: "",
              court: "ICJ",
              summary: "",
              link: ""
            }),
            _reactExports$useStat100 = _slicedToArray(_reactExports$useStat99, 2),
            caseData = _reactExports$useStat100[0],
            setCaseData = _reactExports$useStat100[1];
          var handleTreatySubmit = /*#__PURE__*/function () {
            var _ref281 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee253(e) {
              var _yield$supabase$1$fro6, error;
              return _regenerator().w(function (_context254) {
                while (1) switch (_context254.n) {
                  case 0:
                    e.preventDefault();
                    setLoading(true);
                    _context254.n = 1;
                    return supabase$1.from("treaties").insert([treaty]);
                  case 1:
                    _yield$supabase$1$fro6 = _context254.v;
                    error = _yield$supabase$1$fro6.error;
                    setLoading(false);
                    if (error) {
                      toast({
                        title: "",
                        description: error.message,
                        status: "error"
                      });
                    } else {
                      toast({
                        title: "   !",
                        status: "success"
                      });
                      setTreaty({
                        name: "",
                        date: "",
                        topic: " ",
                        states: "",
                        link: "",
                        description: ""
                      });
                    }
                  case 2:
                    return _context254.a(2);
                }
              }, _callee253);
            }));
            return function handleTreatySubmit(_x326) {
              return _ref281.apply(this, arguments);
            };
          }();
          var handleCaseSubmit = /*#__PURE__*/function () {
            var _ref282 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee254(e) {
              var _yield$supabase$1$fro7, error;
              return _regenerator().w(function (_context255) {
                while (1) switch (_context255.n) {
                  case 0:
                    e.preventDefault();
                    setLoading(true);
                    _context255.n = 1;
                    return supabase$1.from("cases").insert([caseData]);
                  case 1:
                    _yield$supabase$1$fro7 = _context255.v;
                    error = _yield$supabase$1$fro7.error;
                    setLoading(false);
                    if (error) {
                      toast({
                        title: "",
                        description: error.message,
                        status: "error"
                      });
                    } else {
                      toast({
                        title: "   !",
                        status: "success"
                      });
                      setCaseData({
                        name: "",
                        year: "",
                        court: "ICJ",
                        summary: "",
                        link: ""
                      });
                    }
                  case 2:
                    return _context255.a(2);
                }
              }, _callee254);
            }));
            return function handleCaseSubmit(_x327) {
              return _ref282.apply(this, arguments);
            };
          }();
          if (!user) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              textAlign: "center",
              py: 10,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                size: "md",
                children: "      "
              })
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Container, {
            maxW: "container.md",
            py: 8,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
              mb: 6,
              textAlign: "center",
              children: "   "
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Tabs, {
              isFitted: true,
              variant: "enclosed",
              colorScheme: "brand",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(TabList, {
                mb: "1em",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Tab, {
                  children: " "
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Tab, {
                  children: " "
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(TabPanels, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(TabPanel, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx("form", {
                    onSubmit: handleTreatySubmit,
                    children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                      spacing: 4,
                      children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: " "
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          value: treaty.name,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              name: e.target.value
                            }));
                          },
                          placeholder: ":  "
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          type: "number",
                          value: treaty.date,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              date: e.target.value
                            }));
                          },
                          placeholder: "1949"
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                          value: treaty.topic,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              topic: e.target.value
                            }));
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: " ",
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: " ",
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: " ",
                            children: " "
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "",
                            children: ""
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: " ",
                            children: " "
                          })]
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: "  "
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          value: treaty.states,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              states: e.target.value
                            }));
                          },
                          placeholder: ": 196 "
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: "  "
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          type: "url",
                          value: treaty.link,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              link: e.target.value
                            }));
                          }
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                          value: treaty.description,
                          onChange: function onChange(e) {
                            return setTreaty(_objectSpread3(_objectSpread3({}, treaty), {}, {
                              description: e.target.value
                            }));
                          }
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                        type: "submit",
                        colorScheme: "blue",
                        width: "100%",
                        isLoading: loading,
                        children: " "
                      })]
                    })
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(TabPanel, {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx("form", {
                    onSubmit: handleCaseSubmit,
                    children: /* @__PURE__ */jsxRuntimeExports.jsxs(VStack, {
                      spacing: 4,
                      children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: " "
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          value: caseData.name,
                          onChange: function onChange(e) {
                            return setCaseData(_objectSpread3(_objectSpread3({}, caseData), {}, {
                              name: e.target.value
                            }));
                          },
                          placeholder: ":   "
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          type: "number",
                          value: caseData.year,
                          onChange: function onChange(e) {
                            return setCaseData(_objectSpread3(_objectSpread3({}, caseData), {}, {
                              year: e.target.value
                            }));
                          }
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                          value: caseData.court,
                          onChange: function onChange(e) {
                            return setCaseData(_objectSpread3(_objectSpread3({}, caseData), {}, {
                              court: e.target.value
                            }));
                          },
                          children: [/* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "ICJ",
                            children: "   (ICJ)"
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "ICC",
                            children: "  (ICC)"
                          }), /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                            value: "ECHR",
                            children: "  "
                          })]
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        isRequired: true,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: " "
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Input, {
                          type: "url",
                          value: caseData.link,
                          onChange: function onChange(e) {
                            return setCaseData(_objectSpread3(_objectSpread3({}, caseData), {}, {
                              link: e.target.value
                            }));
                          }
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsxs(FormControl, {
                        children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormLabel, {
                          children: ""
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(Textarea, {
                          value: caseData.summary,
                          onChange: function onChange(e) {
                            return setCaseData(_objectSpread3(_objectSpread3({}, caseData), {}, {
                              summary: e.target.value
                            }));
                          }
                        })]
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                        type: "submit",
                        colorScheme: "purple",
                        width: "100%",
                        isLoading: loading,
                        children: " "
                      })]
                    })
                  })
                })]
              })]
            })]
          });
        }
        var config = {
          initialColorMode: 'light',
          useSystemColorMode: false
        };
        var theme = extendTheme({
          config: config,
          direction: 'rtl',
          fonts: {
            heading: "'Cairo', sans-serif",
            body: "'Cairo', sans-serif"
          },
          colors: {
            brand: {
              50: '#eff6ff',
              100: '#dbeafe',
              200: '#bfdbfe',
              300: '#93c5fd',
              400: '#60a5fa',
              500: '#3b82f6',
              600: '#2563eb',
              700: '#1d4ed8',
              800: '#1e40af',
              900: '#1e3a8a'
            }
          },
          styles: {
            global: function global(props) {
              return {
                body: {
                  bg: props.colorMode === 'dark' ? 'gray.900' : 'gray.50',
                  color: props.colorMode === 'dark' ? 'white' : 'gray.800'
                }
              };
            }
          },
          components: {
            Button: {
              defaultProps: {
                colorScheme: 'brand'
              }
            }
          }
        });
        var WorldMapPage = reactExports.lazy(function () {
          return __vitePreload(function () {
            return module.import('./WorldMapPage-legacy-Bm5kDfcZ.js');
          }, false ? __VITE_PRELOAD__ : void 0);
        });
        var CountryCompare = reactExports.lazy(function () {
          return __vitePreload(function () {
            return module.import('./CountryCompare-legacy-BJgzpcue.js');
          }, false ? __VITE_PRELOAD__ : void 0);
        });
        var NewsSection = reactExports.lazy(function () {
          return __vitePreload(function () {
            return module.import('./NewsSection-legacy-DXSkjhSM.js');
          }, false ? __VITE_PRELOAD__ : void 0);
        });
        var LoadingSpinner = function LoadingSpinner() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Center, {
            h: "100vh",
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Spinner, {
              size: "xl",
              color: "brand.500",
              thickness: "4px"
            })
          });
        };
        client.createRoot(document.getElementById("root")).render(/* @__PURE__ */jsxRuntimeExports.jsx(React.StrictMode, {
          children: /* @__PURE__ */jsxRuntimeExports.jsx(ChakraProvider, {
            theme: theme,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(HashRouter, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingSpinner, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsxs(Routes, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(App, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/treaty/:id",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(TreatyDetail, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/case/:id",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(CaseDetail, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/contribute",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(ContributePage, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/ai-search",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(AISearchPage, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/compare",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(ComparePage, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/admin",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(AdminPage, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/world-map",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(WorldMapPage, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/country-compare",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(CountryCompare, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(Route, {
                    path: "/news",
                    element: /* @__PURE__ */jsxRuntimeExports.jsx(NewsSection, {})
                  })]
                })
              })
            })
          })
        }));
      }
    };
  });
})();
//# sourceMappingURL=index-legacy-BKmc3SO3.js.map
